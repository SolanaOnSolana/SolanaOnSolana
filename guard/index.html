<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#070711" />
  <title>$SOS — DEX Terminal (Multi-Chain)</title>
  <meta name="description" content="$SOS DEX Terminal — native chart + live trades across Solana, Ethereum, BNB, Base." />

  <style>
    :root{
      --bg:#070711;
      --bg2:#070711;
      --bg3:#070711;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.085);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --muted2: rgba(255,255,255,.55);
      --g:#14F195;
      --r:#FF4D6D;
      --c:#00D1FF;
      --p:#9945FF;
      --radius: 22px;
      --shadow: 0 14px 40px rgba(0,0,0,.55);
      --max: 1280px;
      --glass: blur(14px);
      --t: .18s ease;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
     margin:0;
     color:var(--text);
     font: 16px/1.6 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
     background: var(--bg);
     overflow-x:hidden;
     position: relative;
     }

    body::before{
     content:"";
     position: fixed;
     inset: 0;
     z-index: -1;
     pointer-events: none;
     background:
     radial-gradient(1200px 760px at 10% 5%, rgba(153,69,255,.24), transparent 60%),
     radial-gradient(1000px 720px at 90% 10%, rgba(20,241,149,.18), transparent 58%),
     radial-gradient(900px 640px at 72% 92%, rgba(0,209,255,.14), transparent 58%),
     radial-gradient(900px 640px at 0% 95%, rgba(0,209,255,.06), transparent 60%),
     var(--bg);
     transform: translateZ(0);
     }
a{color:inherit; text-decoration:none}
    button,input,select{font:inherit}

    .wrap{max-width:var(--max); margin:0 auto; padding: calc(var(--topbar-space, 84px) + 18px) 16px 28px}

    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:12px 12px;
      border:1px solid var(--stroke);
      background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.04));
      border-radius: 26px;
      box-shadow: var(--shadow);
      backdrop-filter: var(--glass);
      position:fixed; top: calc(env(safe-area-inset-top) + 10px); left:50%; transform: translateX(-50%); width: min(var(--max), calc(100vw - 24px)); z-index:2147483500;
    }

    

    /* Topbar: replace $SOS title with Dexguard button */
    .topbar #topDexguardBtn{ padding: 9px 16px; }
    .topbar #topDexguardBtn .dexguardText{ font-size: 18px; }
    .topbar #topDexguardBtn .dexguardChip{ font-size: 12px; }


    /* Topbar brand area (legacy logo styles kept clean so CSS never breaks) */
    .brand{display:flex; align-items:center; gap:10px; min-width:0}

    /* Base (desktop) logo sizing to prevent huge logo rendering on PC */
    .topLogo{
      height: 34px;
      width: auto;
      max-width: 180px;
      display: block;
      object-fit: contain;
    }

    .logo{
      width:38px; height:38px; border-radius:14px;
      display:grid; place-items:center;
      background:
        radial-gradient(14px 14px at 35% 30%, rgba(20,241,149,.9), transparent 60%),
        radial-gradient(14px 14px at 70% 35%, rgba(0,209,255,.9), transparent 60%),
        radial-gradient(14px 14px at 50% 80%, rgba(153,69,255,.9), transparent 60%),
        rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
    }
    .logo span{font-weight:900; letter-spacing:-.02em}

    /* Top-left DexGuard button (replaces old SOS title) */
    .topbar .dexguardBtn{ padding:9px 16px; }
    .topbar .dexguardText{ font-size:18px; }
    @media (max-width:520px){
      .topbar .dexguardText{ font-size:16px; }
    }

    .brandTxt{min-width:0}
    .brandTxt .t1{font-weight:900; letter-spacing:-.02em; font-size:15px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .brandTxt .t2{font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}

    .actions{display:flex; align-items:center; gap:10px}

    .pillRow{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
    .pill{
      display:inline-flex; align-items:center; gap:7px;
      padding:9px 12px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.85);
      cursor:pointer;
      user-select:none;
      transition: transform var(--t), background var(--t), border-color var(--t);
    }
    .pill:hover{transform: translateY(-1px); background: rgba(255,255,255,.07)}
    .pill.active{border-color: rgba(153,69,255,.55); background: rgba(153,69,255,.14)}
    .pill .dot{width:10px; height:10px; border-radius:50%; background: rgba(255,255,255,.18); box-shadow: inset 0 0 0 1px rgba(255,255,255,.14)}
    .pill.active .dot{background: var(--p)}

    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px;
      padding:10px 14px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      cursor:pointer;
      transition: transform var(--t), background var(--t), border-color var(--t);
    }
    .btn:hover{transform: translateY(-1px); background: rgba(255,255,255,.085)}
    .btn.primary{background: rgba(20,241,149,.14); border-color: rgba(20,241,149,.32)}
    .btn.ghost{background: rgba(255,255,255,.03)}

    /* Twitter/X button (topbar) */
    .btn.xbtn{
      background: rgba(0,0,0,.55);
      border-color: rgba(255,255,255,.16);
      color: rgba(255,255,255,.92);
    }
    .btn.xbtn:hover{ background: rgba(0,0,0,.70); }

    /* Hide topbar chain pills + buy button (use lower controls instead) */
    #netPills, #btnBuy{ display:none !important; }
    .btn.xbtn svg{ width:14px; height:14px; display:block; }

    /* Remove topbar chain pills + buy button (keep lower buttons) */
    #netPills{ display:none !important; }
    #btnBuy{ display:none !important; }

    .panel{
      margin-top:14px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: var(--glass);
      overflow:hidden;
    }

    
    /* ===== Dex-style Top Trending Bar + Search (MATCH MAIN PAGE) ===== */
    :root{
      --tickerSpeed: 8.2s;
      --tickerDistance: 50%;

      --solColor: #9945FF;
      --ethColor: #627EEA;
      --bnbColor: #F3BA2F;
      --baseColor:#0052FF;

      --netColor: var(--solColor);
      --netGlow: rgba(153,69,255,.22);
    }

    body.net-sol{ --netColor: var(--solColor); --netGlow: rgba(153,69,255,.22); }
    body.net-eth{ --netColor: var(--ethColor); --netGlow: rgba(98,126,234,.22); }
    body.net-bnb{ --netColor: var(--bnbColor); --netGlow: rgba(243,186,47,.22); }
    body.net-base{ --netColor: var(--baseColor); --netGlow: rgba(0,82,255,.22); }

    /* Top trending bar container (inside panel) */
    .topBar{
      z-index: 60;
      position: relative;
      background: rgba(11,16,51,.45);
      border-bottom: 1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }

    .topBarInner{
      padding: 14px 16px 12px;
      display:flex;
      flex-direction: column;
      gap: 10px;
    }

    .topRow{
      display:flex;
      align-items:center;
      justify-content:flex-start;
      gap: 12px;
      flex-wrap:wrap;
    }

    /* keep chain pills close to LIVE TRENDING (not pushed to far right) */
    .chainToggle{ margin-left: 10px; }

    .bottomRow{
      display:flex;
      align-items:center;
      gap: 12px;
      min-width: 0;
    }

    .hotBlock{ display:flex; align-items:center; gap: 12px; flex-wrap:wrap; }
    .hotLabel{
      display:inline-flex;
      align-items:center;
      gap: 10px;
      padding: 9px 14px;
      border-radius: 999px;
      background: rgba(255,65,65,.10);
      border: 1px solid rgba(255,65,65,.20);
      box-shadow: 0 12px 32px rgba(0,0,0,.24);
      font-weight: 1100;
      letter-spacing: .6px;
    }
    .hotFire{ width: 18px; height: 18px; opacity: .95; display:grid; place-items:center; }

    .dexguardBtn{
      display:inline-flex;
      align-items:center;
      gap:12px;
      padding: 9px 16px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background:
        radial-gradient(140% 120% at 0% 0%, rgba(0,209,255,.18), rgba(0,209,255,0) 55%),
        radial-gradient(140% 120% at 100% 100%, rgba(153,69,255,.18), rgba(153,69,255,0) 55%),
        rgba(8,18,40,.50);
      box-shadow: 0 12px 34px rgba(0,0,0,.28);
      color: rgba(255,255,255,.92);
      font-weight: 1050;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease, box-shadow .15s ease;
      position:relative;
      overflow:hidden;
    }
    .dexguardBtn:hover{
      transform: translateY(-1px);
      border-color: rgba(255,255,255,.18);
      background:
        radial-gradient(140% 120% at 0% 0%, rgba(0,209,255,.22), rgba(0,209,255,0) 60%),
        radial-gradient(140% 120% at 100% 100%, rgba(153,69,255,.22), rgba(153,69,255,0) 60%),
        rgba(8,18,40,.62);
      box-shadow: 0 16px 46px rgba(0,0,0,.36);
    }
    .dexguardBtn:active{ transform: translateY(0px) scale(.995); }
    .dexguardBtn::after{
      content:"";
      position:absolute;
      inset:-60% -40%;
      background: linear-gradient(120deg,
        transparent 0%,
        rgba(255,255,255,.00) 35%,
        rgba(255,255,255,.22) 50%,
        rgba(255,255,255,.06) 60%,
        transparent 75%
      );
      transform: translateX(-170%) rotate(10deg);
      opacity:0;
      pointer-events:none;
      mix-blend-mode: screen;
      animation: dexguardShine 6.8s ease-in-out infinite;
    }
    @keyframes dexguardShine{
      0%, 72%{ opacity:0; transform: translateX(-170%) rotate(10deg); }
      78%{ opacity:.70; }
      92%{ opacity:0; transform: translateX(170%) rotate(10deg); }
      100%{ opacity:0; transform: translateX(170%) rotate(10deg); }
    }

    .dexguardChip{
      position: relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 7px 14px;
      border-radius: 999px;
      background: rgba(3,12,24,.65);
      border: 1px solid rgba(255,255,255,.10);
      font-weight: 1100;
      letter-spacing: .28em;
      font-size: 13px;
      color: rgba(255,255,255,.96);
    }
    .dexguardChip::before{
      content:"";
      position:absolute;
      inset:-2px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(20,241,149,.88), rgba(0,209,255,.88), rgba(153,69,255,.88));
      z-index:-1;
      opacity:.9;
    }
    .dexguardText{
      font-weight: 1050;
      letter-spacing: -.2px;
      font-size: 20px;
      line-height: 1;
    }

    @media (max-width: 520px){
      .dexguardText{ font-size: 18px; }
      .dexguardBtn{ padding: 9px 14px; gap: 10px; }
      .dexguardChip{ padding: 7px 12px; }
    }

    .chainToggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }

    .chainBtn{
      appearance:none;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.92);
      font-weight: 1000;
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 999px;
      cursor:pointer;
      letter-spacing: .35px;
      transition: transform .15s ease, background .15s ease, border-color .15s ease, box-shadow .15s ease;
    }
    .chainBtn:hover{ background: rgba(255,255,255,.09); transform: translateY(-1px); }
    .chainBtn:active{ transform: translateY(0px) scale(.99); }

    .chainBtn[data-net="solana"]{ border-color: rgba(153,69,255,.50); background: rgba(153,69,255,.10); box-shadow: 0 0 0 1px rgba(153,69,255,.12) inset, 0 10px 22px rgba(153,69,255,.10); }
    .chainBtn[data-net="eth"]{ border-color: rgba(98,126,234,.50); background: rgba(98,126,234,.10); box-shadow: 0 0 0 1px rgba(98,126,234,.12) inset, 0 10px 22px rgba(98,126,234,.10); }
    .chainBtn[data-net="bsc"]{ border-color: rgba(243,186,47,.52); background: rgba(243,186,47,.10); box-shadow: 0 0 0 1px rgba(243,186,47,.12) inset, 0 10px 22px rgba(243,186,47,.10); }
    .chainBtn[data-net="base"]{ border-color: rgba(0,82,255,.52); background: rgba(0,82,255,.10); box-shadow: 0 0 0 1px rgba(0,82,255,.12) inset, 0 10px 22px rgba(0,82,255,.10); }

    .chainBtn.active{
      color: rgba(255,255,255,.96);
      text-shadow: 0 1px 0 rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.96);
      box-shadow: 0 10px 26px rgba(0,0,0,.28);
    }
    body.net-sol .chainBtn.active{ background: linear-gradient(90deg, rgba(153,69,255,.96), rgba(153,69,255,.52)); }
    body.net-eth .chainBtn.active{ background: linear-gradient(90deg, rgba(98,126,234,.96), rgba(98,126,234,.52)); }
    body.net-bnb .chainBtn.active{ background: linear-gradient(90deg, rgba(243,186,47,.96), rgba(243,186,47,.50)); }
    body.net-base .chainBtn.active{ background: linear-gradient(90deg, rgba(0,82,255,.96), rgba(0,82,255,.50)); }

    .tickerWrap{
      flex: 1;
      min-width: 0;
      position: relative;
      overflow: hidden;
      border-radius: 999px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 30px rgba(0,0,0,.22);
      padding: 10px 12px;
    }

    .tickerWrap:before,
    .tickerWrap:after{
      content:"";
      position:absolute;
      top:0; bottom:0;
      width: 44px;
      pointer-events:none;
      z-index: 2;
    }
    .tickerWrap:before{ left:0; background: linear-gradient(90deg, rgba(11,16,51,.92), rgba(11,16,51,0)); }
    .tickerWrap:after{ right:0; background: linear-gradient(270deg, rgba(11,16,51,.92), rgba(11,16,51,0)); }

    .tickerTrack{
      display:flex;
      gap: 10px;
      align-items:center;
      white-space: nowrap;
      will-change: transform;
      animation: tickerMarquee var(--tickerSpeed) linear infinite;
    }

    .tickerWrap:hover .tickerTrack{ animation-play-state: paused; }

    @keyframes tickerMarquee{
      0%{ transform: translateX(0); }
      100%{ transform: translateX(calc(-1 * var(--tickerDistance))); }
    }

    .tickerItem{
      display:inline-flex;
      align-items:center;
      gap: 10px;
      padding: 7px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 0 0 1px var(--netGlow) inset;
      color: rgba(255,255,255,.92);
      font-weight: 900;
      font-size: 13px;
      letter-spacing: .1px;
      cursor:pointer;
    }

    .tickerLogoWrap{
      width:28px;
      height:28px;
      flex:0 0 28px;
      border-radius: 6px;
      overflow:hidden;
      display:grid;
      place-items:center;
      background: rgba(255,255,255,.07);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 8px 18px rgba(0,0,0,.22);
    }
    .tickerLogo{ width:100%; height:100%; object-fit: cover; display:block; }
    .tickerLogoFallback{ font-size: 12px; font-weight: 1100; color: rgba(255,255,255,.90); line-height: 1; }
    .tickerItem.top1 .tickerLogoWrap{ border-color: rgba(255,215,0,.35); box-shadow: 0 0 0 1px rgba(255,215,0,.15) inset, 0 10px 22px rgba(0,0,0,.22); }

    .tickerItem .rank{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width: 28px;
      height: 22px;
      padding: 0 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      font-size: 12px;
      font-weight: 1000;
      color: var(--netColor);
    }
    .tickerItem .sym{ font-weight: 950; }

    .tickerPct{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      height: 22px;
      padding: 0 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      font-size: 12px;
      font-weight: 950;
      color: rgba(255,255,255,.90);
    }
    .tickerPct.up{ color: rgba(20,241,149,.98); background: rgba(20,241,149,.10); border-color: rgba(20,241,149,.22); }
    .tickerPct.down{ color: rgba(255,90,90,.96); background: rgba(255,90,90,.10); border-color: rgba(255,90,90,.22); }

    .tickerItem.top1{
      background: rgba(255,215,0,.10);
      border-color: rgba(255,215,0,.32);
      box-shadow: 0 0 0 1px rgba(255,215,0,.18) inset, 0 12px 30px rgba(0,0,0,.26);
    }
    .tickerItem.top1 .rank{
      background: linear-gradient(90deg, #F3BA2F, #FFD700, #FFF2B0);
      color: rgba(10,10,22,.92);
      border: 0;
      font-weight: 1100;
    }

    /* Search (styled like main page) */
    .dexSearch{position: relative; width: 360px; max-width: 44vw; z-index: 99999; isolation:isolate; }
    .dexSearchInner{
      display:flex;
      gap: 8px;
      align-items:center;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 30px rgba(0,0,0,.22);
    }
    .dexInput{
      flex: 1;
      min-width: 0;
      background: transparent;
      border: 0;
      outline: none;
      color: rgba(255,255,255,.92);
      font-weight: 850;
      font-size: 13px;
    }
    .dexInput::placeholder{ color: rgba(255,255,255,.55); font-weight: 800; }

    /* Re-skin existing results dropdown to match main page style */
    .results{
      z-index: 1000001;
display:none;
      position:absolute;
      top: calc(100% + 10px);
      right: 0;
      left: auto;
      width: min(560px, calc(100vw - 28px));
      max-height: 60vh;
      overflow:auto;
      padding: 10px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      /* IMPORTANT: fully readable dropdown (no chart bleed-through) */
      background: rgba(12,16,40,.98);
      box-shadow: 0 26px 90px rgba(0,0,0,.78);
      isolation: isolate;
      z-index: 999999;
    }

    /* Search modal scrim: blocks chart/trades from showing through while searching */
    .searchScrim{
      display:none;
      position:fixed;
      inset:0;
      background: rgba(7,7,17,.72);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 999990;
    }
    .dexSearch.open .searchScrim{ display:block; }


    /* Keep DexGuard search row markup, but make it feel like the main dropdown */
    .resItem{
      border-radius: 16px;
      margin-bottom: 10px;
      border: 1px solid rgba(255,255,255,.10);
      background: #141c44;
      padding: 10px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      cursor:pointer;
      transition: background .15s ease, border-color .15s ease, transform .15s ease;
    }
    .resItem:hover{ background: #18214f; border-color: rgba(255,255,255,.18); transform: translateY(-1px); }
    .resItem:last-child{ margin-bottom: 0; }

    .resL{ display:flex; align-items:center; gap: 10px; min-width:0; }
    .resLogo{
      width: 36px;
      height: 36px;
      border-radius: 12px;
      overflow:hidden;
      display:grid;
      place-items:center;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      flex: 0 0 36px;
    }
    .resLogo img{ width:100%; height:100%; object-fit:cover; display:block; }
    .resLogo .fb{ font-weight:1100; color: rgba(255,255,255,.92); }

    .resTxt{ min-width:0; }
    .resName{ font-weight: 1000; letter-spacing:-.01em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .resMeta{ font-size: 12px; color: rgba(255,255,255,.64); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; margin-top: 2px; }
    .resR{ display:flex; gap: 8px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }

    /* Hide legacy UI bits so the bar looks identical */
    #btnGo{ display:none !important; }
    #modeHint{ display:none !important; }

    @media (max-width: 860px){
      .dexSearch{ width: 100%; max-width: 100%; }
      .bottomRow{ flex-direction: column; align-items: stretch; }
    }
    /* Layout: chart on top, trades underneath (desktop + mobile) */
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
      padding:14px;
    }

    .card{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.045);
      border-radius: 20px;
      overflow:hidden;
    }

    .cardHd{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:14px 14px;
      border-bottom:1px solid rgba(255,255,255,.07);
    }
    .pair{display:flex; align-items:center; gap:10px; min-width:0}
    .tlogo{width:38px; height:38px; border-radius:14px; overflow:hidden; display:grid; place-items:center; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10)}
    .tlogo img{width:100%; height:100%; object-fit:cover}
    .tlogo .fb{font-weight:900; opacity:.9}
    .pairTxt{min-width:0}
    .pairName{font-weight:950; letter-spacing:-.02em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .pairNameSub{font-size:12px; font-weight:800; opacity:.72; margin-left:8px; letter-spacing:0;}
    .pairMeta{font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}

    .stats{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}
    .statPill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.10);
      font-size:12px;
      color: rgba(255,255,255,.86);
      white-space:nowrap;
    }
    .statPill.up{border-color: rgba(20,241,149,.30); background: rgba(20,241,149,.10); color: rgba(20,241,149,.92)}
    .statPill.down{border-color: rgba(255,77,109,.28); background: rgba(255,77,109,.10); color: rgba(255,77,109,.92)}

    #chartWrap{height: clamp(380px, 52vh, 600px); position:relative; z-index:0}
    #chart{position:absolute; inset:0; z-index:1}
    /* Ensure dropdowns/menus always sit above the chart canvas */
    #chart canvas{position:relative; z-index:1}

    .controls{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:12px 12px;
      border-top:1px solid rgba(255,255,255,.07);
      background: rgba(0,0,0,.10);
      flex-wrap:wrap;
    }

    .tfRow{display:flex; gap:6px; flex-wrap:wrap}
    .tf{padding:8px 10px; border-radius: 999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); cursor:pointer; font-weight:850; font-size:12px}
    .tf.active{border-color: rgba(0,209,255,.42); background: rgba(0,209,255,.14)}

    .rightCtl{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .sel{padding:9px 10px; border-radius: 999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); color: var(--text)}

    .tableHd{
      display:flex; align-items:flex-end; justify-content:space-between;
      padding:14px 14px;
      border-bottom:1px solid rgba(255,255,255,.07);
    }
    .ttl{font-weight:950; letter-spacing:-.02em}
    .sub{font-size:12px; color:var(--muted)}

    .trades{
      height: 600px;
      overflow:auto;
    }

    .tradeHead, .tradeRow{
      display:grid;
      grid-template-columns: 90px 70px 90px 1fr 110px 1fr 34px;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      font-size:13px;
    }
    .tradeHead{
      position:sticky; top:0; z-index:5;
      background: rgba(12,12,20,.92);
      backdrop-filter: blur(12px);
      font-size:12px;
      color: rgba(255,255,255,.72);
      font-weight:900;
    }
    .tradeRow:hover{background: rgba(255,255,255,.05)}
    .typeBadge{
      display:inline-flex; align-items:center; justify-content:center;
      padding:6px 10px;
      border-radius:999px;
      font-weight:950;
      font-size:12px;
      letter-spacing:-.01em;
      border:1px solid rgba(255,255,255,.10);
      width:fit-content;
    }
    .typeBadge.buy{background: rgba(20,241,149,.10); border-color: rgba(20,241,149,.30); color: rgba(20,241,149,.95)}
    .typeBadge.sell{background: rgba(255,77,109,.10); border-color: rgba(255,77,109,.28); color: rgba(255,77,109,.95)}

    .mono{font-variant-numeric: tabular-nums; font-feature-settings: "tnum" 1}
    .maker{display:flex; align-items:center; gap:8px; min-width:0}
    .maker .addr{white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color: rgba(255,255,255,.85)}
    .maker .new{font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid rgba(153,69,255,.30); background: rgba(153,69,255,.12); color: rgba(153,69,255,.95); font-weight:900}

    .iconBtn{width:30px; height:30px; border-radius: 999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); display:grid; place-items:center; cursor:pointer}
    .iconBtn:hover{background: rgba(255,255,255,.08)}

    .toast{
      position:fixed;
      left:50%; transform: translateX(-50%);
      bottom:18px;
      background: rgba(10,10,18,.92);
      border:1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.92);
      padding:12px 14px;
      border-radius: 14px;
      box-shadow: 0 14px 60px rgba(0,0,0,.65);
      backdrop-filter: blur(14px);
      display:none;
      z-index:60;
      max-width: calc(100% - 24px);
    }

    /* Mobile-first: keep it clean */
    .mobileTabs{display:none}
    .tabBar{
      display:flex; gap:8px;
      padding:12px 12px;
      border-top:1px solid rgba(255,255,255,.06);
      background: rgba(0,0,0,.12);
    }
    .tab{
      flex:1;
      padding:10px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      font-weight:950;
      cursor:pointer;
      text-align:center;
    }
    .tab.active{border-color: rgba(153,69,255,.55); background: rgba(153,69,255,.14)}

    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr}
      .trades{height: 420px}
      #chartWrap{height: clamp(340px, 48vh, 520px)}
      .topbar{position:fixed; top: calc(env(safe-area-inset-top) + 10px); left:50%; transform: translateX(-50%); width: min(var(--max), calc(100vw - 20px));}
    }

    @media (max-width: 640px){
      /* Remove the harsh green mid-page wash on small screens */
      body{
        background:
          radial-gradient(900px 520px at 25% 0%, rgba(153,69,255,.22), transparent 60%),
          radial-gradient(900px 520px at 85% 18%, rgba(0,209,255,.14), transparent 60%),
          var(--bg);
      }

      .wrap{padding: calc(var(--topbar-space, 84px) + 12px) 10px 18px}

      /* Cleaner, less "thick" top header */
      .topbar{
        padding:10px 10px;
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }
      .actions{justify-content:space-between; width:100%; gap:8px; flex-wrap:wrap}
      .btn{padding:10px 12px; font-size:13px}
      .pill{padding:8px 10px}

      /* Make the trending/search header feel compact & aligned */
      .topBarInner{padding:12px 12px 12px}
      .hotLabel{padding:10px 12px; font-size:13px}
      .chainBtn{padding:8px 10px; font-size:12px}
      .dexSearchInner{padding:10px 12px}
      .results{left:0; right:0; width: calc(100vw - 24px)}

      .tickerTrack{animation-duration: 22s}
      .grid{padding:12px}
      .stats{justify-content:flex-start}

      /* Always show chart then trades (no tabs) */
      .mobileTabs{display:none !important}
      #mobileTradesWrap{display:none !important}
      .desktopOnly{display:block}

      #chartWrap{height: clamp(360px, 52vh, 560px)}
      .trades{height: 520px}

      /* Trades table: keep it readable */
      .tradeHead, .tradeRow{grid-template-columns: 62px 64px 78px 1fr 0 0 34px}
      .tradeHead .hideM, .tradeRow .hideM{display:none}
      .maker .new{display:none}
    }
  

/* ================================
   DexGuard UI/UX Premium Patch (Design-only)
   ================================ */

/* Design tokens */
:root{
  --s-1:8px;
  --s-2:12px;
  --s-3:16px;
  --s-4:20px;
  --s-5:24px;
  --r-1:14px;
  --r-2:18px;
  --r-3:22px;
  --e-1: 0 10px 28px rgba(0,0,0,.36);
  --e-2: 0 18px 54px rgba(0,0,0,.55);
  --glassSm: blur(10px);
  --glassNone: blur(0px);
  --hit:44px;
}

/* Mobile-only performance: reduce expensive blur on large surfaces */
@media (max-width: 760px){
  .panel{
    /* Avoid expensive blur on large surfaces */
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
    /* Avoid heavy shadows on full-width panels */
    box-shadow: var(--e-1) !important;
  }
  .topBar{
    /* Keep glass subtle (no heavy blur on wide area) */
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
  }
}

/* ===== Mobile-first: compact sticky top bar + proper hierarchy ===== */
@media (max-width: 740px){
  .wrap{
    padding: calc(var(--topbar-space, 84px) + 10px) 10px 110px; /* reserve space for bottom sheet */
  }

  .topbar{
    position: fixed;
    top: calc(env(safe-area-inset-top) + 8px);
    left: 50%;
    transform: translateX(-50%);
    width: min(var(--max), calc(100vw - 20px));
    z-index: 1000;
    padding: 10px 10px;
    border-radius: var(--r-2);
    backdrop-filter: var(--glassSm);
    -webkit-backdrop-filter: var(--glassSm);
  }
  .brand{ gap: 10px; }
  #topDexguardBtn{
    min-height: var(--hit);
    padding: 8px 14px;
  }
  .actions{
    gap: 8px;
    flex-wrap: nowrap;
    justify-content: flex-end;
    width: auto;
  }
  #btnBack{
    min-height: var(--hit);
    padding: 10px 12px;
    font-size: 12px;
    white-space: nowrap;
  }
  #btnX{
    width: var(--hit);
    height: var(--hit);
    padding: 0;
    justify-content: center;
  }
  #btnX span{ display:none; }

  /* Trending/search header: compact, app-like */
  .topBarInner{
    padding: 10px 10px 10px;
    gap: 10px;
  }
  .topRow{
    gap: 10px;
    flex-wrap: wrap;
    justify-content: space-between;
  }
  .hotLabel{
    display:none; /* keep accessible via ticker; don't dominate */
  }
  .chainToggle{
    margin-left: 0;
    width: 100%;
    justify-content: space-between;
  }
  .chainBtn{
    flex: 1;
    text-align: center;
    min-height: 40px;
    padding: 10px 10px;
    font-size: 12px;
  }

  .bottomRow{
    flex-direction: column;
    align-items: stretch;
    gap: 10px;
  }
  .tickerWrap{
    padding: 8px 10px;
    border-radius: 18px;
  }
  .tickerTrack{ animation-duration: 22s; }
  .tickerItem{ font-size: 12px; padding: 8px 10px; }

  /* Search: prominent + thumb friendly */
  .dexSearch{ width: 100%; max-width: 100%; }
  .dexSearchInner{
    min-height: var(--hit);
    padding: 10px 12px;
    border-radius: 18px;
  }
  .dexInput{
    font-size: 14px;
    font-weight: 900;
  }
  .results{
    max-height: 58vh;
    border-radius: 18px;
  }

  /* Main content hierarchy */
  #chartWrap{ height: clamp(360px, 52vh, 560px); }
  .card{
    border-radius: var(--r-3);
  }
  .cardHd{
    padding: 12px 12px;
    gap: 10px;
  }
  .tlogo{
    width: 40px;
    height: 40px;
    border-radius: 14px;
  }
  .pairName{
    font-size: 15px;
  }
  .stats{
    justify-content: flex-start;
    gap: 8px;
  }

  /* Hide legacy mobile tabs wrapper entirely */
  .mobileTabs{ display:none !important; }
  #mobileTradesWrap{ display:none !important; }

  /* ===== Live Trades bottom sheet ===== */
  #tradesCard{
    --sheetPeek: 58px;
    --sheetH: clamp(240px, 42vh, 420px);
    position: fixed !important;
    left: 10px;
    right: 10px;
    bottom: calc(env(safe-area-inset-bottom) + 10px);
    margin: 0 !important;
    height: var(--sheetH);
    max-height: 45vh;
    max-width: none !important;
    z-index: 95;
    box-shadow: var(--e-2);
    transform: translateY(calc(100% - var(--sheetPeek)));
    transition: transform .20s cubic-bezier(.2,.9,.2,1);
    will-change: transform;
    background: rgba(10,12,22,.72);
    backdrop-filter: var(--glassSm);
    -webkit-backdrop-filter: var(--glassSm);
    border-radius: 20px;
    overflow: hidden;
  }
  #tradesCard.sheetOpen{
    transform: translateY(0);
  }
  #tradesCard .tableHd{
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255,255,255,.08);
    background: rgba(10,12,22,.74);
    backdrop-filter: var(--glassSm);
    -webkit-backdrop-filter: var(--glassSm);
    cursor: pointer;
    user-select: none;
  }
  #tradesCard .tableHd::before{
    content:"";
    display:block;
    width: 46px;
    height: 4px;
    border-radius: 999px;
    background: rgba(255,255,255,.18);
    margin: 2px auto 8px;
  }
  #tradesCard .tableHd .ttl{
    font-size: 14px;
    letter-spacing: -.01em;
  }
  #tradesCard .tableHd .sub{
    font-size: 12px;
  }
  #tradesCard .tableHd{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
  }
  #tradesCard .tableHd .sheetRight{
    display:flex;
    align-items:center;
    gap: 8px;
  }
  #tradesCard:not(.sheetOpen) .trades{
    display:none;
  }
  #tradesCard.sheetOpen .trades{
    height: calc(var(--sheetH) - 78px);
    max-height: calc(45vh - 78px);
    overflow:auto;
    -webkit-overflow-scrolling: touch;
  }
  #tradesCard .sheetToggleBtn{
    width: 40px;
    height: 40px;
  }
  #tradesCard.sheetOpen .sheetToggleBtn{
    transform: rotate(180deg);
  }


  /* Trades columns: reduce clutter on mobile */
  .tradeHead, .tradeRow{
    grid-template-columns: 64px 64px 84px 1fr 0 0 34px !important;
  }
  .maker .new{ display:none !important; }
}

/* ===== Desktop premium grid balancing ===== */
@media (min-width: 980px){
  .grid{
    gap: 16px;
    padding: 16px;
  }
  #chartWrap{ height: clamp(460px, 56vh, 720px); }
  .cardHd{ padding: 16px 16px; }
  .controls{ padding: 12px 14px; }
  .trades{ height: 560px; }
}

/* ================================
   DexGuard Targeted UI PATCH (A/B/C)
   ================================ */
@media (max-width: 760px){
/* Header pills stay single-row with horizontal scroll if needed (no wrapping) */
#netPills{
  display:flex;
  flex-wrap: nowrap !important;
  gap: 8px;
  overflow-x: auto;
  overflow-y: hidden;
  scrollbar-width: none;
  max-width: 52vw;
}
#netPills::-webkit-scrollbar{ display:none; }
@media (max-width: 640px){
  #netPills{ max-width: 44vw; }
  .pill{ min-height: 40px; padding: 8px 10px; }
}


@media (max-width: 760px){
/* TASK C — Search dropdown never clipped */
.panel{ overflow: visible !important; }
.topBar{ z-index: 5000 !important; }
.dexSearch{ z-index: 6000 !important; }
.results{ z-index: 7000 !important; }
.grid{ position: relative; z-index: 1; }

/* TASK B — Live Trades stays under chart, expands downward only */
#tradesCard{
  position: relative !important;
  left: auto !important; right: auto !important; bottom: auto !important;
  transform: none !important;
  height: auto !important;
  max-height: none !important;
  margin: 0 !important;
}
#tradesCard .tableHd{
  cursor: pointer;
  user-select: none;
}
#tradesCard .tableHd .sheetRight{ display:flex; align-items:center; gap:10px; }
#tradesCard .accToggleBtn{
  width: 40px;
  height: 40px;
  display: grid;
  place-items: center;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.05);
}
#tradesCard .accToggleBtn:hover{ background: rgba(255,255,255,.08); }
#tradesCard .accToggleBtn svg{ transition: transform var(--t); }
#tradesCard.open .accToggleBtn svg{ transform: rotate(180deg); }

/* collapsed: header only */
#tradesCard:not(.open) .trades{ display:none !important; }

/* expanded: internal scrolling region, still in page flow */
#tradesCard.open .trades{
  display:block !important;
  height: auto !important;
  max-height: clamp(240px, 45vh, 600px);
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
@media (max-width: 980px){
  #tradesCard.open .trades{ max-height: clamp(220px, 42vh, 520px); }
}



}
/* ===== DexGuard Live Terminal Patch: Split Panel + Live Txns ===== */
@media (max-width: 760px){
  #btnRefresh,#btnFit{display:none !important;}
}
.splitRoot{display:flex; flex-direction:column; height:clamp(520px,70vh,780px); min-height:480px; max-height:820px; margin-top:10px;}
.splitChart{flex:1 1 auto; min-height:220px; position:relative; display:flex; flex-direction:column;}
.splitChart #chartWrap{flex:1 1 auto; height:100% !important; min-height:220px;}
.splitHandle{flex:0 0 14px; height:14px; cursor:ns-resize; touch-action:none; user-select:none; display:flex; align-items:center; justify-content:center;
  background:rgba(255,255,255,.03); border-top:1px solid rgba(255,255,255,.06); border-bottom:1px solid rgba(255,255,255,.06);}
.splitHandle::before{content:""; width:52px; height:4px; border-radius:999px; background:rgba(255,255,255,.18);}
.splitPanel{flex:0 0 var(--split-bottom,260px); min-height:160px; max-height:calc(100% - 220px); overflow:hidden; display:flex; flex-direction:column;
  background:rgba(0,0,0,.12); border-radius:16px;}
.splitTabs{display:flex; gap:8px; padding:10px 10px 8px; align-items:center; border-bottom:1px solid rgba(255,255,255,.07); background:rgba(0,0,0,.16);}
.splitTab{appearance:none; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.03); color:rgba(255,255,255,.88); padding:8px 10px; border-radius:12px;
  font-weight:650; font-size:12px; letter-spacing:.2px; cursor:pointer;}
.splitTab.active{background:rgba(255,184,0,.14); border-color:rgba(255,184,0,.22); color:#ffd37a;}
.splitBody{flex:1; overflow:auto; -webkit-overflow-scrolling:touch;}
.tradeRow.enter{animation:tradeEnter .26s ease-out both;}
@keyframes tradeEnter{from{opacity:0; transform:translateY(-10px);}to{opacity:1; transform:translateY(0);}}
/* Hide legacy mobile chart/trades tabs (split panel replaces them) */
.mobileTabs{display:none !important;}
#mobileTradesWrap{display:none !important;}



/* ================================
   MOBILE-ONLY GAP + APP-FEEL PATCH (step01)
   - Tightens spacing, removes blank areas under chart/trades
   - Keeps consistent 10–12px side padding
   - Does NOT affect desktop
   ================================ */
@media (max-width: 760px){
  .wrap{
    max-width: 100% !important;
    margin: 0 auto !important;
    padding: 10px 12px 16px !important;
  }

  .topbar{
    margin: 8px 0 10px !important;
    padding: 8px 10px !important;
    border-radius: 18px !important;
  }

  .topBarInner{
    padding: 10px 10px 10px !important;
    gap: 8px !important;
  }

  .grid{
    padding: 10px !important;
    gap: 10px !important;
  }

  .card{ border-radius: 18px !important; }
  .cardHd{ padding: 10px 12px !important; }
  .controls{ padding: 8px 10px !important; gap: 8px !important; }

  /* Prevent large blank areas under the chart */
  #chartWrap{
    height: clamp(280px, 46vh, 460px) !important;
  }

  /* If split layout is enabled, remove its fixed height clamps on mobile */
  .splitRoot{
    height: auto !important;
    min-height: 0 !important;
    max-height: none !important;
    margin-top: 8px !important;
  }
  .splitChart #chartWrap{
    height: auto !important;
    min-height: 220px !important;
  }
  .splitPanel{
    flex: 0 0 auto !important;
    min-height: 140px !important;
    max-height: none !important;
  }

  /* Trades: avoid huge empty space; keep it scrollable within a sensible max-height */
  .trades{
    height: auto !important;
    max-height: clamp(260px, 38vh, 420px) !important;
    overflow: auto !important;
    -webkit-overflow-scrolling: touch;
  }

  /* Tighten ticker/search blocks */
  .tickerWrap{ padding: 8px 10px !important; }
  .dexSearchInner{ padding: 10px 10px !important; }

  /* Reduce extra vertical padding/margins around panels/cards */
  .panel{ margin-top: 0 !important; }
}



/* ================================
   MOBILE-ONLY TOP APP BAR (step02)
   Dexscreener-style single-row header:
   left = logo, right = Back + X
   Safe-area aware (iPhone notch)
   Desktop unchanged
   ================================ */
@media (max-width: 760px){
  /* Reserve space for fixed app bar (safe-area + bar height) */
  :root{ --appbarH: 56px; }

  .wrap{
    /* keep side padding from step01, but add top space for fixed bar */
    padding-top: calc(env(safe-area-inset-top) + var(--appbarH) + 10px) !important;
  }

  .topbar{
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    width: 100% !important;
    transform: none !important;
    margin: 0 !important;

    /* Safe-area padding for iOS */
    padding-top: calc(env(safe-area-inset-top) + 8px) !important;
    padding-bottom: 8px !important;
    padding-left: 12px !important;
    padding-right: 12px !important;

    border-radius: 0 0 18px 18px !important;
    box-shadow: 0 10px 26px rgba(0,0,0,.55) !important;

    display: flex !important;
    flex-direction: row !important;
    flex-wrap: nowrap !important;
    align-items: center !important;
    justify-content: space-between !important;
    gap: 10px !important;

    /* App-bar look */
    background: rgba(12,16,40,.92) !important;
    backdrop-filter: blur(14px) !important;
    -webkit-backdrop-filter: blur(14px) !important;
    border: 1px solid rgba(255,255,255,.10) !important;
    border-left: 0 !important;
    border-right: 0 !important;
    border-top: 0 !important;

    z-index: 99999 !important;
  }

  .topbar .brand{
    flex: 0 1 auto !important;
    min-width: 0 !important;
    display: flex !important;
    align-items: center !important;
  }

  /* Logo sizing like an app bar */
  .topLogo{
    height: 28px !important;
    max-width: 160px !important;
  }

  .topbar .actions{
    flex: 0 0 auto !important;
    display: flex !important;
    align-items: center !important;
    justify-content: flex-end !important;
    flex-wrap: nowrap !important;
    gap: 8px !important;
    white-space: nowrap !important;
    width: auto !important;
    min-width: 0 !important;
  }

  /* Only show Back + X on mobile app bar (keep IDs intact) */
  #netPills{ display: none !important; }
  #btnBuy{ display: none !important; }

  #btnBack{
    min-height: 40px !important;
    height: 40px !important;
    padding: 0 12px !important;
    font-size: 12px !important;
    border-radius: 999px !important;
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
  }

  #btnX{
    width: 40px !important;
    height: 40px !important;
    min-height: 40px !important;
    padding: 0 !important;
    border-radius: 999px !important;
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
  }
  #btnX span{ display: none !important; }

  /* Absolutely prevent any wrapping/stacking */
  .topbar, .topbar *{ max-width: 100%; }
}

/* Extra small devices */
@media (max-width: 360px){
  .topLogo{ max-width: 140px !important; }
  #btnBack{ padding: 0 10px !important; font-size: 11px !important; }
}



/* ================================
   MOBILE-ONLY CHAIN SEGMENTED CONTROL (step03)
   - Dexscreener-style segmented control under the app bar
   - Equal-width, thumb-friendly (min 44px)
   - Keeps existing data-net attributes + event logic intact
   - Desktop unchanged
   ================================ */
@media (max-width: 760px){
  /* Place segmented control on its own line under the header area */
  .topRow{
    flex-direction: column !important;
    align-items: stretch !important;
    justify-content: flex-start !important;
    gap: 10px !important;
    flex-wrap: nowrap !important;
  }

  /* Segmented control container */
  #trendToggle.chainToggle{
    width: 100% !important;
    margin: 0 !important;
    display: flex !important;
    align-items: stretch !important;
    justify-content: space-between !important;
    gap: 0 !important;
    padding: 4px !important;
    border-radius: 16px !important;
    background: rgba(255,255,255,.06) !important;
    border: 1px solid rgba(255,255,255,.12) !important;
    box-shadow: 0 10px 24px rgba(0,0,0,.28) !important;
    overflow: hidden !important;
  }

  /* Segments */
  #trendToggle.chainToggle .chainBtn{
    flex: 1 1 0 !important;
    min-height: 44px !important;
    height: 44px !important;
    padding: 0 10px !important;
    margin: 0 !important;

    border: 0 !important;
    border-radius: 12px !important;
    background: transparent !important;
    box-shadow: none !important;

    font-size: 12px !important;
    font-weight: 1050 !important;
    letter-spacing: .35px !important;
    color: rgba(255,255,255,.84) !important;

    transform: none !important; /* prevent bounce inside segmented control */
  }

  #trendToggle.chainToggle .chainBtn:hover{
    background: rgba(255,255,255,.05) !important;
  }
  #trendToggle.chainToggle .chainBtn:active{
    background: rgba(255,255,255,.08) !important;
  }

  /* Theme-highlight active chain (purple/blue) */
  #trendToggle.chainToggle .chainBtn.active{
    color: rgba(255,255,255,.98) !important;
    text-shadow: 0 1px 0 rgba(0,0,0,.30) !important;
    background: linear-gradient(90deg, rgba(153,69,255,.95), rgba(0,209,255,.72)) !important;
    box-shadow: 0 12px 28px rgba(153,69,255,.18) !important;
  }

  /* Subtle dividers between segments (disabled around active) */
  #trendToggle.chainToggle .chainBtn + .chainBtn{
    box-shadow: inset 1px 0 0 rgba(255,255,255,.08) !important;
  }
  #trendToggle.chainToggle .chainBtn.active + .chainBtn,
  #trendToggle.chainToggle .chainBtn + .chainBtn.active{
    box-shadow: none !important;
  }
}



/* ================================
   MOBILE-ONLY SEARCH APP BAR (step04)
   - Full-width, Dexscreener-style search
   - Sticky ONLY on mobile (no overlap; stays in flow)
   - Respects safe areas + fixed app bar
   - Keeps existing input id/name + JS handlers unchanged
   ================================ */
@media (max-width: 760px){
  /* Put search first in the bottom row for an app-like hierarchy */
  .bottomRow{ position: relative !important; }
  .bottomRow .dexSearch{ order: 0 !important; }
  .bottomRow .tickerWrap{ order: 1 !important; }

  /* Sticky search under the fixed top app bar */
  .dexSearch{
    width: 100% !important;
    max-width: 100% !important;
    position: sticky !important;
    top: calc(env(safe-area-inset-top) + var(--appbarH, 56px) + 8px) !important;
    z-index: 9000 !important;

    /* keep spacing consistent and prevent "floating overlap" feel */
    margin: 0 !important;
  }

  /* Give the sticky region a subtle backing so content never reads "under" it */
  .dexSearch::before{
    content:"";
    position:absolute;
    left:-12px; right:-12px;
    top:-10px;
    height: calc(100% + 20px);
    background: rgba(7,7,17,.92);
    border-bottom: 1px solid rgba(255,255,255,.08);
    border-radius: 0 0 16px 16px;
    z-index: -1;
    pointer-events:none;
  }

  .dexSearchInner{
    width: 100% !important;
    min-height: 48px !important;
    padding: 10px 12px !important;
    border-radius: 16px !important;
    background: rgba(12,16,40,.92) !important;
    border: 1px solid rgba(255,255,255,.14) !important;
    box-shadow: 0 12px 34px rgba(0,0,0,.34) !important;
    backdrop-filter: blur(14px) !important;
    -webkit-backdrop-filter: blur(14px) !important;
  }

  .dexInput{
    font-size: 14px !important;
    font-weight: 950 !important;
    letter-spacing: -.01em !important;
  }

  /* Results dropdown: keep anchored to sticky search and fully readable */
  .dexSearch .results{
    top: calc(100% + 10px) !important;
    left: 0 !important;
    right: 0 !important;
    width: calc(100vw - 24px) !important; /* matches wrap side padding (12px) */
    max-height: 62vh !important;
    border-radius: 18px !important;
  }

  /* Ensure sticky search never causes hidden content behind it */
  .topBarInner{ scroll-margin-top: calc(env(safe-area-inset-top) + var(--appbarH, 56px) + 16px) !important; }
}

/* ================================
   MOBILE-ONLY SEARCH MODAL / SHEET (step05)
   - Dark backdrop blocks chart bleed-through
   - Results sit above EVERYTHING (z-index)
   - Backdrop tap closes results (existing handler)
   - Disables body scroll while open
   - Desktop unchanged
   ================================ */
@media (max-width: 760px){
  body.searchModalOpen{
    overflow: hidden !important;
    touch-action: none;
  }

  /* Backdrop (reuse existing #searchScrim so IDs/handlers stay the same) */
  #searchScrim.searchScrim{
    display: none;
    position: fixed !important;
    inset: 0 !important;
    background: rgba(0,0,0,.72) !important;
    backdrop-filter: blur(10px) !important;
    -webkit-backdrop-filter: blur(10px) !important;
    z-index: 1000000 !important;
  }
  .dexSearch.open #searchScrim.searchScrim{
    display: block !important;
  }

  /* Results as modal/sheet overlay */
  #results.results{
    position: fixed !important;
    left: 12px !important;
    right: 12px !important;
    bottom: calc(env(safe-area-inset-bottom) + 12px) !important;
    top: auto !important;
    width: auto !important;

    max-height: min(72vh, calc(100vh - (env(safe-area-inset-top) + var(--appbarH, 56px) + 120px))) !important;

    border-radius: 18px !important;
    background: rgba(12,16,40,.98) !important;
    box-shadow: 0 26px 90px rgba(0,0,0,.78) !important;

    z-index: 1000001 !important;
    overscroll-behavior: contain;
    -webkit-overflow-scrolling: touch;
  }

  /* Make sure the sticky search stays above content but below the modal stack */
  .dexSearch{
    z-index: 9999 !important;
  }
}



/* ================================
   MOBILE-ONLY TOKEN STATS GRID (step06)
   - Price / Liq / MCap / 24h as a 2x2 Dexscreener-style grid
   - Uses existing rendered values (no data fetching changes)
   - Desktop unchanged
   ================================ */
@media (max-width: 760px){
  /* Stack token header + stats for readability */
  #chartCard .cardHd{
    flex-direction: column !important;
    align-items: stretch !important;
    gap: 10px !important;
  }
  #chartCard .pair{ width: 100% !important; }

  /* 2x2 grid */
  #stats.stats{
    width: 100% !important;
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    gap: 8px !important;
    justify-content: stretch !important;
    align-items: stretch !important;
  }

  /* Small cards/pills */
  #stats .statPill{
    white-space: normal !important;
    border-radius: 14px !important;
    padding: 10px 10px !important;
    min-height: 44px !important;
    display: flex !important;
    flex-direction: column !important;
    align-items: flex-start !important;
    justify-content: center !important;
    gap: 2px !important;
    background: rgba(255,255,255,.05) !important;
    border: 1px solid rgba(255,255,255,.12) !important;
  }
  #stats .statPill:only-child{
    grid-column: 1 / -1 !important;
  }

  #stats .statPill .k{
    font-size: 11px !important;
    font-weight: 900 !important;
    letter-spacing: .18px !important;
    color: rgba(255,255,255,.62) !important;
    line-height: 1.1 !important;
  }
  #stats .statPill .v{
    font-size: 13px !important;
    font-weight: 1050 !important;
    letter-spacing: -.01em !important;
    color: rgba(255,255,255,.92) !important;
    line-height: 1.15 !important;
  }

  /* Up/Down tint like Dexscreener */
  #stats .statPill.up{
    border-color: rgba(20,241,149,.30) !important;
    background: rgba(20,241,149,.10) !important;
  }
  #stats .statPill.up .v{ color: rgba(20,241,149,.96) !important; }

  #stats .statPill.down{
    border-color: rgba(255,77,109,.28) !important;
    background: rgba(255,77,109,.10) !important;
  }
  #stats .statPill.down .v{ color: rgba(255,77,109,.96) !important; }
}



/* ================================
   MOBILE-ONLY CHART AREA (step07)
   - Dexscreener-style: clean, full width, stable height
   - Fixes weird scaling / overscroll issues on mobile
   - Keeps dropdowns/menus above the chart
   - Does NOT affect desktop
   ================================ */
@media (max-width: 760px){
  /* Keep chart in a stable box so lightweight-charts can resize correctly */
  #chartWrap{
    width: 100% !important;
    height: clamp(360px, 52vh, 560px) !important;
    min-height: 360px !important;
    max-height: 560px !important;

    position: relative !important;
    overflow: hidden !important;

    /* Prevent iOS rubber-band / scroll-chaining weirdness while interacting with the chart */
    overscroll-behavior: contain;
    touch-action: none; /* let the chart handle touch gestures; scroll page outside the chart */
  }

  /* Ensure the chart always fills the container (prevents odd scaling) */
  #chart{
    position: absolute !important;
    inset: 0 !important;
    width: 100% !important;
    height: 100% !important;
  }
  #chart > div,
  #chart canvas{
    width: 100% !important;
    height: 100% !important;
    max-width: 100% !important;
    max-height: 100% !important;
  }

  /* Avoid any horizontal wobble from chart internals */
  #chartWrap, #chart, .card{ max-width: 100% !important; }

  /* Keep chart beneath any dropdowns/menus/modals */
  #chartWrap{ z-index: 0 !important; }
  #chart, #chart canvas{ z-index: 0 !important; }
}



/* ================================
   MOBILE-ONLY TIMEFRAME PILL ROW (step08)
   - Dexscreener-like pill row
   - Horizontal scroll if needed, no wrapping
   - Very clear active state (purple/blue theme)
   - Keeps existing click handlers intact (CSS-only)
   - Desktop unchanged
   ================================ */
@media (max-width: 760px){
  /* Timeframes: single-line pill row with horizontal scroll */
  #tfRow.tfRow{
    flex-wrap: nowrap !important;
    overflow-x: auto !important;
    overflow-y: hidden !important;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    gap: 8px !important;
    padding: 4px 2px 2px !important;
    margin: 0 !important;
    white-space: nowrap;
  }
  #tfRow.tfRow::-webkit-scrollbar{ display:none; }

  /* End padding so last pill isn't flush to the edge */
  #tfRow.tfRow::after{
    content:"";
    flex: 0 0 10px;
  }

  /* Pills */
  #tfRow.tfRow .tf{
    flex: 0 0 auto !important;
    min-height: 44px !important;
    height: 44px !important;
    padding: 0 14px !important;
    border-radius: 999px !important;
    border: 1px solid rgba(255,255,255,.14) !important;
    background: rgba(255,255,255,.06) !important;
    color: rgba(255,255,255,.88) !important;
    font-weight: 1000 !important;
    font-size: 12px !important;
    letter-spacing: .25px !important;
    cursor: pointer;
    transform: none !important; /* avoid jitter while scrolling */
  }
  #tfRow.tfRow .tf:hover{ background: rgba(255,255,255,.09) !important; }
  #tfRow.tfRow .tf:active{ background: rgba(255,255,255,.12) !important; }

  /* Clear active state */
  #tfRow.tfRow .tf.active{
    color: rgba(255,255,255,.98) !important;
    text-shadow: 0 1px 0 rgba(0,0,0,.30) !important;
    background: linear-gradient(90deg, rgba(153,69,255,.95), rgba(0,209,255,.70)) !important;
    border-color: rgba(255,255,255,.22) !important;
    box-shadow: 0 12px 28px rgba(153,69,255,.18) !important;
  }
}


/* ================================
   MOBILE-ONLY MODE BAR (step09)
   - Chart+Txns / Chart / Txns (Dexscreener-style)
   - Wires to existing elements via minimal JS
   - Desktop unchanged
   ================================ */
.modeBar{ display:none; }

@media (max-width: 760px){
  .modeBar{
    display:flex;
    gap:8px;
    align-items:center;
    justify-content:space-between;
    padding: 10px 10px 12px;
    border-top: 1px solid rgba(255,255,255,.07);
    background: rgba(0,0,0,.10);
    flex-wrap: nowrap;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
  }
  .modeBar::-webkit-scrollbar{ display:none; }

  .modeBtn{
    flex: 1 0 auto;
    min-height: 44px;
    height: 44px;
    padding: 0 14px;
    border-radius: 999px;
    border: 1px solid rgba(255,255,255,.12);
    background: rgba(255,255,255,.05);
    color: rgba(255,255,255,.88);
    font-weight: 950;
    font-size: 12px;
    letter-spacing: .2px;
    cursor: pointer;
    white-space: nowrap;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    transition: transform .15s ease, background .15s ease, border-color .15s ease, box-shadow .15s ease;
  }
  .modeBtn:active{ transform: scale(.99); }

  .modeBtn.active{
    border-color: rgba(153,69,255,.55);
    background: linear-gradient(90deg, rgba(153,69,255,.92), rgba(0,209,255,.62));
    color: rgba(255,255,255,.98);
    box-shadow: 0 12px 28px rgba(153,69,255,.16);
    text-shadow: 0 1px 0 rgba(0,0,0,.28);
  }

  /* Mode behavior (mobile only) */
  body[data-mmode="chart"] #tradesCard{ display:none !important; }
  body[data-mmode="txns"] #chartWrap,
  body[data-mmode="txns"] .controls{ display:none !important; }

  body[data-mmode="txns"] #tradesCard{ display:block !important; }
  body[data-mmode="chart"] #chartWrap,
  body[data-mmode="chart"] .controls{ display:block !important; }
  body[data-mmode="both"] #chartWrap,
  body[data-mmode="both"] .controls{ display:block !important; }
  body[data-mmode="both"] #tradesCard{ display:block !important; }

  /* Ensure legacy mobile trades wrapper never conflicts */
  #mobileTradesWrap{ display:none !important; }
}



/* ================================
   MOBILE-ONLY LIVE TRADES ACCORDION (step10)
   - Live Trades sits under the chart in normal page flow (NOT floating)
   - Default collapsed; tap header to toggle
   - When open: internal scroll with max-height clamp(240px–520px)
   - Desktop unchanged
   ================================ */
@media (max-width: 760px){
  /* Ensure the main trades card is visible on mobile (even if marked desktopOnly) */
  #tradesCard.desktopOnly{ display: block !important; }

  /* Force normal flow (override any old bottom-sheet rules) */
  #tradesCard{
    position: relative !important;
    left: auto !important;
    right: auto !important;
    bottom: auto !important;
    top: auto !important;
    transform: none !important;

    height: auto !important;
    max-height: none !important;

    margin: 10px 0 0 !important;
    z-index: 2 !important;
  }

  #tradesCard .tableHd{
    display: flex !important;
    align-items: center !important;
    justify-content: space-between !important;
    gap: 10px !important;

    padding: 12px 12px !important;
    border-bottom: 1px solid rgba(255,255,255,.10) !important;
    cursor: pointer !important;
    user-select: none !important;
  }

  #tradesCard .tableHd .ttl{
    font-size: 14px !important;
    letter-spacing: -.01em !important;
  }
  #tradesCard .tableHd .sub{
    font-size: 12px !important;
    opacity: .85 !important;
  }

  #tradesCard .sheetRight{
    display: flex !important;
    align-items: center !important;
    gap: 10px !important;
    flex: 0 0 auto !important;
  }

  #tradesCard .tradeChevron{
    width: 40px !important;
    height: 40px !important;
    min-width: 40px !important;
    display: inline-flex !important;
    align-items: center !important;
    justify-content: center !important;
    border-radius: 999px !important;
    background: rgba(255,255,255,.06) !important;
    border: 1px solid rgba(255,255,255,.10) !important;
    transition: transform .18s ease !important;
  }
  #tradesCard.open .tradeChevron{ transform: rotate(180deg) !important; }

  /* Default collapsed */
  #tradesCard:not(.open) .trades{ display: none !important; }

  /* Open state: internal scrolling */
  #tradesCard.open .trades{
    display: block !important;
    height: auto !important;
    max-height: clamp(240px, 44vh, 520px) !important;
    overflow: auto !important;
    -webkit-overflow-scrolling: touch;
  }

  /* Avoid extra gaps below the list */
  #tradesCard .trades{ padding-bottom: 0 !important; }
}



/* ================================
   MOBILE-ONLY TRADES COLUMN SIMPLIFY (step11)
   - Keep: Age, Type, USD, Price (or Amount), Maker shortened, Link icon
   - Hide nonessential columns on small screens (Amount)
   - CSS/layout only; underlying data unchanged
   ================================ */
@media (max-width: 760px){
  /* Show Price + Maker on mobile even if marked hideM */
  .tradeHead .col.price.hideM, .tradeRow .col.price.hideM,
  .tradeHead .col.maker.hideM, .tradeRow .col.maker.hideM{
    display: block !important;
  }

  /* Hide Amount on mobile */
  .tradeHead .col.amt, .tradeRow .col.amt{
    display: none !important;
  }

  /* Dexscreener-like compact columns */
  .tradeHead, .tradeRow{
    grid-template-columns: 58px 64px 86px 1fr 1fr 34px !important;
    gap: 8px !important;
  }

  /* Readability tuning */
  .tradeRow{ font-size: 12px !important; }
  .tradeHead{ font-size: 11px !important; }

  /* Maker shortening */
  .tradeRow .maker,
  .tradeRow .col.maker{
    min-width: 0 !important;
  }
  .tradeRow .maker .addr{
    max-width: 10ch;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  /* In case maker is rendered as plain text inside the maker column */
  .tradeRow .col.maker,
  .tradeHead .col.maker{
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  /* Keep the Type badge legible in tight rows */
  .typeBadge{
    padding: 6px 9px !important;
    font-size: 11px !important;
  }

  /* Link icon remains thumb-friendly */
  .iconBtn{
    width: 34px !important;
    height: 34px !important;
  }
}


/* ================================
   MOBILE-ONLY OVERLAY STACKING FIX (step13)
   - Ensure overlays (search results, dropdowns, menus) always sit above chart canvas & panels
   - Fix stacking contexts via isolation / z-index without changing desktop
   ================================ */
@media (max-width: 760px){
  /* Create a predictable stacking root for the app */
  body{
    position: relative;
    isolation: isolate; /* prevents weird stacking-context interactions */
  }

  /* Keep chart/canvas at the bottom of the local stacking order */
  #chartCard, #chartWrap, #chart, #chart canvas{
    position: relative;
    z-index: 0 !important;
  }

  /* Panels/cards stay above the chart baseline but below overlays */
  .panel, .grid, .card, .controls{
    position: relative;
    z-index: 1;
  }

  /* Avoid accidental stacking contexts that trap z-index */
  .panel, .card, .grid, #chartWrap, #chart{
    transform: none !important;
    filter: none !important;
    will-change: auto !important;
  }

  /* Search overlay: always on top */
  .searchScrim, #searchScrim{
    position: fixed !important;
    z-index: 2147483000 !important;
  }
  .results, #results{
    z-index: 2147483001 !important;
  }

  /* Generic "overlay-ish" popups/tooltips (safe no-op if not present) */
  [role="dialog"], [role="menu"], [role="listbox"], [role="tooltip"],
  .dropdown, .dropdownMenu, .menu, .menuPanel, .popover, .tooltip, .contextMenu, .sheet{
    z-index: 2147482990 !important;
  }
}


/* ================================
   MOBILE-ONLY SAFE-AREA + SCROLL POLISH (step14)
   - Use env(safe-area-inset-top/bottom) for sticky bars + bottom spacing
   - Prevent "rubber band" overlap on iOS
   - Ensure overlays lock background scroll (works with existing searchModalOpen lock)
   - Desktop unchanged
   ================================ */
@media (max-width: 760px){
  :root{
    --safeTop: env(safe-area-inset-top);
    --safeBottom: env(safe-area-inset-bottom);
  }

  /* Give the whole page a safe bottom so nothing sits under the home indicator */
  .wrap{
    padding-bottom: calc(16px + var(--safeBottom)) !important;
  }

  /* Ensure fixed/sticky bars respect safe areas */
  .topbar{
    padding-top: calc(var(--safeTop) + 8px) !important;
  }
  .dexSearch{
    top: calc(var(--safeTop) + var(--appbarH, 56px) + 8px) !important;
  }

  /* Any bottom UI (toast/sheets) should sit above the home indicator */
  .toast{
    bottom: calc(18px + var(--safeBottom)) !important;
  }
  /* Search results sheet already uses a bottom offset; enforce safe-area just in case */
  #results.results, .results{
    padding-bottom: max(10px, var(--safeBottom)) !important;
  }

  /* Reduce iOS rubber-band bounce that can cause fixed/sticky overlap */
  html, body{
    overscroll-behavior-x: none;
    overscroll-behavior-y: none;
  }

  /* Nested scrollers stay smooth */
  .trades, .results{
    -webkit-overflow-scrolling: touch;
  }

  /* When an overlay is open, keep the background fully locked and non-bouncy */
  body.searchModalOpen{
    overscroll-behavior: none;
    touch-action: none;
  }
}


/* ================================
   MOBILE-ONLY PERFORMANCE OPTIMIZATIONS (step15)
   - Reduce expensive blurs and heavy shadows on large surfaces
   - Keep core behavior unchanged
   ================================ */
@media (max-width: 760px){
  /* Reduce blur cost on large overlays/panels */
  .results,
  #searchScrim.searchScrim,
  .tickerWrap,
  .card{
    backdrop-filter: none !important;
    -webkit-backdrop-filter: none !important;
  }

  /* Soften big drop-shadows on full-width surfaces */
  .results{
    box-shadow: 0 18px 56px rgba(0,0,0,.74) !important;
  }
  .tickerWrap{
    box-shadow: 0 8px 22px rgba(0,0,0,.22) !important;
  }
  .card{
    box-shadow: none !important;
  }
}

/* Respect reduced motion (disable marquee + other non-essential animations) */
@media (prefers-reduced-motion: reduce){
  .tickerTrack{ animation: none !important; }
  .dexguardBtn::after{ animation: none !important; }
  .tradeRow.enter{ animation: none !important; }
}



/* ================================
   DESKTOP TOPBAR FLOW PATCH (non-sticky)
   Requirement:
   - Desktop: topbar stays above Live Trending (in normal page flow), NOT sticky/fixed.
   - Mobile: keep current fixed app-bar behavior unchanged.
   ================================ */
@media (min-width: 761px){
  :root{ --topbar-space: 0px !important; } /* remove reserved space used for fixed mobile appbar */
  .topbar{
    position: relative !important;
    top: auto !important;
    left: auto !important;
    right: auto !important;
    transform: none !important;
    width: 100% !important;
    z-index: 50 !important;
    margin: 0 0 14px 0 !important;
  }
  .wrap{
    padding-top: 18px !important; /* normal desktop spacing */
  }
}

/* ===== DexGuard Micro 01: Runtime Error Banner (non-blocking) ===== */
#rtErrBanner{
  position:fixed;
  top: calc(env(safe-area-inset-top) + 10px);
  left: 50%;
  transform: translateX(-50%);
  z-index: 2147483647;
  max-width: min(560px, calc(100vw - 24px));
  display:none;
  align-items:center;
  gap:10px;
  padding: 10px 12px;
  border-radius: 999px;
  background: rgba(255,77,109,.14);
  border: 1px solid rgba(255,77,109,.30);
  color: rgba(255,255,255,.92);
  box-shadow: 0 14px 60px rgba(0,0,0,.55);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  pointer-events: auto;
  user-select: none;
}
#rtErrBanner.show{ display:flex; }
#rtErrBanner .rtDot{
  width: 10px; height: 10px; border-radius: 50%;
  background: rgba(255,77,109,.95);
  box-shadow: 0 0 0 3px rgba(255,77,109,.20);
  flex: 0 0 10px;
}
#rtErrBanner .rtTxt{
  font-weight: 900;
  font-size: 13px;
  letter-spacing: .1px;
  line-height: 1.25;
  overflow:hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
#rtErrBanner .rtClose{
  margin-left:auto;
  width: 28px; height: 28px;
  display:grid; place-items:center;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06);
  color: rgba(255,255,255,.92);
  cursor:pointer;
  pointer-events:auto;
}
#rtErrBanner .rtClose:hover{ background: rgba(255,255,255,.10); }
@media (max-width: 520px){
  #rtErrBanner .rtTxt{ font-size: 12px; }
}
/* ===== /Micro 01 ===== */


/* ===== DexGuard Micro 02: Critical Render Guard Banner ===== */
#rtStatusBanner{
  position:fixed;
  top: calc(env(safe-area-inset-top) + 56px);
  left: 50%;
  transform: translateX(-50%);
  z-index: 2147483646;
  max-width: min(560px, calc(100vw - 24px));
  display:none;
  align-items:center;
  gap:10px;
  padding: 10px 12px;
  border-radius: 999px;
  background: rgba(255,184,0,.14);
  border: 1px solid rgba(255,184,0,.30);
  color: rgba(255,255,255,.92);
  box-shadow: 0 14px 60px rgba(0,0,0,.55);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  pointer-events: auto;
  user-select: none;
}
#rtStatusBanner.show{ display:flex; }
#rtStatusBanner .rtDot{
  width: 10px; height: 10px; border-radius: 50%;
  background: rgba(255,184,0,.95);
  box-shadow: 0 0 0 3px rgba(255,184,0,.20);
  flex: 0 0 10px;
}
#rtStatusBanner .rtTxt{
  font-weight: 900;
  font-size: 13px;
  letter-spacing: .1px;
  line-height: 1.25;
  overflow:hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
#rtStatusBanner .rtClose{
  margin-left:auto;
  width: 28px; height: 28px;
  display:grid; place-items:center;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06);
  color: rgba(255,255,255,.92);
  cursor:pointer;
  pointer-events:auto;
}
#rtStatusBanner .rtClose:hover{ background: rgba(255,255,255,.10); }
/* ===== /Micro 02 ===== */


/* ===== DexGuard Micro 13: Trades Animation (smooth insert + shift) ===== */
.tradeRow{ will-change: transform, opacity; }
.tradeRow.dg-new{
  opacity: 0;
  transform: translateY(-12px);
}
.tradeRow.dg-new.dg-in{
  opacity: 1;
  transform: translateY(0);
  transition: transform .22s ease, opacity .22s ease;
}
/* Ensure shift animations are smooth but lightweight */
.tradeRow.dg-shift{
  transition: transform .22s ease;
}
/* ===== /Micro 13 ===== */



/* ================================
   MOBILE CHART HEIGHT BOOST (micro_18)
   - Increase chart height on mobile only
   - Desktop unchanged
   ================================ */
@media (max-width: 760px){
  #chartWrap{
    height: clamp(520px, 70vh, 820px) !important;
    min-height: 520px !important;
    max-height: 820px !important;
  }
}
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <img class="topLogo" id="topLogo" src="dexguard.png" alt="DexGuard" loading="eager" decoding="async" />
      </div>

      <div class="actions">
        <div class="pillRow" id="netPills"></div>
        <a class="btn ghost" id="btnBack" href="/">Back to Main</a>
        <a class="btn xbtn" id="btnX" href="https://www.x.com/solana_x1" target="_blank" rel="noreferrer" aria-label="Twitter/X">
          <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true" focusable="false" style="display:block">
            <path fill="currentColor" d="M18.9 2H22l-6.8 7.8L23 22h-6.2l-4.8-7.1L5.8 22H2l7.4-8.5L1 2h6.3l4.3 6.4L18.9 2Zm-1.1 18h1.7L6.2 3.9H4.4L17.8 20Z"/>
          </svg>
          <span>Twitter/X</span>
        </a>
        <a class="btn primary" id="btnBuy" href="#" target="_blank" rel="noreferrer">Buy</a>
      </div>
    </div>
    <div class="panel">
      <!-- TOP TRENDING BAR + SEARCH (MATCH MAIN PAGE) -->
      <div class="topBar" id="topBar">
        <div class="topBarInner">
          <div class="topRow">
            <div class="hotBlock" aria-label="Hot trending live">
              <div class="hotLabel" title="Live trending"><span class="hotFire">🔥</span><span>LIVE TRENDING</span></div>
              <div id="status" style="display:none">Booting…</div>
              <div id="clock" style="display:none"></div>
            </div>

            <div class="chainToggle" id="trendToggle" aria-label="Trending chain">
              <button class="chainBtn active" data-net="solana" type="button">SOL</button>
              <button class="chainBtn" data-net="eth" type="button">ETH</button>
              <button class="chainBtn" data-net="bsc" type="button">BNB</button>
              <button class="chainBtn" data-net="base" type="button">BASE</button>
            </div>
          </div>

          <div class="bottomRow">
            <div class="tickerWrap" aria-label="Trending tokens">
              <div class="tickerTrack" id="tickerTrack">
                <span class="tickerItem" style="opacity:.75"><span class="rank">…</span><span class="tickerLogoWrap"><span class="tickerLogoFallback">•</span></span><span class="sym">Trending</span></span>
                <span class="tickerItem" style="opacity:.75"><span class="rank">…</span><span class="tickerLogoWrap"><span class="tickerLogoFallback">•</span></span><span class="sym">Trending</span></span>
                <span class="tickerItem" style="opacity:.75"><span class="rank">…</span><span class="tickerLogoWrap"><span class="tickerLogoFallback">•</span></span><span class="sym">Trending</span></span>
                <span class="tickerItem" style="opacity:.75"><span class="rank">…</span><span class="tickerLogoWrap"><span class="tickerLogoFallback">•</span></span><span class="sym">Trending</span></span>
              </div>
            </div>

            <div class="dexSearch" role="search" aria-label="Search token by name or contract">
              <div class="dexSearchInner">
                <input class="dexInput" id="q" placeholder="Search token / paste contract…" autocomplete="off" spellcheck="false" />
                <div class="hint" id="modeHint">auto</div>
                <button class="btn" id="btnGo" type="button">Open</button>
              </div>
              <div class="results" id="results"></div>
              <div id="searchScrim" class="searchScrim" aria-hidden="true"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="grid">
        <div class="card" id="chartCard">
          <div class="cardHd">
            <div class="pair">
              <div class="tlogo" id="tokenLogo"><span class="fb" id="tokenLogoFb">$</span></div>
              <div class="pairTxt">
                <div class="pairName" id="pairName">—</div>
                <div class="pairMeta" id="pairMeta">Paste a token / choose a trending token</div>
              </div>
            </div>
            <div class="stats" id="stats"></div>
          </div>

          <div id="chartWrap"><div id="chart"></div></div>

          <div class="controls">
            <div class="tfRow" id="tfRow"></div>
            <div class="rightCtl">
              <button class="btn" id="btnFit" type="button">Fit</button>
              <button class="btn" id="btnRefresh" type="button">Refresh</button>
              <select class="sel" id="poolSel" title="Pool"></select>
            </div>
          </div>


          <!-- ================================
               MOBILE MODE BAR (step09)
               Dexscreener-like: Chart+Txns / Chart / Txns
               ================================ -->
          <div class="modeBar" id="modeBar" aria-label="View mode">
            <button class="modeBtn active" type="button" data-mode="both">Chart+Txns</button>
            <button class="modeBtn" type="button" data-mode="chart">Chart</button>
            <button class="modeBtn" type="button" data-mode="txns">Txns</button>
          </div>

          <div class="mobileTabs">
            <div class="tabBar">
              <button class="tab active" id="tabChart" type="button">Chart</button>
              <button class="tab" id="tabTrades" type="button">Trades</button>
            </div>
          </div>
        </div>

        <div class="card desktopOnly" id="tradesCard">
          <div class="tableHd" role="button" aria-label="Toggle Live Trades" aria-expanded="false">
            <div>
              <div class="ttl">Live Trades</div>
              <div class="sub" id="tradesSub">Buys / Sells (live)</div>
            </div>
            <div class="sheetRight">
              <div class="sub" id="tradesStat">—</div>
            <span class="tradeChevron" aria-hidden="true"><svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false" style="display:block"><path fill="currentColor" d="M6.7 8.7a1 1 0 0 1 1.4 0L12 12.6l3.9-3.9a1 1 0 1 1 1.4 1.4l-4.6 4.6a1 1 0 0 1-1.4 0L6.7 10.1a1 1 0 0 1 0-1.4z"/></svg></span>
            </div>
          </div>

          <div class="trades" id="trades">
            <div class="tradeHead">
              <div class="col age">Age</div>
              <div class="col type">Type</div>
              <div class="col usd">USD</div>
              <div class="col amt">Amount</div>
              <div class="col price hideM">Price</div>
              <div class="col maker hideM">Maker</div>
              <div class="col links"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="grid mobileTabs" id="mobileTradesWrap" style="display:none; padding-top:0">
        <div class="card" style="grid-column:1/-1">
          <div class="tableHd">
            <div>
              <div class="ttl">Live Trades</div>
              <div class="sub" id="tradesSubM">Buys / Sells (live)</div>
            </div>
            <div class="sub" id="tradesStatM">—</div>
          </div>
          <div class="trades" id="tradesM">
            <div class="tradeHead">
              <div class="col age">Age</div>
              <div class="col type">Type</div>
              <div class="col usd">USD</div>
              <div class="col amt">Amount</div>
              <div class="col price hideM">Price</div>
              <div class="col maker hideM">Maker</div>
              <div class="col links"></div>
            </div>
          </div>
        </div>
      </div>

    </div>

    <div class="toast" id="toast"></div>
  </div>

  <script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js"></script>
  <script>
  (function(){
    // SPEEDFIX PATCH START
    function isMobile(){ return window.matchMedia("(max-width:760px)").matches; }
    const requestControllers = new Map();
    const reqIds = { trending:0, token:0, candles:0, trades:0, search:0 };
    function startRequest(key){
      try{ requestControllers.get(key)?.abort(); }catch(e){}
      const ac = new AbortController();
      requestControllers.set(key, ac);
      return ac;
    }
    // Lightweight perf logs (console only)
    const perfToken = { id:0, t0:0, paint:0, candles:0, trades:0, logged:false };
    function perfStartToken(id){
      perfToken.id = id;
      perfToken.t0 = performance.now();
      perfToken.paint = 0;
      perfToken.candles = 0;
      perfToken.trades = 0;
      perfToken.logged = false;
    }
    function perfMarkPaint(id){
      if(id !== perfToken.id || id !== reqIds.token) return;
      if(perfToken.paint) return;
      perfToken.paint = performance.now() - perfToken.t0;
      perfLogIfReady(id);
    }
    function perfMarkCandles(id){
      if(id !== perfToken.id || id !== reqIds.token) return;
      if(perfToken.candles) return;
      perfToken.candles = performance.now() - perfToken.t0;
      perfLogIfReady(id);
    }
    function perfMarkTrades(id){
      if(id !== perfToken.id || id !== reqIds.token) return;
      if(perfToken.trades) return;
      perfToken.trades = performance.now() - perfToken.t0;
      perfLogIfReady(id);
    }
    function perfLogIfReady(id){
      if(id !== perfToken.id || id !== reqIds.token) return;
      if(perfToken.logged) return;
      if(perfToken.paint && perfToken.candles && perfToken.trades){
        console.log(`[PERF] paint=${perfToken.paint.toFixed(0)}ms candles=${perfToken.candles.toFixed(0)}ms trades=${perfToken.trades.toFixed(0)}ms`);
        perfToken.logged = true;
      }
    }

    let tradesFetchInFlight = false;
    let tradesRenderTimer = null;
    let tradesLastRenderAt = 0;
    let tradesPendingPayload = null;
    let tradesPendingReset = false;
    let tradesPendingGuardId = 0;
    let tradesPendingGuardKey = '';
    function scheduleTradesRender(payload, reset, onRendered, guardId, guardKey){
      tradesPendingPayload = payload;
      if(reset) tradesPendingReset = true;
      if(guardId != null) tradesPendingGuardId = guardId;
      if(guardKey != null) tradesPendingGuardKey = guardKey;
      const now = performance.now ? performance.now() : Date.now();
      const elapsed = now - (tradesLastRenderAt||0);
      const delay = Math.max(0, 250 - elapsed); // 4x/sec max
      if(tradesRenderTimer) return;
      tradesRenderTimer = setTimeout(()=>{
        tradesRenderTimer = null;
        // stale guard: never render after token/chain switch
        if(tradesPendingGuardId && tradesPendingGuardId !== reqIds.trades) return;
        if(tradesPendingGuardKey && loadTrades && loadTrades._inFlightKey && tradesPendingGuardKey !== loadTrades._inFlightKey) return;
        tradesLastRenderAt = performance.now ? performance.now() : Date.now();
        const data = tradesPendingPayload;
        const doReset = tradesPendingReset;
        tradesPendingReset = false;
        try{
          const newly = renderTrades(data, {reset: doReset}) || [];
          if(typeof onRendered === 'function') onRendered(newly);
        }catch(e){
          // keep UI stable
        }
      }, delay);
    }
    // SPEEDFIX PATCH END

    // =========================================================
    //  $SOS DEX Terminal — from scratch
    //  Data sources:
    //   - Token discovery: DexScreener public API (search + token pairs)
    //   - OHLCV + trades: GeckoTerminal API (pools)
    //  No embeds. No third-party iframes.
    // =========================================================

    // -------------------- Constants
    const GECKO = 'https://api.geckoterminal.com/api/v2';
    const DS = 'https://api.dexscreener.com/latest/dex';

    const NET_LABEL = { solana:'SOL', eth:'ETH', bsc:'BNB', base:'BASE' };
    const NET_DS = { solana:'solana', eth:'ethereum', bsc:'bsc', base:'base' };
    const NET_GECKO = { solana:'solana', eth:'eth', bsc:'bsc', base:'base' };

    const DEFAULT_TOKEN = {
      solana: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC
      eth:    '0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',  // USDC
      bsc:    '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d',  // USDC
      base:   '0x833589fCD6eDb6E08f4c7C32D4f71b54bda02913'   // USDC
    };

    const DEFAULT_MARKET_TOKEN = {
      solana: 'So11111111111111111111111111111111111111112', // wSOL
      eth:    '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',   // WETH
      bsc:    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',   // WBNB
      base:   '0x4200000000000000000000000000000000000006'    // WETH on Base
    };

    // Prefer stable quote pools for chart correctness
    const STABLE_QUOTES = {
      solana: ['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'],
      eth: ['0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48','0xdAC17F958D2ee523a2206206994597C13D831ec7'],
      bsc: ['0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d','0x55d398326f99059fF775485246999027B3197955'],
      base:['0x833589fCD6eDb6E08f4c7C32D4f71b54bda02913']
    };

    
    // Prefer native quote pools first (wSOL / WETH / WBNB)
    const NATIVE_QUOTES = {
      solana: ['So11111111111111111111111111111111111111112'],
      eth:   ['0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2'],  // WETH
      bsc:   ['0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c'],  // WBNB
      base:  ['0x4200000000000000000000000000000000000006']   // WETH (Base)
    };
// Chart timeframes -> Gecko candle granularity
    const TF = [
      {k:'1m',  gecko:'minute',   agg:60,    live:true},
      {k:'5m',  gecko:'minute',   agg:300},
      {k:'15m', gecko:'minute',   agg:900},
      {k:'1h',  gecko:'hour',     agg:3600},
      {k:'4h',  gecko:'hour',     agg:14400},
      {k:'1w',  gecko:'day',      agg:604800},
      {k:'1d',  gecko:'day',      agg:86400},
      {k:'ALL', gecko:'day',      agg:86400}
    ];

    // -------------------- DOM
    const $ = (id)=>document.getElementById(id);
    const netPills = $('netPills');
    const statusEl = $('status');
    const clockEl = $('clock');
    const tickerTrack = $('tickerTrack');
    const q = $('q');
    const dexSearch = q?.closest?.('.dexSearch');
    const results = $('results');
    const searchScrim = $('searchScrim');
    const btnGo = $('btnGo');
    const modeHint = $('modeHint');

    const pairNameEl = $('pairName');
    const pairMetaEl = $('pairMeta');
    const statsEl = $('stats');
    const tokenLogo = $('tokenLogo');
    const tokenLogoFb = $('tokenLogoFb');

    const poolSel = $('poolSel');
    const tfRow = $('tfRow');
    const btnFit = $('btnFit');
    const btnRefresh = $('btnRefresh');

    const tradesDesk = $('trades');
    const tradesMob = $('tradesM');
    const tradesStat = $('tradesStat');
    const tradesStatM = $('tradesStatM');

    const btnBack = $('btnBack');
    const btnBuy = $('btnBuy');

    const topDexguardBtn = $('topDexguardBtn');

    const tabChart = $('tabChart');
    const tabTrades = $('tabTrades');
    const mobileTradesWrap = $('mobileTradesWrap');
    const chartCard = $('chartCard');
    const tradesCard = $('tradesCard');

    const toastEl = $('toast');

    // -------------------- Helpers
    const sleep = (ms)=>new Promise(r=>setTimeout(r, ms));
    const lc = (v)=>String(v||'').toLowerCase();

    function toast(msg, ms=2200){
      toastEl.textContent = msg;
      toastEl.style.display='block';
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=>toastEl.style.display='none', ms);
    }

    function esc(s){
      return String(s??'').replace(/[&<>"]/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[m]));
    }

    function shortAddr(a){
      a = String(a||'');
      if(a.length<=14) return a;
      return a.slice(0,6)+'…'+a.slice(-4);
    }

    function num(v){
      const n = Number(v);
      return Number.isFinite(n) ? n : NaN;
    }

    const DG_FMT = (()=> {
  const hasIntl = (typeof Intl !== 'undefined' && Intl && Intl.NumberFormat);
  const nfCache = new Map();

  function _key(opts){
    try{ return JSON.stringify(opts||{}); }catch(_){ return String(Math.random()); }
  }
  function _nf(opts){
    const k = _key(opts);
    if(nfCache.has(k)) return nfCache.get(k);
    let nf = null;
    if(hasIntl){
      try{ nf = new Intl.NumberFormat(undefined, opts); }catch(_){ nf = null; }
    }
    nfCache.set(k, nf);
    return nf;
  }
  function _trimZeros(s){
    if(!s) return s;
    // Only trim for dot-decimal; Intl with minFractionDigits=0 won't add ugly zeros anyway.
    if(s.indexOf('.')>-1) return s.replace(/(\.\d*?)0+$/,'$1').replace(/\.$/,'');
    return s;
  }
  function format(n, {maxDp=2, minDp=0, grouping=true}={}){
    n = Number(n);
    if(!Number.isFinite(n)) return '—';
    if(!hasIntl){
      const s = n.toFixed(maxDp);
      return _trimZeros(s);
    }
    const nf = _nf({useGrouping: grouping, minimumFractionDigits: minDp, maximumFractionDigits: maxDp});
    const out = nf ? nf.format(n) : String(n);
    return _trimZeros(out);
  }

  function price(v){
    v = Number(v);
    if(!Number.isFinite(v)) return '—';
    if(v===0) return '0';
    const abs = Math.abs(v);

    // Dynamic decimals: large vs tiny (avoid ugly zeros)
    if(abs >= 1000) return format(v, {maxDp:2,  minDp:0, grouping:true});
    if(abs >= 1)    return format(v, {maxDp:6,  minDp:0, grouping:false});
    if(abs >= 0.01) return format(v, {maxDp:8,  minDp:0, grouping:false});
    if(abs >= 0.0001) return format(v, {maxDp:10, minDp:0, grouping:false});
    if(abs >= 1e-8) return format(v, {maxDp:12, minDp:0, grouping:false});

    // Ultra tiny: exponential (readable, no trailing zeros)
    try{ return v.toExponential(4).replace(/e\+?/,'e'); }catch(_){ return String(v); }
  }

  function compact(n){
    n = Number(n);
    if(!Number.isFinite(n)) return '—';
    const abs = Math.abs(n);
    const sign = n < 0 ? '-' : '';
    const val = Math.abs(n);

    const pick = (div, suf, dp)=>{
      const x = val/div;
      const s = format(x, {maxDp: dp, minDp:0, grouping:false});
      return sign + s + suf;
    };

    if(abs >= 1e12) return pick(1e12,'T',2);
    if(abs >= 1e9)  return pick(1e9,'B',2);
    if(abs >= 1e6)  return pick(1e6,'M',2);
    if(abs >= 1e3)  return pick(1e3,'K',2);
    if(abs === 0)   return '0';
    if(abs >= 1)    return format(n, {maxDp:4, minDp:0, grouping:false});
    return format(n, {maxDp:6, minDp:0, grouping:false});
  }

  function usdCompact(n){ return '$' + compact(n); }
  function usdPrice(v){ return '$' + price(v); }

  function pct(p){
    p = Number(p);
    if(!Number.isFinite(p)) return '—';
    const s = format(p, {maxDp:2, minDp:0, grouping:false});
    return (p>0?'+':'') + s + '%';
  }

  return { format, price, compact, usdCompact, usdPrice, pct };
})();

function formatCompact(n){ return DG_FMT.compact(n); }

function formatPrice(v){ return DG_FMT.price(v); }

    function nowClock(){
      const d = new Date();
      clockEl.textContent = d.toLocaleString(undefined, {hour:'2-digit', minute:'2-digit', second:'2-digit'});
    }

    // fetch with timeout + retry + CORS fallback via allorigins
    async function fetchJson(url, {timeout=12000, retries=1, signal}={}){
      const proxy = (u)=>'https://api.allorigins.win/raw?url=' + encodeURIComponent(u);
      let lastErr=null;
      for(let i=0;i<=retries;i++){
        const ctl = new AbortController();
        // allow external cancellation + internal timeout
        if(signal){
          try{
            if(signal.aborted) ctl.abort();
            else signal.addEventListener('abort', ()=>{ try{ ctl.abort(); }catch(e){} }, {once:true});
          }catch(e){}
        }
        const t = setTimeout(()=>{ try{ ctl.abort(); }catch(e){} }, timeout);
        try{
          const r = await fetch(url, {
            headers:{'accept':'application/json'},
            signal: ctl.signal,
            cache: 'no-store'
          });
          clearTimeout(t);
          if(!r.ok) throw new Error('HTTP '+r.status);
          return await r.json();
        }catch(e){
          clearTimeout(t);
          lastErr=e;
          // abort requested externally -> stop immediately
          if(signal && signal.aborted) throw e;
          if(e && e.name==='AbortError' && signal) throw e;
          // try proxy for CORS / network error
          try{
            const msg = String(e&&e.message||e||'');
            const isCors = (e instanceof TypeError) || /Failed to fetch|NetworkError|CORS/i.test(msg);
            if(isCors){
              const r2 = await fetch(proxy(url), {cache:'no-store', signal: ctl.signal});
              if(r2.ok){
                const txt = await r2.text();
                return JSON.parse(txt);
              }
            }
          }catch(_){ }
          if(i<retries) await sleep(250*(i+1));
        }
      }
      throw lastErr || new Error('Network');
    }

    function normalizeChain(x){
      x = lc(x);
      if(x==='sol' || x==='solana') return 'solana';
      if(x==='eth' || x==='ethereum') return 'eth';
      if(x==='bnb' || x==='bsc') return 'bsc';
      if(x==='base') return 'base';
      return 'solana';
    }

    function isEvmAddr(s){
      return /^0x[a-fA-F0-9]{40}$/.test(String(s||'').trim());
    }

    function isSolAddr(s){
      // best-effort base58 length
      s = String(s||'').trim();
      return s.length>=32 && s.length<=50 && /^[1-9A-HJ-NP-Za-km-z]+$/.test(s);
    }

    // robust pool address extraction from gecko pool object
    function poolAddressFromPool(p){
      const a = p?.attributes || {};
      if(a.address) return String(a.address);
      const id = String(p?.id||'');
      // examples:
      //  - "solana_..._POOL"
      //  - "ethereum:0xPOOL"
      //  - "bsc/0xPOOL"
      const last = id.split('_').pop();
      const last2 = last.split(':').pop();
      const last3 = last2.split('/').pop();
      return last3;
    }

    function tokenIdToAddr(id){
      id = String(id||'').trim();
      if(!id) return '';
      // Gecko often uses ids like 'solana_<addr>' or 'ethereum_<addr>'
      if(id.includes('_')) return id.split('_').pop();
      if(id.includes(':')) return id.split(':').pop();
      if(id.includes('/')) return id.split('/').pop();
      return id;
    }

    function tokenAddrFromPool(p, which){
      const a = p?.attributes || {};
      let v = a[`${which}_token_address`] || a[`${which}_token_id`] || '';
      if(!v){
        const rel = p?.relationships?.[`${which}_token`]?.data?.id || '';
        v = rel;
      }
      return tokenIdToAddr(v);
    }

    function tokenSymFromPool(p, which){
      const a = p?.attributes || {};
      const k = `${which}_token_symbol`;
      const sym = a[k] || a[`${which}_symbol`] || '';
      return String(sym||'').replace(/\s+/g,'').slice(0,12);
    }

    function tokenImgFromPool(p, which){
      const a = p?.attributes || {};
      // Some responses include image urls per token
      const direct = a[`${which}_token_image_url`] || a[`${which}_token_logo`] || '';
      if(direct) return String(direct);
      // Best-effort fallback: sometimes nested token object is present (not always)
      const nested = a?.[`${which}_token`]?.data?.attributes?.image_url || a?.[`${which}_token`]?.data?.attributes?.imageUrl || '';
      return String(nested||'');
    }

    function tokenPriceFromPool(p, which){
      const a = p?.attributes || {};
      const v = (which==='base') ? (a.base_token_price_usd || a.token_price_usd || a.price_usd) : (a.quote_token_price_usd || a.quote_price_usd);
      const n = Number(v);
      return Number.isFinite(n) ? n : NaN;
    }

    function poolLiqUsd(p){
      const a = p?.attributes || {};
      const v = num(a.reserve_in_usd || a.liquidity_in_usd || a.liquidity_usd || a.reserveUsd);
      return Number.isFinite(v) ? v : 0;
    }

    function poolCreatedMs(p){
      const a = p?.attributes || {};
      const t = Date.parse(a.pool_created_at || a.created_at || a.createdAt || a.creation_time || '');
      return Number.isFinite(t) ? t : NaN;
    }

    function fmtAge(ms){
      if(!Number.isFinite(ms)) return '—';
      const d = Math.max(0, Date.now()-ms);
      const s = Math.floor(d/1000);
      if(s<60) return s+'s';
      const m = Math.floor(s/60);
      if(m<60) return m+'m';
      const h = Math.floor(m/60);
      if(h<24) return h+'h';
      const days = Math.floor(h/24);
      return days+'d';
    }

    function explorerTx(net, sig){
      net = normalizeChain(net);
      if(net==='solana') return 'https://solscan.io/tx/'+sig;
      if(net==='eth') return 'https://etherscan.io/tx/'+sig;
      if(net==='bsc') return 'https://bscscan.com/tx/'+sig;
      if(net==='base') return 'https://basescan.org/tx/'+sig;
      return '#';
    }

    function explorerAddr(net, a){
      net = normalizeChain(net);
      if(net==='solana') return 'https://solscan.io/account/'+a;
      if(net==='eth') return 'https://etherscan.io/address/'+a;
      if(net==='bsc') return 'https://bscscan.com/address/'+a;
      if(net==='base') return 'https://basescan.org/address/'+a;
      return '#';
    }

    // Buy link (best-effort) — can be replaced later per your preference
    function buildBuyUrl(net, tokenAddr){
      net = normalizeChain(net);
      if(net==='solana') return 'https://jup.ag/swap/SOL-' + encodeURIComponent(tokenAddr);
      if(net==='eth') return 'https://app.uniswap.org/#/swap?outputCurrency=' + encodeURIComponent(tokenAddr);
      if(net==='bsc') return 'https://pancakeswap.finance/swap?outputCurrency=' + encodeURIComponent(tokenAddr);
      if(net==='base') return 'https://app.uniswap.org/#/swap?chain=base&outputCurrency=' + encodeURIComponent(tokenAddr);
      return '#';
    }

    // -------------------- State

    // -------------------- URL Param Parsing (unified)
    function parseTokenFromUrl(url){
      try{
        const u = url ? new URL(url, location.href) : new URL(location.href);
        const sp = u.searchParams;
        const raw = String(
          sp.get('addr') ||
          sp.get('address') ||
          sp.get('ca') ||
          // backward/compat fallbacks (keep minimal)
          sp.get('token') ||
          sp.get('contract') ||
          ''
        ).trim();
        return raw ? raw : null;
      }catch(e){
        try{ console.warn('parseTokenFromUrl failed', e); }catch(_){}
        return null;
      }
    }

    const qs = new URLSearchParams(location.search);
    let activeNet = normalizeChain(qs.get('chain') || 'solana');
    let addr = (parseTokenFromUrl() || '').trim();

    let activeTF = TF.find(x=>x.k==='15m') || TF[0];
    let poolChoices = [];
    let poolId = '';
    let poolAddr = '';
    let tokenSide = 'base';
        let curTokenSymbol = 'TOKEN';
    let curQuoteSymbol = '';
    let curTokenName = '';
    let curTokenImage = '';
    let curTokenAddr = '';
let seenMakers = new Set();
    let tradesSeen = new Set();

    let pollTradesTimer = null;
    let pollMetaTimer = null;
    let pollCandleTimer = null;
    let trendingTimer = null;
    let trendingGen = 0;
    let trendingLoadFn = null;
    let ageTimer = null;

    // -------------------- Chart
    const chartEl = $('chart');
    const chart = LightweightCharts.createChart(chartEl, {
      width: chartEl.clientWidth || 800,
      height: chartEl.clientHeight || 520,
      layout: { background: { type:'solid', color:'rgba(0,0,0,0)' }, textColor:'rgba(255,255,255,.86)' },
      grid: { vertLines:{color:'rgba(255,255,255,.06)'}, horzLines:{color:'rgba(255,255,255,.06)'} },
      rightPriceScale: { borderColor:'rgba(255,255,255,.12)' },
      timeScale: { borderColor:'rgba(255,255,255,.12)', timeVisible:true, secondsVisible:false },
      crosshair: { mode: 1 },
      handleScroll: { mouseWheel:true, pressedMouseMove:true, horzTouchDrag:true, vertTouchDrag:true },
      handleScale: { axisPressedMouseMove:true, mouseWheel:true, pinch:true },
    });


    // Unified number formatting for chart scale
    try{ chart.applyOptions({ localization:{ priceFormatter:(p)=>DG_FMT.price(p) } }); }catch(_){ }


    const candleSeries = chart.addCandlestickSeries({
      upColor: 'rgba(20,241,149,.95)',
      downColor:'rgba(255,77,109,.95)',
      wickUpColor:'rgba(20,241,149,.95)',
      wickDownColor:'rgba(255,77,109,.95)',
      borderVisible:false,
      autoscaleInfoProvider: (original) => {
        const res = original();
        try{
          const pr = res && res.priceRange;
          if(pr && Number.isFinite(pr.minValue) && Number.isFinite(pr.maxValue)){
            const min = pr.minValue;
            const max = pr.maxValue;
            const span = (max - min) || Math.max(Math.abs(max), Math.abs(min), 1);
            const pad = span * 0.04;
            return { ...res, priceRange: { minValue: min - pad, maxValue: max + pad } };
          }
        }catch(_){ }
        return res;
      },
      priceFormat:{ type:'price', precision: 10, minMove: 1e-10 }
    });

    const volumeSeries = chart.addHistogramSeries({
      priceFormat: { type:'volume' },
      priceScaleId: '',
      lastValueVisible:false,
      base:0,
    });
    chart.priceScale('').applyOptions({ scaleMargins:{ top:0.84, bottom:0 } });


    // ===== Micro Smooth Update (interpolate last close) =====
    let _dgCloseTween = { raf:0, barTime:0, from:NaN, to:NaN, start:0, dur:120, open:NaN, high:NaN, low:NaN };
    let _dgRendered = { time:0, close:NaN };
    function _dgCancelCloseTween(){
      try{ if(_dgCloseTween.raf){ cancelAnimationFrame(_dgCloseTween.raf); } }catch(_){}
      _dgCloseTween.raf = 0;
    }
    function _dgCandleUpdateImmediate(o){
      try{ candleSeries.update(o); }catch(_){}
      if(o && Number.isFinite(o.time)){ _dgRendered.time = o.time; _dgRendered.close = Number.isFinite(o.close) ? o.close : _dgRendered.close; }
    }
    function dgSmoothCandleUpdate(o, prevClose){
      if(!o || !Number.isFinite(o.time) || !Number.isFinite(o.close)){ _dgCancelCloseTween(); _dgCandleUpdateImmediate(o); return; }

      // Respect reduced motion / hidden tabs
      try{
        if(document.hidden){ _dgCancelCloseTween(); _dgCandleUpdateImmediate(o); return; }
        if(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches){ _dgCancelCloseTween(); _dgCandleUpdateImmediate(o); return; }
      }catch(_){}

      // If we switch to a different bar while animating, stop the old tween
      if(_dgCloseTween.raf && _dgCloseTween.barTime && o.time !== _dgCloseTween.barTime){
        _dgCancelCloseTween();
      }

      const to = o.close;
      const sameBar = (o.time === _dgRendered.time) || (o.time === _dgCloseTween.barTime);
      const baseFrom = Number.isFinite(prevClose) ? prevClose
        : (sameBar && Number.isFinite(_dgRendered.close) ? _dgRendered.close
          : (Number.isFinite(o.open) ? o.open : to));

      if(!Number.isFinite(baseFrom) || !Number.isFinite(to)){ _dgCancelCloseTween(); _dgCandleUpdateImmediate(o); return; }

      const diff = Math.abs(to - baseFrom);
      // tiny diffs -> update immediately (prevents jitter + CPU churn)
      if(diff <= Math.max(Math.abs(to) * 1e-10, 1e-12)){ _dgCancelCloseTween(); _dgCandleUpdateImmediate(o); return; }

      // If tween already running on same bar, retarget smoothly from current rendered value
      if(_dgCloseTween.raf && o.time === _dgCloseTween.barTime){
        const cur = (Number.isFinite(_dgRendered.close) ? _dgRendered.close : baseFrom);
        _dgCloseTween.from = cur;
        _dgCloseTween.to = to;
        _dgCloseTween.open = o.open;
        _dgCloseTween.high = o.high;
        _dgCloseTween.low  = o.low;
        _dgCloseTween.start = performance.now();
        return;
      }

      _dgCloseTween.barTime = o.time;
      _dgCloseTween.from = baseFrom;
      _dgCloseTween.to = to;
      _dgCloseTween.open = o.open;
      _dgCloseTween.high = o.high;
      _dgCloseTween.low  = o.low;
      _dgCloseTween.start = performance.now();

      const step = (t)=>{
        const p = (t - _dgCloseTween.start) / _dgCloseTween.dur;
        if(p >= 1){
          _dgCloseTween.raf = 0;
          _dgCandleUpdateImmediate({time:_dgCloseTween.barTime, open:_dgCloseTween.open, high:_dgCloseTween.high, low:_dgCloseTween.low, close:_dgCloseTween.to});
          return;
        }
        const x = p < 0 ? 0 : p;
        const e = 1 - Math.pow(1 - x, 3); // easeOutCubic
        const v = _dgCloseTween.from + (_dgCloseTween.to - _dgCloseTween.from) * e;
        try{ candleSeries.update({time:_dgCloseTween.barTime, open:_dgCloseTween.open, high:_dgCloseTween.high, low:_dgCloseTween.low, close:v}); }catch(_){}
        _dgRendered.time = _dgCloseTween.barTime; _dgRendered.close = v;
        _dgCloseTween.raf = requestAnimationFrame(step);
      };
      _dgCloseTween.raf = requestAnimationFrame(step);
    }
    // ===== /Micro Smooth Update =====


    let _chartResizeT = 0;
    const debounceChartResize = ()=>{
      clearTimeout(_chartResizeT);
      _chartResizeT = setTimeout(()=>{
        try{
          if(chart && chartEl){
            const w = chartEl.clientWidth || chartEl.getBoundingClientRect().width;
            const h = chartEl.clientHeight || chartEl.getBoundingClientRect().height;
            if(w && h){
              chart.applyOptions({ width: Math.floor(w), height: Math.floor(h) });
              // Keep view stable; fitContent only if needed elsewhere
            }
          }
        }catch(_){}
      }, 120);
    };

    const ro = new ResizeObserver(debounceChartResize);
    ro.observe(chartEl);
/* Fit button removed (auto-fit handled) */

    // -------------------- UI boot
    function renderNetPills(){
      netPills.innerHTML='';
      const nets=[{k:'solana',label:'SOL'},{k:'eth',label:'ETH'},{k:'bsc',label:'BNB'},{k:'base',label:'BASE'}];
      nets.forEach(n=>{
        const b=document.createElement('div');
        b.className='pill'+(activeNet===n.k?' active':'');
        b.innerHTML = `<span class="dot"></span>${esc(n.label)}`;
        b.onclick=()=>{
          activeNet=n.k;
          renderNetPills();
          toast('Chain: '+n.label);
          // keep current addr if it matches chain type; otherwise default
          if(!addr || (activeNet==='solana' ? !isSolAddr(addr) : !isEvmAddr(addr))){ addr = DEFAULT_MARKET_TOKEN[activeNet]; }
          navigate(activeNet, addr);
        };
        netPills.appendChild(b);
      });
    }

    function renderTimeframes(){
      tfRow.innerHTML='';
      TF.forEach(t=>{
        const b=document.createElement('button');
        b.className='tf'+(t.k===activeTF.k?' active':'');
        b.textContent=t.k;
        b.onclick=()=>{
          activeTF=t;
          [...tfRow.children].forEach(x=>x.classList.toggle('active', x.textContent===t.k));
          // reset viewport flags on timeframe change
          userInteracted = false;
          programmaticRangeChange = false;
          didInitialViewport = false;
          didFitOnce = false;
          _lastLogicalRange = null;
          if(poolAddr){
            try{ if(typeof stopLiveLoops==='function') stopLiveLoops(); }catch(_){ }
            (async()=>{
              await Promise.all([loadCandles(true), loadTrades(true)]);
              startLiveLoops();
            })();
          }
        };
        tfRow.appendChild(b);
      });
    }

    
    function setActiveTFKey(key){
      const t = TF.find(x=>x.k===key) || TF.find(x=>x.k==='15m') || TF[0];
      activeTF = t;
      if(tfRow && tfRow.children && tfRow.children.length){
        [...tfRow.children].forEach(x=>x.classList.toggle('active', x.textContent===t.k));
      }
      return t;
    }
function setMobileTab(which){
      if(!tabChart || !tabTrades) return;
      const isTrades = which==='trades';
      tabChart.classList.toggle('active', !isTrades);
      tabTrades.classList.toggle('active', isTrades);
      mobileTradesWrap.style.display = isTrades ? 'block' : 'none';
      chartCard.style.display = isTrades ? 'none' : 'block';
    }

    if(tabChart && tabTrades){
      tabChart.onclick=()=>setMobileTab('chart');
      tabTrades.onclick=()=>setMobileTab('trades');
    }



    // ================================
    // Mobile mode bar (step09): Chart+Txns / Chart / Txns
    // - Minimal JS, wires to existing elements (chartCard/tradesCard)
    // ================================
    const modeBar = document.getElementById('modeBar');
    const modeBtns = modeBar ? Array.from(modeBar.querySelectorAll('.modeBtn')) : [];
    const mqMode = window.matchMedia('(max-width: 760px)');

    function applyMobileMode(mode){
      if(!mqMode.matches) return;
      document.body.dataset.mmode = mode;

      // Active state
      modeBtns.forEach(b=>b.classList.toggle('active', b.dataset.mode===mode));

      // Always keep legacy mobile wrapper hidden (we use main trades card)
      if(mobileTradesWrap) mobileTradesWrap.style.display = 'none';

      // Show/hide using existing elements (no refactor)
      if(chartCard) chartCard.style.display = (mode==='txns') ? 'none' : 'block';
      if(tradesCard) tradesCard.style.display = (mode==='chart') ? 'none' : 'block';

      // Ensure chart reflows correctly when shown again
      if(mode!=='txns'){
        try{
          requestAnimationFrame(()=>{
            try{ chart.resize(chartEl.clientWidth, chartEl.clientHeight); }catch(_e){}            // SPEEDFIX step07: no auto-fit on mode switching
          });
        }catch(_e){}
      }
    }

    if(modeBar && modeBtns.length){
      modeBtns.forEach(btn=>{
        btn.addEventListener('click', ()=>{
          applyMobileMode(btn.dataset.mode || 'both');
        }, {passive:true});
      });
      // Default = Chart+Txns
      applyMobileMode(document.body.dataset.mmode || 'both');
    }

    // Keep mode consistent across rotations/resizes; restore desktop defaults when leaving mobile
    window.addEventListener('resize', ()=>{
      if(mqMode.matches){
        applyMobileMode(document.body.dataset.mmode || 'both');
      }else{
        // Remove mobile overrides on desktop
        if(chartCard) chartCard.style.display = '';
        if(tradesCard) tradesCard.style.display = '';
        delete document.body.dataset.mmode;
      }
    });


    // -------------------- Mobile-only: Live Trades accordion (step10)
    const mqTradesAcc = (window.matchMedia ? window.matchMedia('(max-width: 760px)') : {matches:false, addEventListener:()=>{}, removeEventListener:()=>{}});
function initTradesAccordion(){
      if(!tradesCard) return;
      const hd = tradesCard.querySelector('.tableHd');
      if(!hd) return;

      const setOpen = (open)=>{
        tradesCard.classList.toggle('open', !!open);
        hd.setAttribute('aria-expanded', open ? 'true' : 'false');
      };

      if(mqTradesAcc.matches){
        // Default collapsed on mobile
        setOpen(false);

        if(!hd.dataset.accBound){
          hd.dataset.accBound = '1';
          hd.addEventListener('click', ()=>{
            if(!mqTradesAcc.matches) return;
            setOpen(!tradesCard.classList.contains('open'));
          }, {passive:true});
          hd.addEventListener('keydown', (e)=>{
            if(!mqTradesAcc.matches) return;
            if(e.key === 'Enter' || e.key === ' '){
              e.preventDefault();
              setOpen(!tradesCard.classList.contains('open'));
            }
          });
        }
      }else{
        // Desktop: keep normal behavior (no forced collapse)
        tradesCard.classList.remove('open');
        hd.setAttribute('aria-expanded', 'true');
      }
    }
    initTradesAccordion();
    window.addEventListener('resize', initTradesAccordion);


    // Top-left Dexguard button -> jump to trending bar
    if(topDexguardBtn){
      topDexguardBtn.onclick = ()=>{
        const tb = document.getElementById('topBar');
        if(tb) tb.scrollIntoView({behavior:'smooth', block:'start'});
      };
    }
    /* Refresh button removed (auto updates) */
// -------------------- Search
    let searchTimer=null;
    let searchReq=0;



// Mobile-only: lock page scroll when search modal is open (Dexscreener-style)
let __searchLockY = 0;
function setSearchModalOpen(open){
  try{
    if(!window.matchMedia || !window.matchMedia('(max-width: 760px)').matches) return;
    if(open){
      __searchLockY = window.scrollY || document.documentElement.scrollTop || 0;
      document.body.classList.add('searchModalOpen');
      // iOS-friendly scroll lock
      document.body.style.position = 'fixed';
      document.body.style.top = `-${__searchLockY}px`;
      document.body.style.left = '0';
      document.body.style.right = '0';
      document.body.style.width = '100%';
    }else{
      if(document.body.classList.contains('searchModalOpen')){
        document.body.classList.remove('searchModalOpen');
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.left = '';
        document.body.style.right = '';
        document.body.style.width = '';
        window.scrollTo(0, __searchLockY || 0);
      }
    }
  }catch(_){}
}

    function showResults(html){
      results.innerHTML = html;
      const open = !!html;
      results.style.display = open ? 'block' : 'none';
      if(searchScrim) searchScrim.style.display = open ? 'block' : 'none';
      if(dexSearch) dexSearch.classList.toggle('open', open);
          setSearchModalOpen(open);
    }

    function hideResults(){
      results.style.display = 'none';
      if(searchScrim) searchScrim.style.display = 'none';
      if(dexSearch) dexSearch.classList.remove('open');
          setSearchModalOpen(false);
    }

    if(searchScrim){
      searchScrim.addEventListener('click', hideResults);
    }

    async function dsSearch(query, fetchOpts={}){
      // DexScreener search is used ONLY for discovery. We do not embed anything.
      const url = DS + '/search/?q=' + encodeURIComponent(query);
      const j = await fetchJson(url, {timeout:12000, retries:1, signal: fetchOpts.signal});
      return Array.isArray(j?.pairs) ? j.pairs : [];
    }

    async function dsTokenPairsV1(net, tokenAddr, fetchOpts={}){
      const chain = NET_DS[normalizeChain(net)] || 'solana';
      const url = `https://api.dexscreener.com/token-pairs/v1/${chain}/${encodeURIComponent(tokenAddr)}`;
      try{
        const j = await fetchJson(url, {timeout:14000, retries:1, signal: fetchOpts.signal});
        return Array.isArray(j) ? j : [];
      }catch(_){
        return [];
      }
    }

    function bestPairAnyNet(pairs){
      const list = (pairs||[]).slice();
      if(!list.length) return null;
      list.sort((a,b)=>{
        const la = Number(a?.liquidity?.usd||0);
        const lb = Number(b?.liquidity?.usd||0);
        if(lb!==la) return lb-la;
        const va = Number(a?.volume?.h24||0);
        const vb = Number(b?.volume?.h24||0);
        return vb-va;
      });
      return list[0];
    }

    function bestPairForNet(pairs, net){
      const want = NET_DS[normalizeChain(net)];
      const list = (pairs||[]).filter(p=>lc(p?.chainId)===want);
      if(!list.length) return null;
      list.sort((a,b)=>{
        const la = Number(a?.liquidity?.usd||0);
        const lb = Number(b?.liquidity?.usd||0);
        if(lb!==la) return lb-la;
        const va = Number(a?.volume?.h24||0);
        const vb = Number(b?.volume?.h24||0);
        return vb-va;
      });
      return list[0];
    }


    function dsExtractTokenMeta(pair, tokenAddr){
      const tAddr = lc(tokenAddr||'');
      const base = pair?.baseToken || {};
      const quote = pair?.quoteToken || {};
      const baseAddr = lc(base?.address||'');
      const quoteAddr = lc(quote?.address||'');
      const isQuote = !!tAddr && !!quoteAddr && tAddr===quoteAddr;
      const tok = isQuote ? quote : base;
      const oth = isQuote ? base : quote;

      const sym = String(tok?.symbol||'TOKEN').replace(/\s+/g,'').slice(0,12) || 'TOKEN';
      const name = String(tok?.name||'').trim();
      const quoteSym = String(oth?.symbol||'').replace(/\s+/g,'').slice(0,12);

      const img = String(
        pair?.info?.imageUrl || pair?.info?.image_url ||
        pair?.imageUrl || pair?.image_url ||
        tok?.logoURI || tok?.logoUrl || tok?.logo_url || tok?.icon || tok?.image ||
        ''
      ).trim();

      return { symbol: sym, name, quoteSymbol: quoteSym, image: img };
    }


    function netFromDsChainId(chainId){
      const c = lc(chainId);
      if(c==='solana') return 'solana';
      if(c==='ethereum') return 'eth';
      if(c==='bsc') return 'bsc';
      if(c==='base') return 'base';
      return null;
    }

    function bestPairAnyNet(pairs){
      const list = (pairs||[]).filter(p=>netFromDsChainId(p?.chainId));
      if(!list.length) return null;
      list.sort((a,b)=>{
        const la = Number(a?.liquidity?.usd||0);
        const lb = Number(b?.liquidity?.usd||0);
        if(lb!==la) return lb-la;
        const va = Number(a?.volume?.h24||0);
        const vb = Number(b?.volume?.h24||0);
        return vb-va;
      });
      return list[0];
    }

    function renderSearchResults(pairs){
      const best = bestPairForNet(pairs, activeNet);
      // show top 12 for chain
      const want = NET_DS[activeNet];
      const list = (pairs||[]).filter(p=>lc(p?.chainId)===want).slice(0, 12);
      if(!list.length){
        showResults(`<div style="padding:12px; color:rgba(255,255,255,.75)">No results on ${esc(NET_LABEL[activeNet])}. Try another chain.</div>`);
        return;
      }
      const html = list.map(p=>{
        const base = p?.baseToken || {};
        const sym = String(base.symbol || base.name || 'TOKEN');
        const name = String(base.name || sym);
        const addr = String(base.address || '');
        const img = p?.info?.imageUrl || p?.info?.image_url || '';
        const pct = num(p?.priceChange?.h24);
        const mc = num(p?.marketCap || p?.fdv);
        const pctTxt = Number.isFinite(pct) ? DG_FMT.pct(pct) : '—';
        const pctClass = Number.isFinite(pct) ? (pct>0?'up':(pct<0?'down':'')) : '';
        const logo = img ? `<img src="${esc(img)}" referrerpolicy="no-referrer" onerror="this.remove();"/>` : `<span class="fb">${esc(sym.slice(0,1).toUpperCase())}</span>`;
        return `
          <div class="resItem" data-addr="${esc(addr)}" data-name="${esc(sym)}">
            <div class="resL">
              <div class="resLogo">${logo}</div>
              <div class="resTxt">
                <div class="resName">$${esc(sym)} <span style="opacity:.65">(${esc(name)})</span></div>
                <div class="resMeta">${esc(NET_LABEL[activeNet])} • ${esc(shortAddr(addr))} • Liq $${esc(formatCompact(p?.liquidity?.usd))}</div>
              </div>
            </div>
            <div class="resR">
              <span class="statPill ${pctClass}">24h ${esc(pctTxt)}</span>
              <span class="statPill">MCap ${esc(formatCompact(mc))}</span>
            </div>
          </div>
        `;
      }).join('');
      showResults(html);

      // click bind
      [...results.querySelectorAll('.resItem')].forEach(el=>{
        el.onclick=()=>{
          const a = el.getAttribute('data-addr')||'';
          hideResults();
          q.value = a;
          openToken(a);
        };
      });
    }

    q.addEventListener('input', ()=>{
      clearTimeout(searchTimer);
      const v = q.value.trim();

      // mode hint
      if(isEvmAddr(v)) modeHint.textContent = 'EVM';
      else if(isSolAddr(v)) modeHint.textContent = 'SOL';
      else modeHint.textContent = 'auto';

      if(v.length<2){ hideResults(); return; }
      searchTimer = setTimeout(async ()=>{
        const id = ++searchReq;
        try{
          const pairs = await dsSearch(v);
          if(id!==searchReq) return;
          renderSearchResults(pairs);
        }catch(e){
          if(id!==searchReq) return;
          if(e && e.name==='AbortError') return;
          showResults(`<div style="padding:12px; color:rgba(255,255,255,.75)">Search error. Try again.</div>`);
        }
      }, 220);
    });

    q.addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){
        e.preventDefault();
        hideResults();
        openToken(q.value.trim());
      }
    });

    document.addEventListener('click', (e)=>{
      if(!results.contains(e.target) && e.target!==q) hideResults();
    });

    btnGo.onclick=()=>openToken(q.value.trim());

    // -------------------- Gecko: pool selection
    function geckoNet(){ return NET_GECKO[activeNet]; }

    async function resolvePoolsFromGecko(tokenAddr, fetchOpts={}){
      // /networks/{network}/tokens/{token}/pools?include=base_token,quote_token&page=1
      const url = `${GECKO}/networks/${encodeURIComponent(geckoNet())}/tokens/${encodeURIComponent(tokenAddr)}/pools?include=base_token,quote_token,dex&page=1`;
      const j = await fetchJson(url, {timeout:14000, retries:1, signal: fetchOpts.signal});
      return Array.isArray(j?.data) ? j.data : [];
    }

    function chooseBestPool(pools, tokenAddr){
      const tok = lc(tokenAddr);
      const nativeSet = new Set((NATIVE_QUOTES[activeNet]||[]).map(lc));
      const stableSet = new Set((STABLE_QUOTES[activeNet]||[]).map(lc));

      const ranked = (pools||[]).map(p=>{
        const base = lc(tokenAddrFromPool(p,'base'));
        const quote = lc(tokenAddrFromPool(p,'quote'));
        const liq = poolLiqUsd(p);
        const created = poolCreatedMs(p);
        const isBase = base===tok;
        const isQuote = quote===tok;

        // Only consider "quote preference" when the token is the base side, so charts/stats align with TOKEN/QUOTE
        const nativeQuote = isBase && nativeSet.has(quote);
        const stableQuote = isBase && stableSet.has(quote);

        // Priority: 2=native, 1=stable, 0=other
        const tier = nativeQuote ? 2 : (stableQuote ? 1 : 0);

        return {p, tier, liq: (liq||0), isBase, isQuote, created: (created||0)};
      }).filter(x=>!!x.p);

      ranked.sort((A,B)=>{
        // 1) native quote
        if(B.tier !== A.tier) return B.tier - A.tier;
        // 2) stable quote (already in tier)
        // 3) highest liquidity
        if((B.liq||0) !== (A.liq||0)) return (B.liq||0) - (A.liq||0);
        // Tiebreakers (keep deterministic)
        if(!!B.isBase !== !!A.isBase) return (B.isBase?1:0) - (A.isBase?1:0);
        if(!!B.isQuote !== !!A.isQuote) return (B.isQuote?1:0) - (A.isQuote?1:0);
        if(A.created && B.created && A.created !== B.created) return A.created - B.created; // older first
        return 0;
      });

      return ranked[0]?.p || null;
    }

    function renderPoolSelect(pools){
      poolSel.innerHTML='';
      const opts = pools.slice(0, 25).map((p,i)=>{
        const a = p?.attributes || {};
        const dex = String(a.dex_name || a.dex || 'DEX');
        const name = String(a.name || a.pool_name || '').trim();
        const liq = poolLiqUsd(p);
        const age = fmtAge(poolCreatedMs(p));
        const label = `${dex} • ${name?name:shortAddr(poolAddressFromPool(p))} • Liq $${formatCompact(liq)} • ${age}`;
        const id = String(p?.id||'');
        return `<option value="${esc(id)}">${esc(label)}</option>`;
      }).join('');
      poolSel.innerHTML = opts;
      poolSel.style.display = opts ? 'inline-flex' : 'none';
      poolSel.disabled = !opts;

      poolSel.onchange = ()=>{
        const id = poolSel.value;
        const picked = pools.find(x=>String(x?.id||'')===id);
        if(picked){
          applyPool(picked);
          loadCandles(true);
          loadTrades(true);
          loadMeta(true);
        }
      };
    }

    function knownSymbolFromAddr(chain, address){
      try{
        const a = String(address||'').trim();
        if(!a) return '';
        const al = a.toLowerCase();
        const ck = String(chain||'').toLowerCase();

        // Native wrapped -> native symbol
        const n = (NATIVE_QUOTES[ck]||[]).map(x=>String(x||'').toLowerCase());
        if(n.includes(al)){
          if(ck==='solana') return 'SOL';
          if(ck==='bsc') return 'BNB';
          return 'ETH'; // eth + base native wrapped
        }

        // Stable quotes -> stable symbol
        const st = (STABLE_QUOTES[ck]||[]).map(x=>String(x||'').toLowerCase());
        if(st.includes(al)){
          // heuristic by position (matches file ordering)
          if(ck==='eth' || ck==='bsc'){
            if(al===st[1]) return 'USDT';
            return 'USDC';
          }
          return 'USDC';
        }

      }catch(_){}
      return '';
    }

    function normalizePairSymbol(sym){
      const s = String(sym||'').trim();
      if(!s) return '';
      const up = s.toUpperCase();
      if(up==='WSOL') return 'SOL';
      if(up==='WETH') return 'ETH';
      if(up==='WBNB') return 'BNB';
      return up;
    }

    function applyTokenHeader(meta){
      const symIn = String(meta?.symbol||'').trim();
      const nameIn = String(meta?.name||'').trim();
      const quoteIn = String(meta?.quoteSymbol||'').trim();
      const imgIn = String(meta?.image||'').trim();

      const sym = (symIn && symIn.toUpperCase()!=='TOKEN')
        ? symIn
        : ((curTokenSymbol && curTokenSymbol.toUpperCase()!=='TOKEN') ? curTokenSymbol : (symIn||'TOKEN'));

      const hasQuoteKey = !!(meta && Object.prototype.hasOwnProperty.call(meta,'quoteSymbol'));
      const quote = hasQuoteKey ? quoteIn : (quoteIn || curQuoteSymbol || '');
      const name = nameIn || curTokenName || '';
      const img  = imgIn  || curTokenImage || '';

      curTokenSymbol = normalizePairSymbol(sym) || 'TOKEN';
      curQuoteSymbol = normalizePairSymbol(quote) || '';
      if(name) curTokenName = name;
      if(imgIn) curTokenImage = imgIn;

      const symN = normalizePairSymbol(sym) || 'TOKEN';
      const quoteN = normalizePairSymbol(quote) || '';
      const title = quoteN ? `$${symN}/${quoteN}` : `$${symN}`;
      const nameHtml = (name && name.toLowerCase()!==sym.toLowerCase())
        ? `<span class="pairNameSub">${esc(name)}</span>` : '';
      pairNameEl.innerHTML = `${esc(title)}${nameHtml ? ' ' + nameHtml : ''}`;
      pairMetaEl.textContent = `${NET_LABEL[activeNet]} • ${shortAddr(addr)} • Native chart + live trades`;

      if(img){
        tokenLogo.innerHTML = `<img src="${esc(img)}" alt="" referrerpolicy="no-referrer" onerror="this.onerror=null; this.remove(); var p=this.parentNode; if(p){p.innerHTML='<span class=\\"fb\\">${esc(sym.slice(0,1).toUpperCase())}</span>';}" />`;
      }else{
        tokenLogo.innerHTML = `<span class="fb">${esc(sym.slice(0,1).toUpperCase())}</span>`;
      }
    }

    function applyStats(st){
      const pills=[];
      if(Number.isFinite(st.price)) pills.push(`<span class="statPill"><span class="k">Price</span><span class="v">$${esc(formatPrice(st.price))}</span></span>`);
      if(Number.isFinite(st.liq)) pills.push(`<span class="statPill"><span class="k">Liq</span><span class="v">$${esc(formatCompact(st.liq))}</span></span>`);
      if(Number.isFinite(st.mcap)) pills.push(`<span class="statPill"><span class="k">MCap</span><span class="v">${esc(formatCompact(st.mcap))}</span></span>`);
      if(Number.isFinite(st.h24)) pills.push(`<span class="statPill ${st.h24>0?'up':(st.h24<0?'down':'')}"><span class="k">24h</span><span class="v">${esc(DG_FMT.pct(st.h24))}</span></span>`);
      statsEl.innerHTML = pills.join('') || `<span class="statPill"><span class="k">—</span><span class="v">—</span></span>`;
    }

    function applyPool(p){
      const a = p?.attributes || {};
      poolId = String(p?.id||'');
      poolAddr = poolAddressFromPool(p);

      // Determine side: if token matches base -> buys are quote->base? We use Gecko trade_type.
      const base = lc(tokenAddrFromPool(p,'base'));
      const quote = lc(tokenAddrFromPool(p,'quote'));
      tokenSide = (base===lc(addr)) ? 'base' : ((quote===lc(addr)) ? 'quote' : 'base');

      // Meta (pick correct token side)
      const baseAddr = tokenAddrFromPool(p,'base');
      const quoteAddr = tokenAddrFromPool(p,'quote');

      const baseSymRaw = tokenSymFromPool(p,'base') || knownSymbolFromAddr(activeNet, baseAddr) || 'TOKEN';
      const quoteSymRaw = tokenSymFromPool(p,'quote') || knownSymbolFromAddr(activeNet, quoteAddr) || '';

      const baseSym = normalizePairSymbol(baseSymRaw) || 'TOKEN';
      const quoteSym = normalizePairSymbol(quoteSymRaw) || '';
      const sym = tokenSide==='base' ? baseSym : (quoteSym || baseSym || 'TOKEN');
      const quoteShown = tokenSide==='base' ? quoteSym : baseSym;
      const img = tokenSide==='base' ? tokenImgFromPool(p,'base') : tokenImgFromPool(p,'quote');
      const symFinal = (sym && sym.toUpperCase()!=='TOKEN') ? sym : (curTokenSymbol||'TOKEN');
      const imgFinal = img || curTokenImage || '';
      const nameFinal = curTokenName || '';
      const quoteFinal = quoteShown || curQuoteSymbol || '';
      applyTokenHeader({symbol: symFinal, name: nameFinal, quoteSymbol: quoteFinal, image: imgFinal});

      // initial stats best-effort (pick correct side price)
      const price = tokenSide==='base' ? tokenPriceFromPool(p,'base') : tokenPriceFromPool(p,'quote');
      const liq = num(a.reserve_in_usd || a.liquidity_in_usd || a.liquidity_usd);
      const mcap = num(a.market_cap_usd || a.fdv_usd);
      const h24 = num(a.price_change_percentage?.h24 || a.price_change_percentage_24h || a.price_change_24h);
      applyStats({price, liq, mcap, h24});

      btnBuy.href = buildBuyUrl(activeNet, addr);
      try{ startTradesPolling(); }catch(_){ }
    }

    // -------------------- Candles
    let rawCandles=[];

    // Candles paging + viewport normalization
    const CANDLE_LIMIT = 1000;
    const candlePager = { loading:false, hasMore:true, before:null, key:'' };
    let _lastCandleFitKey = '';
    let _pagingAttached = false;

    function desiredViewportBars(){
      const k = activeTF?.k || '15m';
      if(k==='1m') return 320;
      if(k==='5m') return 300;
      if(k==='15m') return 260;
      if(k==='1h') return 240;
      if(k==='4h') return 220;
      if(k==='1d') return 200;
      if(k==='1w') return 180;
      if(k==='ALL') return 260;
      return 260;
    }

    
    // -------------------- Viewport stability flags (SPEEDFIX step06)
    let userInteracted = false;
    let programmaticRangeChange = false;
    let didInitialViewport = false;
    let didFitOnce = false;  // per token+timeframe
    let _lastLogicalRange = null;

    function withProgrammaticRangeChange(fn){
      programmaticRangeChange = true;
      try{ fn && fn(); }catch(_e){}
      requestAnimationFrame(()=>{ programmaticRangeChange = false; });
    }
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function syncBarSpacing(){
      try{
        if(userInteracted) return;
        const r = chart.timeScale().getVisibleLogicalRange();
        const bars = r ? Math.max(10, Math.round(r.to - r.from)) : desiredViewportBars();
        const w = Math.max(320, chartEl.clientWidth || 800);
        const spacing = clamp(w / (bars * 1.15), 3.5, 18);
        withProgrammaticRangeChange(()=>{ chart.timeScale().applyOptions({ barSpacing: spacing }); });
      }catch(_){}
    }

    function applyDefaultViewport(){
      try{
        const total = (rawCandles||[]).length;
        if(!total){ return; }
        if(didInitialViewport){ syncBarSpacing(); return; }
        const bars = desiredViewportBars();
        const from = Math.max(0, total - bars);
        const to = Math.max(0, total - 1);
        withProgrammaticRangeChange(()=>{ 
          chart.timeScale().setVisibleLogicalRange({from, to});
          chart.timeScale().applyOptions({ rightOffset: 6 });
        });
        didInitialViewport = true;
        syncBarSpacing();
      }catch(_){}
    }

    function attachPaging(){
      if(_pagingAttached) return;
      _pagingAttached = true;

      chart.timeScale().subscribeVisibleLogicalRangeChange((range)=>{
        if(!range) return;
        // detect user-driven range changes to prevent viewport resets
        if(!programmaticRangeChange){
          if(_lastLogicalRange){
            const df = Math.abs((range.from||0) - (_lastLogicalRange.from||0));
            const dt = Math.abs((range.to||0) - (_lastLogicalRange.to||0));
            if(df > 2 || dt > 2){ userInteracted = true; }
          }
          _lastLogicalRange = { from: range.from, to: range.to };
        }
        if(!poolAddr) return;
        if(candlePager.loading || !candlePager.hasMore) return;
        if(range.from < 30){
          loadOlderCandles();
        }
      });

      // keep candle spacing stable on resize
      const _ro2 = new ResizeObserver(()=>{ try{ syncBarSpacing(); }catch(_){} });
      _ro2.observe(chartEl);
    }


    function geckoCandlesUrl(gran, before){
      // /networks/{network}/pools/{pool}/ohlcv/{timeframe}?aggregate=...&before_timestamp=...&limit=1000&currency=usd
      const agg = (activeTF.k==='ALL' ? 1 : Math.max(1, Math.floor(activeTF.agg / (gran==='minute'?60:(gran==='hour'?3600:86400)) )));
      const params = new URLSearchParams();
      params.set('aggregate', String(agg));
      params.set('limit', '1000');
      params.set('currency','usd');
      if(before) params.set('before_timestamp', String(before));
      return `${GECKO}/networks/${encodeURIComponent(geckoNet())}/pools/${encodeURIComponent(poolAddr)}/ohlcv/${encodeURIComponent(gran)}?`+params.toString();
    }

    function mapGeckoOhlcv(j){
      const list = j?.data?.attributes?.ohlcv_list;
      if(!Array.isArray(list)) return [];
      const cleanNum = (v)=>{
        if(v==null) return NaN;
        if(typeof v==='string') v = v.replace(/,/g,'').trim();
        const n = Number(v);
        return Number.isFinite(n) ? n : NaN;
      };
      const out = [];
      for(const r of list){
        if(!r || r.length<5) continue;
        const ts = cleanNum(r[0]) || 0;
        const time = ts>1e12 ? Math.floor(ts/1000) : Math.floor(ts);
        const open = cleanNum(r[1]);
        const high0 = cleanNum(r[2]);
        const low0  = cleanNum(r[3]);
        const close= cleanNum(r[4]);
        const volume = cleanNum(r[5]);
        if(!(time>0) || !Number.isFinite(open) || !Number.isFinite(close) || !Number.isFinite(high0) || !Number.isFinite(low0)) continue;
        const high = Math.max(high0, open, close);
        const low  = Math.min(low0, open, close);
        out.push({time, open, high, low, close, volume: Number.isFinite(volume)?volume:0});
      }
      return out;
    }

    function applyCandlesToChart(fit){
      // Ensure strictly ascending + unique by time
      const map = new Map();
      for(const c of (rawCandles||[])){
        if(!c || !(c.time>0)) continue;
        map.set(c.time, c);
      }
      rawCandles = Array.from(map.values()).sort((a,b)=>a.time-b.time);
      const src = rawCandles;

      candleSeries.setData(src.map(c=>({time:c.time, open:c.open, high:c.high, low:c.low, close:c.close})));
      volumeSeries.setData(src.map(c=>({time:c.time, value:c.volume||0, color:(c.close>=c.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'})));

      if(src && src.length) perfMarkCandles(perfToken.id);

      if(fit){
        applyDefaultViewport();
      }else{
        // keep bar spacing reasonable even during live updates
        syncBarSpacing();
      }
    }

    function applyTradeToCandles(tr){
      if(!rawCandles || !rawCandles.length) return;
      if(!Number.isFinite(tr?.price)) return;
      if(!Number.isFinite(tr?.tsMs)) return;

      const tsSec = Math.floor(tr.tsMs/1000);
      const bucket = Math.floor(tsSec / activeTF.agg) * activeTF.agg;

      const last = rawCandles[rawCandles.length-1];
      const usdVol = Number.isFinite(tr.usd) ? tr.usd : 0;

      if(bucket < last.time - activeTF.agg*3){
        // too old for current visible timeframe; ignore
        return;
      }

      if(bucket === last.time){
        const _dgPrevClose = last.close; last.close = tr.price;
        if(tr.price > last.high) last.high = tr.price;
        if(tr.price < last.low) last.low = tr.price;
        if(usdVol) last.volume = (Number.isFinite(last.volume)?last.volume:0) + usdVol;
        dgSmoothCandleUpdate({time:last.time, open:last.open, high:last.high, low:last.low, close:last.close}, _dgPrevClose);
        volumeSeries.update({time:last.time, value:last.volume, color:(last.close>=last.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
        return;
      }

      if(bucket > last.time){
        const open = Number.isFinite(last.close) ? last.close : tr.price;
        const c = {
          time: bucket,
          open,
          high: Math.max(open, tr.price),
          low: Math.min(open, tr.price),
          close: tr.price,
          volume: usdVol
        };
        rawCandles.push(c);
        _dgCancelCloseTween(); _dgCandleUpdateImmediate({time:c.time, open:c.open, high:c.high, low:c.low, close:c.close});
        volumeSeries.update({time:c.time, value:c.volume, color:(c.close>=c.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
      }
    }

    /* ===== DexGuard Micro 14: Chart Update Hook (update last candle from newest trade) ===== */
    function updateLastCandleFromTrade(tr){
      try{
        if(!tr || !Number.isFinite(tr.price)) return;
        if(!rawCandles || !rawCandles.length) return;
        if(!candleSeries) return;
        if(!Number.isFinite(activeTF?.agg) || activeTF.agg<=0) return;
        if(!Number.isFinite(tr.tsMs)) return;

        const tsSec = Math.floor(tr.tsMs/1000);
        const bucket = Math.floor(tsSec / activeTF.agg) * activeTF.agg;

        let last = rawCandles[rawCandles.length-1];
        if(!last || !(last.time>0)) return;

        // Ignore very old or out-of-order trades (keeps chart stable)
        if(bucket < last.time - activeTF.agg*3) return;

        const p = tr.price;
        const usdVol = Number.isFinite(tr.usd) ? tr.usd : 0;

        // Same candle -> update OHLCV
        if(bucket === last.time){
          const _dgPrevClose = last.close; last.close = p;
          if(Number.isFinite(last.high)) last.high = Math.max(last.high, p);
          else last.high = p;
          if(Number.isFinite(last.low)) last.low = Math.min(last.low, p);
          else last.low = p;
          if(usdVol){
            last.volume = (Number.isFinite(last.volume)?last.volume:0) + usdVol;
          }

          dgSmoothCandleUpdate({time:last.time, open:last.open, high:last.high, low:last.low, close:last.close}, _dgPrevClose);
          try{
            if(volumeSeries){
              const v = Number.isFinite(last.volume) ? last.volume : 0;
              volumeSeries.update({time:last.time, value:v, color:(last.close>=last.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
            }
          }catch(_){}
          return;
        }

        // New timeframe bucket -> create new candle(s) on boundary
        if(bucket > last.time){
          // Fill missing buckets with flat candles so the series never breaks
          let prev = last;
          let t = prev.time + activeTF.agg;
          let guard = 0;
          while(t < bucket && guard < 500){
            const o = Number.isFinite(prev.close) ? prev.close : (Number.isFinite(prev.open)?prev.open:tr.price);
            const flat = {time:t, open:o, high:o, low:o, close:o, volume:0};
            rawCandles.push(flat);
            _dgCancelCloseTween(); _dgCandleUpdateImmediate({time:flat.time, open:flat.open, high:flat.high, low:flat.low, close:flat.close});
            try{
              if(volumeSeries){
                volumeSeries.update({time:flat.time, value:0, color:'rgba(20,241,149,.18)'});
              }
            }catch(_){}
            prev = flat;
            t += activeTF.agg;
            guard++;
          }

          const open = Number.isFinite(prev.close) ? prev.close : (Number.isFinite(prev.open)?prev.open:p);
          const c = {
            time: bucket,
            open,
            high: Math.max(open, p),
            low: Math.min(open, p),
            close: p,
            volume: usdVol
          };
          rawCandles.push(c);
          _dgCancelCloseTween(); _dgCandleUpdateImmediate({time:c.time, open:c.open, high:c.high, low:c.low, close:c.close});
          try{
            if(volumeSeries){
              volumeSeries.update({time:c.time, value:(Number.isFinite(c.volume)?c.volume:0), color:(c.close>=c.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
            }
          }catch(_){}
        }
      }catch(_){}
    }
    /* ===== /Micro 14 ===== */



    async function refreshLatestCandles(){
      if(!poolAddr) return;
      const _key0 = `${activeNet}|${poolAddr}|${activeTF?.k||''}`;
      const id = ++reqIds.candles;
      const ac = startRequest(`candles:${activeNet}:${poolAddr}:${activeTF?.k||''}`);
      const _reqId = (refreshLatestCandles._reqId = (refreshLatestCandles._reqId||0) + 1);
      const _my = _reqId;
      try{
        const gran = activeTF.gecko;
        const url = geckoCandlesUrl(gran, null);
        const j = await fetchJson(url, {timeout:16000, retries:1, signal: ac.signal});
        if(id !== reqIds.candles) return;
        if(_my !== refreshLatestCandles._reqId) return;
        if(_key0 !== `${activeNet}|${poolAddr}|${activeTF?.k||''}`) return;
        const part = mapGeckoOhlcv(j);
        if(!part.length) return;
        part.sort((a,b)=>a.time-b.time);

        // Merge by time, keeping history
        const earliest = part[0].time;
        const keep = rawCandles.filter(c=>c.time < earliest);
        const map = new Map();
        for(const c of part) map.set(c.time, c);
        rawCandles = keep.concat(Array.from(map.values()).sort((a,b)=>a.time-b.time));

        applyCandlesToChart(false);
      }catch(e){
        // ignore
      }
    }


    async function loadCandles(fit){
      if(!poolAddr) return;
      attachPaging();

      const id = ++reqIds.candles;
      const tfKey = `${activeNet}|${poolAddr}|${activeTF?.k||''}`;
      const ac = startRequest(`candles:${activeNet}:${poolAddr}:${activeTF?.k||''}`);

      statusEl.textContent = 'Loading chart…';
      candlePager.loading = true;
      candlePager.hasMore = true;
      candlePager.before = null;
      candlePager.key = tfKey;

      rawCandles=[];
      candleSeries.setData([]);
      volumeSeries.setData([]);

      try{
        const gran = activeTF.gecko;
        const needBars = desiredViewportBars();
        const maxPages = (activeTF.k==='ALL' ? 6 : 3);

        // 1) Fetch newest page first and render immediately
        let before = null;
        let pages = 0;

        const url0 = geckoCandlesUrl(gran, before);
        const j0 = await fetchJson(url0, {timeout:18000, retries:1, signal: ac.signal});
        if(id !== reqIds.candles) return;

        let part0 = mapGeckoOhlcv(j0);
        if(!part0.length){
          statusEl.textContent = 'Chart not available for this pool.';
          candlePager.hasMore = false;
          candlePager.before = null;
          candlePager.loading = false;
          return;
        }
        part0.sort((a,b)=>a.time-b.time);

        // Set pager for older
        before = part0[0].time - 1;
        pages = 1;

        // Initial render
        rawCandles = part0;
        candlePager.before = before;

        const shouldFit = !!fit && (_lastCandleFitKey !== tfKey);
        applyCandlesToChart(shouldFit);
        if(shouldFit) _lastCandleFitKey = tfKey;

        statusEl.textContent = 'Live.';
        candlePager.loading = false;

        // 2) Backfill older pages in background until enough bars exist
        requestAnimationFrame(()=>{ (async ()=>{
          try{
            const targetBars = Math.floor(needBars * 1.6);
            let fetched = pages;
            let localBefore = before;

            while(id === reqIds.candles && fetched < maxPages && candlePager.hasMore && localBefore && rawCandles.length < targetBars){
              candlePager.loading = true;

              const url = geckoCandlesUrl(gran, localBefore);
              const j = await fetchJson(url, {timeout:18000, retries:1, signal: ac.signal});
              if(id !== reqIds.candles) return;

              const part = mapGeckoOhlcv(j);
              if(!part.length){
                candlePager.hasMore = false;
                break;
              }
              part.sort((a,b)=>a.time-b.time);

              // Merge by time, keep unique
              const map = new Map();
              for(const c of rawCandles) map.set(c.time, c);
              for(const c of part) map.set(c.time, c);
              rawCandles = Array.from(map.values()).sort((a,b)=>a.time-b.time);

              // Continue paging older
              localBefore = part[0].time - 1;
              candlePager.before = localBefore;

              if(part.length < (CANDLE_LIMIT - 10)) candlePager.hasMore = false;

              applyCandlesToChart(false);
              fetched++;
            }
          }catch(e){
            // ignore background errors
          }finally{
            if(id === reqIds.candles) candlePager.loading = false;
          }
        })(); });
      }catch(e){
        statusEl.textContent = 'Chart error.';
        console.error(e);
      }finally{
        if(id === reqIds.candles) candlePager.loading = false;
      }
    }

    async function loadOlderCandles(){
      if(!poolAddr) return;
      if(candlePager.loading || !candlePager.hasMore) return;

      const key = `${activeNet}|${poolAddr}|${activeTF?.k||''}`;
      if(candlePager.key && candlePager.key !== key) return; // stale
      const before = candlePager.before;
      if(!before) { candlePager.hasMore = false; return; }

      candlePager.loading = true;
      const prevRange = (()=>{ try{ return chart.timeScale().getVisibleLogicalRange(); }catch(_){ return null; } })();
      const prevTimes = new Set(rawCandles.map(c=>c.time));

      const id = ++reqIds.candles;
      const ac = startRequest(`candles:${activeNet}:${poolAddr}:${activeTF?.k||''}`);

      try{
        const url = geckoCandlesUrl(activeTF.gecko, before);
        const j = await fetchJson(url, {timeout:18000, retries:1, signal: ac.signal});
        if(id !== reqIds.candles) return;
        let part = mapGeckoOhlcv(j);
        if(!part.length){
          candlePager.hasMore = false;
          return;
        }
        part.sort((a,b)=>a.time-b.time);

        let added = 0;
        for(const c of part){
          if(!prevTimes.has(c.time)) added++;
        }

        // merge + dedupe
        const map = new Map();
        for(const c of rawCandles) map.set(c.time, c);
        for(const c of part) map.set(c.time, c);
        rawCandles = Array.from(map.values()).sort((a,b)=>a.time-b.time);

        // update pager
        candlePager.before = rawCandles[0].time - 1;
        if(part.length < (CANDLE_LIMIT - 10)) candlePager.hasMore = false;

        applyCandlesToChart(false);

        // keep viewport anchored after prepend
        if(prevRange && added>0){
          withProgrammaticRangeChange(()=>{ chart.timeScale().setVisibleLogicalRange({
            from: prevRange.from + added,
            to: prevRange.to + added
          }); });
        }
        syncBarSpacing();
      }catch(e){
        // keep hasMore true; transient errors
      }finally{
        candlePager.loading = false;
      }
    }

    // -------------------- Trades
    function tradesContainer(){
      // write to both desktop + mobile
      return [tradesDesk, tradesMob];
    }

    function ensureTradeHead(){
      // head exists in markup
    }

    function timeAgo(tsMs){
      const d = Math.max(0, Date.now() - tsMs);
      const s = Math.floor(d/1000);
      if(s<60) return s+'s';
      const m = Math.floor(s/60);
      if(m<60) return m+'m';
      const h = Math.floor(m/60);
      if(h<24) return h+'h';
      const days = Math.floor(h/24);
      return days+'d';
    }

    function parseTrade(t){
      const a = t?.attributes || {};
      const id = String(t?.id || a.tx_hash || a.transaction_hash || a.signature || a.transaction_id || '') || '';
      const side = String(a.trade_type || a.side || a.taker_side || a.kind || '').toLowerCase();
      const type = side.includes('sell') ? 'sell' : (side.includes('buy') ? 'buy' : (a.is_buy===true?'buy':(a.is_sell===true?'sell':'')));

      const tx = String(a.tx_hash || a.transaction_hash || a.signature || a.transaction_id || id || '').trim();
      const maker = String(
        a.taker || a.trader || a.wallet_address || a.from_address || a.maker || a.maker_address || a.tx_from_address || a.user_address || ''
      ).trim();

      const rawTs = (a.block_timestamp ?? a.timestamp ?? a.time ?? a.created_at ?? a.mined_at ?? a.block_time ?? 0);
      let tsMs = NaN;
      if(typeof rawTs==='number'){
        tsMs = rawTs>1e12 ? rawTs : rawTs*1000;
      }else{
        const tsv = String(rawTs||'').trim();
        if(tsv && /^\d+(\.\d+)?$/.test(tsv)){
          const n = Number(tsv);
          tsMs = n>1e12 ? n : n*1000;
        }else{
          const d = Date.parse(tsv);
          if(Number.isFinite(d)) tsMs = d;
        }
      }
      if(!Number.isFinite(tsMs)) tsMs = Date.now();

      const usd = num(a.volume_in_usd || a.usd_value || a.volume_usd || a.amount_usd || a.total_usd);
      const price = num(a.price_in_usd || a.price_usd || a.price);
      const baseAmt = num(a.base_token_amount || a.amount_base || a.base_amount || a.base_token_volume || a.base_volume);
      const quoteAmt = num(a.quote_token_amount || a.amount_quote || a.quote_amount || a.quote_token_volume || a.quote_volume);
      const amount = Number.isFinite(baseAmt) ? baseAmt : (Number.isFinite(quoteAmt)? quoteAmt : NaN);

      return { id, type, tx, maker, tsMs, usd, price, amount };
    }

    function tradeRowHtml(tr){
      const age = timeAgo(tr.tsMs);
      const usdTxt = Number.isFinite(tr.usd) ? '$'+formatCompact(tr.usd) : '—';
      const amtTxt = Number.isFinite(tr.amount) ? formatCompact(tr.amount)+' '+esc(curTokenSymbol) : '—';
      const priceTxt = Number.isFinite(tr.price) ? '$'+formatPrice(tr.price) : '—';

      const isNew = tr.maker ? (!seenMakers.has(tr.maker)) : false;
      if(tr.maker) seenMakers.add(tr.maker);

      const makerHtml = tr.maker
        ? `<div class="maker"><span class="addr mono" title="${esc(tr.maker)}">${esc(shortAddr(tr.maker))}</span>${isNew?'<span class="new">NEW</span>':''}</div>`
        : `<span class="mono" style="opacity:.7">—</span>`;

      const txUrl = tr.tx ? explorerTx(activeNet, tr.tx) : '#';
      const addrUrl = tr.maker ? explorerAddr(activeNet, tr.maker) : '#';

      return `
        <div class=\"tradeRow\" data-id=\"${esc(tr.id)}\" data-ts=\"${Number.isFinite(tr.tsMs)?tr.tsMs:0}\" data-price=\"${Number.isFinite(tr.price)?tr.price:''}\" data-usd=\"${Number.isFinite(tr.usd)?tr.usd:''}\" data-type=\"${esc(tr.type||'')}\">
          <div class=\"mono age\">${esc(age)}</div>
          <div><span class="typeBadge ${tr.type==='sell'?'sell':'buy'}">${tr.type==='sell'?'SELL':'BUY'}</span></div>
          <div class="mono">${esc(usdTxt)}</div>
          <div class="mono">${amtTxt}</div>
          <div class="mono hideM">${esc(priceTxt)}</div>
          <div class="hideM">${makerHtml}</div>
          <div>
            <a class="iconBtn" href="${esc(txUrl)}" target="_blank" rel="noreferrer" title="Open Tx">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14 3h7v7" stroke="rgba(255,255,255,.80)" stroke-width="2" stroke-linecap="round"/><path d="M21 3 10 14" stroke="rgba(255,255,255,.80)" stroke-width="2" stroke-linecap="round"/><path d="M10 5H7a4 4 0 0 0-4 4v8a4 4 0 0 0 4 4h8a4 4 0 0 0 4-4v-3" stroke="rgba(255,255,255,.55)" stroke-width="2" stroke-linecap="round"/></svg>
            </a>
          </div>
        </div>
      `;
    }

    async function geckoPoolApiId(){
      try{
        // Prefer explicit pool address; normalize EVM to lowercase
        let pid = String(poolAddr||'').trim();
        if(!pid && poolId) pid = String(poolId||'').trim();
        if(!pid) return '';
        // If pid contains prefixes/separators, derive last segment
        let last = pid;
        try{
          if(last.includes('_')) last = last.split('_').pop();
          if(last.includes(':')) last = last.split(':').pop();
          if(last.includes('/')) last = last.split('/').pop();
        }catch(_){}
        // Use parsed last segment if it looks like an address
        let chosen = String(last||pid).trim();
        if(!chosen) chosen = String(pid||'').trim();

        // EVM pool addresses are case-insensitive; Gecko is safest with lowercase
        if(activeNet !== 'solana') chosen = chosen.toLowerCase();
        return chosen;
      }catch(_){ return ''; }
    }

    async function geckoTrades(limit=80, fetchOpts={}){
      const net = geckoNet();
      const pid1 = geckoPoolApiId();
      if(!pid1) return [];

      const base1 = `${GECKO}/networks/${encodeURIComponent(net)}/pools/${encodeURIComponent(pid1)}/trades`;

      // GeckoTerminal uses JSON:API pagination. Try page params first, then fallback to limit.
      const tries = [];
      tries.push(base1 + `?page=1&limit=${encodeURIComponent(limit)}`);
      tries.push(base1 + `?page=1`);
      tries.push(base1 + `?limit=${encodeURIComponent(limit)}`);

      // If poolId differs (e.g., prefixed id), try it as well
      try{
        const raw = String(poolId||'').trim();
        if(raw && raw !== pid1){
          const raw2 = encodeURIComponent(raw);
          const base2 = `${GECKO}/networks/${encodeURIComponent(net)}/pools/${raw2}/trades`;
          tries.push(base2 + `?page=1&limit=${encodeURIComponent(limit)}`);
          tries.push(base2 + `?page=1`);
          tries.push(base2 + `?limit=${encodeURIComponent(limit)}`);
        }
      }catch(_){}

      for(const url of tries){
        try{
          const j = await fetchJson(url, {timeout:14000, retries:1, signal: fetchOpts.signal});
          if(Array.isArray(j?.data)) return j.data;
        }catch(e){ /* ignore */ }
      }

      return [];
    }
    // ===== DexGuard Micro 11: Trades UI fallback states (empty vs error) =====
    function tradesHasAnyRows(){
      try{
        const el = document.getElementById('trades');
        if(!el) return false;
        return !!(el.querySelector('.tradeRow') || el.querySelector('.tradeHead'));
      }catch(_){ return false; }
    }

    function setTradesFallback(msg){
      try{
        const el = document.getElementById('trades');
        if(!el) return;
        const safe = String(msg||'').replace(/[<>&]/g, s=>({ '<':'&lt;','>':'&gt;','&':'&amp;' }[s]));
        el.innerHTML = `<div style="padding:14px 12px;color:rgba(255,255,255,.70);font-weight:900;font-size:13px;letter-spacing:.1px;">${safe}</div>`;
      }catch(_){}
    }

    function showTradesRetrying(){
      try{
        const el = document.getElementById('trades');
        if(!el) return;
        // only overwrite if there are no rows; otherwise keep last good trades visible
        const hasRows = !!(el.querySelector('.tradeRow'));
        if(!hasRows){
          setTradesFallback('Trades retrying…');
        }
      }catch(_){}
    }
    // ===== /Micro 11 =====
    // ===== DexGuard Micro 12: Trades Dedupe (tx hash/signature + fallback key) =====
    function tradeDedupeKey(tr){
      try{
        const txRaw = String((tr && (tr.tx || tr.id)) || '').trim();
        if(txRaw && txRaw !== '0' && txRaw !== 'null' && txRaw !== 'undefined'){
          return 'tx:' + txRaw.toLowerCase();
        }
        const ts = Number.isFinite(tr?.tsMs) ? Math.floor(tr.tsMs) : 0;
        const type = String(tr?.type || '').toLowerCase();
        const maker = String(tr?.maker || '').toLowerCase();
        const usd = Number.isFinite(tr?.usd) ? (Math.round(tr.usd * 100) / 100) : '';
        const price = Number.isFinite(tr?.price) ? (Math.round(tr.price * 1e10) / 1e10) : '';
        const amt = Number.isFinite(tr?.amount) ? (Math.round(tr.amount * 1e10) / 1e10) : '';
        return 'f:' + [ts, type, maker, usd, price, amt].join('|');
      }catch(_){
        try{ return 'f:' + String(Date.now()) + '|' + Math.random(); }catch(__){ return 'f:' + Math.random(); }
      }
    }
    // ===== /Micro 12 =====
    function renderTrades(trades, {reset=false} = {}){
      try{
        const el = document.getElementById('trades');
        if(!el){ return; }

        // Keep last-good rows visible on fetch failures (handled elsewhere)
        if(!Array.isArray(trades)){
          setTradesFallback('Trades retrying…');
          return;
        }
        if(trades.length===0){
          setTradesFallback('No recent trades');
          return;
        }

        // State per pool signature (so dedupe survives polling, resets on pool/pair change)
        const sig = `${activeNet}|${String(poolAddr||'').toLowerCase()}|${String(poolId||'')}`;
        const S = (window.__DG_TRADES_UI__ || (window.__DG_TRADES_UI__ = {sig:'', keys:new Set(), max: 80}));
        if(reset || S.sig !== sig){
          S.sig = sig;
          S.keys = new Set();
          // clear and rebuild header
          el.innerHTML = '';
        }

        // Ensure header exists
        let head = el.querySelector('.tradeHead');
        if(!head){
          head = document.createElement('div');
          head.className = 'tradeHead';
          head.innerHTML = `
            <div>Time</div>
            <div>Type</div>
            <div class="hideM">USD</div>
            <div>Amount</div>
            <div class="hideM">Price</div>
            <div class="hideM">Maker</div>
            <div></div>
          `;
          el.appendChild(head);
        }

        // Snapshot positions for FLIP (existing rows only)
        const existingRows = Array.from(el.querySelectorAll('.tradeRow'));
        const beforeTops = new Map();
        for(const r of existingRows){
          try{ beforeTops.set(r, r.getBoundingClientRect().top); }catch(_){}
        }

        // Normalize incoming trades into renderable rows (most recent first)
        const norm = [];
        for(const t of trades){
          try{
            const a = t?.attributes || t || {};
            const ts = Number(a?.timestamp || a?.time || a?.ts || 0);
            const tsMs = ts ? (ts > 3e12 ? ts : ts*1000) : (a?.tsMs || 0);
            const side = String(a?.kind || a?.side || a?.type || '').toLowerCase();
            const type = side.includes('sell') ? 'sell' : (side.includes('buy') ? 'buy' : (a?.isBuy ? 'buy' : 'sell'));
            const price = Number(a?.price_usd || a?.priceUsd || a?.price || 0);
            const usd = Number(a?.volume_usd || a?.usd || a?.amount_usd || 0);
            const baseAmt = Number(a?.base_amount || a?.baseAmount || a?.amount || 0);
            const quoteAmt = Number(a?.quote_amount || a?.quoteAmount || 0);
            const maker = String(a?.tx_from || a?.maker || a?.trader || a?.owner || '').trim();
            const tx = String(a?.tx_hash || a?.txHash || a?.tx || t?.tx || t?.id || '').trim();

            const amt = baseAmt || quoteAmt || 0;

            const tr = { tsMs: Number(tsMs)||0, type, price: Number(price)||0, usd: Number(usd)||0, amount: Number(amt)||0, maker, tx };
            tr.id = tx || '';
            tr.k = tradeDedupeKey(tr);
            norm.push(tr);
          }catch(_){}
        }
        norm.sort((A,B)=>(B.tsMs||0)-(A.tsMs||0));
        const top = norm.slice(0, S.max);

        // Determine new trades to insert (preserve order newest->oldest)
        const newOnes = [];
        for(const tr of top){
          if(!S.keys.has(tr.k)){
            newOnes.push(tr);
          }
        }

        // If nothing new, ensure panel is never blank
        if(!newOnes.length){
          if(!el.querySelector('.tradeRow')){
            setTradesFallback('No recent trades');
          }
          return;
        }

        // Helper formatters
        const fmtTime = (ms)=>{
          try{
            const d = new Date(ms||Date.now());
            const hh = String(d.getHours()).padStart(2,'0');
            const mm = String(d.getMinutes()).padStart(2,'0');
            const ss = String(d.getSeconds()).padStart(2,'0');
            return `${hh}:${mm}:${ss}`;
          }catch(_){ return ''; }
        };
        const fmtNum = (n, dp=2)=>{
          try{
            if(!Number.isFinite(n)) return '–';
            return n.toLocaleString(undefined, {maximumFractionDigits: dp});
          }catch(_){ return String(n); }
        };
        const shortAddr = (a)=>{
          try{
            const s = String(a||'');
            if(!s) return '—';
            if(s.length<=12) return s;
            return s.slice(0,6)+'…'+s.slice(-4);
          }catch(_){ return '—'; }
        };

        // Insert at top (below header): newest first. Build nodes without rebuilding entire list.
        
        // Micro 14: Update last candle from the newest accepted trade price (post-dedupe)
        try{
          if(newOnes && newOnes.length){
            updateLastCandleFromTrade(newOnes[0]);
          }
        }catch(_){}

const insertBefore = head.nextSibling;
        for(const tr of newOnes){
          S.keys.add(tr.k);

          const row = document.createElement('div');
          row.className = 'tradeRow dg-new';
          row.dataset.k = tr.k;

          const tbadge = `<span class="typeBadge ${tr.type==='buy'?'buy':'sell'}">${tr.type.toUpperCase()}</span>`;
          const usdTxt = Number.isFinite(tr.usd) ? DG_FMT.usdCompact(tr.usd) : '—';
          const amtTxt = Number.isFinite(tr.amount) ? DG_FMT.compact(tr.amount) : '—';
          const priceTxt = Number.isFinite(tr.price) ? DG_FMT.usdPrice(tr.price) : '—';

          const makerHtml = `<div class="maker"><span class="addr mono">${shortAddr(tr.maker)}</span></div>`;
          const txLink = tr.tx ? `<a class="iconBtn" href="${explorerTxUrl(tr.tx)}" target="_blank" rel="noopener" title="Tx">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M14 3h7v7" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M10 14L21 3" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
              <path d="M21 14v6a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h6" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
          </a>` : `<div></div>`;

          row.innerHTML = `
            <div class="mono">${fmtTime(tr.tsMs)}</div>
            <div>${tbadge}</div>
            <div class="mono hideM">${usdTxt}</div>
            <div class="mono">${amtTxt}</div>
            <div class="mono hideM">${priceTxt}</div>
            <div class="hideM">${makerHtml}</div>
            <div>${txLink}</div>
          `;

          el.insertBefore(row, insertBefore);
          requestAnimationFrame(()=>{ try{ row.classList.add('dg-in'); }catch(_){} });
        }

        // Prune extra rows beyond max (keep newest)
        const rowsNow = Array.from(el.querySelectorAll('.tradeRow'));
        if(rowsNow.length > S.max){
          for(let i=S.max; i<rowsNow.length; i++){
            try{
              const k = rowsNow[i].dataset.k;
              if(k) S.keys.delete(k);
              rowsNow[i].remove();
            }catch(_){}
          }
        }

        // FLIP: animate older rows shifting down smoothly
        requestAnimationFrame(()=>{
          try{
            const rowsAfter = Array.from(el.querySelectorAll('.tradeRow'));
            for(const r of rowsAfter){
              if(r.classList.contains('dg-new')) continue;
              const bt = beforeTops.get(r);
              if(bt == null) continue;
              const at = r.getBoundingClientRect().top;
              const dy = bt - at;
              if(Math.abs(dy) < 0.5) continue;
              r.classList.add('dg-shift');
              r.style.transition = 'none';
              r.style.transform = `translateY(${dy}px)`;
              r.getBoundingClientRect();
              r.style.transition = 'transform .22s ease';
              r.style.transform = 'translateY(0)';
              setTimeout(()=>{
                try{
                  r.style.transition = '';
                  r.style.transform = '';
                  r.classList.remove('dg-shift');
                }catch(_){}
              }, 260);
            }
            for(const r of el.querySelectorAll('.tradeRow.dg-new')){
              setTimeout(()=>{ try{ r.classList.remove('dg-new'); }catch(_){ } }, 320);
            }
          }catch(_){}
        });

      }catch(_){
        try{ setTradesFallback('Trades retrying…'); }catch(__){}
      }
    }

    function updateAges(){
      tradesContainer().forEach(el=>{
        [...el.querySelectorAll('.tradeRow')].forEach(row=>{
          const ts = Number(row.getAttribute('data-ts')||0);
          if(!ts) return;
          const ageEl = row.querySelector('.age');
          if(ageEl) ageEl.textContent = timeAgo(ts);
        });
      });
    }

    function applyTradeToCandles(tr){
      if(!rawCandles || !rawCandles.length) return;
      if(!Number.isFinite(tr.price)) return;
      if(!Number.isFinite(activeTF?.agg) || activeTF.agg<=0) return;

      const tsSec = Math.floor(tr.tsMs/1000);
      const bucket = Math.floor(tsSec / activeTF.agg) * activeTF.agg;

      const last = rawCandles[rawCandles.length-1];
      const usdVol = Number.isFinite(tr.usd) ? tr.usd : 0;

      // ignore very old trades (keeps chart stable)
      if(bucket < last.time - activeTF.agg*5) return;

      if(bucket === last.time){
        const _dgPrevClose = last.close; last.close = tr.price;
        last.high = Math.max(last.high, tr.price);
        last.low  = Math.min(last.low, tr.price);
        last.volume = (Number(last.volume)||0) + usdVol;
        dgSmoothCandleUpdate({time:last.time, open:last.open, high:last.high, low:last.low, close:last.close}, _dgPrevClose);
        volumeSeries.update({time:last.time, value:last.volume, color:(last.close>=last.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
        return;
      }

      if(bucket > last.time){
        const open = Number.isFinite(last.close) ? last.close : tr.price;
        const close = tr.price;
        const high = Math.max(open, close);
        const low = Math.min(open, close);
        const c = {time: bucket, open, high, low, close, volume: usdVol};
        rawCandles.push(c);
        _dgCancelCloseTween(); _dgCandleUpdateImmediate({time:c.time, open:c.open, high:c.high, low:c.low, close:c.close});
        volumeSeries.update({time:c.time, value:c.volume, color:(c.close>=c.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
      }
    }
    async function loadTrades(reset=false){
      if(!poolAddr) return;
      const _trKey = `trades:${activeNet}:${poolAddr}`;
      if(tradesFetchInFlight && loadTrades._inFlightKey === _trKey) return;
      loadTrades._inFlightKey = _trKey;
      tradesFetchInFlight = true;
      const _key0 = `${activeNet}|${poolAddr}`;
      const id = ++reqIds.trades;
      const ac = startRequest(_trKey);
      const _reqId = (loadTrades._reqId = (loadTrades._reqId||0) + 1);
      const _my = _reqId;
      try{
        const data = await geckoTrades(80, {signal: ac.signal});
        if(id !== reqIds.trades) return;
        if(_my !== loadTrades._reqId) return;
        if(_key0 !== `${activeNet}|${poolAddr}`) return;
        scheduleTradesRender(data, reset, (newly)=>{
          if(id !== reqIds.trades) return;
          if(_my !== loadTrades._reqId) return;
          if(_key0 !== `${activeNet}|${poolAddr}`) return;
          if(newly && newly.length){
            // Apply oldest->newest so candle updates are correct
            newly.slice().sort((a,b)=>a.tsMs-b.tsMs).forEach(applyTradeToCandles);
          }
        }, id, _trKey);
      }catch(e){
        // keep UI stable
      }
      finally{
        if(loadTrades._inFlightKey === _trKey) tradesFetchInFlight = false;
      }
    }

    function stopLiveLoops(){
            try{ stopTradesPolling(); }catch(_){ }
LIVE.gen++;
      const st = LIVE;
      if(st.tTrades){ clearTimeout(st.tTrades); st.tTrades=null; }
      if(st.tCandles){ clearTimeout(st.tCandles); st.tCandles=null; }
      if(st.tMeta){ clearTimeout(st.tMeta); st.tMeta=null; }
      if(st.tAges){ clearInterval(st.tAges); st.tAges=null; }
    }

    const LIVE = { gen:0, tTrades:null, tCandles:null, tMeta:null, tAges:null, failTrades:0, tradeDelay:1500 };

    
    // ===== DexGuard Micro 10: Trades Polling (stable interval + backoff) =====
    const TRADES_POLL = (window.__DG_TRADES_POLL__ || (window.__DG_TRADES_POLL__ = {
      timer: null,
      running: false,
      normalMs: 3000,
      delayMs: 3000,
      maxMs: 30000,
      failCount: 0,
      sig: '',
      ctrl: null
    }));

    function tradesPollSig(){
      try{
        return `${activeNet}|${String(poolAddr||'').toLowerCase()}|${String(poolId||'')}`;
      }catch(_){ return ''; }
    }

    function stopTradesPolling(){
      try{
        TRADES_POLL.running = false;
        if(TRADES_POLL.timer){ clearTimeout(TRADES_POLL.timer); TRADES_POLL.timer = null; }
        if(TRADES_POLL.ctrl){ try{ TRADES_POLL.ctrl.abort(); }catch(_){ } TRADES_POLL.ctrl = null; }
      }catch(_){}
    }

    async function pollTradesOnce(){
      try{
        if(!TRADES_POLL.running) return;
        const sigNow = tradesPollSig();
        if(TRADES_POLL.sig && sigNow !== TRADES_POLL.sig){
          // token/pool changed; stop this loop
          stopTradesPolling();
          return;
        }

        // Must have a selected pool; otherwise retry soon
        const pid = String(poolAddr||poolId||'').trim();
        if(!pid){
          TRADES_POLL.failCount = Math.min(TRADES_POLL.failCount + 1, 6);
          TRADES_POLL.delayMs = Math.min(TRADES_POLL.maxMs, Math.round(TRADES_POLL.normalMs * Math.pow(2, TRADES_POLL.failCount)));
          try{ showTradesRetrying(); }catch(_){ }
          TRADES_POLL.timer = setTimeout(pollTradesOnce, TRADES_POLL.delayMs);
          return;
        }

        // Abort previous in-flight request
        if(TRADES_POLL.ctrl){ try{ TRADES_POLL.ctrl.abort(); }catch(_){ } }
        TRADES_POLL.ctrl = new AbortController();

        const data = await geckoTrades(80, {signal: TRADES_POLL.ctrl.signal});
        if(Array.isArray(data)){
          try{ renderTrades(data); }catch(_){}
          TRADES_POLL.failCount = 0;
          TRADES_POLL.delayMs = TRADES_POLL.normalMs;
        }else{
          TRADES_POLL.failCount = Math.min(TRADES_POLL.failCount + 1, 6);
          TRADES_POLL.delayMs = Math.min(TRADES_POLL.maxMs, Math.round(TRADES_POLL.normalMs * Math.pow(2, TRADES_POLL.failCount)));
        }
      }catch(e){
        try{ console.warn("TradesPoll failure", e);
        try{ showTradesRetrying(); }catch(_){ } }catch(_){}
        TRADES_POLL.failCount = Math.min(TRADES_POLL.failCount + 1, 6);
        TRADES_POLL.delayMs = Math.min(TRADES_POLL.maxMs, Math.round(TRADES_POLL.normalMs * Math.pow(2, TRADES_POLL.failCount)));
      }finally{
        try{
          if(!TRADES_POLL.running) return;
          const sigNow2 = tradesPollSig();
          if(TRADES_POLL.sig && sigNow2 !== TRADES_POLL.sig) return;
          // Ensure only one active loop
          if(TRADES_POLL.timer){ clearTimeout(TRADES_POLL.timer); TRADES_POLL.timer = null; }
          TRADES_POLL.timer = setTimeout(pollTradesOnce, TRADES_POLL.delayMs);
        }catch(_){}
      }
    }

    function startTradesPolling(){
      try{
        stopTradesPolling(); // guarantee no overlap
        TRADES_POLL.running = true;
        TRADES_POLL.failCount = 0;
        TRADES_POLL.delayMs = TRADES_POLL.normalMs;
        TRADES_POLL.sig = tradesPollSig();
        try{ console.debug("TradesPoll start", TRADES_POLL.sig); }catch(_){}
        TRADES_POLL.timer = setTimeout(pollTradesOnce, 120);
      }catch(_){}
    }
    // ===== /Micro 10 =====

function startLiveLoops(){
      stopLiveLoops();
      const gen = LIVE.gen;
      LIVE.failTrades = 0;
      LIVE.tradeDelay = 1500;

      const scheduleTrades = async ()=>{
        if(gen !== LIVE.gen) return;
        try{
          await loadTrades(false);
          LIVE.failTrades = 0;
          LIVE.tradeDelay = 1500;
      try{ startTradesPolling(); }catch(_){ }
        }catch(_){
          LIVE.failTrades = (LIVE.failTrades||0) + 1;
          LIVE.tradeDelay = Math.min(7000, Math.round(1500 * Math.pow(1.25, LIVE.failTrades)));
        }
        LIVE.tTrades = setTimeout(scheduleTrades, LIVE.tradeDelay);
      };

      const scheduleCandles = async ()=>{
        if(gen !== LIVE.gen) return;
        try{ await refreshLatestCandles(); }catch(_){}
        LIVE.tCandles = setTimeout(scheduleCandles, 9000);
      };

      const scheduleMeta = async ()=>{
        if(gen !== LIVE.gen) return;
        try{ await loadMeta(); }catch(_){}
        LIVE.tMeta = setTimeout(scheduleMeta, 15000);
      };

      LIVE.tAges = setInterval(()=>{ if(gen === LIVE.gen) updateAges(); }, 1000);

      scheduleTrades();
      scheduleCandles();
      scheduleMeta();
    }


// -------------------- Meta (refresh price/liquidity/24h)
    async function geckoPool(fetchOpts={}){
      const url = `${GECKO}/networks/${encodeURIComponent(geckoNet())}/pools/${encodeURIComponent(poolAddr)}?include=base_token,quote_token`;
      const j = await fetchJson(url, {timeout:14000, retries:1, signal: fetchOpts.signal});
      return j?.data || null;
    }

    async function loadMeta(){
      if(!poolAddr) return;
      try{
        const p = await geckoPool();
        if(!p) return;
        applyPool(p);
      }catch(e){
        // ignore
      }
    }

    
    // -------------------- Trending (match main site)
    const TREND_CACHE = new Map();
    const TREND_LS_PREFIX = 'dexguard_trending_cache_v1:';
    function trendLsKey(chain){ return TREND_LS_PREFIX + String(chain||''); }
    function trendBuildIncMap(included){
      const m = new Map();
      for(const it of (included||[])){
        if(!it || !it.id) continue;
        const id = String(it.id);
        if(it.type) m.set(String(it.type)+':' + id, it);
        m.set(id, it);
      }
      return m;
    }
    function trendReadCache(chain){
      try{
        const raw = localStorage.getItem(trendLsKey(chain));
        if(!raw) return null;
        const obj = JSON.parse(raw);
        if(!obj || !Array.isArray(obj.data) || !Array.isArray(obj.included)) return null;
        return obj;
      }catch(e){ return null; }
    }
    function trendWriteCache(chain, data, included){
      try{
        localStorage.setItem(trendLsKey(chain), JSON.stringify({ts: Date.now(), chain: String(chain||''), data, included}));
      }catch(e){}
    }
    
    // ---- Per-chain trending cache (memory + localStorage)
    const TREND_CHAIN_CACHE = (window.__DG_TREND_CHAIN_CACHE__ || (window.__DG_TREND_CHAIN_CACHE__ = new Map()));
    function trendIsValidList(list){
      return Array.isArray(list) && list.length > 0;
    }
    function trendIsValidBundle(obj){
      return !!(obj && Array.isArray(obj.data) && Array.isArray(obj.included));
    }
    function setCachedTrending(chain, data, included){
      try{
        const ck = String(chain||'');
        // Update cache ONLY on successful fetch (non-empty list)
        if(!trendIsValidList(data)) return;
        const inc = Array.isArray(included) ? included : [];
        const bundle = {ts: Date.now(), chain: ck, data: data, included: inc};
        TREND_CHAIN_CACHE.set(ck, bundle);
        try{ trendWriteCache(ck, data, inc); }catch(e){}
      }catch(e){}
    }
    function getCachedTrendingBundle(chain){
      try{
        const ck = String(chain||'');
        const mem = TREND_CHAIN_CACHE.get(ck);
        if(trendIsValidBundle(mem) && trendIsValidList(mem.data)) return mem;
        const ls = trendReadCache(ck);
        if(trendIsValidBundle(ls) && trendIsValidList(ls.data)){
          // hydrate memory cache
          try{ TREND_CHAIN_CACHE.set(ck, ls); }catch(e){}
          return ls;
        }
      }catch(e){}
      return null;
    }
    function getCachedTrending(chain){
      const b = getCachedTrendingBundle(chain);
      return (b && trendIsValidList(b.data)) ? b.data : null;
    }

    // -------------------- Last-success token (per chain)
    const LAST_TOKEN_LS_PREFIX = 'dexguard_last_token_v1:';
    function lastTokenKey(chain){ return LAST_TOKEN_LS_PREFIX + String(chain||''); }
    function setLastToken(chain, address){
      try{
        const ck = String(chain||'');
        const a = String(address||'').trim();
        if(!a) return;
        localStorage.setItem(lastTokenKey(ck), a);
      }catch(_){}
    }
    function getLastToken(chain){
      try{
        const ck = String(chain||'');
        const a = String(localStorage.getItem(lastTokenKey(ck))||'').trim();
        if(!a) return null;
        // validate type by chain
        if(ck==='solana'){ if(typeof isSolAddr==='function' && !isSolAddr(a)) return null; }
        else { if(typeof isEvmAddr==='function' && !isEvmAddr(a)) return null; }
        return a;
      }catch(_){ return null; }
    }

    function extractTrendingTokenAddr(p, incMap){
      try{
        if(!p) return null;
        const rel = p?.relationships || {};
        const baseRef = rel?.base_token?.data || null;
        const baseId = baseRef?.id ? String(baseRef.id) : '';
        const baseType = baseRef?.type ? String(baseRef.type) : '';
        const baseT = baseId ? ((incMap?.get(baseType+':' + baseId) || incMap?.get(baseId))?.attributes || {}) : {};
        const tokenAddr = String((baseT?.address || baseId || '')).trim();
        return tokenAddr ? tokenAddr : null;
      }catch(_){ return null; }
    }

    function stopTrendingInterval(){
      if(trendingTimer){ try{ clearInterval(trendingTimer); }catch(e){} trendingTimer = null; }
    }

    function applyNetTheme(){
      document.body.classList.remove('net-sol','net-eth','net-bnb','net-base');
      if(activeNet==='solana') document.body.classList.add('net-sol');
      else if(activeNet==='eth') document.body.classList.add('net-eth');
      else if(activeNet==='bsc') document.body.classList.add('net-bnb');
      else if(activeNet==='base') document.body.classList.add('net-base');
    }

    function syncTrendToggle(){
      const wrap = $('trendToggle');
      if(!wrap) return;
      [...wrap.querySelectorAll('.chainBtn')].forEach(b=>{
        b.classList.toggle('active', normalizeChain(b.dataset.net)===(activeNet));
      });
    }

    async function fetchTrendingPools(net){
      const chainKey = activeNet;
      const id = ++reqIds.trending;
      const ac = startRequest(`trending:${chainKey}`);
      const key = String(chainKey||net||'');
      const cached = TREND_CACHE.get(key);
      const now = Date.now();
      if(cached && (now - cached.ts) < 45000) return cached.data;

      const url = `${GECKO}/networks/${encodeURIComponent(net)}/trending_pools?include=base_token,quote_token,dex`;
      const j = await fetchJson(url, {timeout:14000, retries:0, signal: ac.signal});
      if(id !== reqIds.trending) return null;
      const data = Array.isArray(j?.data) ? j.data : [];
      const inc  = Array.isArray(j?.included) ? j.included : [];
      const incMap = new Map();
      for(const it of inc){
        if(!it?.id) continue;
        const iid = String(it.id);
        if(it?.type) incMap.set(String(it.type)+':' + iid, it);
        incMap.set(iid, it);
      }
      const out = { data, incMap };
      TREND_CACHE.set(key, {ts: now, data: out});
      try{ setCachedTrending(chainKey, data, inc); }catch(e){}
      return out;
    }

    
    // Render ticker items EXACT like main page
    function poolToTickerItem(p, n, incMap){
      const a = p?.attributes || {};
      const rel = p?.relationships || {};
      const baseRef = rel?.base_token?.data || null;
      const quoteRef = rel?.quote_token?.data || null;

      const baseId = baseRef?.id ? String(baseRef.id) : '';
      const baseType = baseRef?.type ? String(baseRef.type) : '';
      const quoteId = quoteRef?.id ? String(quoteRef.id) : '';
      const quoteType = quoteRef?.type ? String(quoteRef.type) : '';

      const baseT = baseId ? ((incMap.get(baseType+':' + baseId) || incMap.get(baseId))?.attributes || {}) : {};
      const quoteT = quoteId ? ((incMap.get(quoteType+':' + quoteId) || incMap.get(quoteId))?.attributes || {}) : {};

      const sym = String((baseT?.symbol || baseT?.name || '')).trim() || (a?.name ? String(a.name).split('/')[0].trim() : '') || 'TOKEN';
      const symClean = String(sym||'TOKEN').replace(/[^a-zA-Z0-9_$\.\-]/g,'').slice(0,24) || 'TOKEN';
      const symDisp = symClean.startsWith('$') ? symClean : ('$' + symClean.replace(/^\$/,''));

      const pctRaw = ((a?.price_change_percentage && (a.price_change_percentage.h24 ?? a.price_change_percentage['h24'] ?? a.price_change_percentage['24h'])) ?? a?.price_change_percentage_24h ?? a?.price_change_percentage_h24 ?? null);
      const pctNum = (pctRaw===null || pctRaw===undefined || pctRaw==='') ? NaN : Number(pctRaw);
      const pctTxt = Number.isFinite(pctNum) ? DG_FMT.pct(pctNum) : '';
      const pctCls = Number.isFinite(pctNum) ? (pctNum>0?'up':(pctNum<0?'down':'')) : '';

      const logoUrlRaw = String(
        baseT?.image_url || baseT?.imageUrl || baseT?.image || baseT?.logo_url || baseT?.logoUrl ||
        quoteT?.image_url || quoteT?.imageUrl || quoteT?.image || quoteT?.logo_url || quoteT?.logoUrl ||
        a?.image_url || a?.imageUrl || a?.base_token_image_url || a?.base_token_imageUrl || a?.token_image_url || a?.token_imageUrl ||
        ''
      ).trim();
      let logoUrl = logoUrlRaw;
      if(logoUrl && logoUrl.startsWith('/')) logoUrl = 'https://www.geckoterminal.com' + logoUrl;
      const first = (symClean || 'T').slice(0,1).toUpperCase();

      // Prefer token CA (GeckoTerminal base_token id is usually the token CA)
      const tokenAddr = String((baseT?.address || baseId || '')).trim();

      const top1 = (n===0);
      const cls = `tickerItem${top1?' top1':''}`;
      const rankTxt = top1 ? `🔥 #1` : `#${n+1}`;

      const logo = logoUrl
        ? `<span class="tickerLogoWrap"><img class="tickerLogo" src="${esc(logoUrl)}" alt="" loading="lazy" referrerpolicy="no-referrer" onerror="this.remove(); var w=this.closest('.tickerLogoWrap'); if(w){w.innerHTML='<span class=tickerLogoFallback>${esc(first)}</span>';}\"></span>`
        : `<span class="tickerLogoWrap"><span class="tickerLogoFallback">${esc(first)}</span></span>`;

      return `<a class="${cls}" href="#" data-addr="${esc(tokenAddr)}" title="Open ${esc(symDisp)}">
        <span class="rank">${esc(rankTxt)}</span>
        ${logo}
        <span class="sym">${esc(symDisp)}</span>
        ${pctTxt ? `<span class="tickerPct ${esc(pctCls)}">${esc(pctTxt)}</span>` : ''}
      </a>`;
    }

    // Make the marquee a true endless loop: distance + duration scale with content width.
    function syncTickerMarquee(){
      try{
        if(!tickerTrack) return;
        const isMobile = window.matchMedia('(max-width: 860px)').matches;
        const pxPerSec = isMobile ? 120 : 95;
        requestAnimationFrame(()=>{
          const total = tickerTrack.scrollWidth || 0;
          if(total < 20) return;
          const one = Math.max(1, Math.round(total / 2));
          document.documentElement.style.setProperty('--tickerDistance', one + 'px');
          const dur = Math.min(22, Math.max(6.5, one / pxPerSec));
          document.documentElement.style.setProperty('--tickerSpeed', dur.toFixed(2) + 's');
        });
      }catch(_e){}
    }

    let _tickerResizeT = null;
    window.addEventListener('resize', ()=>{
      clearTimeout(_tickerResizeT);
      _tickerResizeT = setTimeout(syncTickerMarquee, 120);
    }, {passive:true});

    function renderTrendingTicker(pools, incMap){
      const top = (pools||[]).slice(0, 10);
      if(!top.length){
        tickerTrack.innerHTML = `<span class="tickerItem" style="opacity:.75"><span class="rank">!</span><span class="sym">Trending unavailable</span></span>`;
        syncTickerMarquee();
        return;
      }

      const items = top.map((p,i)=>poolToTickerItem(p,i,incMap)).join('');
      tickerTrack.innerHTML = items + items;
      syncTickerMarquee();
    }
    async function startTrending(){
      const gen = ++trendingGen;
      stopTrendingInterval();
      applyNetTheme();
      syncTrendToggle();

      // Render immediately from cache (per chain), then refresh in background
      try{
        const c = getCachedTrendingBundle(activeNet);
        if(c){
          const im = trendBuildIncMap(c.included);
          renderTrendingTicker(c.data, im);
        }
      }catch(e){}

      const load = async ()=>{
        if(gen !== trendingGen) return;
        const net = geckoNet();
        const delays = [0, 600, 1200];
        let lastErr = null;
        for(let attempt=0; attempt<delays.length; attempt++){
          if(gen !== trendingGen) return;
          if(attempt>0) await sleep(delays[attempt]);
          if(gen !== trendingGen) return;
          try{
            const res = await fetchTrendingPools(net);
            if(gen !== trendingGen) return;
            if(!res) return; // stale
            renderTrendingTicker(res.data, res.incMap);
            statusEl.textContent = 'Live.';
            return;
          }catch(e){
            if(e && e.name==='AbortError') return;
            lastErr = e;
          }
        }
        if(gen !== trendingGen) return;
        statusEl.textContent = 'Temporarily unavailable';
        try{
          if(!tickerTrack.querySelector('.tickerItem')){
            tickerTrack.innerHTML = `<div class="tickerEmpty">Temporarily unavailable.</div>`;
            syncTickerMarquee();
          }
        }catch(_){ }
        try{ console.error('trending failed', lastErr); }catch(_){ }
      };

      trendingLoadFn = load;
      // Initial refresh (background)
      load();

      // Ensure only one trending interval exists, pause/resume on visibility
      stopTrendingInterval();
      trendingTimer = setInterval(()=>{
        if(document.hidden) return;
        try{ trendingLoadFn && trendingLoadFn(); }catch(_){ }
      }, 25000);

      if(!startTrending._visBound){
        startTrending._visBound = true;
        document.addEventListener('visibilitychange', ()=>{
          if(document.hidden){
            stopTrendingInterval();
            try{ if(typeof stopLiveLoops==='function') stopLiveLoops(); }catch(_){ }
          }else{
            try{ trendingLoadFn && trendingLoadFn(); }catch(_){ }
            stopTrendingInterval();
            trendingTimer = setInterval(()=>{
              if(document.hidden) return;
              try{ trendingLoadFn && trendingLoadFn(); }catch(_){ }
            }, 25000);
            // resume candles/trades loops only if a token is active
            if(poolAddr){
              try{ if(typeof startLiveLoops==='function') startLiveLoops(); }catch(_){ }
            }
          }
        });
      }

      tickerTrack.onclick = (e)=>{
        const a = e.target.closest('.tickerItem');
        if(!a) return;
        e.preventDefault();
        const tAddr = a.getAttribute('data-addr') || '';
        if(tAddr) openToken(tAddr, {skipInput:true});
      };

      const toggle = $('trendToggle');
      if(toggle){
        toggle.onclick = (e)=>{
          const b = e.target.closest('.chainBtn');
          if(!b) return;
          const net = normalizeChain(b.dataset.net || 'solana');
          if(net===activeNet) return;

          // Cancel live polling (chart/trades) immediately to prevent stale updates
          try{ if(typeof stopLiveLoops==='function') stopLiveLoops(); }catch(_){ }
          try{ poolAddr=''; poolId=''; }catch(_){ }

          activeNet = net;
          applyNetTheme();
          syncTrendToggle();
          renderNetPills();

          // Update URL with new chain; token will be set once we open #1 trending
          try{ addr=''; updateUrl(); }catch(_){ }

          // Chain switch auto-open: #1 trending for selected chain (cache -> fetch -> fallback)
          try{
            const CS = (window.__DG_CHAIN_SWITCH__ || (window.__DG_CHAIN_SWITCH__ = {}));
            CS.net = activeNet;
            CS.ts = Date.now();
            CS.done = false;

            const tryOpenTop = ()=>{
              try{
                const c = getCachedTrendingBundle(activeNet);
                if(c){
                  const im = trendBuildIncMap(c.included);
                  const a0 = extractTrendingTokenAddr((c.data||[])[0], im);
                  if(a0){
                    CS.done = true;
                    addr = a0;
                    try{ updateUrl(); }catch(_){}
                    openToken(a0, {skipInput:true, silent:true, boot:true});
                    return true;
                  }
                }
              }catch(_){}
              return false;
            };

            // Kick off trending refresh for the selected chain (uses cache fallback internally)
            try{ startTrending(); }catch(_){ }

            // Immediate open from cache if possible
            if(tryOpenTop()) return;

            // Retry after short delay to catch freshly fetched trending
            setTimeout(()=>{
              try{
                if(CS.done || CS.net!==activeNet) return;
                if(tryOpenTop()) return;
              }catch(_){}
            }, 1200);

            // Final fallback: last-success token for chain, else existing default
            setTimeout(()=>{
              try{
                if(CS.done || CS.net!==activeNet) return;
                const last = (typeof getLastToken==='function') ? getLastToken(activeNet) : null;
                if(last){
                  CS.done = true;
                  addr = last;
                  try{ updateUrl(); }catch(_){}
                  openToken(last, {skipInput:true, silent:true, boot:true});
                  return;
                }
                const def = DEFAULT_MARKET_TOKEN[activeNet];
                CS.done = true;
                addr = def;
                try{ updateUrl(); }catch(_){}
                openToken(def, {skipInput:true, silent:true, boot:true});
              }catch(_){}
            }, 2600);
          }catch(_){}
        };
      }
    }


    // -------------------- Navigation + Boot
    function updateUrl(){
      const u = new URL(location.href);
      u.searchParams.set('chain', activeNet);
      if(addr) u.searchParams.set('addr', addr);
      history.replaceState({}, '', u.toString());
    }

    function navigate(chain, address){
      activeNet = normalizeChain(chain);
      addr = String(address||'').trim();
      updateUrl();
      renderNetPills();
      applyNetTheme();
      try{ if(typeof stopLiveLoops==='function') stopLiveLoops(); }catch(_){ }
      startTrending();
      // if address exists, load it
      if(addr){
        openToken(addr, {skipInput:true, silent:true, boot:true});
      }
    }

    function tradeSkeletonHtml(n){
      let out='';
      for(let i=0;i<n;i++){
        out += `<div class="tradeRow" style="opacity:.55">
          <div class="mono">—</div>
          <div><span class="typeBadge" style="opacity:.85">—</span></div>
          <div class="mono">—</div>
          <div class="mono">—</div>
          <div class="mono hideM">—</div>
          <div class="maker hideM"><span class="addr">—</span></div>
          <button class="iconBtn" type="button" aria-label="loading" style="opacity:.45; pointer-events:none">…</button>
        </div>`;
      }
      return out;
    }

    function ensureChartSkeleton(){
      const wrap = document.getElementById('chartWrap');
      if(!wrap) return null;
      let el = document.getElementById('chartSkeleton');
      if(el) return el;
      el = document.createElement('div');
      el.id = 'chartSkeleton';
      el.style.cssText = 'position:absolute;inset:0;display:none;pointer-events:none;z-index:2;';
      el.innerHTML = `<div style="position:absolute;inset:14px;border-radius:16px;border:1px solid rgba(255,255,255,.08);background:rgba(255,255,255,.04);"></div>`;
      wrap.appendChild(el);
      return el;
    }

    function setTokenLoadingUI(){
      try{
        statsEl.innerHTML = [
          `<span class="statPill"><span class="k">Price</span><span class="v">—</span></span>`,
          `<span class="statPill"><span class="k">Liquidity</span><span class="v">—</span></span>`,
          `<span class="statPill"><span class="k">MCap/FDV</span><span class="v">—</span></span>`,
          `<span class="statPill"><span class="k">24h</span><span class="v">—</span></span>`
        ].join('');
      }catch(_){}
      try{
        const sk = ensureChartSkeleton();
        if(sk) sk.style.display = 'block';
      }catch(_){}
      try{
        const ph = tradeSkeletonHtml(6);
        tradesContainer().forEach(el=>{
          const head = el.querySelector('.tradeHead');
          el.innerHTML = '';
          if(head) el.appendChild(head);
          el.insertAdjacentHTML('beforeend', ph);
        });
      }catch(_){}
    }

    function clearTokenLoadingUI(){
      try{
        const sk = document.getElementById('chartSkeleton');
        if(sk) sk.style.display = 'none';
      }catch(_){}
    }



    async function openToken(input, opts={}){
          try{ if(typeof stopLiveLoops==='function') stopLiveLoops(); }catch(_){ }
          const skipInput = !!opts.skipInput;
          const silent = !!opts.silent;
          const boot = !!opts.boot;

          let v = String(input||'').trim();
          if(!v){ toast('Paste a token name or address'); return; }
          if(!skipInput) q.value = v;

          const id = ++reqIds.token;
          perfStartToken(id);
          let _tokenKey = `token:${activeNet}:${v}`;
          let _tokenAC = startRequest(_tokenKey);

          // reset view
          statusEl.textContent = 'Loading…';
          pairNameEl.textContent = 'Loading…';
          pairMetaEl.textContent = 'Resolving best pool…';
          results.innerHTML = '';

          // Force default chart timeframe on every token selection
          setActiveTFKey('15m');
          // reset viewport flags on token selection
          userInteracted = false;
          programmaticRangeChange = false;
          didInitialViewport = false;
          didFitOnce = false;
          _lastLogicalRange = null;

          // Instant UI feedback (must render before any network)
          setTokenLoadingUI();
          await new Promise(r=>requestAnimationFrame(r));
          if(id !== reqIds.token) return;
          perfMarkPaint(id);

          let dsPair = null;

          // If user typed a name/symbol (not an address), resolve via DexScreener search (auto across chains)
          if(!isEvmAddr(v) && !isSolAddr(v)){
            statusEl.textContent = 'Searching…';
            pairNameEl.textContent = 'Searching…';
            pairMetaEl.textContent = 'Finding best match…';
            try{
              const _sId = ++reqIds.search;
              const _sKey = `search:${activeNet}`;
              const _sAc = startRequest(_sKey);
              const pairs = await dsSearch(v, {signal: _sAc.signal});
              if(_sId !== reqIds.search) return;
              if(id !== reqIds.token) return;
              if(!pairs.length){
                statusEl.textContent = 'Not found.';
                pairNameEl.textContent = 'Not found';
                pairMetaEl.textContent = 'Try a contract address.';
                toast('No results. Try contract address.');
                clearTokenLoadingUI();
                return;
              }
              const best = bestPairAnyNet(pairs);
              if(!best){
                toast('No usable pair found.');
                clearTokenLoadingUI();
                return;
              }
              // switch net to best match chain
              const chainId = lc(best?.chainId||'');
              const newNet = (chainId==='solana') ? 'solana' : (chainId==='ethereum' ? 'eth' : (chainId==='bsc' ? 'bsc' : (chainId==='base' ? 'base' : activeNet)));
              if(newNet !== activeNet){
                activeNet = newNet;
                renderNetPills();
                startTrending();
              }
              _tokenKey = `token:${activeNet}:${v}`;
              _tokenAC = startRequest(_tokenKey);

              dsPair = best;
              v = String(best?.baseToken?.address || '').trim() || v;
              if(!skipInput) q.value = v;
              _tokenKey = `token:${activeNet}:${v}`;
              _tokenAC = startRequest(_tokenKey);
            }catch(e){
              statusEl.textContent = 'Search error.';
              toast('Search failed. Try again.');
              return;
            }
          }

          // If it's an EVM address and no dsPair yet, try all EVM nets and pick best liquidity
          if(isEvmAddr(v) && !dsPair){
            const nets = ['eth','bsc','base'];
            let best = null;
            for(const n of nets){
              const arr = await dsTokenPairsV1(n, v, {signal: _tokenAC.signal});
              if(id !== reqIds.token) return;
              const cand = bestPairAnyNet(arr);
              if(cand && (!best || Number(cand?.liquidity?.usd||0) > Number(best?.liquidity?.usd||0))) best = cand;
            }
            if(best){
              const chainId = lc(best?.chainId||'');
              const newNet = (chainId==='ethereum') ? 'eth' : (chainId==='bsc' ? 'bsc' : (chainId==='base' ? 'base' : activeNet));
              if(newNet !== activeNet){
                activeNet = newNet;
                renderNetPills();
                startTrending();
              }
              _tokenKey = `token:${activeNet}:${v}`;
              _tokenAC = startRequest(_tokenKey);
              dsPair = best;
            }
          }

          // If it's Solana address and no dsPair yet, fetch DS token-pairs on Solana
          if(isSolAddr(v) && !dsPair){
            const arr = await dsTokenPairsV1('solana', v, {signal: _tokenAC.signal});
            if(id !== reqIds.token) return;
            const best = bestPairAnyNet(arr);
            if(best) dsPair = best;
          }

          // preferred pool address (pairAddress is usually the AMM pool address)
          let preferredPool = dsPair?.pairAddress || dsPair?.pair_address || '';

          // Fill header from DexScreener meta (fast symbols/logos/stats)
          if(dsPair){
            const meta = dsExtractTokenMeta(dsPair, v);
            curTokenAddr = v;
            if(meta?.image) curTokenImage = meta.image;
            if(meta?.name) curTokenName = meta.name;
            applyTokenHeader(meta);

            applyStats({
              price: num(dsPair?.priceUsd),
              liq: num(dsPair?.liquidity?.usd),
              mcap: num(dsPair?.fdv),
              h24: num(dsPair?.priceChange?.h24),
            });
          }else{
            curTokenAddr = v;
            curTokenName = '';
            curTokenImage = '';
            applyTokenHeader({symbol:'TOKEN', name:'', quoteSymbol:'', image:''});
            applyStats({});
          }

          // reset caches/timers
          tradesSeen = new Set();
          seenMakers = new Set();

          try{
            // 1) preferred pool first (when available via DexScreener)
            if(preferredPool){
              poolAddr = preferredPool;
              const p = await geckoPool({signal: _tokenAC.signal});
              if(id !== reqIds.token) return;
              if(p){
                if(id !== reqIds.token) return;
                applyPool(p);
                statusEl.textContent = 'Loading…';
                await Promise.all([loadCandles(true), loadTrades(true)]);
                if(id !== reqIds.token) return;
                clearTokenLoadingUI();
                if(id !== reqIds.token) return;
                statusEl.textContent = 'Live.';
                startLiveLoops();
                
                try{ addr = v; }catch(_){ }
                try{ updateUrl(); }catch(_){ }
                try{ setLastToken(activeNet, v); }catch(_){ }
return;
              }
            }

            // 2) fallback: Gecko token pools -> choose best
            const pools = await resolvePoolsFromGecko(v, {signal: _tokenAC.signal});
            if(id !== reqIds.token) return;
            if(!pools.length){
              statusEl.textContent = 'Not found.';
              pairNameEl.textContent = 'Not found';
              pairMetaEl.textContent = 'Try a different token or chain.';
              toast('Token not found on this chain.');
              clearTokenLoadingUI();
              return;
            }

            const best = chooseBestPool(pools, v);
            poolChoices = pools;
            poolAddr = poolAddressFromPool(best);

            const _cP = loadCandles(true);
            const _tP = loadTrades(true);
            const p = await geckoPool({signal: _tokenAC.signal});
            if(id !== reqIds.token) return;
            if(!p) throw new Error('Pool fetch failed');
            if(id !== reqIds.token) return;
            applyPool(p);

            statusEl.textContent = 'Loading…';
            await Promise.all([_cP, _tP]);
                if(id !== reqIds.token) return;
                clearTokenLoadingUI();
                if(id !== reqIds.token) return;
            statusEl.textContent = 'Live.';
            startLiveLoops();
          
                try{ addr = v; }catch(_){ }
                try{ updateUrl(); }catch(_){ }
                try{ setLastToken(activeNet, v); }catch(_){ }
}catch(e){
            console.error(e);
            statusEl.textContent = 'Load error.';
            clearTokenLoadingUI();
            // Avoid noisy toast on first load / auto-open. Show toast only after user actions.
            if(!silent && !boot){
              toast('Failed to load chart/trades. API blocked or pool unsupported.');
            }
            // One gentle auto-retry on boot (sometimes APIs are rate-limited on initial load)
            if(boot && !openToken._bootRetried){
              openToken._bootRetried = true;
              setTimeout(()=>openToken(addr, {skipInput:true, silent:true}), 1200);
            }
    }
        }

    
    // Boot UI
    renderNetPills();
    renderTimeframes();
    applyNetTheme();

// Boot trending
    startTrending();

    // Auto-Open Logic (URL > #1 trending > last-success > fallback)
    (function bootAutoOpen(){
      const BOOT = { done:false, pendingTrending:false, startedNet: activeNet, fromUrl: !!(addr && String(addr).trim()) };
      try{ window.__DG_BOOT_AUTO = BOOT; }catch(_){}
      const openNow = (a)=>{
        if(BOOT.done) return true;
        const t = String(a||'').trim();
        if(!t) return false;
        BOOT.done = true;
        try{ BOOT.pendingTrending = false; }catch(_){}
        try{ addr = t; }catch(_){}
        try{ updateUrl(); }catch(_){}
        openToken(t, {skipInput:true, silent:true, boot:true});
        return true;
      };

      // 1) URL param token
      if(BOOT.fromUrl){
        openNow(addr);
        return;
      }

      // 2) #1 trending (cache immediate)
      try{
        const b = getCachedTrendingBundle(activeNet);
        if(b){
          const im = trendBuildIncMap(b.included);
          const a0 = extractTrendingTokenAddr((b.data||[])[0], im);
          if(openNow(a0)) return;
        }
      }catch(_){}

      // 2b) Wait briefly for fresh trending fetch to arrive, then open #1
      BOOT.pendingTrending = true;

      // 3) last-success token (after short wait)
      setTimeout(()=>{
        if(BOOT.done) return;
        BOOT.pendingTrending = false;
        const last = getLastToken(activeNet);
        if(openNow(last)) return;

        // 4) existing default fallback
        openNow(DEFAULT_MARKET_TOKEN[activeNet]);
      }, 2600);
    })();

// ================================
//  UI/UX Premium Patch (Design-only)
//  - Mobile Live Trades bottom sheet
//  - Close search results on outside tap (no global scrim)
// ================================

// Sync top padding for fixed top bar (prevents content hidden underneath)
function syncTopbarSpace(){
  try{
    const tb = document.querySelector('.topbar');
    if(!tb) return;
    const cs = getComputedStyle(tb);
    const top = parseFloat(cs.top) || 0;
    const h = Math.ceil(tb.getBoundingClientRect().height || 0);
    const space = Math.max(64, h + top + 12);
    document.documentElement.style.setProperty('--topbar-space', space + 'px');
  }catch(_){}
}
requestAnimationFrame(syncTopbarSpace);
window.addEventListener('resize', ()=>requestAnimationFrame(syncTopbarSpace), {passive:true});
if(window.visualViewport){
  window.visualViewport.addEventListener('resize', ()=>requestAnimationFrame(syncTopbarSpace), {passive:true});
}


// Close search dropdown on outside interactions (no full-page dimming/blur)
document.addEventListener('pointerdown', (e)=>{
  try{
    if(results && results.style.display === 'block'){
      if(dexSearch && !dexSearch.contains(e.target)){
        hideResults();
      }
    }
  }catch(_){}
}, {capture:true});

if(searchScrim){
  // ensure scrim never blocks UI
  searchScrim.style.display = 'none';
}


// Live Trades accordion (in-page; expands downward; never overlays chart)
(function initTradesAccordion(){
  try{
    if(!tradesCard) return;
    const hd = tradesCard.querySelector('.tableHd');
    if(!hd) return;

    // Toggle button (chevron) for affordance
    let btn = tradesCard.querySelector('.accToggleBtn');
    if(!btn){
      btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'accToggleBtn';
      btn.setAttribute('aria-label','Toggle Live Trades');
      btn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path fill="currentColor" d="M7.41 8.58 12 13.17l4.59-4.59L18 10l-6 6-6-6z"/></svg>';
      const right = hd.querySelector('.sheetRight') || hd;
      right.appendChild(btn);
    }

    function setOpen(open){
      const isOpen = !!open;
      tradesCard.classList.toggle('open', isOpen);
      hd.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
    }

    function toggle(){
      setOpen(!tradesCard.classList.contains('open'));
    }

    // Default: open on desktop, collapsed on mobile
    const mq = window.matchMedia('(max-width: 740px)');
    setOpen(!mq.matches);
    if(mq && mq.addEventListener){ mq.addEventListener('change', ()=>{ setOpen(!mq.matches); }); }

    btn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); toggle(); });
    hd.addEventListener('click', (e)=>{ e.preventDefault(); toggle(); });

    document.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape') setOpen(false);
    });
  }catch(_){}
})();
  })();
  

// ================================
//  DexGuard Split Panel (Chart + Txns) + Drag Handle
// ================================
(function initSplitPanel(){
  try{
    const __isMobile = (window.matchMedia && window.matchMedia('(max-width: 760px)').matches);
    if(!__isMobile) return;
    const rootId = 'splitRoot';
    if(document.getElementById(rootId)) return;
    if(!chartCard || !tradesCard) return;

    // Remove legacy buttons completely
    try{ if(btnFit) btnFit.remove(); }catch(_){}
    try{ if(btnRefresh) btnRefresh.remove(); }catch(_){}

    // Hide legacy mobile tab wrapper + mobile trades wrapper (split replaces)
    try{ const mt = chartCard.querySelector('.mobileTabs'); if(mt) mt.remove(); }catch(_){}
    try{ if(mobileTradesWrap) mobileTradesWrap.style.display='none'; }catch(_){}

    // Build split DOM
    const splitRoot = document.createElement('div');
    splitRoot.id = rootId;
    splitRoot.className = 'splitRoot';

    const splitChart = document.createElement('div');
    splitChart.className = 'splitChart';

    const splitHandle = document.createElement('div');
    splitHandle.className = 'splitHandle';
    splitHandle.setAttribute('role','separator');
    splitHandle.setAttribute('aria-orientation','horizontal');
    splitHandle.title = 'Drag to resize';

    const splitPanel = document.createElement('div');
    splitPanel.className = 'splitPanel';

    const splitTabs = document.createElement('div');
    splitTabs.className = 'splitTabs';

    const mkTab = (key, label)=>{
      const b=document.createElement('button');
      b.type='button';
      b.className='splitTab';
      b.dataset.key=key;
      b.textContent=label;
      return b;
    };

    const tabBoth = mkTab('both','Chart+Txns');
    const tabChartOnly = mkTab('chart','Chart');
    const tabTxnsOnly = mkTab('txns','Txns');
    splitTabs.appendChild(tabBoth);
    splitTabs.appendChild(tabChartOnly);
    splitTabs.appendChild(tabTxnsOnly);

    const splitBody = document.createElement('div');
    splitBody.className = 'splitBody';

    splitPanel.appendChild(splitTabs);
    splitPanel.appendChild(splitBody);

    // Move chartWrap + controls into splitChart
    const chartWrapEl = document.getElementById('chartWrap');
    const controlsEl = chartCard.querySelector('.controls');
    if(chartWrapEl) splitChart.appendChild(chartWrapEl);
    if(controlsEl) splitChart.appendChild(controlsEl);

    // Move trades card into splitBody
    tradesCard.classList.remove('desktopOnly');
    splitBody.appendChild(tradesCard);

    // Insert into chartCard (after header)
    const hd = chartCard.querySelector('.cardHd');
    if(hd && hd.parentNode){
      hd.parentNode.insertBefore(splitRoot, hd.nextSibling);
    }else{
      chartCard.appendChild(splitRoot);
    }
    splitRoot.appendChild(splitChart);
    splitRoot.appendChild(splitHandle);
    splitRoot.appendChild(splitPanel);

    // Default heights
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const recompute = ()=>{
      const total = splitRoot.clientHeight || 0;
      const minBottom = 160;
      const maxBottom = Math.max(minBottom, total - 240);
      const cur = parseFloat(getComputedStyle(splitRoot).getPropertyValue('--split-bottom')) || 260;
      const next = clamp(cur, minBottom, maxBottom);
      splitRoot.style.setProperty('--split-bottom', next + 'px');
      debounceChartResize();
      };
    window.addEventListener('resize', ()=>{ debounceChartResize(); recompute(); }, {passive:true});
    requestAnimationFrame(recompute);

    // Tabs behavior
    const setMode = (mode)=>{
      tabBoth.classList.toggle('active', mode==='both');
      tabChartOnly.classList.toggle('active', mode==='chart');
      tabTxnsOnly.classList.toggle('active', mode==='txns');

      if(mode==='chart'){
        splitPanel.style.display = 'none';
        splitHandle.style.display = 'none';
        splitChart.style.flex = '1 1 auto';
      }else if(mode==='txns'){
        splitChart.style.display = 'none';
        splitHandle.style.display = 'none';
        splitPanel.style.display = 'flex';
      }else{
        splitChart.style.display = 'flex';
        splitPanel.style.display = 'flex';
        splitHandle.style.display = 'flex';
      }

      requestAnimationFrame(()=>{
        try{
          if(mode!=='txns'){
            chart.applyOptions({ width: chartEl.clientWidth, height: chartEl.clientHeight });
            /* SPEEDFIX step07: disable auto-fit on tab/mode switching */
          }
        }catch(_){}
      });
    };

    tabBoth.onclick = ()=>setMode('both');
    tabChartOnly.onclick = ()=>setMode('chart');
    tabTxnsOnly.onclick = ()=>setMode('txns');
    setMode('both');

    // Drag handle behavior
    let dragging=false, startY=0, startBottom=0;
    const onMove = (e)=>{
      if(!dragging) return;
      const y = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
      const dy = y - startY;
      const total = splitRoot.clientHeight || 0;
      const minBottom = 160;
      const maxBottom = Math.max(minBottom, total - 240);
      const next = clamp(startBottom - dy, minBottom, maxBottom);
      splitRoot.style.setProperty('--split-bottom', next + 'px');
      debounceChartResize();
      e.preventDefault?.();
    };
    const onUp = ()=>{
      if(!dragging) return;
      dragging=false;
      document.body.classList.remove('dragging');
      window.removeEventListener('pointermove', onMove, {passive:false});
      window.removeEventListener('pointerup', onUp);
      window.removeEventListener('touchmove', onMove, {passive:false});
      window.removeEventListener('touchend', onUp);
    };

    const onDown = (e)=>{
      if(tabChartOnly.classList.contains('active') || tabTxnsOnly.classList.contains('active')) return;
      dragging=true;
      startY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
      startBottom = parseFloat(getComputedStyle(splitRoot).getPropertyValue('--split-bottom')) || 260;
      document.body.classList.add('dragging');
      if(e.pointerId && splitHandle.setPointerCapture) try{ splitHandle.setPointerCapture(e.pointerId); }catch(_){}
      window.addEventListener('pointermove', onMove, {passive:false});
      window.addEventListener('pointerup', onUp);
      window.addEventListener('touchmove', onMove, {passive:false});
      window.addEventListener('touchend', onUp);
      e.preventDefault?.();
    };

    splitHandle.addEventListener('pointerdown', onDown, {passive:false});
    splitHandle.addEventListener('touchstart', onDown, {passive:false});
  }catch(_){}
})();</script>

<script>
/* ===== DexGuard Micro 01: Hard Safety (global error catcher + banner) ===== */
(function(){
  try{
    var DG_RT_BANNER_ID = "rtErrBanner";
    var dg_rt_hideTimer = null;
    var dg_rt_lastShown = 0;

    function dgEnsureRuntimeBanner(){
      var b = document.getElementById(DG_RT_BANNER_ID);
      if(b) return b;

      b = document.createElement("div");
      b.id = DG_RT_BANNER_ID;
      b.setAttribute("role","status");
      b.setAttribute("aria-live","polite");

      var dot = document.createElement("div");
      dot.className = "rtDot";

      var txt = document.createElement("div");
      txt.className = "rtTxt";
      txt.textContent = "Runtime error — retrying…";

      var close = document.createElement("button");
      close.type = "button";
      close.className = "rtClose";
      close.setAttribute("aria-label","Dismiss");
      close.textContent = "×";
      close.addEventListener("click", function(ev){
        try{
          ev.preventDefault();
          ev.stopPropagation();
          b.classList.remove("show");
        }catch(_){}
      }, {passive:false});

      b.addEventListener("click", function(){
        try{ b.classList.remove("show"); }catch(_){}
      }, {passive:true});

      b.appendChild(dot);
      b.appendChild(txt);
      b.appendChild(close);

      document.addEventListener("DOMContentLoaded", function(){
        try{ document.body && document.body.appendChild(b); }catch(_){}
      }, {once:true});

      if(document.body){
        try{ document.body.appendChild(b); }catch(_){}
      }
      return b;
    }

    function dgShowRuntimeBanner(reason){
      try{
        var now = Date.now();
        // throttle repeated errors
        if(now - dg_rt_lastShown < 500) return;
        dg_rt_lastShown = now;

        var b = dgEnsureRuntimeBanner();
        if(!b) return;

        var t = b.querySelector(".rtTxt");
        if(t){
          // keep text stable; optionally add short hint
          t.textContent = "Runtime error — retrying…";
        }

        b.classList.add("show");
        if(dg_rt_hideTimer) clearTimeout(dg_rt_hideTimer);
        dg_rt_hideTimer = setTimeout(function(){
          try{ b.classList.remove("show"); }catch(_){}
        }, 5200);
      }catch(_){}
    }

    function dgLogFullError(tag, payload){
      try{
        // Make sure we never throw from logger
        console.error(tag, payload);
      }catch(_){}
    }

    // window.onerror (sync errors)
    var prevOnError = window.onerror;
    window.onerror = function(message, source, lineno, colno, error){
      try{
        dgLogFullError("GlobalError", {
          message: message,
          source: source,
          lineno: lineno,
          colno: colno,
          error: error,
          stack: error && error.stack ? String(error.stack) : undefined
        });
        dgShowRuntimeBanner(error || message);
      }catch(_){}
      // Never block default handling
      if(typeof prevOnError === "function"){
        try{ return prevOnError.apply(this, arguments); }catch(_){}
      }
      return false;
    };

    // Error events (resource errors, etc.)
    window.addEventListener("error", function(ev){
      try{
        // Resource errors may not have ev.error
        var payload = {
          message: ev && ev.message,
          filename: ev && ev.filename,
          lineno: ev && ev.lineno,
          colno: ev && ev.colno,
          error: ev && ev.error,
          stack: ev && ev.error && ev.error.stack ? String(ev.error.stack) : undefined,
          target: ev && ev.target ? (ev.target.tagName || ev.target.nodeName || ev.target.toString()) : undefined
        };
        dgLogFullError("UnhandledErrorEvent", payload);
        dgShowRuntimeBanner(ev && (ev.error || ev.message));
      }catch(_){}
    }, true);

    // Promise rejections
    var prevOnRej = window.onunhandledrejection;
    window.onunhandledrejection = function(ev){
      try{
        var r = ev && ev.reason;
        dgLogFullError("UnhandledRejection", {
          reason: r,
          reasonType: (r && r.constructor && r.constructor.name) ? r.constructor.name : typeof r,
          stack: r && r.stack ? String(r.stack) : undefined
        });
        dgShowRuntimeBanner(r);
      }catch(_){}
      if(typeof prevOnRej === "function"){
        try{ return prevOnRej.apply(this, arguments); }catch(_){}
      }
      return false;
    };

    window.addEventListener("unhandledrejection", function(ev){
      try{
        var r = ev && ev.reason;
        dgLogFullError("UnhandledRejectionEvent", {
          reason: r,
          reasonType: (r && r.constructor && r.constructor.name) ? r.constructor.name : typeof r,
          stack: r && r.stack ? String(r.stack) : undefined
        });
        dgShowRuntimeBanner(r);
      }catch(_){}
    }, true);

    // Ensure banner exists early without blocking execution
    dgEnsureRuntimeBanner();
  }catch(_){}
})();
</script>


<script>
/* ===== DexGuard Micro 02: Critical Render Guard (blank screen prevention) ===== */
(function(){
  try{
    var DG_GUARD = window.__DG_RENDER_GUARD__ || (window.__DG_RENDER_GUARD__ = {
      lastAction: null,
      retrying: false,
      attempts: 0,
      lastRetryAt: 0,
      lastCheckAt: 0
    });

    var DG_STATUS_ID = "rtStatusBanner";
    var dg_status_hideTimer = null;

    function dgEnsureStatusBanner(){
      var b = document.getElementById(DG_STATUS_ID);
      if(b) return b;

      b = document.createElement("div");
      b.id = DG_STATUS_ID;
      b.setAttribute("role","status");
      b.setAttribute("aria-live","polite");

      var dot = document.createElement("div");
      dot.className = "rtDot";

      var txt = document.createElement("div");
      txt.className = "rtTxt";
      txt.textContent = "Loading failed — retrying…";

      var close = document.createElement("button");
      close.type = "button";
      close.className = "rtClose";
      close.setAttribute("aria-label","Dismiss");
      close.textContent = "×";
      close.addEventListener("click", function(ev){
        try{
          ev.preventDefault();
          ev.stopPropagation();
          b.classList.remove("show");
        }catch(_){}
      }, {passive:false});

      b.appendChild(dot);
      b.appendChild(txt);
      b.appendChild(close);

      document.addEventListener("DOMContentLoaded", function(){
        try{ document.body && document.body.appendChild(b); }catch(_){}
      }, {once:true});

      if(document.body){
        try{ document.body.appendChild(b); }catch(_){}
      }
      return b;
    }

    function dgShowStatusBanner(){
      try{
        var b = dgEnsureStatusBanner();
        if(!b) return;
        b.classList.add("show");
        if(dg_status_hideTimer) clearTimeout(dg_status_hideTimer);
        dg_status_hideTimer = setTimeout(function(){
          try{ b.classList.remove("show"); }catch(_){}
        }, 6000);
      }catch(_){}
    }

    function dgHasMeaningfulText(el){
      try{
        if(!el) return false;
        var t = (el.textContent || "").replace(/\s+/g," ").trim();
        return t.length > 0;
      }catch(_){ return false; }
    }

    function dgIsEmpty(el){
      try{
        if(!el) return true;
        // If element is hidden but exists, still counts as present
        if(el.children && el.children.length > 0) return false;
        return !dgHasMeaningfulText(el);
      }catch(_){ return true; }
    }

    function dgCriticalState(){
      var misses = [];
      try{
        // trending ticker
        var tr = document.getElementById("tickerTrack");
        if(dgIsEmpty(tr)) misses.push("trending");

        // token header area
        var pn = document.getElementById("pairName");
        var pm = document.getElementById("pairMeta");
        if(!pn || !dgHasMeaningfulText(pn)){
          // also consider header container
          var cc = document.getElementById("chartCard");
          var hd = cc ? cc.querySelector(".cardHd") : null;
          if(dgIsEmpty(hd)) misses.push("tokenHeader");
        }

        // chart container
        var cw = document.getElementById("chartWrap");
        var c = document.getElementById("chart");
        var hasCanvas = false;
        try{
          hasCanvas = !!(c && (c.querySelector("canvas") || c.querySelector("svg") || c.querySelector("iframe") || (c.children && c.children.length>0)));
        }catch(_){}
        if(!cw || (!hasCanvas && dgIsEmpty(cw) && dgIsEmpty(c))) misses.push("chart");

        // trades container
        var t = document.getElementById("trades");
        var hasRows = false;
        try{
          hasRows = !!(t && (t.querySelector(".tradeRow") || t.querySelector(".tradeHead")));
        }catch(_){}
        if(!t || (!hasRows && dgIsEmpty(t))) misses.push("trades");
      }catch(_){}
      return misses;
    }

    function dgRetryLastAction(reason){
      try{
        var now = Date.now();
        if(DG_GUARD.retrying && (now - DG_GUARD.lastRetryAt) < 1200) return;
        DG_GUARD.retrying = true;
        DG_GUARD.lastRetryAt = now;
        DG_GUARD.attempts = Math.min((DG_GUARD.attempts || 0) + 1, 6);

        var delay = 850 + (DG_GUARD.attempts * 350);
        setTimeout(function(){
          try{
            var act = DG_GUARD.lastAction;
            // Prefer re-running last explicit action
            if(act && act.type === "token" && typeof window.openToken === "function"){
              var inp = act.input;
              var opts = act.opts || {};
              // keep silent + avoid altering user input box
              var merged = {};
              for(var k in opts) merged[k] = opts[k];
              merged.silent = true;
              merged.skipInput = true;
              try{ window.openToken(inp, merged); }catch(e){ try{ console.error("guard retry openToken failed", e); }catch(_){ } }
            }else if(act && act.type === "trending" && typeof window.startTrending === "function"){
              try{ window.startTrending(); }catch(e){ try{ console.error("guard retry startTrending failed", e); }catch(_){ } }
            }else{
              // Fallback: if input has a token/address, try openToken
              var q = document.getElementById("q");
              var v = q ? String(q.value||"").trim() : "";
              if(v && typeof window.openToken === "function"){
                try{ window.openToken(v, {silent:true, skipInput:true}); }catch(e){ try{ console.error("guard retry fallback openToken failed", e); }catch(_){ } }
              }else if(typeof window.startTrending === "function"){
                try{ window.startTrending(); }catch(e){ try{ console.error("guard retry fallback startTrending failed", e); }catch(_){ } }
              }
            }
          }catch(_){}
          DG_GUARD.retrying = false;
        }, delay);
      }catch(_){}
    }

    function dgRunGuardCheck(reason){
      try{
        var now = Date.now();
        if(now - (DG_GUARD.lastCheckAt||0) < 350) return;
        DG_GUARD.lastCheckAt = now;

        var misses = dgCriticalState();
        if(misses && misses.length){
          try{ console.warn("RenderGuard: missing/empty sections", misses, "reason:", reason); }catch(_){}
          dgShowStatusBanner();
          dgRetryLastAction(reason);
        }else{
          // Reset attempts on success so backoff doesn't keep growing
          DG_GUARD.attempts = 0;
        }
      }catch(_){}
    }

    function dgScheduleChecks(reason){
      try{
        // Grace periods: allow content to render
        setTimeout(function(){ dgRunGuardCheck(reason || "post"); }, 1600);
        setTimeout(function(){ dgRunGuardCheck(reason || "post"); }, 3200);
      }catch(_){}
    }

    // Hook token switches (openToken)
    try{
      if(typeof window.openToken === "function" && !window.openToken.__dg_wrapped){
        var _openToken = window.openToken;
        var wrapped = function(input, opts){
          try{
            DG_GUARD.lastAction = { type:"token", input: String(input||""), opts: (opts||{}) };
            dgScheduleChecks("tokenSwitch");
          }catch(_){}
          return _openToken.apply(this, arguments);
        };
        wrapped.__dg_wrapped = true;
        window.openToken = wrapped;
      }
    }catch(_){}

    // Hook trending refreshes
    try{
      if(typeof window.startTrending === "function" && !window.startTrending.__dg_wrapped){
        var _st = window.startTrending;
        var w2 = function(){
          try{ DG_GUARD.lastAction = { type:"trending" }; dgScheduleChecks("trending"); }catch(_){}
          return _st.apply(this, arguments);
        };
        w2.__dg_wrapped = true;
        window.startTrending = w2;
      }
    }catch(_){}

    // Run after initial load
    dgEnsureStatusBanner();
    document.addEventListener("DOMContentLoaded", function(){
      try{
        // Seed lastAction from existing input, if any
        var q = document.getElementById("q");
        var v = q ? String(q.value||"").trim() : "";
        if(v && !DG_GUARD.lastAction){
          DG_GUARD.lastAction = { type:"token", input: v, opts: {silent:true, skipInput:true} };
        }
      }catch(_){}
      dgScheduleChecks("boot");
      // Periodic lightweight check (rare) to prevent blank screen persisting
      try{
        setInterval(function(){ dgRunGuardCheck("interval"); }, 12000);
      }catch(_){}
    }, {once:true});

    // Also check after navigation events that often imply token changes
    window.addEventListener("hashchange", function(){ dgScheduleChecks("hashchange"); }, {passive:true});
    window.addEventListener("popstate", function(){ dgScheduleChecks("popstate"); }, {passive:true});
  }catch(_){}
})();
</script>

</body>
</html>


/* ================================
   MOBILE-ONLY TRENDING TICKER COMPACT + SMOOTH (step12)
   - Reduce height/padding, smaller cards, better readability
   - Smooth marquee (GPU-friendly), less heavy shadows (less jank)
   - Keeps existing click behavior
   - Desktop unchanged
   ================================ */
@media (max-width: 760px){
  /* Compact container spacing */
  .topBarInner{ gap: 8px !important; padding: 10px 10px 10px !important; }

  /* Ticker wrapper: slimmer + lighter paint cost */
  .tickerWrap{
    padding: 6px 8px !important;
    border-radius: 16px !important;
    border: 1px solid rgba(255,255,255,.10) !important;
    background: rgba(255,255,255,.045) !important;
    box-shadow: 0 8px 22px rgba(0,0,0,.18) !important;
  }
