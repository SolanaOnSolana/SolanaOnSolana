<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#070711" />
  <title>$SOS — Guardian Check (Multi-Chain) • Premium</title>
  <meta name="description" content="Guardian Approved — token risk score + launch readiness + cluster intelligence + bubble/graph map (best-effort)." />

  <style>
    :root{
      --bg:#070711;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.08);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);

      --g:#14F195;
      --c:#00D1FF;
      --p:#9945FF;

      --radius: 22px;
      --shadow: 0 12px 32px rgba(0,0,0,.45);
      --max: 1180px;

      --sol-g1:#14F195;
      --sol-g2:#00D1FF;
      --sol-g3:#9945FF;
      --bnb-yellow:#F0B90B;
      --base-blue:#0052FF;

      --good: rgba(20,241,149,.18);
      --warn: rgba(255,220,130,.14);
      --bad:  rgba(255,120,150,.16);

      --src-onchain: rgba(20,241,149,.16);
      --src-indexer: rgba(0,209,255,.14);
      --src-api: rgba(153,69,255,.14);
      --src-heur: rgba(255,220,130,.12);

      --focus: rgba(0,209,255,.55);
      --focusGlow: rgba(0,209,255,.14);

      --gridGap: 16px;
      --danger: rgba(255,120,150,.95);

      --mono: ui-monospace, Menlo, Consolas, monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;

      /* viz */
      --vizH: 420px;
      --vizH_m: 360px;

      /* subtle glass */
      --glass: rgba(7,7,17,.68);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--text);
      font: 15.5px/1.55 var(--sans);
      background: var(--bg);
      position:relative;
      overflow-x:hidden;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      z-index:-1;
      pointer-events:none;
      background:
        radial-gradient(1200px 700px at 10% 5%, rgba(153,69,255,.22), transparent 60%),
        radial-gradient(1000px 650px at 90% 10%, rgba(20,241,149,.18), transparent 55%),
        radial-gradient(900px 600px at 70% 85%, rgba(0,209,255,.14), transparent 55%),
        var(--bg);
      transform: translateZ(0);
    }

    a{color:inherit; text-decoration:none}
    .wrap{max-width:var(--max); margin:0 auto; padding:0 18px; width:100%;}
    main{padding:22px 0 42px}

    /* ====== Topbar ====== */
    .topbar{
      position:sticky;
      top:0;
      z-index:40;
      backdrop-filter: blur(14px);
      background: rgba(7,7,17,.62);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:12px 0;
      flex-wrap:wrap;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      min-width: 260px;
      user-select:none;
    }
    .brand img{
      width:40px; height:40px;
      object-fit:contain;
      filter: drop-shadow(0 10px 25px rgba(0,0,0,.45));
    }
    .bt{display:flex; flex-direction:column; line-height:1.05}
    .bt .t{font-weight:1000; letter-spacing:-.2px; font-size:16px}
    .bt .s{font-weight:850; color:var(--muted); font-size:12.5px}

    .actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
      width:100%;
    }
    @media (min-width: 980px){
      .actions{width:auto}
    }

    /* ====== Buttons ====== */
    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:9px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      font-weight:950;
      font-size:13px;
      transition: .15s ease;
      user-select:none;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      white-space:nowrap;
    }
    .btn:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .btn:active{transform: translateY(0px)}
    .btn.grad{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .btn.ghost{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.12);
    }
    .btn.danger{
      border:1px solid rgba(255,120,150,.35);
      background: rgba(255,120,150,.10);
      color: rgba(255,210,220,.95);
    }
    .btn[disabled]{opacity:.55; pointer-events:none}
    .btn:focus{outline:none}
    .btn:focus-visible{
      box-shadow: 0 0 0 3px var(--focusGlow);
      border-color: var(--focus);
    }

    /* ====== Cards / Panels ====== */
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.05));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .inner{padding:22px}
    .hero{
      position:relative;
      overflow:hidden;
      isolation:isolate;
    }
    .hero::before{
      content:"";
      position:absolute;
      inset:-70px -40px;
      background:
        radial-gradient(900px 520px at 18% 28%, rgba(20,241,149,.16), transparent 60%),
        radial-gradient(900px 520px at 82% 20%, rgba(0,209,255,.12), transparent 60%),
        radial-gradient(900px 520px at 70% 86%, rgba(153,69,255,.14), transparent 60%);
      z-index:0;
      pointer-events:none;
    }
    .hero > *{position:relative; z-index:1}

    .h1{
      margin:0;
      font-weight:1000;
      letter-spacing:-1px;
      line-height:1.05;
      font-size: clamp(34px, 4.6vw, 62px);
    }
    .gradText{
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;
    }
    .sub{
      margin-top:10px;
      color: rgba(255,255,255,.76);
      font-weight:850;
      max-width: 940px;
    }

    .classified{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .stamp{
      font-weight:1000;
      font-size:12px;
      letter-spacing: .45px;
      text-transform:uppercase;
      color: rgba(255,255,255,.76);
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius: 999px;
      padding:7px 10px;
    }

    .layout{
      margin-top:16px;
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:var(--gridGap);
      align-items:start;
    }
    @media (max-width: 980px){ .layout{grid-template-columns:1fr} }

    .analysisGrid{
      margin-top: var(--gridGap);
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap: var(--gridGap);
      align-items:start;
    }
    @media (max-width: 980px){ .analysisGrid{grid-template-columns:1fr} }

    .panel{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 18px;
      padding:16px;
      overflow:hidden;
    }

    .panelHead{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .panelTitle{
      font-weight:1000;
      letter-spacing:.35px;
      text-transform:uppercase;
      font-size:12px;
      color: rgba(255,255,255,.72);
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .panelSub{
      color: rgba(255,255,255,.62);
      font-weight:850;
      font-size:12.5px;
      line-height:1.35;
      margin-top:6px;
    }

    /* ====== Inputs ====== */
    label{
      display:block;
      font-weight:950;
      font-size:12.5px;
      letter-spacing:.35px;
      color: rgba(255,255,255,.82);
      margin-bottom:8px;
    }
    input, textarea, select{
      width:100%;
      padding:14px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.92);
      outline:none;
      font-weight:900;
      letter-spacing:.2px;
      font-size:16px;
      max-width:100%;
      font-family: var(--sans);
    }
    textarea{min-height: 120px; resize: vertical}
    input:focus, textarea:focus, select:focus{
      border-color: var(--focus);
      box-shadow: 0 0 0 3px var(--focusGlow);
    }

    .statusLine{
      margin-top:12px;
      color: rgba(255,255,255,.72);
      font-weight:900;
      min-height: 18px;
      font-size:13px;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .mono{
      font-family: var(--mono);
      font-weight:900;
      color: rgba(255,255,255,.86);
      margin-top:6px;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* ====== Badges / Pills ====== */
    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:7px 11px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
    }
    .badge.good{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}
    .badge.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .badge.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}

    .badge.src{border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.05); color: rgba(255,255,255,.84)}
    .badge.src.onchain{border-color: rgba(20,241,149,.26); background: var(--src-onchain);}
    .badge.src.indexer{border-color: rgba(0,209,255,.26); background: var(--src-indexer);}
    .badge.src.api{border-color: rgba(153,69,255,.26); background: var(--src-api);}
    .badge.src.heur{border-color: rgba(255,220,130,.26); background: var(--src-heur);}

    .pillRow{
      display:flex;
      gap:8px;
      align-items:center;
      flex:0 0 auto;
      justify-content:flex-end;
      flex-wrap:wrap;
    }
    .pill{
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor:pointer;
    }
    .pill.ok{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}
    .pill.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .pill.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}

    .infoBtn{
      width:26px; height:26px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.86);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      font-weight:1000;
      font-size:13px;
      line-height:1;
      -webkit-tap-highlight-color: transparent;
    }
    .infoBtn:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }
    .infoBtn:active{ transform: translateY(0px); }
    .infoBtn span{ transform: translateY(-0.5px); }

    .explorerBtn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .explorerBtn:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }

    /* ====== Results header ====== */
    .resultTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .resultTitle{
      margin:0;
      font-weight:1000;
      font-size:22px;
      letter-spacing:-.4px;
    }

    .tokenHead{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:10px;
      min-width:0;
    }
    .tokenLogoWrap{
      width:44px; height:44px;
      border-radius:12px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      display:flex;
      flex:0 0 auto;
      position:relative;
      align-items:center;
      justify-content:center;
    }
    .tokenLogoWrap img{
      width:100%; height:100%;
      object-fit:cover;
      display:block;
    }
    .identicon{ width:100%; height:100%; display:block; }

    .tokenName{
      font-weight:1000;
      font-size:16px;
      letter-spacing:-.2px;
      line-height:1.15;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .tokenSymbol{
      margin-top:2px;
      color: rgba(255,255,255,.70);
      font-weight:900;
      font-size:12.5px;
    }

    /* ====== Metric cards ====== */
    .metricStack{margin-top:12px; display:grid; gap:10px;}
    .metric{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      border-radius: 16px;
      padding:12px 12px;
    }
    .metricK{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      color: rgba(255,255,255,.70);
      font-weight:1000;
      font-size:12px;
      letter-spacing:.45px;
      text-transform:uppercase;
    }
    .metricV{
      margin-top:8px;
      font-weight:1000;
      font-size:20px;
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .metricMini{
      margin-top:6px;
      font-weight:850;
      font-size:12px;
      color: rgba(255,255,255,.62);
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .bar{
      margin-top:10px;
      height:12px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .bar > div{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      border-radius:999px;
      transition: width .25s ease;
    }

    /* ====== Lists ====== */
    .list{
      margin:10px 0 0;
      padding:0;
      list-style:none;
      display:grid;
      gap:10px;
    }
    .li{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      border-radius: 16px;
      padding:12px 12px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      min-width:0;
    }
    .li .left{min-width:0;}
    .li .t{font-weight:1000; font-size:13px; letter-spacing:.2px;}
    .li .d{
      margin-top:4px;
      color: rgba(255,255,255,.70);
      font-weight:750;
      font-size:12.5px;
      line-height:1.35;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* ====== Chain selection ====== */
    .chainRow{ margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; }
    .chainBtn{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      user-select:none;
      font-weight:1000;
      font-size:13px;
      color: rgba(255,255,255,.88);
      -webkit-tap-highlight-color: transparent;
    }
    .chainBtn:hover{ background: rgba(255,255,255,.10); }
    .chainBtn.active{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .chainBtn:focus-visible{
      outline:none;
      box-shadow: 0 0 0 3px var(--focusGlow);
    }
    .chainIcon{
      width:18px; height:18px;
      border-radius:6px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      flex:0 0 auto;
    }
    .chainIcon svg{ width:18px; height:18px; display:block; }
    .chainMiniHint{
      margin-top:10px;
      font-size:12.5px;
      color: rgba(255,255,255,.62);
      font-weight:850;
      line-height:1.35;
    }

    /* ====== Viz ====== */
    .vizWrap{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
      border-radius: 18px;
      overflow:hidden;
      position:relative;
    }
    .vizTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      padding:12px 12px 10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    .vizTitle{
      font-weight:1000;
      letter-spacing:.35px;
      text-transform:uppercase;
      font-size:12px;
      color: rgba(255,255,255,.72);
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .vizHint{
      color: rgba(255,255,255,.62);
      font-weight:850;
      font-size:12.5px;
      line-height:1.35;
      margin-top:6px;
      max-width: 560px;
    }
    .vizControls{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }
    .seg{
      display:inline-flex;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      border-radius: 999px;
      overflow:hidden;
    }
    .seg button{
      border:0;
      background:transparent;
      color: rgba(255,255,255,.82);
      font-weight:1000;
      font-size:12px;
      padding:8px 10px;
      cursor:pointer;
    }
    .seg button.active{
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.92);
    }
    .seg button[disabled]{ opacity:.45; cursor:not-allowed; }

    .vizStage{
      height: var(--vizH);
      position:relative;
      display:block;
      background:
        radial-gradient(900px 520px at 30% 30%, rgba(20,241,149,.08), transparent 60%),
        radial-gradient(900px 520px at 70% 20%, rgba(0,209,255,.06), transparent 60%),
        radial-gradient(900px 520px at 60% 85%, rgba(153,69,255,.06), transparent 60%),
        rgba(0,0,0,.10);
    }
    @media (max-width: 980px){
      .vizStage{ height: var(--vizH_m); }
    }
    canvas.vizCanvas{ width:100%; height:100%; display:block; }
    .vizOverlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
      text-align:center;
      color: rgba(255,255,255,.68);
      font-weight:900;
    }

    /* ====== Clusters ====== */
    .clusterGrid{ display:grid; grid-template-columns: 1fr; gap:10px; }
    .clusterCard{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      border-radius: 16px;
      padding:12px 12px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }
    .clusterLeft{min-width:0}
    .clusterT{
      font-weight:1000;
      font-size:13px;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .dot{
      width:10px;height:10px;border-radius:999px;
      background: rgba(255,255,255,.22);
      border:1px solid rgba(255,255,255,.12);
      flex:0 0 auto;
    }
    .dot.good{ background: rgba(20,241,149,.50); }
    .dot.warn{ background: rgba(255,220,130,.55); }
    .dot.bad{  background: rgba(255,120,150,.55); }

    .clusterD{
      margin-top:5px;
      color: rgba(255,255,255,.70);
      font-weight:750;
      font-size:12.5px;
      line-height:1.35;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .clusterRight{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end;
      flex:0 0 auto;
    }

    /* ====== Diagnostics ====== */
    .diagGrid{
      margin-top: 16px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--gridGap);
      align-items:start;
    }
    @media (max-width: 980px){ .diagGrid{grid-template-columns:1fr} }
    .kv{
      display:grid;
      grid-template-columns: 140px 1fr;
      gap:10px;
      align-items:start;
      font-size:12.5px;
      color: rgba(255,255,255,.72);
      font-weight:850;
    }
    .kv b{color: rgba(255,255,255,.90)}
    .kv .mono{margin:0; font-size:12px}

    /* ====== Footer ====== */
    footer{
      padding: 18px 0 34px;
      color: rgba(255,255,255,.45);
      font-weight:650;
      text-align:center;
      font-size:12px;
    }

    /* ====== Modal + Toast ====== */
    .modalWrap{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:100;
    }
    .modal{
      width:min(980px, 100%);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(7,7,17,.92);
      box-shadow: 0 16px 50px rgba(0,0,0,.5);
      overflow:hidden;
    }
    .modalHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .modalTitle{ font-weight:1000; letter-spacing:-.3px; }
    .modalBody{
      padding:14px 16px 16px;
      color: rgba(255,255,255,.84);
      font-weight:850;
      line-height:1.5;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .modalBody .field{
      display:grid;
      grid-template-columns: 1fr;
      gap:6px;
      margin:12px 0;
      padding:12px;
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      background: rgba(0,0,0,.12);
    }
    .modalBody .help{
      color: rgba(255,255,255,.66);
      font-weight:850;
      font-size:12.5px;
      line-height:1.35;
    }
    .modalActions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      margin-top:12px;
    }

    .toast{
      position:fixed;
      top: max(16px, env(safe-area-inset-top));
      left:50%;
      transform:translateX(-50%);
      width:min(980px, calc(100% - 28px));
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(7,7,17,.90);
      box-shadow: 0 16px 50px rgba(0,0,0,.45);
      padding:14px 14px;
      display:none;
      z-index:120;
      backdrop-filter: blur(12px);
    }
    .toastRow{display:flex; align-items:center; justify-content:space-between; gap:12px;}
    .toastTitle{font-weight:1000; font-size:16px; letter-spacing:-.2px;}
    .toastClose{
      padding:9px 12px;
      border-radius:999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      font-weight:950;
      cursor:pointer;
    }
    .toastClose:hover{background: rgba(255,255,255,.10);}

    /* ====== Key Signals cards ====== */
    .signalCard{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      border-radius: 16px;
      padding:12px 12px;
    }
    .signalTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .signalK{
      font-weight:1000;
      letter-spacing:.45px;
      text-transform:uppercase;
      font-size:12px;
      color: rgba(255,255,255,.72);
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .signalV{
      margin-top:8px;
      font-weight:1000;
      font-size:18px;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .signalMini{
      margin-top:6px;
      font-weight:850;
      font-size:12px;
      color: rgba(255,255,255,.62);
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* ====== Responsive tightening ====== */
    @media (max-width: 980px){
      .wrap{ padding: 0 14px; }
      .inner{ padding: 16px; }
      .panel{ padding: 14px; }
      .brand{ min-width: 0; width: 100%; }
      .actions{ width: 100%; justify-content: flex-start; }
      .actions .btn{ width: 100%; justify-content: center; padding: 12px 14px; font-size: 14px; }
      .resultTop{ flex-direction: column; align-items: stretch; }
      .resultTop > div:last-child{ width: 100%; justify-content: flex-start; }
      .resultTop .badge{ width: fit-content; }
      .tokenHead{ flex-wrap: nowrap; }
      .tokenName{ font-size: 18px; }
      .tokenSymbol{ font-size: 13px; }
      .metricV{ flex-direction: column; align-items: flex-start; gap: 6px; font-size: 22px; }
      .metricK{ flex-wrap: wrap; gap: 8px; }
      .metricK .badge{ margin-left: auto; }
      .li{ flex-direction: column; align-items: flex-start; gap: 10px; }
      .pillRow{ width:100%; justify-content:flex-start; flex-wrap:wrap; }
      .modal{ width:100%; }
      .toast{ left:14px; right:14px; transform:none; width:auto; }
      .kv{grid-template-columns: 1fr; gap:6px}
    }

    @media (prefers-reduced-motion: reduce){
      .btn:hover{transform:none}
      .bar > div{transition:none}
      .infoBtn:hover{transform:none}
      .explorerBtn:hover{transform:none}
    }
  </style>
</head>

<body>
  <!-- Toast -->
  <div class="toast" id="toast">
    <div class="toastRow">
      <div class="toastTitle" id="toastTitle">—</div>
      <button class="toastClose" id="toastClose" type="button">Close</button>
    </div>
  </div>

  <div class="topbar">
    <div class="wrap">
      <div class="row">
        <div class="brand">
          <img id="brandLogo" src="assets/logo.png" alt="$SOS" onerror="this.style.display='none'">
          <div class="bt">
            <div class="t">$SOS</div>
            <div class="s">Guardian Scanner • Multi-Chain • Clusters</div>
          </div>
        </div>

        <div class="actions">
          <a class="btn" href="https://solanax1.com/" rel="noreferrer">← Back to Main</a>
          <button class="btn ghost" id="btnSettings" type="button">Settings</button>
          <button class="btn ghost" id="btnKeys" type="button">API Keys</button>
          <button class="btn grad" id="btnScan" type="button">Run Guardian Check</button>
          <button class="btn grad" id="btnExport" type="button" disabled>Download Scan Report</button>
        </div>
      </div>
    </div>
  </div>

  <main class="wrap">
    <section class="card hero">
      <div class="inner">
        <div class="classified">
          <div class="stamp">GUARDIAN SYSTEM • MAINNET • BEST-EFFORT VERIFIED</div>
          <div class="stamp" id="stampTime">—</div>
        </div>

        <h1 class="h1" style="margin-top:12px;">
          <span class="gradText">Guardian Contract</span> Scanner
        </h1>

        <div class="sub">
          Multi-chain scan: Solana + ETH + BNB + Base — now with
          <span class="gradText">clusters</span>, <span class="gradText">bubble map</span>, and <span class="gradText">linked wallets</span> (best-effort).
        </div>

        <div class="layout">
          <!-- INPUT -->
          <div class="panel">
            <div class="panelHead">
              <div>
                <div class="panelTitle">Scan Input</div>
                <div class="panelSub">Paste token address. Auto-validate per chain. Tip: press Enter to scan.</div>
              </div>
              <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
                <span class="badge" id="netStamp">—</span>
                <span class="badge" id="engineStamp">ENGINE: —</span>
              </div>
            </div>

            <label>Choose Chain</label>
            <div class="chainRow" id="chainRow"></div>
            <div class="chainMiniHint" id="chainHint">—</div>

            <label for="mint" style="margin-top:14px;" id="addrLabel">Token Address</label>
            <input id="mint" placeholder="Paste token address..." autocomplete="off" spellcheck="false" inputmode="text" />

            <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;">
              <button class="btn grad" id="btnScanInline" type="button" style="flex:1 1 220px;">Run Guardian Check</button>
              <button class="btn" id="btnPaste" type="button" style="flex:0 0 auto;">Paste</button>
              <button class="btn" id="btnClear" type="button" style="flex:0 0 auto;">Clear</button>
              <button class="btn" id="btnCopyAddr" type="button" style="flex:0 0 auto;">Copy</button>
            </div>

            <div class="statusLine" id="status"></div>

            <div class="panel" style="margin-top:14px; background:rgba(0,0,0,.12)">
              <div class="panelHead" style="margin-bottom:8px">
                <div>
                  <div class="panelTitle">Network Health</div>
                  <div class="panelSub">Live connectivity checks (RPC / APIs). Helps diagnose “no holders / endless loading”.</div>
                </div>
                <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
                  <button class="btn" id="btnDiag" type="button">Run Diagnostics</button>
                </div>
              </div>

              <div class="kv">
                <div>Solana RPC</div><div><b id="diagSol">—</b> <span class="mono" id="diagSolUrl"></span></div>
                <div>EVM RPC</div><div><b id="diagEvm">—</b> <span class="mono" id="diagEvmUrl"></span></div>
                <div>Dexscreener</div><div><b id="diagDex">—</b> <span class="mono" id="diagDexUrl"></span></div>
                <div>GoldRush</div><div><b id="diagGold">—</b> <span class="mono" id="diagGoldUrl"></span></div>
              </div>

              <div class="statusLine" id="diagNote" style="margin-top:10px;">—</div>
            </div>
          </div>

          <!-- RESULTS -->
          <div class="panel" id="resultsPanel">
            <div class="resultTop">
              <div style="min-width:0">
                <div class="tokenHead">
                  <div class="tokenLogoWrap" id="tokenLogoWrap" aria-hidden="false">
                    <img id="tokenLogo" alt="" style="display:none">
                    <svg class="identicon" id="tokenIdenticon" viewBox="0 0 44 44" aria-hidden="true"></svg>
                  </div>
                  <div style="min-width:0">
                    <div class="tokenName" id="tokenName">—</div>
                    <div class="tokenSymbol" id="tokenSymbol">—</div>
                  </div>
                </div>

                <h3 class="resultTitle" id="verdictTitle">—</h3>
                <div class="mono" id="mintShort">—</div>
              </div>

              <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                <span class="badge" id="verdictBadge">—</span>
                <span class="badge good" id="scoreBadge">—</span>
              </div>
            </div>

            <div class="metricStack" id="metrics"></div>
            <div class="statusLine" id="summary">—</div>

            <!-- KEY SIGNALS -->
            <div class="metricStack" id="keySignals"></div>
          </div>
        </div>

        <div class="analysisGrid">
          <!-- Bubble Map / Graph -->
          <div class="panel" id="vizPanel">
            <div class="panelHead">
              <div>
                <div class="panelTitle">
                  <span class="badge">LIVE</span>
                  Bubble Map • Wallet Graph
                </div>
                <div class="panelSub" id="vizSub">
                  Shows holder bubbles + linked wallet edges (best-effort). Run a scan to populate.
                </div>
              </div>

              <div class="vizControls">
                <div class="seg" role="tablist" aria-label="Visualization mode">
                  <button type="button" id="vizModeBubbles" class="active" aria-selected="true">Bubbles</button>
                  <button type="button" id="vizModeGraph" aria-selected="false" disabled>Graph</button>
                </div>
                <button class="btn" id="btnVizReset" type="button">Reset View</button>
              </div>
            </div>

            <div class="vizWrap">
              <div class="vizTop">
                <div style="min-width:0">
                  <div class="vizTitle">Holders & Clusters (Live)</div>
                  <div class="vizHint" id="vizHint">
                    Tip: Hover for wallet info. Click to open explorer. Zoom with trackpad/wheel.
                  </div>
                </div>
                <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end;">
                  <span class="badge" id="vizStamp">—</span>
                  <span class="badge" id="vizLegend">—</span>
                </div>
              </div>

              <div class="vizStage" id="vizStage">
                <canvas class="vizCanvas" id="vizCanvas"></canvas>
                <div class="vizOverlay" id="vizOverlay">
                  No visualization data yet. Run a scan.
                </div>
              </div>
            </div>
          </div>

          <!-- Cluster Summary -->
          <div class="panel" id="clusterPanel">
            <div class="panelHead">
              <div>
                <div class="panelTitle">
                  <span class="badge">NEW</span>
                  Cluster Intelligence
                </div>
                <div class="panelSub" id="clusterSub">
                  Detects linked wallets, split-wallet patterns, shared funders (best-effort).
                </div>
              </div>
              <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
                <span class="badge" id="clusterStamp">—</span>
              </div>
            </div>

            <div class="clusterGrid" id="clusterGrid">
              <div class="clusterCard">
                <div class="clusterLeft">
                  <div class="clusterT"><span class="dot warn"></span> No scan yet</div>
                  <div class="clusterD">Run a scan to generate cluster groups, linked wallets, and bundle/split heuristics.</div>
                </div>
                <div class="clusterRight">
                  <span class="badge warn">WAIT</span>
                </div>
              </div>
            </div>

            <div class="statusLine" id="clusterFoot" style="margin-top:12px;">—</div>
          </div>
        </div>

        <!-- Checks -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">GUARDIAN CHECKS</div>
            <div class="stamp" id="scanHint">—</div>
          </div>
          <ul class="list" id="checksList" style="margin-top:10px;"></ul>
        </div>

        <!-- Launch readiness -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">LAUNCH READINESS</div>
            <div class="stamp">ACTION LIST</div>
          </div>
          <ul class="list" id="todoList" style="margin-top:10px;"></ul>
        </div>

        <!-- Token standard details -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOKEN STANDARD DETAILS</div>
            <div class="stamp">ON-CHAIN</div>
          </div>
          <ul class="list" id="extList" style="margin-top:10px;"></ul>
        </div>

        <!-- Metadata -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOKEN METADATA</div>
            <div class="stamp">RPC / ON-CHAIN</div>
          </div>
          <ul class="list" id="metaList" style="margin-top:10px;"></ul>
        </div>

        <!-- Top holders -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOP HOLDERS (PREVIEW)</div>
            <div class="stamp" id="holdersStamp">MAINNET</div>
          </div>
          <ul class="list" id="holdersList" style="margin-top:10px;"></ul>
        </div>

        <!-- Diagnostics (expanded, premium) -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">DIAGNOSTICS</div>
            <div class="stamp">ANTI-DOWN / FAILOVER</div>
          </div>

          <div class="diagGrid" style="margin-top:12px;">
            <div class="panel" style="background:rgba(0,0,0,.12)">
              <div class="panelTitle">Runtime</div>
              <div class="panelSub">Client-only scanner (no backend). If providers rate-limit, you’ll see it here.</div>
              <div class="kv" style="margin-top:10px">
                <div>Build</div><div><b id="diagBuild">—</b></div>
                <div>Chain</div><div><b id="diagChain">—</b></div>
                <div>Address</div><div class="mono" id="diagAddr">—</div>
                <div>Engine</div><div><b id="diagEngine">—</b></div>
                <div>Requests</div><div><b id="diagReq">—</b></div>
              </div>
            </div>

            <div class="panel" style="background:rgba(0,0,0,.12)">
              <div class="panelTitle">Provider Failover</div>
              <div class="panelSub">We auto-rotate endpoints + backoff on 429/5xx to prevent “forever loading”.</div>
              <div class="kv" style="margin-top:10px">
                <div>Solana RPC</div><div class="mono" id="diagSolList">—</div>
                <div>EVM RPC</div><div class="mono" id="diagEvmList">—</div>
                <div>Timeout</div><div><b id="diagTimeout">—</b></div>
                <div>Retries</div><div><b id="diagRetry">—</b></div>
              </div>
            </div>
          </div>

          <div class="statusLine" id="diagFoot" style="margin-top:12px;">
            Tip: If ETH/BNB “no holders” → add GoldRush key OR switch to a backend. This UI shows exactly what is missing.
          </div>
        </div>

      </div>
    </section>

    <footer>© <span id="y"></span> $SOS • Guardian Check</footer>
  </main>

  <!-- Modal -->
  <div class="modalWrap" id="modalWrap" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle" id="modalTitle">Guardian Details</div>
        <button class="btn" id="modalClose" type="button">Close</button>
      </div>
      <div class="modalBody" id="modalBody"></div>
    </div>
  </div>

  <script>
  /* ============================================================
     PART 1 JS — Premium Framework + UI + Safe Networking Core
     Engines + scan logic continue in PART 2+
  ============================================================ */

  /* ===== DOM helpers ===== */
  const qs = (id) => document.getElementById(id);
  const setText = (id, v) => { const el = qs(id); if(el) el.textContent = (v ?? ""); };
  const setHTML = (id, v) => { const el = qs(id); if(el) el.innerHTML = (v ?? ""); };
  const on = (id, ev, fn) => { const el = qs(id); if(el) el.addEventListener(ev, fn); };

  const esc = (x) => String(x ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;");

  function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }
  function shortAddr(a){ return a ? (a.slice(0,4) + "…" + a.slice(-4)) : "—"; }

  function fmtInt(n){
    if(n === null || n === undefined || Number.isNaN(n)) return "—";
    try { return new Intl.NumberFormat("en-US").format(Math.round(Number(n))); }
    catch { return String(n); }
  }
  function fmtPct(n){
    if(n === null || n === undefined || Number.isNaN(n)) return "—";
    return `${Number(n).toFixed(2)}%`;
  }

  function formatUsd(n){
    const x = Number(n);
    if(!Number.isFinite(x)) return "—";
    if(x >= 1e9) return (x/1e9).toFixed(2) + "B";
    if(x >= 1e6) return (x/1e6).toFixed(2) + "M";
    if(x >= 1e3) return (x/1e3).toFixed(2) + "K";
    return x.toFixed(2);
  }

  /* ===== App State ===== */
  const BUILD_ID = "premium-v1.0-part1";
  const APP = {
    ACTIVE_CHAIN_ID: "sol",
    SCANNING: false,
    LAST_SCAN: null,
    ABORT: null,
    CACHE: new Map(),
    INFO_MAP: new Map(),
    BRAND_LOGO_DATAURL: "",
    REQUESTS: { total:0, ok:0, fail:0, lastErr:"" },
    ENGINE_READY: false, // will flip true once PART 2+ injected
  };

  /* ===== Engine registry (PART 2+ fills these) ===== */
  const ENGINES = {
    // required (PART 2+ will implement)
    scanSolana: null,
    scanEvm: null,

    // optional
    runDiagnostics: null,
    exportReport: null,
    initViz: null,
  };

  /* ===== Icons ===== */
  const ICONS = {
    sol: `
      <svg viewBox="0 0 64 64" aria-hidden="true">
        <defs>
          <linearGradient id="solg" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="${getComputedStyle(document.documentElement).getPropertyValue('--sol-g1').trim() || '#14F195'}"/>
            <stop offset="0.5" stop-color="${getComputedStyle(document.documentElement).getPropertyValue('--sol-g2').trim() || '#00D1FF'}"/>
            <stop offset="1" stop-color="${getComputedStyle(document.documentElement).getPropertyValue('--sol-g3').trim() || '#9945FF'}"/>
          </linearGradient>
        </defs>
        <path d="M14 18c1.6-1.8 3.5-2.7 5.7-2.7h33.6c3.3 0 5 4 2.8 6.5l-6.1 6.8c-1.6 1.8-3.5 2.7-5.7 2.7H10.7c-3.3 0-5-4-2.8-6.5L14 18Z" fill="url(#solg)"/>
        <path d="M14 38.9c1.6-1.8 3.5-2.7 5.7-2.7h33.6c3.3 0 5 4 2.8 6.5l-6.1 6.8c-1.6 1.8-3.5 2.7-5.7 2.7H10.7c-3.3 0-5-4-2.8-6.5L14 38.9Z" fill="url(#solg)" opacity=".7"/>
        <path d="M50 28.5c-1.6 1.8-3.5 2.7-5.7 2.7H10.7c-3.3 0-5-4-2.8-6.5L14 17.9c1.6-1.8 3.5-2.7 5.7-2.7h33.6c3.3 0 5 4 2.8 6.5L50 28.5Z" fill="url(#solg)" opacity=".9"/>
      </svg>
    `,
    eth: `
      <svg viewBox="0 0 64 64" aria-hidden="true">
        <path d="M32 6l16 26-16 9-16-9L32 6Z" fill="currentColor" opacity=".95"/>
        <path d="M32 58l16-22-16 9-16-9 16 22Z" fill="currentColor" opacity=".75"/>
      </svg>
    `,
    bnb: `
      <svg viewBox="0 0 64 64" aria-hidden="true">
        <path fill="${getComputedStyle(document.documentElement).getPropertyValue('--bnb-yellow').trim() || '#F0B90B'}"
          d="M32 6l8.6 8.6L32 23.2l-8.6-8.6L32 6Zm15.4 15.4L56 30l-8.6 8.6-8.6-8.6L47.4 21.4ZM16.6 21.4 25.2 30l-8.6 8.6L8 30l8.6-8.6ZM32 32.8l8.6 8.6L32 50l-8.6-8.6L32 32.8Zm0-6.9 5.1 5.1L32 36.2 26.9 31 32 25.9Z"/>
      </svg>
    `,
    base: `
      <svg viewBox="0 0 64 64" aria-hidden="true">
        <circle cx="32" cy="32" r="26" fill="${getComputedStyle(document.documentElement).getPropertyValue('--base-blue').trim() || '#0052FF'}"/>
        <path d="M27.5 22h8.1c6.2 0 11.2 5 11.2 11.1S41.8 44.2 35.6 44.2h-8.1V22Zm5.3 5.1v12h2.4c3.3 0 6-2.7 6-6s-2.7-6-6-6h-2.4Z"
              fill="#fff"/>
      </svg>
    `
  };

  /* ===== Chains ===== */
  const CHAINS = [
    { id:"sol",  name:"Solana",   kind:"solana", stamp:"SOL MAINNET",  addrLabel:"Token Mint Address",        placeholder:"Paste token mint (Solana)..." },
    { id:"eth",  name:"Ethereum", kind:"evm",    stamp:"ETH MAINNET",  addrLabel:"Token Contract Address",    placeholder:"Paste ERC-20 contract (0x...)" },
    { id:"bnb",  name:"BNB",      kind:"evm",    stamp:"BNB MAINNET",  addrLabel:"Token Contract Address",    placeholder:"Paste BEP-20 contract (0x...)" },
    { id:"base", name:"Base",     kind:"evm",    stamp:"BASE MAINNET", addrLabel:"Token Contract Address",    placeholder:"Paste Base token contract (0x...)" }
  ];
  function chainObj(){ return CHAINS.find(c => c.id === APP.ACTIVE_CHAIN_ID) || CHAINS[0]; }

  /* ===== Local config (Settings + Keys) ===== */
  const CFG_DEFAULT = {
    // you had these keys in your original (keeping them as defaults for now)
    HELIUS_KEY: "b566a086-57d4-4433-8661-faed9ad07ba0",
    GOLDRUSH_API_KEY: "cqt_rQVTMTXwYkPJBrwf7ff6JWmdkywR",

    // request behavior
    TIMEOUT_MS: 18000,
    RETRIES: 2,
    RETRY_BACKOFF_MS: 650,

    // provider lists (failover order)
    SOL_RPC_FALLBACKS: [
      "https://api.mainnet-beta.solana.com",
      "https://rpc.ankr.com/solana"
    ],
    EVM_RPCS: {
      1:    ["https://ethereum.publicnode.com", "https://rpc.ankr.com/eth", "https://cloudflare-eth.com"],
      56:   ["https://bsc.publicnode.com", "https://rpc.ankr.com/bsc", "https://bsc-dataseed.binance.org"],
      8453: ["https://base.publicnode.com", "https://mainnet.base.org", "https://rpc.ankr.com/base"]
    },

    // analysis tuning
    HOLDER_COUNT: 10,
    GRAPH_EDGE_LIMIT: 90,
    CLUSTER_LIMIT: 10,

    // UX toggles
    AUTO_LABEL_LP: true,
    ENABLE_DEXSCREENER: true,
    ENABLE_TRUSTWALLET_LOGO_FALLBACK: true,
    ENABLE_VERBOSE_DIAG: false,
  };

  const STORAGE_KEY = "sos_guardian_cfg_premium_v1";
  const CFG = loadCfg();

  function loadCfg(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return structuredClone(CFG_DEFAULT);
      const j = JSON.parse(raw);
      const merged = {
        ...structuredClone(CFG_DEFAULT),
        ...j,
        EVM_RPCS: { ...structuredClone(CFG_DEFAULT.EVM_RPCS), ...(j?.EVM_RPCS || {}) },
        SOL_RPC_FALLBACKS: Array.isArray(j?.SOL_RPC_FALLBACKS) ? j.SOL_RPC_FALLBACKS : structuredClone(CFG_DEFAULT.SOL_RPC_FALLBACKS),
      };
      return merged;
    }catch{
      return structuredClone(CFG_DEFAULT);
    }
  }
  function saveCfg(){
    try{
      localStorage.setItem(STORAGE_KEY, JSON.stringify(CFG));
      showToast("Saved settings locally.");
    }catch{
      showToast("Failed to save settings (storage blocked).");
    }
  }
  function resetCfg(){
    try{
      localStorage.removeItem(STORAGE_KEY);
    }catch{}
    Object.assign(CFG, structuredClone(CFG_DEFAULT));
    showToast("Settings reset to defaults.");
  }

  /* ===== Time stamp (Berlin) ===== */
  let STAMP_TIMER = null;
  function updateStampTime(){
    const now = new Date();
    setText("stampTime",
      new Intl.DateTimeFormat("de-DE",{
        timeZone:"Europe/Berlin",
        year:"numeric", month:"2-digit", day:"2-digit",
        hour:"2-digit", minute:"2-digit", second:"2-digit"
      }).format(now)
    );
  }
  function startLiveStampTime(){
    if(STAMP_TIMER) clearInterval(STAMP_TIMER);
    updateStampTime();
    STAMP_TIMER = setInterval(updateStampTime, 1000);
  }

  /* ===== Toast + Modal ===== */
  function showToast(title){
    const t = qs("toast");
    if(!t) return;
    setText("toastTitle", title || "");
    t.style.display = "block";
  }
  function hideToast(){
    const t = qs("toast");
    if(!t) return;
    t.style.display = "none";
  }
  function openModal(title, bodyHtml){
    setText("modalTitle", title || "Guardian Details");
    setHTML("modalBody", bodyHtml || "");
    const w = qs("modalWrap");
    if(w){ w.style.display = "flex"; w.setAttribute("aria-hidden","false"); }
  }
  function closeModal(){
    const w = qs("modalWrap");
    if(w){ w.style.display = "none"; w.setAttribute("aria-hidden","true"); }
  }

  /* ===== Info registry (click any pill/info for details) ===== */
  function newInfoId(){ return "i_" + Math.random().toString(36).slice(2) + Date.now().toString(36); }
  function registerInfo(html){ const id = newInfoId(); APP.INFO_MAP.set(id, html); return id; }
  function getInfo(id){ return APP.INFO_MAP.get(id) || ""; }

  function explain(title, bullets){
    const body = (bullets||[]).map(b => `<div style="margin:6px 0">${esc(b)}</div>`).join("");
    return `
      <div style="font-weight:1000; font-size:18px; margin-bottom:10px">${esc(title)}</div>
      <div style="color:rgba(255,255,255,.72); font-weight:850; line-height:1.55">${body}</div>
    `;
  }

  // global click handler
  (function wireInfoClicks(){
    document.addEventListener("click", (e) => {
      const t = e.target;
      const openEl = t?.closest?.("[data-open='1']");
      if(openEl){
        const title = openEl.getAttribute("data-title") || "Details";
        const infoId = openEl.getAttribute("data-info") || "";
        const html = getInfo(infoId);
        if(html) openModal(title, html);
      }
    });
    document.addEventListener("keydown", (e) => {
      if(e.key !== "Enter" && e.key !== " ") return;
      const a = document.activeElement;
      if(a && a.matches && a.matches("[data-open='1']")){
        e.preventDefault();
        const title = a.getAttribute("data-title") || "Details";
        const infoId = a.getAttribute("data-info") || "";
        const html = getInfo(infoId);
        if(html) openModal(title, html);
      }
    });
  })();

  /* ===== Validation helpers ===== */
  function looksBase58(s){
    return typeof s === "string" && s.length >= 32 && s.length <= 52 && /^[1-9A-HJ-NP-Za-km-z]+$/.test(s);
  }
  function looksEvmAddress(s){
    return typeof s === "string" && /^0x[0-9a-fA-F]{40}$/.test(s.trim());
  }

  /* ===== Explorers ===== */
  function explorerBase(chainId){
    if(chainId === "sol")  return {name:"Solscan", base:"https://solscan.io/account/"};
    if(chainId === "eth")  return {name:"Etherscan", base:"https://etherscan.io/address/"};
    if(chainId === "bnb")  return {name:"BscScan", base:"https://bscscan.com/address/"};
    if(chainId === "base") return {name:"BaseScan", base:"https://basescan.org/address/"};
    return {name:"Explorer", base:"#"};
  }

  /* ===== UI: chain buttons ===== */
  function renderChainButtons(){
    const row = qs("chainRow");
    if(!row) return;
    row.innerHTML = "";
    for(const c of CHAINS){
      const b = document.createElement("button");
      b.type = "button";
      b.className = "chainBtn" + (c.id === APP.ACTIVE_CHAIN_ID ? " active" : "");
      b.innerHTML = `<span class="chainIcon">${ICONS[c.id] || ""}</span><span>${esc(c.name)}</span>`;
      b.addEventListener("click", () => setActiveChain(c.id, true));
      row.appendChild(b);
    }
  }

  function setActiveChain(chainId, pushUrl){
    const found = CHAINS.find(x => x.id === chainId) || CHAINS[0];
    APP.ACTIVE_CHAIN_ID = found.id;

    renderChainButtons();
    setText("holdersStamp", found.stamp || "MAINNET");
    setText("clusterStamp", found.stamp || "MAINNET");
    setText("scanHint", found.stamp || "MAINNET");
    setText("addrLabel", found.addrLabel || "Token Address");
    setText("netStamp", found.stamp || "MAINNET");
    setText("diagChain", found.name || "—");

    const mint = qs("mint");
    if(mint) mint.placeholder = found.placeholder || "Paste token address...";

    setText("chainHint",
      found.kind === "solana"
        ? "Solana: validates base58 mint. On-chain checks via RPC; holders via largest accounts."
        : "EVM: validates 0x address. On-chain reads via public RPC. Holders/Transfers need an indexer key (GoldRush) for best results."
    );

    // update URL param
    if(pushUrl){
      const url = new URL(location.href);
      url.searchParams.set("chain", found.id);
      history.replaceState({}, "", url.toString());
    }

    // reset UI content
    resetUiForNewChain();
  }

  function resetUiForNewChain(){
    setText("status", "");
    setText("mintShort", "—");
    setText("verdictTitle", "—");
    setText("verdictBadge", "—");
    setText("scoreBadge", "—");
    setText("summary", "Run a scan to generate a full Guardian report.");
    setText("vizStamp", "—");
    setText("vizLegend", "—");
    setText("vizSub", "Shows holder bubbles + linked wallet edges (best-effort). Run a scan to populate.");
    setText("clusterFoot", "—");
    setText("engineStamp", APP.ENGINE_READY ? "ENGINE: READY" : "ENGINE: LOADING…");

    // clear sections
    const idsToClear = ["metrics","checksList","todoList","extList","metaList","holdersList","keySignals"];
    for(const id of idsToClear){
      const el = qs(id);
      if(el) el.innerHTML = "";
    }

    // reset token header
    applyTokenHeader({name:"—", symbol:"—", image:""}, "");

    // viz overlay
    const overlay = qs("vizOverlay");
    if(overlay){
      overlay.style.display = "flex";
      overlay.textContent = "No visualization data yet. Run a scan.";
    }

    // clusters default card
    const grid = qs("clusterGrid");
    if(grid){
      grid.innerHTML = `
        <div class="clusterCard">
          <div class="clusterLeft">
            <div class="clusterT"><span class="dot warn"></span> No scan yet</div>
            <div class="clusterD">Run a scan to generate cluster groups, linked wallets, and bundle/split heuristics.</div>
          </div>
          <div class="clusterRight"><span class="badge warn">WAIT</span></div>
        </div>
      `;
    }

    // export disabled
    const exBtn = qs("btnExport");
    if(exBtn) exBtn.disabled = true;

    // diagnostics clear
    setText("diagAddr","—");
    setText("diagEngine", APP.ENGINE_READY ? "READY" : "LOADING");
    setText("diagReq", `${APP.REQUESTS.total} total • ${APP.REQUESTS.ok} ok • ${APP.REQUESTS.fail} fail`);
    setText("diagFoot","Tip: If ETH/BNB “no holders” → add GoldRush key OR switch to a backend. This UI shows exactly what is missing.");
  }

  /* ===== Token header (logo + identicon fallback) ===== */
  function hash32(str){
    let h = 2166136261 >>> 0;
    const s = String(str || "");
    for(let i=0;i<s.length;i++){
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619) >>> 0;
    }
    return h >>> 0;
  }
  function identiconSvg(el, seed){
    if(!el) return;
    const h = hash32(seed || "—");
    const c1 = `hsl(${(h % 360)}, 90%, 55%)`;
    const c2 = `hsl(${((h>>>8) % 360)}, 90%, 45%)`;
    const c3 = `hsl(${((h>>>16) % 360)}, 90%, 60%)`;
    const size = 44;
    const cell = 44 / 5;
    let bits = h ^ (h>>>13) ^ (h>>>7);

    let rects = "";
    for(let y=0;y<5;y++){
      for(let x=0;x<3;x++){
        const on = (bits & 1) === 1;
        bits = (bits >>> 1) | (bits << 31);
        if(on){
          const xx = x * cell;
          const yy = y * cell;
          const fill = ((x+y)%3===0?c1:((x+y)%3===1?c2:c3));
          rects += `<rect x="${xx}" y="${yy}" width="${cell}" height="${cell}" rx="4" fill="${fill}" opacity="0.95"/>`;
          const mx = (4-x) * cell;
          rects += `<rect x="${mx}" y="${yy}" width="${cell}" height="${cell}" rx="4" fill="${fill}" opacity="0.95"/>`;
        }
      }
    }

    el.innerHTML = `
      <defs>
        <linearGradient id="ig" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0" stop-color="${c1}" stop-opacity="0.65"/>
          <stop offset="1" stop-color="${c3}" stop-opacity="0.20"/>
        </linearGradient>
      </defs>
      <rect x="0" y="0" width="${size}" height="${size}" rx="12" fill="rgba(0,0,0,.12)" />
      <rect x="0" y="0" width="${size}" height="${size}" rx="12" fill="url(#ig)" />
      <g>${rects}</g>
    `;
  }

  function applyTokenHeader(meta, addr){
    const nameEl = qs("tokenName");
    const symEl  = qs("tokenSymbol");
    const img    = qs("tokenLogo");
    const ico    = qs("tokenIdenticon");

    const name = (meta?.name || "Token").trim() || "Token";
    const sym  = (meta?.symbol || "").trim();

    if(nameEl) nameEl.textContent = name;
    if(symEl)  symEl.textContent  = sym ? `$${sym}` : (addr ? `Addr: ${shortAddr(addr)}` : "—");

    if(img && ico){
      const hasImg = !!(meta?.image && String(meta.image).trim());
      if(hasImg){
        img.style.display = "block";
        img.src = meta.image;
        img.alt = name;
        ico.style.display = "none";
        img.onerror = () => {
          img.style.display = "none";
          ico.style.display = "block";
          identiconSvg(ico, addr || name);
        };
      }else{
        img.removeAttribute("src");
        img.alt = "";
        img.style.display = "none";
        ico.style.display = "block";
        identiconSvg(ico, addr || name);
      }
    }
  }

  /* ===== Rendering helpers ===== */
  function pillLabel(sev){ return sev==="ok" ? "PASS" : sev==="bad" ? "FAIL" : "WATCH"; }
  function pillClass(sev){ return sev==="ok" ? "pill ok" : sev==="bad" ? "pill bad" : "pill warn"; }

  function renderList(listEl, items, defaultTitle){
    if(!listEl) return;
    listEl.innerHTML = "";
    const arr = Array.isArray(items) ? items : [];

    for(const it of arr){
      const sev = it.sev || "warn";
      const title = it.t || defaultTitle || "Details";
      const desc = it.d || "—";
      const infoTitle = it.infoTitle || title;

      const html = (it.infoHtml && String(it.infoHtml).trim())
        ? String(it.infoHtml)
        : explain(infoTitle, [
            desc,
            it.why ? ("Why: " + it.why) : "Why: best-effort.",
            it.fix ? ("Fix: " + it.fix) : "Fix: —",
            "Status: " + pillLabel(sev)
          ]);

      const infoId = registerInfo(html);

      const li = document.createElement("li");
      li.className = "li";
      li.innerHTML = `
        <div class="left">
          <div class="t">${esc(title)}</div>
          <div class="d">${esc(desc)}</div>
        </div>
        <div class="pillRow">
          <span class="${pillClass(sev)}" role="button" tabindex="0"
                data-open="1" data-title="${esc(infoTitle)}" data-info="${esc(infoId)}">${pillLabel(sev)}</span>
          <button class="infoBtn" type="button" aria-label="Info"
                  data-open="1" data-title="${esc(infoTitle)}" data-info="${esc(infoId)}"><span>i</span></button>
        </div>
      `;
      listEl.appendChild(li);
    }

    if(!arr.length){
      const li = document.createElement("li");
      li.className = "li";
      li.innerHTML = `
        <div class="left">
          <div class="t">${esc(defaultTitle || "No data")}</div>
          <div class="d">—</div>
        </div>
        <div class="pillRow"><span class="pill warn">WAIT</span></div>
      `;
      listEl.appendChild(li);
    }
  }

  function renderMetrics(rows){
    const wrap = qs("metrics");
    if(!wrap) return;
    wrap.innerHTML = "";

    const arr = Array.isArray(rows) ? rows : [];
    for(const r of arr){
      const d = document.createElement("div");
      d.className = "metric";
      const bar = (typeof r.barPct === "number")
        ? `<div class="bar"><div style="width:${clamp(r.barPct,0,100)}%"></div></div>`
        : "";
      d.innerHTML = `
        <div class="metricK">
          <span>${esc(r.label || "—")}</span>
          <span class="badge" style="opacity:.9">${esc(r.badge || r.value || "—")}</span>
        </div>
        <div class="metricV">${esc(r.value || "—")}</div>
        <div class="metricMini">${esc(r.mini || "")}</div>
        ${bar}
      `;
      wrap.appendChild(d);
    }
  }

  function srcBadge(src){
    const s = String(src || "heur").toLowerCase();
    const cls =
      s.includes("on") ? "onchain" :
      s.includes("index") ? "indexer" :
      s.includes("api") ? "api" : "heur";
    const label =
      cls === "onchain" ? "On-chain verified" :
      cls === "indexer" ? "Indexer required" :
      cls === "api" ? "API signal" : "Heuristic";
    return `<span class="badge src ${cls}">${esc(label)}</span>`;
  }
  function sevToBadge(sev){
    const ok = sev === "ok";
    const bad = sev === "bad";
    const cls = ok ? "badge good" : bad ? "badge bad" : "badge warn";
    const icon = ok ? "↑" : bad ? "↓" : "→";
    const label = ok ? "YES" : bad ? "NO" : "UNKNOWN";
    return `<span class="${cls}">${icon} ${label}</span>`;
  }
  function renderKeySignals(signals){
    const wrap = qs("keySignals");
    if(!wrap) return;
    wrap.innerHTML = "";
    const rows = Array.isArray(signals) ? signals : [];
    for(const s of rows){
      const div = document.createElement("div");
      div.className = "signalCard";
      div.innerHTML = `
        <div class="signalTop">
          <div class="signalK">${esc(s.k || "Signal")}</div>
          <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
            ${srcBadge(s.src || "heur")}
            ${sevToBadge(s.sev || "warn")}
          </div>
        </div>
        <div class="signalV">${esc(s.v || "—")}</div>
        <div class="signalMini">${esc(s.mini || "")}</div>
      `;
      wrap.appendChild(div);
    }
    if(!rows.length){
      wrap.innerHTML = `<div class="signalCard"><div class="signalK">Key Signals</div><div class="signalV">—</div></div>`;
    }
  }

  function setVerdict(score, critical){
    const badge = qs("verdictBadge");
    const scoreEl = qs("scoreBadge");
    if(scoreEl) scoreEl.textContent = `SCORE ${score}/100`;

    let title = "WATCHLIST";
    let sev = "warn";
    if(score >= 85 && !critical){ title = "GUARDIAN APPROVED"; sev = "ok"; }
    else if(score >= 70){ title = "CONDITIONAL PASS"; sev = "warn"; }
    else { title = "HIGH RISK"; sev = "bad"; }

    setText("verdictTitle", title);
    if(badge){
      badge.className = "badge " + (sev==="ok" ? "good" : sev==="bad" ? "bad" : "warn");
      badge.textContent = sev==="ok" ? "APPROVED" : sev==="bad" ? "RISK" : "WATCH";
    }
    if(scoreEl){
      scoreEl.className = "badge " + (score >= 85 ? "good" : score >= 60 ? "warn" : "bad");
    }
  }

  function setScanButtons(disabled){
    const b1 = qs("btnScan");
    const b2 = qs("btnScanInline");
    if(b1) b1.disabled = !!disabled;
    if(b2) b2.disabled = !!disabled;
    const b3 = qs("btnExport");
    if(b3 && disabled) b3.disabled = true;
  }

  function setStatus(msg){ setText("status", msg || ""); }

  /* ===== Safe Networking Core (queue + retry + timeout + failover) ===== */
  // Part 2 will use this heavily for RPC/APIs.

  // Simple request queue to avoid provider overload (helps “endless loading”).
  const REQ = {
    inFlight: 0,
    max: 6,
    q: [],
  };

  function enqueue(fn){
    return new Promise((resolve, reject) => {
      REQ.q.push({ fn, resolve, reject });
      pumpQueue();
    });
  }

  function pumpQueue(){
    while(REQ.inFlight < REQ.max && REQ.q.length){
      const job = REQ.q.shift();
      REQ.inFlight++;
      job.fn()
        .then(job.resolve)
        .catch(job.reject)
        .finally(() => {
          REQ.inFlight--;
          pumpQueue();
          setText("diagReq", `${APP.REQUESTS.total} total • ${APP.REQUESTS.ok} ok • ${APP.REQUESTS.fail} fail`);
        });
    }
  }

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  function isRetryableStatus(status){
    return status === 408 || status === 429 || (status >= 500 && status <= 599);
  }

  async function safeFetch(url, opts = {}, meta = {}){
    const timeoutMs = Number(meta.timeoutMs ?? CFG.TIMEOUT_MS ?? 18000);
    const retries = Number(meta.retries ?? CFG.RETRIES ?? 2);
    const backoff = Number(meta.backoffMs ?? CFG.RETRY_BACKOFF_MS ?? 650);
    const cacheKey = meta.key || (opts?.method || "GET") + "::" + url;

    // cache clone
    if(meta.cache !== false){
      const cached = APP.CACHE.get(cacheKey);
      if(cached){
        try { return cached.clone(); } catch {}
      }
    }

    return await enqueue(async () => {
      APP.REQUESTS.total++;

      let lastErr = null;
      for(let attempt = 0; attempt <= retries; attempt++){
        const ctrl = new AbortController();
        const timer = setTimeout(() => ctrl.abort(), timeoutMs);

        // merge signals (opts.signal + ctrl.signal)
        const signals = [];
        if(opts.signal) signals.push(opts.signal);
        signals.push(ctrl.signal);

        const combined = new AbortController();
        const onAbort = () => combined.abort();

        for(const s of signals){
          if(!s) continue;
          if(s.aborted){ combined.abort(); break; }
          s.addEventListener("abort", onAbort, { once:true });
        }

        try{
          const res = await fetch(url, { ...opts, signal: combined.signal });

          // non-ok handling
          if(!res.ok){
            const status = res.status;
            const text = await res.text().catch(()=> "");
            const err = new Error(`HTTP ${status}: ${text.slice(0,160)}`);
            err.status = status;

            if(attempt < retries && isRetryableStatus(status)){
              lastErr = err;
              await sleep(backoff * (attempt + 1));
              continue;
            }
            throw err;
          }

          // OK: cache + return clone
          APP.REQUESTS.ok++;
          if(meta.cache !== false) APP.CACHE.set(cacheKey, res);
          return res.clone();

        }catch(e){
          lastErr = e;
          APP.REQUESTS.fail++;
          APP.REQUESTS.lastErr = String(e?.message || e).slice(0,200);

          // AbortError shouldn't retry if user aborted
          if(String(e?.name || "") === "AbortError" && (opts.signal?.aborted || APP.ABORT?.signal?.aborted)){
            throw e;
          }

          if(attempt < retries){
            await sleep(backoff * (attempt + 1));
            continue;
          }
          throw e;

        }finally{
          clearTimeout(timer);
          for(const s of signals){
            try{ s.removeEventListener("abort", onAbort); }catch{}
          }
        }
      }
      throw lastErr || new Error("Request failed");
    });
  }

  /* ===== Provider helpers (Part 2 uses these) ===== */
  function solRpcUrls(){
    const urls = [];
    const k = (CFG.HELIUS_KEY || "").trim();
    if(k) urls.push(`https://mainnet.helius-rpc.com/?api-key=${encodeURIComponent(k)}`);
    for(const u of (CFG.SOL_RPC_FALLBACKS || [])){
      if(typeof u === "string" && u.trim()) urls.push(u.trim());
    }
    // remove dupes
    return [...new Set(urls)];
  }

  function evmRpcUrls(chainId){
    const list = (CFG.EVM_RPCS && CFG.EVM_RPCS[chainId]) ? CFG.EVM_RPCS[chainId] : [];
    return [...new Set((list||[]).filter(Boolean).map(x => String(x).trim()).filter(Boolean))];
  }

  function evmChainIdFromActive(){
    if(APP.ACTIVE_CHAIN_ID === "eth") return 1;
    if(APP.ACTIVE_CHAIN_ID === "bnb") return 56;
    if(APP.ACTIVE_CHAIN_ID === "base") return 8453;
    return 1;
  }

  /* ===== API Keys modal (kept premium + editable) ===== */
  function openKeysModal(){
    const html = `
      ${explain("API Keys (stored locally)", [
        "Keys are saved in your browser (localStorage).",
        "Public frontend apps expose keys — a backend is recommended for production.",
        "Without GoldRush: EVM holders/graph will be limited (still does on-chain basics)."
      ])}

      <div class="field">
        <label>Helius (Solana RPC)</label>
        <input id="k_helius" placeholder="paste helius key..." value="${esc(CFG.HELIUS_KEY || "")}">
        <div class="help">Improves Solana RPC reliability. If down / rate-limited, fallbacks are used.</div>
      </div>

      <div class="field">
        <label>GoldRush / Covalent key (EVM holders + transfers)</label>
        <input id="k_goldrush" placeholder="paste goldrush key..." value="${esc(CFG.GOLDRUSH_API_KEY || "")}">
        <div class="help">Required for EVM top holders + transfer relationships (graph/clusters).</div>
      </div>

      <div class="modalActions">
        <button class="btn" type="button" id="k_cancel">Cancel</button>
        <button class="btn danger" type="button" id="k_reset">Reset</button>
        <button class="btn grad" type="button" id="k_save">Save</button>
      </div>
    `;
    openModal("API Keys", html);

    setTimeout(() => {
      const bCancel = document.getElementById("k_cancel");
      const bSave = document.getElementById("k_save");
      const bReset = document.getElementById("k_reset");

      if(bCancel) bCancel.onclick = closeModal;
      if(bReset) bReset.onclick = () => { resetCfg(); closeModal(); syncDiagPanel(); };
      if(bSave) bSave.onclick = () => {
        CFG.HELIUS_KEY = (document.getElementById("k_helius")?.value || "").trim();
        CFG.GOLDRUSH_API_KEY = (document.getElementById("k_goldrush")?.value || "").trim();
        saveCfg();
        closeModal();
        syncDiagPanel();
      };
    }, 0);
  }

  /* ===== Settings modal (timeouts, retries, RPC lists, toggles) ===== */
  function openSettingsModal(){
    const c = chainObj();
    const activeEvm = evmChainIdFromActive();
    const evmList = evmRpcUrls(activeEvm).join("\n");
    const solList = solRpcUrls().join("\n");

    const html = `
      ${explain("Settings (premium)", [
        "Tweak failover, timeouts, RPC lists, and analysis depth.",
        "If ETH/BNB feels slow: lower HOLDER_COUNT or increase TIMEOUT_MS.",
        "If everything is ‘down’: replace RPC URLs with your own providers."
      ])}

      <div class="field">
        <label>Timeout (ms)</label>
        <input id="s_timeout" value="${esc(String(CFG.TIMEOUT_MS||18000))}">
        <div class="help">Per request timeout. Increase if providers are slow. Default: 18000.</div>
      </div>

      <div class="field">
        <label>Retries</label>
        <input id="s_retries" value="${esc(String(CFG.RETRIES||2))}">
        <div class="help">Retries for 429/5xx/timeout. Default: 2.</div>
      </div>

      <div class="field">
        <label>Retry backoff (ms)</label>
        <input id="s_backoff" value="${esc(String(CFG.RETRY_BACKOFF_MS||650))}">
        <div class="help">Delay multiplier per retry. Default: 650.</div>
      </div>

      <div class="field">
        <label>Holders to display</label>
        <input id="s_holders" value="${esc(String(CFG.HOLDER_COUNT||10))}">
        <div class="help">Top holders list + bubbles count. Default: 10.</div>
      </div>

      <div class="field">
        <label>Solana RPC list (auto-failover)</label>
        <textarea id="s_sol" spellcheck="false">${esc(solList)}</textarea>
        <div class="help">First is primary. One per line. Helius URL is auto-injected when key exists.</div>
      </div>

      <div class="field">
        <label>EVM RPC list for current chain (${esc(c.name)} / chainId ${activeEvm})</label>
        <textarea id="s_evm" spellcheck="false">${esc(evmList)}</textarea>
        <div class="help">One per line. You can paste private provider endpoints.</div>
      </div>

      <div class="field">
        <label>Feature toggles</label>
        <div style="display:grid; gap:10px; margin-top:6px">
          <label style="margin:0; font-weight:900">
            <input type="checkbox" id="t_dex" ${CFG.ENABLE_DEXSCREENER ? "checked":""} style="width:auto; transform:translateY(2px); margin-right:8px">
            Enable Dexscreener enrichment
          </label>
          <label style="margin:0; font-weight:900">
            <input type="checkbox" id="t_tw" ${CFG.ENABLE_TRUSTWALLET_LOGO_FALLBACK ? "checked":""} style="width:auto; transform:translateY(2px); margin-right:8px">
            Enable TrustWallet token logo fallback (EVM)
          </label>
          <label style="margin:0; font-weight:900">
            <input type="checkbox" id="t_lp" ${CFG.AUTO_LABEL_LP ? "checked":""} style="width:auto; transform:translateY(2px); margin-right:8px">
            Auto-label likely LP/Router addresses (best-effort)
          </label>
          <label style="margin:0; font-weight:900">
            <input type="checkbox" id="t_vdiag" ${CFG.ENABLE_VERBOSE_DIAG ? "checked":""} style="width:auto; transform:translateY(2px); margin-right:8px">
            Verbose diagnostics (more logs)
          </label>
        </div>
      </div>

      <div class="modalActions">
        <button class="btn" type="button" id="s_cancel">Cancel</button>
        <button class="btn danger" type="button" id="s_reset">Reset</button>
        <button class="btn grad" type="button" id="s_save">Save</button>
      </div>
    `;
    openModal("Settings", html);

    setTimeout(() => {
      const bCancel = document.getElementById("s_cancel");
      const bSave = document.getElementById("s_save");
      const bReset = document.getElementById("s_reset");

      if(bCancel) bCancel.onclick = closeModal;
      if(bReset) bReset.onclick = () => { resetCfg(); closeModal(); syncDiagPanel(); };

      if(bSave) bSave.onclick = () => {
        const nTimeout = Number(document.getElementById("s_timeout")?.value || CFG.TIMEOUT_MS);
        const nRetries = Number(document.getElementById("s_retries")?.value || CFG.RETRIES);
        const nBackoff = Number(document.getElementById("s_backoff")?.value || CFG.RETRY_BACKOFF_MS);
        const nHolders = Number(document.getElementById("s_holders")?.value || CFG.HOLDER_COUNT);

        CFG.TIMEOUT_MS = clamp(Math.round(nTimeout||18000), 4000, 90000);
        CFG.RETRIES = clamp(Math.round(nRetries||2), 0, 6);
        CFG.RETRY_BACKOFF_MS = clamp(Math.round(nBackoff||650), 0, 8000);
        CFG.HOLDER_COUNT = clamp(Math.round(nHolders||10), 5, 50);

        // parse lists
        const solRaw = String(document.getElementById("s_sol")?.value || "");
        CFG.SOL_RPC_FALLBACKS = solRaw.split("\n").map(x => x.trim()).filter(Boolean)
          .filter(x => !x.includes("helius-rpc.com/?api-key=")); // helius handled via key

        const evmRaw = String(document.getElementById("s_evm")?.value || "");
        const evmArr = evmRaw.split("\n").map(x => x.trim()).filter(Boolean);
        if(!CFG.EVM_RPCS) CFG.EVM_RPCS = {};
        CFG.EVM_RPCS[activeEvm] = evmArr;

        // toggles
        CFG.ENABLE_DEXSCREENER = !!document.getElementById("t_dex")?.checked;
        CFG.ENABLE_TRUSTWALLET_LOGO_FALLBACK = !!document.getElementById("t_tw")?.checked;
        CFG.AUTO_LABEL_LP = !!document.getElementById("t_lp")?.checked;
        CFG.ENABLE_VERBOSE_DIAG = !!document.getElementById("t_vdiag")?.checked;

        saveCfg();
        closeModal();
        syncDiagPanel();
      };
    }, 0);
  }

  /* ===== Diagnostics panel sync ===== */
  function syncDiagPanel(){
    const c = chainObj();
    const addr = (qs("mint")?.value || "").trim();
    setText("diagBuild", BUILD_ID);
    setText("diagChain", c.name || "—");
    setText("diagAddr", addr || "—");
    setText("diagEngine", APP.ENGINE_READY ? "READY" : "LOADING");
    setText("diagTimeout", `${CFG.TIMEOUT_MS}ms`);
    setText("diagRetry", `${CFG.RETRIES} retries • backoff ${CFG.RETRY_BACKOFF_MS}ms`);
    setText("diagSolList", solRpcUrls().slice(0,6).join(" | ") || "—");
    setText("diagEvmList", evmRpcUrls(evmChainIdFromActive()).slice(0,6).join(" | ") || "—");
    setText("diagReq", `${APP.REQUESTS.total} total • ${APP.REQUESTS.ok} ok • ${APP.REQUESTS.fail} fail`);
  }

  /* ============================================================
     STOP POINT FOR PART 1.
     PART 2 will add:
       - Dexscreener enrichment + TrustWallet logos
       - Solana RPC engine + getAsset + top holders ownership resolution
       - EVM RPC engine (ERC20 meta, proxy, owner/paused, supply)
       - GoldRush holders/transfers + graph edges + clustering
       - Bubble/Graph viz engine (canvas interactions)
       - Export report with brand logo + token logo + viz snapshot
       - Full runScan() dispatcher
       - Diagnostics runner (actual live pings)
       - init() that flips ENGINE_READY when parts loaded
  ============================================================ */

  </script>
  
  <script>

/* ============================================================
   PART 2 JS — Providers + Diagnostics Pings + Enrichment
   + Core scan dispatcher + Solana/EVM base engines (MVP)
   NOTE: Bubble/Graph + Clusters + Export will come in PART 3+
============================================================ */

/* ===========================
   Diagnostics (LIVE pings)
   =========================== */
ENGINES.runDiagnostics = async function(){
  const c = chainObj();
  const solUrls = solRpcUrls();
  const evmUrls = (c.kind === "evm") ? evmRpcUrls(evmChainIdFromActive()) : evmRpcUrls(1);

  // UI defaults
  setText("diagSol", "…"); setText("diagSolUrl", "");
  setText("diagEvm", "…"); setText("diagEvmUrl", "");
  setText("diagDex", "…"); setText("diagDexUrl", "");
  setText("diagGold", "…"); setText("diagGoldUrl", "");
  setText("diagNote", "Running health checks…");

  const out = { sol:false, evm:false, dex:false, gold:false };

  // Solana ping (getLatestBlockhash)
  try{
    const url = solUrls[0] || "https://api.mainnet-beta.solana.com";
    setText("diagSolUrl", url);
    const body = {
      jsonrpc:"2.0", id:1, method:"getLatestBlockhash", params:[{commitment:"processed"}]
    };
    const res = await safeFetch(url, {
      method:"POST",
      headers:{ "content-type":"application/json" },
      body: JSON.stringify(body)
    }, { key:"diag:sol", cache:false, timeoutMs: 9000, retries: 1 });

    const j = await res.json();
    out.sol = !!j?.result?.value?.blockhash;
    setText("diagSol", out.sol ? "OK" : "FAIL");
  }catch(e){
    setText("diagSol", "FAIL");
    if(CFG.ENABLE_VERBOSE_DIAG) console.warn("Sol diag failed:", e);
  }

  // EVM ping (eth_blockNumber)
  try{
    const list = evmUrls;
    const url = list[0] || "https://ethereum.publicnode.com";
    setText("diagEvmUrl", url);
    const body = { jsonrpc:"2.0", id:1, method:"eth_blockNumber", params:[] };
    const res = await safeFetch(url, {
      method:"POST",
      headers:{ "content-type":"application/json" },
      body: JSON.stringify(body)
    }, { key:"diag:evm", cache:false, timeoutMs: 9000, retries: 1 });

    const j = await res.json();
    out.evm = !!j?.result;
    setText("diagEvm", out.evm ? "OK" : "FAIL");
  }catch(e){
    setText("diagEvm", "FAIL");
    if(CFG.ENABLE_VERBOSE_DIAG) console.warn("EVM diag failed:", e);
  }

  // Dexscreener ping
  try{
    const url = "https://api.dexscreener.com/latest/dex/search/?q=solana";
    setText("diagDexUrl", "dexscreener.com");
    const res = await safeFetch(url, { method:"GET" }, { key:"diag:dex", cache:false, timeoutMs: 9000, retries: 1 });
    const j = await res.json();
    out.dex = Array.isArray(j?.pairs);
    setText("diagDex", out.dex ? "OK" : "FAIL");
  }catch(e){
    setText("diagDex", "FAIL");
  }

  // GoldRush ping (only if key present)
  try{
    const k = (CFG.GOLDRUSH_API_KEY||"").trim();
    setText("diagGoldUrl", k ? "GoldRush key set" : "No key");
    if(!k){
      out.gold = false;
      setText("diagGold", "NO KEY");
    }else{
      // simple ping: balances for a known address is too heavy, use metadata endpoint
      const url = "https://api.covalenthq.com/v1/chains/";
      const res = await safeFetch(url, {
        method:"GET",
        headers:{ "Authorization": "Bearer " + k }
      }, { key:"diag:gold", cache:false, timeoutMs: 9000, retries: 1 });

      out.gold = res.ok;
      setText("diagGold", out.gold ? "OK" : "FAIL");
    }
  }catch(e){
    setText("diagGold", "FAIL");
  }

  const note = [];
  if(!out.sol) note.push("Solana RPC failing → switch RPC list or check Helius key / rate limits.");
  if(!out.evm) note.push("EVM RPC failing → switch RPC list or use a different endpoint.");
  if(!out.dex) note.push("Dexscreener unreachable → price/liquidity enrichment will be limited.");
  if((chainObj().kind==="evm") && !(CFG.GOLDRUSH_API_KEY||"").trim()){
    note.push("GoldRush key missing → EVM holders + graph edges will be limited.");
  }
  setText("diagNote", note.length ? note.join(" ") : "All good.");
  syncDiagPanel();
  return out;
};


/* ===========================
   Enrichment: Dexscreener
   =========================== */
async function dexSearch(query){
  if(!CFG.ENABLE_DEXSCREENER) return null;
  const q = encodeURIComponent(String(query||"").slice(0,120));
  const url = `https://api.dexscreener.com/latest/dex/search/?q=${q}`;
  const res = await safeFetch(url, { method:"GET" }, { key:"dex:search:"+q, cache:true, timeoutMs: 12000, retries: 1 });
  const j = await res.json().catch(()=>null);
  return j;
}

function pickDexPairForChain(dexJson, chainId){
  const pairs = dexJson?.pairs;
  if(!Array.isArray(pairs) || !pairs.length) return null;

  const want =
    chainId==="sol" ? "solana" :
    chainId==="eth" ? "ethereum" :
    chainId==="bnb" ? "bsc" :
    chainId==="base" ? "base" : "";

  const filtered = pairs.filter(p => String(p?.chainId||"").toLowerCase() === want);
  const arr = filtered.length ? filtered : pairs;

  // prefer highest liquidity USD
  arr.sort((a,b)=> (Number(b?.liquidity?.usd||0) - Number(a?.liquidity?.usd||0)));
  return arr[0] || null;
}


/* ===========================
   Token logo fallback (EVM)
   TrustWallet assets (best-effort)
   =========================== */
function trustwalletLogo(chainId, addr){
  if(!CFG.ENABLE_TRUSTWALLET_LOGO_FALLBACK) return "";
  const a = String(addr||"").toLowerCase();
  if(!looksEvmAddress(a)) return "";
  // TrustWallet repo structure:
  // https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum/assets/<addr>/logo.png
  const base =
    chainId==="eth" ? "ethereum" :
    chainId==="bnb" ? "smartchain" :
    chainId==="base" ? "base" : "ethereum";

  return `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/${base}/assets/${a}/logo.png`;
}


/* ===========================
   Minimal Solana RPC
   - jsonrpc request helper with failover
   =========================== */
async function solRpc(method, params, meta={}){
  const urls = solRpcUrls();
  let lastErr = null;

  for(let i=0;i<urls.length;i++){
    const url = urls[i];
    try{
      const body = { jsonrpc:"2.0", id:1, method, params: params||[] };
      const res = await safeFetch(url, {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body),
        signal: APP.ABORT?.signal
      }, { key: (meta.key || `sol:${method}:${i}`), cache: meta.cache ?? false, timeoutMs: meta.timeoutMs ?? CFG.TIMEOUT_MS });

      const j = await res.json();
      if(j?.error) throw new Error(j.error?.message || "Solana RPC error");
      return { url, json: j };
    }catch(e){
      lastErr = e;
      if(CFG.ENABLE_VERBOSE_DIAG) console.warn("solRpc fail", url, e);
      continue;
    }
  }
  throw lastErr || new Error("Solana RPC failed");
}


/* ===========================
   Minimal EVM RPC (JSON-RPC)
   with failover
   =========================== */
async function evmRpc(chainId, method, params, meta={}){
  const urls = evmRpcUrls(chainId);
  let lastErr = null;

  for(let i=0;i<urls.length;i++){
    const url = urls[i];
    try{
      const body = { jsonrpc:"2.0", id:1, method, params: params||[] };
      const res = await safeFetch(url, {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body),
        signal: APP.ABORT?.signal
      }, { key: (meta.key || `evm:${chainId}:${method}:${i}`), cache: meta.cache ?? false, timeoutMs: meta.timeoutMs ?? CFG.TIMEOUT_MS });

      const j = await res.json();
      if(j?.error) throw new Error(j.error?.message || "EVM RPC error");
      return { url, json: j };
    }catch(e){
      lastErr = e;
      if(CFG.ENABLE_VERBOSE_DIAG) console.warn("evmRpc fail", url, e);
      continue;
    }
  }
  throw lastErr || new Error("EVM RPC failed");
}


/* ===========================
   EVM ABI helpers (ERC20 basic)
   (no external libs)
   =========================== */
function pad64(hex){ return hex.replace(/^0x/,"").padStart(64,"0"); }
function keccakSig4(sig){
  // minimal precomputed selectors (avoid crypto libs):
  // name() -> 0x06fdde03
  // symbol() -> 0x95d89b41
  // decimals() -> 0x313ce567
  // totalSupply() -> 0x18160ddd
  // owner() -> 0x8da5cb5b
  // getOwner() -> 0x893d20e8 (some tokens)
  const m = {
    "name()":"0x06fdde03",
    "symbol()":"0x95d89b41",
    "decimals()":"0x313ce567",
    "totalSupply()":"0x18160ddd",
    "owner()":"0x8da5cb5b",
    "getOwner()":"0x893d20e8"
  };
  return m[sig] || "0x";
}

function hexToInt(hex){
  if(!hex) return null;
  try{ return BigInt(hex); }catch{ return null; }
}
function decodeUint(hex){
  const v = hexToInt(hex);
  if(v===null) return null;
  return v;
}
function decodeAddress(hex){
  if(!hex || hex.length < 66) return null;
  const clean = hex.replace(/^0x/,"");
  return "0x" + clean.slice(24,64);
}

function decodeStringReturn(hex){
  // Handles dynamic string returned by ABI:
  // 0x
  // [offset 32 bytes]
  // [length 32 bytes]
  // [data...]
  const clean = (hex||"").replace(/^0x/,"");
  if(clean.length < 128) return null;

  const offset = Number(BigInt("0x"+clean.slice(0,64)));
  const lenPos = offset*2;
  if(clean.length < lenPos + 64) return null;

  const len = Number(BigInt("0x"+clean.slice(lenPos, lenPos+64)));
  const dataPos = lenPos + 64;
  const dataHex = clean.slice(dataPos, dataPos + len*2);

  try{
    const bytes = dataHex.match(/.{1,2}/g)?.map(b=>parseInt(b,16)) || [];
    const str = new TextDecoder().decode(new Uint8Array(bytes));
    return str.replace(/\0/g,"").trim() || null;
  }catch{
    return null;
  }
}

async function evmCall(chainId, to, data, metaKey){
  const { json } = await evmRpc(chainId, "eth_call", [{
    to, data
  }, "latest"], { key: metaKey, cache:false });
  return json?.result || null;
}

async function erc20Meta(chainId, addr){
  const out = { name:null, symbol:null, decimals:null, totalSupply:null, owner:null };

  // name
  try{
    const r = await evmCall(chainId, addr, keccakSig4("name()"), `erc20:name:${chainId}:${addr}`);
    out.name = decodeStringReturn(r) || null;
  }catch{}

  // symbol
  try{
    const r = await evmCall(chainId, addr, keccakSig4("symbol()"), `erc20:symbol:${chainId}:${addr}`);
    out.symbol = decodeStringReturn(r) || null;
  }catch{}

  // decimals
  try{
    const r = await evmCall(chainId, addr, keccakSig4("decimals()"), `erc20:dec:${chainId}:${addr}`);
    const v = decodeUint(r);
    out.decimals = v===null ? null : Number(v);
  }catch{}

  // totalSupply
  try{
    const r = await evmCall(chainId, addr, keccakSig4("totalSupply()"), `erc20:supply:${chainId}:${addr}`);
    out.totalSupply = decodeUint(r);
  }catch{}

  // owner / getOwner
  try{
    const r = await evmCall(chainId, addr, keccakSig4("owner()"), `erc20:owner:${chainId}:${addr}`);
    const a = decodeAddress(r);
    if(a && looksEvmAddress(a)) out.owner = a;
  }catch{}
  if(!out.owner){
    try{
      const r = await evmCall(chainId, addr, keccakSig4("getOwner()"), `erc20:getOwner:${chainId}:${addr}`);
      const a = decodeAddress(r);
      if(a && looksEvmAddress(a)) out.owner = a;
    }catch{}
  }

  return out;
}


/* ===========================
   GoldRush (holders) — EVM only (best-effort)
   Uses Bearer key.
   =========================== */
async function goldrushTopHolders(chainId, tokenAddr, limit){
  const k = (CFG.GOLDRUSH_API_KEY||"").trim();
  if(!k) return { holders:[], note:"No GoldRush key set." };

  // Covalent endpoint example (token holders v2):
  // /v1/{chain_id}/tokens/{token_address}/token_holders/?page-size=...
  const url = `https://api.covalenthq.com/v1/${chainId}/tokens/${tokenAddr}/token_holders/?page-size=${clamp(limit||10,5,50)}&page-number=0`;

  const res = await safeFetch(url, {
    method:"GET",
    headers:{ "Authorization": "Bearer " + k }
  }, { key:`gold:holders:${chainId}:${tokenAddr}:${limit}`, cache:false, timeoutMs: 20000, retries: 1 });

  const j = await res.json().catch(()=>null);
  const data = j?.data;
  const items = data?.items;
  if(!Array.isArray(items)) return { holders:[], note:"No holder data returned." };

  const holders = items.map(it => ({
    address: it?.address || "",
    balance: it?.balance || null,
    pct: it?.total_supply && it?.balance
      ? (Number(it.balance) / Number(it.total_supply)) * 100
      : null
  })).filter(x => x.address);

  return { holders, note: data?.pagination ? "OK" : "OK" };
}


/* ===========================
   Solana scan engine (base)
   - getAsset (Helius) if possible
   - fallback: minimal metadata display
   - top holders via getTokenLargestAccounts
   =========================== */
async function solGetAsset(mint){
  const key = (CFG.HELIUS_KEY||"").trim();
  if(!key) return null;

  // Helius getAsset
  const url = `https://mainnet.helius-rpc.com/?api-key=${encodeURIComponent(key)}`;
  const body = {
    jsonrpc:"2.0", id:"getAsset", method:"getAsset",
    params:{ id: mint }
  };

  const res = await safeFetch(url, {
    method:"POST",
    headers:{ "content-type":"application/json" },
    body: JSON.stringify(body),
    signal: APP.ABORT?.signal
  }, { key:`sol:getAsset:${mint}`, cache:false, timeoutMs: 18000, retries: 1 });

  const j = await res.json().catch(()=>null);
  return j?.result || null;
}

async function solTopHolders(mint, limit){
  // getTokenLargestAccounts -> returns token accounts + uiAmount
  const { json } = await solRpc("getTokenLargestAccounts", [mint], { key:`sol:largest:${mint}`, cache:false, timeoutMs: 18000 });
  const arr = json?.result?.value;
  if(!Array.isArray(arr)) return [];

  const top = arr.slice(0, clamp(limit||10, 5, 50)).map(x => ({
    tokenAccount: x?.address || "",
    uiAmount: x?.uiAmount || null,
    amount: x?.amount || null
  })).filter(x=>x.tokenAccount);

  // resolve owner via getAccountInfo
  const owners = [];
  for(const t of top){
    try{
      const { json: j2 } = await solRpc("getAccountInfo", [t.tokenAccount, { encoding:"jsonParsed" }], { key:`sol:acct:${t.tokenAccount}`, cache:false, timeoutMs: 18000 });
      const owner = j2?.result?.value?.data?.parsed?.info?.owner;
      owners.push({
        address: owner || t.tokenAccount,
        tokenAccount: t.tokenAccount,
        uiAmount: t.uiAmount,
        amount: t.amount
      });
    }catch{
      owners.push({
        address: t.tokenAccount,
        tokenAccount: t.tokenAccount,
        uiAmount: t.uiAmount,
        amount: t.amount
      });
    }
  }
  return owners;
}

ENGINES.scanSolana = async function(mint){
  const t0 = Date.now();
  setText("engineStamp", "ENGINE: SOLANA");
  setText("diagEngine", "SOLANA");
  setText("diagAddr", mint);

  // metadata via helius
  let meta = { name:"Solana Token", symbol:"", image:"" };
  let extraMeta = [];
  try{
    const asset = await solGetAsset(mint);
    if(asset){
      const content = asset?.content;
      const m = asset?.content?.metadata;
      const links = asset?.content?.links;

      meta.name = m?.name || asset?.content?.metadata?.name || meta.name;
      meta.symbol = m?.symbol || asset?.content?.metadata?.symbol || "";

      const img = content?.files?.[0]?.uri || links?.image || content?.links?.image || "";
      meta.image = img || "";

      extraMeta.push({ t:"Supply (raw)", d: asset?.token_info?.supply ? String(asset.token_info.supply) : "—", sev:"warn" });
      extraMeta.push({ t:"Decimals", d: asset?.token_info?.decimals!=null ? String(asset.token_info.decimals) : "—", sev:"warn" });
      if(asset?.token_info?.mint_authority){
        extraMeta.push({ t:"Mint Authority", d: String(asset.token_info.mint_authority), sev:"warn" });
      }
      if(asset?.token_info?.freeze_authority){
        extraMeta.push({ t:"Freeze Authority", d: String(asset.token_info.freeze_authority), sev:"warn" });
      }
    }
  }catch(e){
    if(CFG.ENABLE_VERBOSE_DIAG) console.warn("sol getAsset fail", e);
  }

  applyTokenHeader(meta, mint);
  setText("mintShort", mint);
  setText("summary", "Solana scan running…");

  // Top holders
  let holders = [];
  try{
    holders = await solTopHolders(mint, CFG.HOLDER_COUNT || 10);
  }catch(e){
    holders = [];
  }

  // Estimate holder pct from top uiAmount sum (best-effort)
  const sum = holders.reduce((a,b)=> a + (Number(b.uiAmount||0) || 0), 0);
  const mapped = holders.map(h => ({
    address: h.address,
    pct: sum > 0 ? ((Number(h.uiAmount||0) || 0) / sum) * 100 : null,
    uiAmount: h.uiAmount
  }));

  // Render holders list (preview)
  const hList = qs("holdersList");
  if(hList){
    hList.innerHTML = "";
    const ex = explorerBase("sol");
    for(const h of mapped){
      const li = document.createElement("li");
      li.className = "li";
      li.innerHTML = `
        <div class="left">
          <div class="t">${esc(shortAddr(h.address))}</div>
          <div class="d">Amount: ${esc(String(h.uiAmount ?? "—"))} • Share: ${esc(h.pct==null?"—":fmtPct(h.pct))}</div>
        </div>
        <div class="pillRow">
          <a class="explorerBtn" href="${ex.base}${encodeURIComponent(h.address)}" target="_blank" rel="noreferrer">Open ${esc(ex.name)}</a>
        </div>
      `;
      hList.appendChild(li);
    }
    if(!mapped.length){
      const li = document.createElement("li");
      li.className = "li";
      li.innerHTML = `<div class="left"><div class="t">No holder data</div><div class="d">RPC returned no largest accounts.</div></div><div class="pillRow"><span class="pill warn">WAIT</span></div>`;
      hList.appendChild(li);
    }
  }

  // Minimal checks + todos for now (Part 3 expands massively)
  const checks = [
    { t:"Mint address valid", d:"Base58 format validated.", sev:"ok" },
    { t:"Metadata", d: meta.name !== "Solana Token" ? "Helius getAsset loaded." : "Helius getAsset unavailable (key missing or limited).", sev: meta.name !== "Solana Token" ? "ok" : "warn" },
    { t:"Top holders loaded", d: mapped.length ? `Loaded ${mapped.length} largest holders (best-effort).` : "Could not load holders.", sev: mapped.length ? "ok" : "warn" }
  ];
  renderList(qs("checksList"), checks, "Checks");

  const todo = [
    { t:"Renounce mint authority (if needed)", d:"If you want immutability: set mint authority to null.", sev:"warn" },
    { t:"Freeze authority", d:"If freeze authority exists, consider disabling for trust.", sev:"warn" }
  ];
  renderList(qs("todoList"), todo, "Launch actions");

  renderList(qs("metaList"), extraMeta, "Metadata");

  // Score (very basic for now)
  const score = mapped.length ? 78 : 65;
  setVerdict(score, false);

  setText("vizStamp", `SOL • ${mapped.length} holders`);
  setText("clusterStamp", "SOL MAINNET");
  setText("clusterFoot", "Clusters/graph will load in PART 3 (transfer edges + wallet links).");

  // enable export later (Part 4)
  setText("summary", `Solana scan complete in ${((Date.now()-t0)/1000).toFixed(2)}s (basic engine).`);
  return { chain:"sol", mint, meta, holders:mapped, ms: Date.now()-t0 };
};


/* ===========================
   EVM scan engine (base)
   - ERC20 meta via eth_call
   - Dexscreener enrichment
   - Holders via GoldRush if key
   =========================== */
ENGINES.scanEvm = async function(addr){
  const t0 = Date.now();
  const chainId = evmChainIdFromActive();
  setText("engineStamp", "ENGINE: EVM");
  setText("diagEngine", "EVM");
  setText("diagAddr", addr);

  setText("summary", "EVM scan running…");

  // basic ERC20
  const m = await erc20Meta(chainId, addr);
  const meta = {
    name: m.name || "EVM Token",
    symbol: m.symbol || "",
    image: trustwalletLogo(APP.ACTIVE_CHAIN_ID, addr) || ""
  };
  applyTokenHeader(meta, addr);
  setText("mintShort", addr);

  // Dex enrichment (search by address)
  let dexPair = null;
  try{
    const dex = await dexSearch(addr);
    dexPair = pickDexPairForChain(dex, APP.ACTIVE_CHAIN_ID);
  }catch{}

  // holders via GoldRush
  let holdersRes = { holders:[], note:"—" };
  try{
    holdersRes = await goldrushTopHolders(chainId, addr, CFG.HOLDER_COUNT || 10);
  }catch(e){
    holdersRes = { holders:[], note:"GoldRush fetch failed." };
  }

  // render holders
  const hList = qs("holdersList");
  if(hList){
    hList.innerHTML = "";
    const ex = explorerBase(APP.ACTIVE_CHAIN_ID);
    for(const h of holdersRes.holders){
      const li = document.createElement("li");
      li.className = "li";
      li.innerHTML = `
        <div class="left">
          <div class="t">${esc(shortAddr(h.address))}</div>
          <div class="d">Share: ${esc(h.pct==null?"—":fmtPct(h.pct))}</div>
        </div>
        <div class="pillRow">
          <a class="explorerBtn" href="${ex.base}${encodeURIComponent(h.address)}" target="_blank" rel="noreferrer">Open ${esc(ex.name)}</a>
        </div>
      `;
      hList.appendChild(li);
    }
    if(!holdersRes.holders.length){
      const li = document.createElement("li");
      li.className = "li";
      li.innerHTML = `<div class="left"><div class="t">No holder data</div><div class="d">${esc(holdersRes.note || "No data")}</div></div><div class="pillRow"><span class="pill warn">WAIT</span></div>`;
      hList.appendChild(li);
    }
  }

  // meta list
  const metaList = [];
  metaList.push({ t:"Name", d: meta.name || "—", sev: meta.name ? "ok":"warn" });
  metaList.push({ t:"Symbol", d: meta.symbol ? "$"+meta.symbol : "—", sev: meta.symbol ? "ok":"warn" });
  metaList.push({ t:"Decimals", d: m.decimals!=null ? String(m.decimals) : "—", sev: m.decimals!=null ? "ok":"warn" });

  if(m.totalSupply!=null && m.decimals!=null){
    const supply = Number(m.totalSupply) / (10 ** m.decimals);
    metaList.push({ t:"Total supply", d: fmtInt(supply), sev:"warn" });
  }else{
    metaList.push({ t:"Total supply", d: "—", sev:"warn" });
  }

  metaList.push({ t:"Owner", d: m.owner ? String(m.owner) : "—", sev: m.owner ? "warn":"warn" });

  if(dexPair){
    metaList.push({ t:"Dex pair", d: `${dexPair?.dexId || "DEX"} • ${dexPair?.baseToken?.symbol || ""}/${dexPair?.quoteToken?.symbol || ""}`, sev:"ok" });
    metaList.push({ t:"Liquidity", d: dexPair?.liquidity?.usd!=null ? ("$"+formatUsd(dexPair.liquidity.usd)) : "—", sev:"warn" });
    metaList.push({ t:"FDV", d: dexPair?.fdv!=null ? ("$"+formatUsd(dexPair.fdv)) : "—", sev:"warn" });
  }else{
    metaList.push({ t:"Dexscreener", d:"No pair found (or API unavailable).", sev:"warn" });
  }
  renderList(qs("metaList"), metaList, "Metadata");

  // key signals
  const sig = [];
  sig.push({ k:"Holders coverage", v: holdersRes.holders.length ? `Top ${holdersRes.holders.length} loaded` : "Limited", mini: holdersRes.note || "", sev: holdersRes.holders.length ? "ok":"warn", src: holdersRes.holders.length ? "indexer":"heur" });
  sig.push({ k:"Owner() present", v: m.owner ? "Yes" : "Unknown", mini: "Many tokens do not expose owner().", sev: m.owner ? "warn":"warn", src:"onchain" });
  sig.push({ k:"Liquidity found", v: dexPair?.liquidity?.usd!=null ? "Yes" : "Unknown", mini: "Using Dexscreener best-effort.", sev: dexPair?.liquidity?.usd!=null ? "ok":"warn", src:"api" });
  renderKeySignals(sig);

  // checks list
  const checks = [];
  checks.push({ t:"Contract address valid", d:"0x address validated.", sev:"ok" });
  checks.push({ t:"ERC20 metadata", d: meta.symbol ? "Read via eth_call." : "Partial (token may be proxy/non-standard).", sev: meta.symbol ? "ok":"warn" });
  checks.push({ t:"Holders", d: holdersRes.holders.length ? "Loaded via indexer." : "No indexer holders (missing key or blocked).", sev: holdersRes.holders.length ? "ok":"warn" });
  renderList(qs("checksList"), checks, "Checks");

  // todo list (basic)
  const todo = [
    { t:"Verify ownership", d:"If owner exists: confirm renounced or timelock.", sev:"warn" },
    { t:"Audit proxy/upgradeability", d:"If proxy: ensure implementation locked.", sev:"warn" },
  ];
  renderList(qs("todoList"), todo, "Launch actions");

  // score
  let score = 72;
  if(meta.symbol && holdersRes.holders.length) score = 80;
  if(!holdersRes.holders.length) score -= 8;
  setVerdict(score, false);

  setText("vizStamp", `${APP.ACTIVE_CHAIN_ID.toUpperCase()} • ${holdersRes.holders.length || 0} holders`);
  setText("clusterFoot", "Clusters/graph will load in PART 3 (transfer edges + wallet links).");

  setText("summary", `EVM scan complete in ${((Date.now()-t0)/1000).toFixed(2)}s (basic engine).`);
  return { chain:APP.ACTIVE_CHAIN_ID, addr, meta, holders:holdersRes.holders, dexPair, ms: Date.now()-t0 };
};


/* ===========================
   Scan Dispatcher (now functional)
   =========================== */
async function runScan(){
  const c = chainObj();
  const addr = (qs("mint")?.value || "").trim();
  syncDiagPanel();

  if(!addr){
    showToast("Paste an address first.");
    return;
  }

  // validate
  if(c.kind === "solana" && !looksBase58(addr)){
    showToast("Invalid Solana mint (base58).");
    return;
  }
  if(c.kind === "evm" && !looksEvmAddress(addr)){
    showToast("Invalid EVM contract (0x…).");
    return;
  }

  // abort setup
  if(APP.ABORT) try{ APP.ABORT.abort(); }catch{}
  APP.ABORT = new AbortController();

  APP.SCANNING = true;
  setScanButtons(true);
  setStatus("Scanning…");

  // enable diagnostics button
  setText("engineStamp", APP.ENGINE_READY ? "ENGINE: READY" : "ENGINE: READY (Core)");
  setText("diagEngine", c.kind === "solana" ? "SOLANA" : "EVM");

  try{
    let result = null;
    if(c.kind === "solana"){
      result = await ENGINES.scanSolana(addr);
    }else{
      result = await ENGINES.scanEvm(addr);
    }
    APP.LAST_SCAN = result;

    // enable graph tab later (part 3)
    const g = qs("vizModeGraph");
    if(g) g.disabled = true;

    // export later (part 4)
    const exBtn = qs("btnExport");
    if(exBtn) exBtn.disabled = true;

    setStatus("Scan finished.");
  }catch(e){
    console.error(e);
    setStatus("Scan failed: " + (e?.message || e));
    showToast("Scan failed. Open Diagnostics / try different RPC.");
  }finally{
    APP.SCANNING = false;
    setScanButtons(false);
    syncDiagPanel();
  }
}


/* ===========================
   Basic UI wiring (now live)
   =========================== */
on("toastClose","click", hideToast);
on("modalClose","click", closeModal);
on("modalWrap","click",(e)=>{ if(e.target===qs("modalWrap")) closeModal(); });

on("btnKeys","click", openKeysModal);
on("btnSettings","click", openSettingsModal);

on("btnScan","click", runScan);
on("btnScanInline","click", runScan);

on("btnPaste","click", async () => {
  try{
    const txt = await navigator.clipboard.readText();
    if(txt) qs("mint").value = txt.trim();
    syncDiagPanel();
  }catch{
    showToast("Clipboard not available (browser restriction).");
  }
});

on("btnClear","click", () => {
  qs("mint").value = "";
  syncDiagPanel();
  setStatus("");
});

on("btnCopyAddr","click", async () => {
  const v = (qs("mint")?.value || "").trim();
  if(!v) return showToast("Nothing to copy.");
  try{ await navigator.clipboard.writeText(v); showToast("Copied."); }
  catch{ showToast("Copy failed (browser restriction)."); }
});

on("mint","keydown",(e)=>{
  if(e.key==="Enter"){
    e.preventDefault();
    runScan();
  }
});

on("btnDiag","click", async ()=>{
  try{
    await ENGINES.runDiagnostics();
    showToast("Diagnostics complete.");
  }catch{
    showToast("Diagnostics failed.");
  }
});

/* ===========================
   Init (activate chain param)
   =========================== */
(function initPart2(){
  setText("y", String(new Date().getFullYear()));
  startLiveStampTime();

  // chain param
  const url = new URL(location.href);
  const chain = url.searchParams.get("chain");
  if(chain && CHAINS.some(c=>c.id===chain)){
    APP.ACTIVE_CHAIN_ID = chain;
  }

  renderChainButtons();
  setActiveChain(APP.ACTIVE_CHAIN_ID, false);

  // mark engine ready for core
  APP.ENGINE_READY = true;
  setText("engineStamp", "ENGINE: READY (Core)");
  syncDiagPanel();

  // run initial diagnostics quietly (non-blocking)
  ENGINES.runDiagnostics().catch(()=>{});
})();
</script>

  <script>
/* ============================================================
   PART 3 — Premium Bubble Map + Basic Graph + Cluster v1
   - Canvas zoom/pan/hover/click
   - Bubble sizing by holder share / amount (best-effort)
   - Graph mode v1 (synthetic edges; real transfer edges Part 4)
   - Cluster intelligence v1 (heuristic)
============================================================ */

/* ===========================
   Small helpers (Part 3)
   =========================== */
function isNum(x){ return typeof x === "number" && Number.isFinite(x); }
function lerp(a,b,t){ return a + (b-a)*t; }
function nowMs(){ return (typeof performance !== "undefined" ? performance.now() : Date.now()); }

function nicePct(p){
  if(!isNum(p)) return "—";
  if(p >= 10) return p.toFixed(1) + "%";
  if(p >= 1) return p.toFixed(2) + "%";
  return p.toFixed(3) + "%";
}

function normalizeAddrForChain(chainId, addr){
  if(!addr) return "";
  if(chainId === "sol") return String(addr);
  return String(addr).toLowerCase();
}

function maybeOpenExplorer(chainId, addr){
  const ex = explorerBase(chainId);
  const a = encodeURIComponent(String(addr||""));
  if(!ex.base || ex.base === "#") return;
  window.open(ex.base + a, "_blank", "noreferrer");
}

/* ===========================
   VIZ state + init
   =========================== */
const VIZ = {
  ready: false,
  mode: "bubbles", // bubbles | graph
  canvas: null,
  ctx: null,
  dpr: 1,

  w: 0, h: 0,
  view: { x:0, y:0, s:1 },    // pan offsets + scale
  dragging: false,
  dragStart: { x:0, y:0, vx:0, vy:0 },
  pointer: { x:0, y:0, down:false },
  hover: null,
  lastFrame: 0,

  nodes: [],
  edges: [], // for graph mode
  meta: { chainId:"sol", tokenAddr:"", tokenName:"", tokenSymbol:"" },

  // interaction
  zoomMin: 0.55,
  zoomMax: 2.75,
};

function vizWorldToScreen(wx, wy){
  return {
    x: (wx * VIZ.view.s) + VIZ.view.x,
    y: (wy * VIZ.view.s) + VIZ.view.y
  };
}
function vizScreenToWorld(sx, sy){
  return {
    x: (sx - VIZ.view.x) / VIZ.view.s,
    y: (sy - VIZ.view.y) / VIZ.view.s
  };
}

function vizResize(){
  if(!VIZ.canvas) return;
  const rect = VIZ.canvas.getBoundingClientRect();
  VIZ.dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
  VIZ.w = Math.max(10, Math.floor(rect.width));
  VIZ.h = Math.max(10, Math.floor(rect.height));
  VIZ.canvas.width  = Math.floor(VIZ.w * VIZ.dpr);
  VIZ.canvas.height = Math.floor(VIZ.h * VIZ.dpr);
  VIZ.ctx.setTransform(VIZ.dpr,0,0,VIZ.dpr,0,0);
}

function vizResetView(){
  // center world origin into canvas
  VIZ.view.s = 1;
  VIZ.view.x = VIZ.w * 0.5;
  VIZ.view.y = VIZ.h * 0.5;
}

function vizSetOverlay(text){
  const o = qs("vizOverlay");
  if(!o) return;
  if(text){
    o.style.display = "flex";
    o.textContent = text;
  }else{
    o.style.display = "none";
  }
}

function vizSetLegend(text){
  setText("vizLegend", text || "—");
}

function vizSetSub(text){
  setText("vizSub", text || "");
}

function vizApplyModeButtons(){
  const b = qs("vizModeBubbles");
  const g = qs("vizModeGraph");
  if(b) b.classList.toggle("active", VIZ.mode === "bubbles");
  if(g) g.classList.toggle("active", VIZ.mode === "graph");
  if(b) b.setAttribute("aria-selected", VIZ.mode === "bubbles" ? "true":"false");
  if(g) g.setAttribute("aria-selected", VIZ.mode === "graph" ? "true":"false");
}

function vizSetMode(mode){
  VIZ.mode = (mode === "graph") ? "graph" : "bubbles";
  vizApplyModeButtons();
  if(VIZ.mode === "graph"){
    vizSetLegend("Nodes • Edges");
    vizSetSub("Graph mode shows wallet relationships (v1 synthetic edges). Real transfer edges come in Part 4.");
  }else{
    vizSetLegend("Bubbles sized by share");
    vizSetSub("Bubble map shows top holders sized by share (best-effort). Hover / click for details.");
  }
  vizRenderOnce();
}

function vizHitTest(sx, sy){
  if(!VIZ.nodes.length) return null;
  const p = vizScreenToWorld(sx, sy);

  // check nearest within radius
  let best = null;
  let bestD = Infinity;
  for(const n of VIZ.nodes){
    const dx = p.x - n.x;
    const dy = p.y - n.y;
    const d2 = dx*dx + dy*dy;
    const r = (n.r || 10);
    if(d2 <= r*r && d2 < bestD){
      best = n;
      bestD = d2;
    }
  }
  return best;
}

/* ===========================
   Bubble layout / packing
   =========================== */
function buildNodesFromScan(scan){
  const chainId = scan?.chain || APP.ACTIVE_CHAIN_ID || "sol";
  const tokenAddr = scan?.mint || scan?.addr || "";
  const tokenName = scan?.meta?.name || "Token";
  const tokenSymbol = scan?.meta?.symbol || "";

  VIZ.meta = { chainId, tokenAddr, tokenName, tokenSymbol };

  // holders list might be {address,pct,uiAmount} (sol) or {address,pct,balance} (evm)
  const holders = Array.isArray(scan?.holders) ? scan.holders : [];
  const top = holders.slice(0, clamp(CFG.HOLDER_COUNT || 10, 5, 50));

  // compute pct if missing (best-effort from balances)
  let havePct = top.some(h => isNum(h?.pct));
  let computed = top.map(h => ({...h}));

  if(!havePct){
    // try from uiAmount or balance sum
    const sum = computed.reduce((a,h)=> a + (Number(h?.uiAmount||0) || Number(h?.balance||0) || 0), 0);
    if(sum > 0){
      computed = computed.map(h => {
        const val = (Number(h?.uiAmount||0) || Number(h?.balance||0) || 0);
        return { ...h, pct: (val/sum)*100 };
      });
    }
  }

  // sort by pct desc
  computed.sort((a,b)=> (Number(b?.pct||0) - Number(a?.pct||0)));

  // create node objects
  const nodes = [];
  const nMax = computed.length;

  // base sizes
  // radius range in world units (not pixels)
  const rMin = 10;
  const rMax = 46;

  const maxPct = Math.max(0.0001, ...computed.map(h=>Number(h?.pct||0)));
  for(let i=0;i<nMax;i++){
    const h = computed[i];
    const pct = Number(h?.pct||0);
    const t = Math.sqrt(Math.max(0, pct / maxPct)); // sqrt for nicer distribution
    const r = lerp(rMin, rMax, clamp(t,0,1));

    const addr = normalizeAddrForChain(chainId, h?.address || "");
    nodes.push({
      id: addr || ("n"+i),
      addr,
      pct: isNum(pct) ? pct : null,
      val: h?.uiAmount ?? h?.balance ?? null,
      label: shortAddr(addr),
      r,
      x: 0,
      y: 0,
      sev: (pct >= 15 ? "bad" : pct >= 8 ? "warn" : "ok"), // concentration heuristic
      tags: [],
    });
  }

  // Place nodes on a spiral then relax collisions
  const spacing = 8;
  for(let i=0;i<nodes.length;i++){
    const a = i * 0.85;
    const rad = (i===0 ? 0 : (nodes[i-1].r + nodes[i].r + spacing)) + i*1.6;
    nodes[i].x = Math.cos(a) * rad;
    nodes[i].y = Math.sin(a) * rad;
  }

  // Collision relax
  const iters = 240;
  for(let k=0;k<iters;k++){
    for(let i=0;i<nodes.length;i++){
      for(let j=i+1;j<nodes.length;j++){
        const a = nodes[i], b = nodes[j];
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.sqrt(dx*dx + dy*dy) || 0.0001;
        const minD = a.r + b.r + spacing;
        if(dist < minD){
          const push = (minD - dist) * 0.5;
          const ux = dx / dist;
          const uy = dy / dist;
          a.x -= ux * push;
          a.y -= uy * push;
          b.x += ux * push;
          b.y += uy * push;
        }
      }
    }
    // mild centering
    for(const n of nodes){
      n.x *= 0.997;
      n.y *= 0.997;
    }
  }

  // Tag LP/pair if Dex pair exists (EVM)
  try{
    const pairAddr = scan?.dexPair?.pairAddress || scan?.dexPair?.pair?.address || scan?.dexPair?.pair || "";
    if(pairAddr && chainId !== "sol"){
      const p = normalizeAddrForChain(chainId, pairAddr);
      for(const n of nodes){
        if(n.addr && n.addr === p){
          n.tags.push("PAIR/LP");
          n.sev = "warn";
        }
      }
    }
  }catch{}

  VIZ.nodes = nodes;

  // graph edges v1 (synthetic)
  VIZ.edges = buildGraphEdgesV1(scan, nodes);

  // legend + stamps
  setText("vizStamp", `${String(chainId).toUpperCase()} • ${nodes.length} holders`);
  vizSetLegend("Bubbles sized by share");
  return nodes;
}

/* ===========================
   Graph edges v1 (synthetic)
   Part 4 will replace with real transfer edges.
=========================== */
function buildGraphEdgesV1(scan, nodes){
  const edges = [];
  if(!nodes.length) return edges;

  // Create a hub node for token itself (not clickable address if sol mint is same)
  const chainId = scan?.chain || APP.ACTIVE_CHAIN_ID;
  const tokenAddr = normalizeAddrForChain(chainId, scan?.mint || scan?.addr || "");
  const hubId = tokenAddr ? ("token:"+tokenAddr) : "token:unknown";

  // Ensure hub exists as a node (small)
  const hub = {
    id: hubId,
    addr: tokenAddr,
    pct: null,
    val: null,
    label: (scan?.meta?.symbol ? "$"+scan.meta.symbol : "TOKEN"),
    r: 14,
    x: 0,
    y: 0,
    sev: "ok",
    tags: ["TOKEN"],
    isHub: true
  };

  // Place hub at center and push others outward a bit
  hub.x = 0; hub.y = 0;
  const outNodes = [hub, ...nodes.map(n => ({...n, x:n.x*1.15, y:n.y*1.15}))];

  // Connect top N holders to hub
  const N = Math.min(nodes.length, 18);
  for(let i=0;i<N;i++){
    edges.push({ a: hubId, b: nodes[i].id, w: 1 });
  }

  // Cluster edges among close pct bands (heuristic)
  for(let i=0;i<nodes.length;i++){
    for(let j=i+1;j<nodes.length;j++){
      const pi = Number(nodes[i].pct||0);
      const pj = Number(nodes[j].pct||0);
      if(Math.abs(pi - pj) <= 0.35 && (pi+pj) > 0.8){
        if(edges.length >= 120) break;
        edges.push({ a: nodes[i].id, b: nodes[j].id, w: 0.4 });
      }
    }
    if(edges.length >= 120) break;
  }

  // overwrite viz nodes with hub included
  VIZ.nodes = outNodes;
  return edges;
}

/* ===========================
   Rendering (Canvas)
   =========================== */
function getCssVar(name, fallback){
  try{
    const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    return v || fallback;
  }catch{ return fallback; }
}

function vizColorForNode(n){
  // severity-coded glow, but keep your premium vibe
  if(n?.isHub) return "rgba(255,255,255,.85)";
  if(n?.sev === "bad")  return "rgba(255,120,150,.95)";
  if(n?.sev === "warn") return "rgba(255,220,130,.95)";
  return "rgba(20,241,149,.95)";
}

function vizDrawBackground(ctx){
  // subtle grid
  const step = 60;
  ctx.save();
  ctx.globalAlpha = 0.18;
  ctx.lineWidth = 1;

  const left = (-VIZ.view.x / VIZ.view.s) - 200;
  const top  = (-VIZ.view.y / VIZ.view.s) - 200;
  const right = left + (VIZ.w / VIZ.view.s) + 400;
  const bottom= top  + (VIZ.h / VIZ.view.s) + 400;

  const x0 = Math.floor(left/step)*step;
  const y0 = Math.floor(top/step)*step;

  ctx.strokeStyle = "rgba(255,255,255,.10)";
  for(let x=x0; x<right; x+=step){
    const s = vizWorldToScreen(x, 0);
    ctx.beginPath();
    ctx.moveTo(s.x, 0);
    ctx.lineTo(s.x, VIZ.h);
    ctx.stroke();
  }
  for(let y=y0; y<bottom; y+=step){
    const s = vizWorldToScreen(0, y);
    ctx.beginPath();
    ctx.moveTo(0, s.y);
    ctx.lineTo(VIZ.w, s.y);
    ctx.stroke();
  }
  ctx.restore();
}

function vizDrawEdges(ctx){
  if(VIZ.mode !== "graph") return;
  if(!VIZ.edges.length) return;

  const index = new Map();
  for(const n of VIZ.nodes) index.set(n.id, n);

  ctx.save();
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.22;
  ctx.strokeStyle = "rgba(255,255,255,.55)";

  for(const e of VIZ.edges){
    const a = index.get(e.a);
    const b = index.get(e.b);
    if(!a || !b) continue;
    const A = vizWorldToScreen(a.x, a.y);
    const B = vizWorldToScreen(b.x, b.y);
    ctx.globalAlpha = 0.10 + Math.min(0.22, (e.w || 0.4)*0.22);
    ctx.beginPath();
    ctx.moveTo(A.x, A.y);
    ctx.lineTo(B.x, B.y);
    ctx.stroke();
  }
  ctx.restore();
}

function vizDrawNodes(ctx){
  const nodes = VIZ.nodes || [];
  if(!nodes.length) return;

  // draw largest first for glow
  const sorted = nodes.slice().sort((a,b)=> (b.r - a.r));

  for(const n of sorted){
    const s = vizWorldToScreen(n.x, n.y);
    const r = n.r * VIZ.view.s;

    // glow
    ctx.save();
    ctx.beginPath();
    ctx.arc(s.x, s.y, r + 10, 0, Math.PI*2);
    ctx.fillStyle = "rgba(0,0,0,.18)";
    ctx.fill();
    ctx.restore();

    // main bubble
    ctx.save();
    ctx.beginPath();
    ctx.arc(s.x, s.y, r, 0, Math.PI*2);
    ctx.fillStyle = "rgba(255,255,255,.06)";
    ctx.fill();
    ctx.lineWidth = 1.2;
    ctx.strokeStyle = "rgba(255,255,255,.15)";
    ctx.stroke();
    ctx.restore();

    // inner ring colored
    ctx.save();
    ctx.beginPath();
    ctx.arc(s.x, s.y, Math.max(2, r*0.88), 0, Math.PI*2);
    ctx.strokeStyle = vizColorForNode(n);
    ctx.globalAlpha = 0.55;
    ctx.lineWidth = Math.max(1, r*0.06);
    ctx.stroke();
    ctx.restore();

    // hover highlight
    if(VIZ.hover && VIZ.hover.id === n.id){
      ctx.save();
      ctx.beginPath();
      ctx.arc(s.x, s.y, r+4, 0, Math.PI*2);
      ctx.strokeStyle = "rgba(0,209,255,.9)";
      ctx.globalAlpha = 0.9;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }

    // text label (only if big enough)
    if(r >= 20){
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.88)";
      ctx.font = `900 ${Math.max(10, Math.min(14, r*0.28))}px ${getCssVar("--sans","system-ui")}`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      const t1 = n.isHub ? (n.label || "TOKEN") : (n.label || shortAddr(n.addr));
      ctx.fillText(t1, s.x, s.y - 6);

      // pct line
      if(isNum(n.pct)){
        ctx.fillStyle = "rgba(255,255,255,.65)";
        ctx.font = `850 ${Math.max(9, Math.min(12, r*0.22))}px ${getCssVar("--sans","system-ui")}`;
        ctx.fillText(nicePct(n.pct), s.x, s.y + 10);
      }else if(n.tags?.length){
        ctx.fillStyle = "rgba(255,255,255,.62)";
        ctx.font = `850 ${Math.max(9, Math.min(12, r*0.22))}px ${getCssVar("--sans","system-ui")}`;
        ctx.fillText(n.tags[0], s.x, s.y + 10);
      }
      ctx.restore();
    }
  }
}

function vizRender(){
  if(!VIZ.ctx) return;
  const ctx = VIZ.ctx;
  ctx.clearRect(0,0,VIZ.w,VIZ.h);

  // background
  vizDrawBackground(ctx);

  // edges (graph mode)
  vizDrawEdges(ctx);

  // nodes
  vizDrawNodes(ctx);
}

function vizRenderOnce(){
  vizRender();
}

function vizLoop(t){
  VIZ.lastFrame = t;
  vizRender();
  requestAnimationFrame(vizLoop);
}

/* ===========================
   Cluster Intelligence v1
   =========================== */
function buildClusterSummary(scan){
  const chainId = scan?.chain || APP.ACTIVE_CHAIN_ID;
  const holders = Array.isArray(scan?.holders) ? scan.holders : [];

  // compute top concentration
  const top = holders.slice(0, 10).map(h => Number(h?.pct||0)).filter(x=>isNum(x));
  const top1 = top[0] || 0;
  const top3 = (top[0]||0) + (top[1]||0) + (top[2]||0);
  const top5 = top.slice(0,5).reduce((a,b)=>a+b,0);

  const clusters = [];

  // 1) Whale concentration
  if(top1 >= 15){
    clusters.push({
      sev:"bad",
      title:`High concentration: #1 holder ~${nicePct(top1)}`,
      desc:"A single wallet controls a large share (best-effort). Investigate wallet identity, vesting, locks, and sell risk.",
      tags:["CONCENTRATION"]
    });
  }else if(top3 >= 25){
    clusters.push({
      sev:"warn",
      title:`Top 3 holders ~${nicePct(top3)}`,
      desc:"Ownership is somewhat concentrated. Check distribution, team wallets, and LP locking.",
      tags:["DISTRIBUTION"]
    });
  }else{
    clusters.push({
      sev:"ok",
      title:`Distribution looks healthier (Top 5 ~${nicePct(top5)})`,
      desc:"No extreme whale signal in the top set (best-effort). Still verify LP + ownership.",
      tags:["DISTRIBUTION"]
    });
  }

  // 2) Pair/LP presence (EVM via Dexscreener)
  const pairAddr = scan?.dexPair?.pairAddress || "";
  if(pairAddr && chainId !== "sol"){
    clusters.push({
      sev:"ok",
      title:"Dex pair detected (Dexscreener)",
      desc:"A liquidity pool pair address was found. Verify liquidity lock, ownership of LP tokens, and trading taxes.",
      tags:["LP/PAIR"]
    });
  }else if(chainId !== "sol"){
    clusters.push({
      sev:"warn",
      title:"No Dex pair detected yet",
      desc:"Dexscreener did not return a matching pair (could be new token, no liquidity, or API limitation).",
      tags:["LIQUIDITY"]
    });
  }

  // 3) Indexer coverage (EVM holders)
  if(chainObj().kind === "evm"){
    const has = Array.isArray(scan?.holders) && scan.holders.length > 0 && scan.holders.some(h=>isNum(h?.pct));
    if(!has){
      clusters.push({
        sev:"warn",
        title:"Indexer-limited holder coverage",
        desc:"Without GoldRush holder supply context, the scanner can only approximate. Add/verify key or use a backend.",
        tags:["INDEXER"]
      });
    }
  }

  return clusters;
}

function renderClustersFromScan(scan){
  const grid = qs("clusterGrid");
  if(!grid) return;

  const clusters = buildClusterSummary(scan);
  if(!clusters.length){
    grid.innerHTML = `
      <div class="clusterCard">
        <div class="clusterLeft">
          <div class="clusterT"><span class="dot warn"></span> No cluster insights</div>
          <div class="clusterD">Not enough data for clustering.</div>
        </div>
        <div class="clusterRight"><span class="badge warn">WAIT</span></div>
      </div>
    `;
    return;
  }

  grid.innerHTML = "";
  for(const c of clusters){
    const dotCls = c.sev === "ok" ? "dot good" : c.sev === "bad" ? "dot bad" : "dot warn";
    const badgeCls = c.sev === "ok" ? "badge good" : c.sev === "bad" ? "badge bad" : "badge warn";
    const badgeTxt = c.sev === "ok" ? "PASS" : c.sev === "bad" ? "RISK" : "WATCH";

    const infoHtml = explain(c.title, [
      c.desc,
      "Note: Cluster signals are best-effort and can be wrong without transfer edges.",
      "Next: Part 4 adds transfer-based edges & shared funder detection."
    ]);
    const infoId = registerInfo(infoHtml);

    const card = document.createElement("div");
    card.className = "clusterCard";
    card.innerHTML = `
      <div class="clusterLeft">
        <div class="clusterT">
          <span class="${dotCls}"></span>
          ${esc(c.title)}
          ${c.tags?.map(t=>`<span class="badge" style="opacity:.85">${esc(t)}</span>`).join("") || ""}
        </div>
        <div class="clusterD">${esc(c.desc)}</div>
      </div>
      <div class="clusterRight">
        <span class="${badgeCls}" data-open="1" role="button" tabindex="0"
              data-title="${esc(c.title)}" data-info="${esc(infoId)}">${badgeTxt}</span>
        <button class="infoBtn" type="button" data-open="1" data-title="${esc(c.title)}" data-info="${esc(infoId)}"><span>i</span></button>
      </div>
    `;
    grid.appendChild(card);
  }

  setText("clusterFoot", "Cluster v1 uses distribution + DEX signals. Transfer-based wallet linking ships in Part 4.");
}

/* ===========================
   ENGINES.initViz (Part 3)
   =========================== */
ENGINES.initViz = function(scan){
  // ensure canvas exists
  const canvas = qs("vizCanvas");
  if(!canvas) return;

  VIZ.canvas = canvas;
  VIZ.ctx = canvas.getContext("2d", { alpha:true, desynchronized:true });
  VIZ.ready = true;

  vizResize();
  vizResetView();

  // build nodes
  const nodes = buildNodesFromScan(scan);
  if(!nodes.length){
    vizSetOverlay("No holder data yet. Run a scan with working RPC/indexer.");
    return;
  }
  vizSetOverlay(null);

  // enable graph button now that we have edges (even if synthetic)
  const g = qs("vizModeGraph");
  if(g){
    g.disabled = false;
    g.setAttribute("aria-selected", "false");
  }

  // default mode bubbles
  vizSetMode("bubbles");

  // clusters
  renderClustersFromScan(scan);

  // stamp + legend
  vizSetLegend(VIZ.mode === "graph" ? "Nodes • Edges" : "Bubbles sized by share");

  // start loop once
  if(!VIZ._loopStarted){
    VIZ._loopStarted = true;
    requestAnimationFrame(vizLoop);
  }
};

/* ===========================
   VIZ interactions (mouse/touch)
   =========================== */
function wireVizEvents(){
  const canvas = qs("vizCanvas");
  if(!canvas) return;

  // resize observer
  const ro = new ResizeObserver(() => {
    vizResize();
    vizRenderOnce();
  });
  ro.observe(canvas);

  // zoom wheel
  canvas.addEventListener("wheel", (e) => {
    if(!VIZ.ready) return;
    e.preventDefault();

    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;

    const before = vizScreenToWorld(sx, sy);

    const delta = -Math.sign(e.deltaY);
    const factor = delta > 0 ? 1.10 : 0.90;

    const ns = clamp(VIZ.view.s * factor, VIZ.zoomMin, VIZ.zoomMax);
    VIZ.view.s = ns;

    const after = vizScreenToWorld(sx, sy);

    // keep point stable under cursor
    VIZ.view.x += (after.x - before.x) * VIZ.view.s;
    VIZ.view.y += (after.y - before.y) * VIZ.view.s;

  }, { passive:false });

  // pan drag
  canvas.addEventListener("pointerdown", (e) => {
    if(!VIZ.ready) return;
    canvas.setPointerCapture?.(e.pointerId);
    VIZ.dragging = true;
    VIZ.dragStart.x = e.clientX;
    VIZ.dragStart.y = e.clientY;
    VIZ.dragStart.vx = VIZ.view.x;
    VIZ.dragStart.vy = VIZ.view.y;
    VIZ.pointer.down = true;
  });

  canvas.addEventListener("pointermove", (e) => {
    if(!VIZ.ready) return;

    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;

    // hover
    const hit = vizHitTest(sx, sy);
    VIZ.hover = hit;

    // overlay with hover info
    if(hit){
      const chainId = VIZ.meta.chainId || APP.ACTIVE_CHAIN_ID;
      const title = hit.isHub ? (VIZ.meta.tokenName || "TOKEN") : shortAddr(hit.addr);
      const line2 = hit.isHub
        ? (VIZ.meta.tokenSymbol ? "$"+VIZ.meta.tokenSymbol : "Token node")
        : (isNum(hit.pct) ? ("Share: " + nicePct(hit.pct)) : "Share: —");
      const line3 = hit.tags?.length ? ("Tag: " + hit.tags.join(", ")) : "Click to open explorer";

      vizSetOverlay(`${title} • ${line2} • ${line3}`);
    }else{
      vizSetOverlay(null);
    }

    // dragging
    if(VIZ.dragging){
      const dx = e.clientX - VIZ.dragStart.x;
      const dy = e.clientY - VIZ.dragStart.y;
      VIZ.view.x = VIZ.dragStart.vx + dx;
      VIZ.view.y = VIZ.dragStart.vy + dy;
    }
  });

  canvas.addEventListener("pointerup", (e) => {
    if(!VIZ.ready) return;
    VIZ.dragging = false;
    VIZ.pointer.down = false;
  });

  // click open explorer
  canvas.addEventListener("click", (e) => {
    if(!VIZ.ready) return;
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left;
    const sy = e.clientY - rect.top;
    const hit = vizHitTest(sx, sy);
    if(!hit) return;

    const chainId = VIZ.meta.chainId || APP.ACTIVE_CHAIN_ID;
    if(hit.isHub){
      if(VIZ.meta.tokenAddr) maybeOpenExplorer(chainId, VIZ.meta.tokenAddr);
      return;
    }
    if(hit.addr) maybeOpenExplorer(chainId, hit.addr);
  });

  // reset view button
  on("btnVizReset","click", () => {
    vizResetView();
    vizRenderOnce();
  });

  // mode buttons
  on("vizModeBubbles","click", () => vizSetMode("bubbles"));
  on("vizModeGraph","click", () => vizSetMode("graph"));
}

/* ===========================
   After-scan hook wiring
   (important: old listeners still point to old runScan reference)
   We remove them and re-bind a wrapper that calls runScan then initViz.
   =========================== */
function rewireScanButtonsForPart3(){
  const b1 = qs("btnScan");
  const b2 = qs("btnScanInline");
  const mint = qs("mint");

  // remove old listeners
  try{ if(b1) b1.removeEventListener("click", runScan); }catch{}
  try{ if(b2) b2.removeEventListener("click", runScan); }catch{}

  // wrapper
  const wrapped = async (e) => {
    // run existing scan (Part 2)
    await runScan();

    // now init viz + clusters
    if(APP.LAST_SCAN){
      try{
        ENGINES.initViz?.(APP.LAST_SCAN);
      }catch(err){
        console.warn("Viz init failed:", err);
      }
    }
  };

  if(b1) b1.addEventListener("click", wrapped);
  if(b2) b2.addEventListener("click", wrapped);

  // Enter key: remove old + re-add
  try{
    if(mint){
      // clone technique to drop all previous listeners safely
      // (this keeps element attributes/value)
      const clone = mint.cloneNode(true);
      mint.parentNode.replaceChild(clone, mint);
    }
  }catch{}

  // re-bind Enter
  const mint2 = qs("mint");
  if(mint2){
    mint2.addEventListener("keydown", async (e) => {
      if(e.key === "Enter"){
        e.preventDefault();
        await wrapped(e);
      }
    });
  }
}

/* ===========================
   Part 3 init
   =========================== */
(function initPart3(){
  // wire viz events
  wireVizEvents();

  // rewire scan buttons so viz + clusters always build
  rewireScanButtonsForPart3();

  // set legend defaults
  vizSetLegend("—");

  // if already scanned (hot reload), rebuild viz
  if(APP.LAST_SCAN){
    try{ ENGINES.initViz?.(APP.LAST_SCAN); }catch{}
  }
})();
</script>
  
  
