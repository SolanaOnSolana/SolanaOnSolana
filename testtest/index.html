<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#070711" />
  <title>$SOS — Guardian Check (Multi-Chain) • Next Level</title>
  <meta name="description" content="Guardian Approved — token risk score + launch readiness + cluster & bubble map (best-effort, on-chain verifiable when possible)." />

  <style>
    :root{
      --bg:#070711;
      --panel: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --g:#14F195;
      --c:#00D1FF;
      --p:#9945FF;
      --radius: 22px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --max: 1180px;

      --sol-g1:#14F195;
      --sol-g2:#00D1FF;
      --sol-g3:#9945FF;
      --bnb-yellow:#F0B90B;
      --base-blue:#0052FF;

      --good: rgba(20,241,149,.18);
      --warn: rgba(255,220,130,.14);
      --bad:  rgba(255,120,150,.16);
      --gridGap: 16px;

      --src-onchain: rgba(20,241,149,.16);
      --src-indexer: rgba(0,209,255,.14);
      --src-api: rgba(153,69,255,.14);
      --src-heur: rgba(255,220,130,.12);

      --focus: rgba(0,209,255,.45);
      --focusGlow: rgba(0,209,255,.12);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--text);
      font: 15.5px/1.55 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: var(--bg);
      position:relative;
      overflow-x:hidden;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      z-index:-1;
      pointer-events:none;
      background:
        radial-gradient(1200px 700px at 10% 5%, rgba(153,69,255,.22), transparent 60%),
        radial-gradient(1000px 650px at 90% 10%, rgba(20,241,149,.18), transparent 55%),
        radial-gradient(900px 600px at 70% 85%, rgba(0,209,255,.14), transparent 55%),
        var(--bg);
      transform: translateZ(0);
    }
    a{color:inherit; text-decoration:none}
    .wrap{max-width:var(--max); margin:0 auto; padding:0 18px; width:100%;}
    main{padding:22px 0 42px}

    .topbar{
      position:sticky;
      top:0;
      z-index:20;
      backdrop-filter: blur(14px);
      background: rgba(7,7,17,.62);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:12px 0;
      flex-wrap:wrap;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      min-width: 260px;
      user-select:none;
    }
    .brand img{
      width:40px;
      height:40px;
      object-fit:contain;
      filter: drop-shadow(0 10px 25px rgba(0,0,0,.45));
    }
    .bt{display:flex; flex-direction:column; line-height:1.05}
    .bt .t{font-weight:1000; letter-spacing:-.2px; font-size:16px}
    .bt .s{font-weight:850; color:var(--muted); font-size:12.5px}

    .actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
      width:100%;
    }
    @media (min-width: 980px){
      .actions{width:auto}
    }

    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:9px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      font-weight:950;
      font-size:13px;
      transition: .15s ease;
      user-select:none;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      white-space:nowrap;
    }
    .btn:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .btn.grad{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .btn.ghost{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.12);
    }
    .btn[disabled]{opacity:.55; pointer-events:none}
    .btn:focus{outline:none}
    .btn:focus-visible{
      box-shadow: 0 0 0 3px var(--focusGlow);
      border-color: var(--focus);
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.05));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .inner{padding:22px}

    .hero{
      position:relative;
      overflow:hidden;
      isolation:isolate;
    }
    .hero::before{
      content:"";
      position:absolute;
      inset:-70px -40px;
      background:
        radial-gradient(900px 520px at 18% 28%, rgba(20,241,149,.16), transparent 60%),
        radial-gradient(900px 520px at 82% 20%, rgba(0,209,255,.12), transparent 60%),
        radial-gradient(900px 520px at 70% 86%, rgba(153,69,255,.14), transparent 60%);
      z-index:0;
      pointer-events:none;
    }
    .hero > *{position:relative; z-index:1}

    .h1{
      margin:0;
      font-weight:1000;
      letter-spacing:-1px;
      line-height:1.05;
      font-size: clamp(34px, 4.6vw, 62px);
    }
    .gradText{
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;
    }
    .sub{
      margin-top:10px;
      color: rgba(255,255,255,.76);
      font-weight:850;
      max-width: 940px;
    }

    .classified{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .stamp{
      font-weight:1000;
      font-size:12px;
      letter-spacing: .45px;
      text-transform:uppercase;
      color: rgba(255,255,255,.76);
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius: 999px;
      padding:7px 10px;
    }

    .layout{
      margin-top:16px;
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:var(--gridGap);
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns:1fr}
    }

    .analysisGrid{
      margin-top: var(--gridGap);
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap: var(--gridGap);
      align-items:start;
    }
    @media (max-width: 980px){
      .analysisGrid{grid-template-columns:1fr}
    }

    .panel{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 18px;
      padding:16px;
      overflow:hidden;
    }

    .panelHead{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .panelTitle{
      font-weight:1000;
      letter-spacing:.35px;
      text-transform:uppercase;
      font-size:12px;
      color: rgba(255,255,255,.72);
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .panelSub{
      color: rgba(255,255,255,.62);
      font-weight:850;
      font-size:12.5px;
      line-height:1.35;
      margin-top:6px;
    }

    label{
      display:block;
      font-weight:950;
      font-size:12.5px;
      letter-spacing:.35px;
      color: rgba(255,255,255,.82);
      margin-bottom:8px;
    }
    input{
      width:100%;
      padding:14px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.92);
      outline:none;
      font-weight:900;
      letter-spacing:.2px;
      font-size:16px;
      max-width:100%;
    }
    input:focus{
      border-color: var(--focus);
      box-shadow: 0 0 0 3px var(--focusGlow);
    }

    .statusLine{
      margin-top:12px;
      color: rgba(255,255,255,.72);
      font-weight:900;
      min-height: 18px;
      font-size:13px;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:7px 11px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
    }
    .badge.good{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}
    .badge.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .badge.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}

    .badge.src{border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.05); color: rgba(255,255,255,.84)}
    .badge.src.onchain{border-color: rgba(20,241,149,.26); background: var(--src-onchain);}
    .badge.src.indexer{border-color: rgba(0,209,255,.26); background: var(--src-indexer);}
    .badge.src.api{border-color: rgba(153,69,255,.26); background: var(--src-api);}
    .badge.src.heur{border-color: rgba(255,220,130,.26); background: var(--src-heur);}

    .resultTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .resultTitle{
      margin:0;
      font-weight:1000;
      font-size:22px;
      letter-spacing:-.4px;
    }
    .mono{
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-weight:900;
      color: rgba(255,255,255,.86);
      margin-top:6px;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    .tokenHead{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:10px;
      min-width:0;
    }
    .tokenLogoWrap{
      width:44px;
      height:44px;
      border-radius:12px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      display:flex;
      flex:0 0 auto;
      position:relative;
      align-items:center;
      justify-content:center;
    }
    .tokenLogoWrap img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .identicon{
      width:100%;
      height:100%;
      display:block;
    }

    .tokenName{
      font-weight:1000;
      font-size:16px;
      letter-spacing:-.2px;
      line-height:1.15;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .tokenSymbol{
      margin-top:2px;
      color: rgba(255,255,255,.70);
      font-weight:900;
      font-size:12.5px;
    }

    .metricStack{margin-top:12px; display:grid; gap:10px;}
    .metric{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      border-radius: 16px;
      padding:12px 12px;
    }
    .metricK{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      color: rgba(255,255,255,.70);
      font-weight:1000;
      font-size:12px;
      letter-spacing:.45px;
      text-transform:uppercase;
    }
    .metricV{
      margin-top:8px;
      font-weight:1000;
      font-size:20px;
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .metricMini{
      margin-top:6px;
      font-weight:850;
      font-size:12px;
      color: rgba(255,255,255,.62);
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    .bar{
      margin-top:10px;
      height:12px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .bar > div{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      border-radius:999px;
      transition: width .25s ease;
    }

    .list{
      margin:10px 0 0;
      padding:0;
      list-style:none;
      display:grid;
      gap:10px;
    }
    .li{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      border-radius: 16px;
      padding:12px 12px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      min-width:0;
    }
    .li .left{min-width:0;}
    .li .t{font-weight:1000; font-size:13px; letter-spacing:.2px;}
    .li .d{
      margin-top:4px;
      color: rgba(255,255,255,.70);
      font-weight:750;
      font-size:12.5px;
      line-height:1.35;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    .pillRow{
      display:flex;
      gap:8px;
      align-items:center;
      flex:0 0 auto;
      justify-content:flex-end;
      flex-wrap:wrap;
    }
    .pill{
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor:pointer;
    }
    .pill.ok{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}
    .pill.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .pill.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}
    .infoBtn{
      width:26px;
      height:26px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.86);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      font-weight:1000;
      font-size:13px;
      line-height:1;
      -webkit-tap-highlight-color: transparent;
    }
    .infoBtn:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }
    .infoBtn:active{ transform: translateY(0px); }
    .infoBtn span{ transform: translateY(-0.5px); }

    .explorerBtn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .explorerBtn:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }

    /* ===== Bubble Map / Graph Canvas ===== */
    .vizWrap{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
      border-radius: 18px;
      overflow:hidden;
      position:relative;
    }
    .vizTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      padding:12px 12px 10px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
    }
    .vizTitle{
      font-weight:1000;
      letter-spacing:.35px;
      text-transform:uppercase;
      font-size:12px;
      color: rgba(255,255,255,.72);
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .vizHint{
      color: rgba(255,255,255,.62);
      font-weight:850;
      font-size:12.5px;
      line-height:1.35;
      margin-top:6px;
      max-width: 560px;
    }
    .vizControls{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }
    .seg{
      display:inline-flex;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      border-radius: 999px;
      overflow:hidden;
    }
    .seg button{
      border:0;
      background:transparent;
      color: rgba(255,255,255,.82);
      font-weight:1000;
      font-size:12px;
      padding:8px 10px;
      cursor:pointer;
    }
    .seg button.active{
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.92);
    }
    .seg button[disabled]{ opacity:.45; cursor:not-allowed; }

    .vizStage{
      height: 420px;
      position:relative;
      display:block;
      background:
        radial-gradient(900px 520px at 30% 30%, rgba(20,241,149,.08), transparent 60%),
        radial-gradient(900px 520px at 70% 20%, rgba(0,209,255,.06), transparent 60%),
        radial-gradient(900px 520px at 60% 85%, rgba(153,69,255,.06), transparent 60%),
        rgba(0,0,0,.10);
    }
    @media (max-width: 980px){
      .vizStage{ height: 360px; }
    }
    canvas.vizCanvas{
      width:100%;
      height:100%;
      display:block;
    }
    .vizOverlay{
      position:absolute;
      inset:0;
      pointer-events:none;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
      text-align:center;
      color: rgba(255,255,255,.68);
      font-weight:900;
    }

    /* ===== cluster cards ===== */
    .clusterGrid{ display:grid; grid-template-columns: 1fr; gap:10px; }
    .clusterCard{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      border-radius: 16px;
      padding:12px 12px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
    }
    .clusterLeft{min-width:0}
    .clusterT{
      font-weight:1000;
      font-size:13px;
      letter-spacing:.2px;
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .dot{
      width:10px;height:10px;border-radius:999px;
      background: rgba(255,255,255,.22);
      border:1px solid rgba(255,255,255,.12);
      flex:0 0 auto;
    }
    .dot.good{ background: rgba(20,241,149,.50); }
    .dot.warn{ background: rgba(255,220,130,.55); }
    .dot.bad{  background: rgba(255,120,150,.55); }

    .clusterD{
      margin-top:5px;
      color: rgba(255,255,255,.70);
      font-weight:750;
      font-size:12.5px;
      line-height:1.35;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .clusterRight{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap; justify-content:flex-end;
      flex:0 0 auto;
    }

    /* chain selection */
    .chainRow{ margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; }
    .chainBtn{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      user-select:none;
      font-weight:1000;
      font-size:13px;
      color: rgba(255,255,255,.88);
      -webkit-tap-highlight-color: transparent;
    }
    .chainBtn:hover{ background: rgba(255,255,255,.10); }
    .chainBtn.active{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .chainBtn:focus-visible{
      outline:none;
      box-shadow: 0 0 0 3px var(--focusGlow);
    }
    .chainIcon{
      width:18px;
      height:18px;
      border-radius:6px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      flex:0 0 auto;
    }
    .chainIcon svg{ width:18px; height:18px; display:block; }
    .chainMiniHint{
      margin-top:10px;
      font-size:12.5px;
      color: rgba(255,255,255,.62);
      font-weight:850;
      line-height:1.35;
    }

    footer{
      padding: 18px 0 34px;
      color: rgba(255,255,255,.45);
      font-weight:650;
      text-align:center;
      font-size:12px;
    }

    /* modal + toast */
    .modalWrap{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:100;
    }
    .modal{
      width:min(920px, 100%);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(7,7,17,.92);
      box-shadow: 0 16px 50px rgba(0,0,0,.5);
      overflow:hidden;
    }
    .modalHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .modalTitle{ font-weight:1000; letter-spacing:-.3px; }
    .modalBody{
      padding:14px 16px 16px;
      color: rgba(255,255,255,.84);
      font-weight:850;
      line-height:1.5;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .modalBody .field{
      display:grid;
      grid-template-columns: 1fr;
      gap:6px;
      margin:12px 0;
      padding:12px;
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      background: rgba(0,0,0,.12);
    }
    .modalBody .field input{
      border-radius: 14px;
      padding:12px 12px;
      font-size:14px;
    }
    .modalBody .help{
      color: rgba(255,255,255,.66);
      font-weight:850;
      font-size:12.5px;
      line-height:1.35;
    }
    .modalActions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
      margin-top:12px;
    }

    .toast{
      position:fixed;
      top: max(16px, env(safe-area-inset-top));
      left:50%;
      transform:translateX(-50%);
      width:min(920px, calc(100% - 28px));
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(7,7,17,.90);
      box-shadow: 0 16px 50px rgba(0,0,0,.45);
      padding:14px 14px;
      display:none;
      z-index:120;
      backdrop-filter: blur(12px);
    }
    .toastRow{display:flex; align-items:center; justify-content:space-between; gap:12px;}
    .toastTitle{font-weight:1000; font-size:16px; letter-spacing:-.2px;}
    .toastClose{
      padding:9px 12px;
      border-radius:999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      font-weight:950;
      cursor:pointer;
    }
    .toastClose:hover{background: rgba(255,255,255,.10);}

    /* Key Signals cards */
    .signalCard{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      border-radius: 16px;
      padding:12px 12px;
    }
    .signalTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .signalK{
      font-weight:1000;
      letter-spacing:.45px;
      text-transform:uppercase;
      font-size:12px;
      color: rgba(255,255,255,.72);
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .signalV{
      margin-top:8px;
      font-weight:1000;
      font-size:18px;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .signalMini{
      margin-top:6px;
      font-weight:850;
      font-size:12px;
      color: rgba(255,255,255,.62);
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* Responsive tightening */
    @media (max-width: 980px){
      .wrap{ padding: 0 14px; }
      .inner{ padding: 16px; }
      .panel{ padding: 14px; }
      .brand{ min-width: 0; width: 100%; }
      .actions{ width: 100%; justify-content: flex-start; }
      .actions .btn{ width: 100%; justify-content: center; padding: 12px 14px; font-size: 14px; }
      .resultTop{ flex-direction: column; align-items: stretch; }
      .resultTop > div:last-child{ width: 100%; justify-content: flex-start; }
      .resultTop .badge{ width: fit-content; }
      .tokenHead{ flex-wrap: nowrap; }
      .tokenName{ font-size: 18px; }
      .tokenSymbol{ font-size: 13px; }
      .metricV{ flex-direction: column; align-items: flex-start; gap: 6px; font-size: 22px; }
      .metricK{ flex-wrap: wrap; gap: 8px; }
      .metricK .badge{ margin-left: auto; }
      .li{ flex-direction: column; align-items: flex-start; gap: 10px; }
      .pillRow{ width:100%; justify-content:flex-start; flex-wrap:wrap; }
      .modal{ width:100%; }
      .toast{ left:14px; right:14px; transform:none; width:auto; }
    }

    @media (prefers-reduced-motion: reduce){
      .btn:hover{transform:none}
      .bar > div{transition:none}
      .infoBtn:hover{transform:none}
      .explorerBtn:hover{transform:none}
    }
  </style>
</head>

<body>
  <!-- Toast -->
  <div class="toast" id="toast">
    <div class="toastRow">
      <div class="toastTitle" id="toastTitle">—</div>
      <button class="toastClose" id="toastClose" type="button">Close</button>
    </div>
  </div>

  <div class="topbar">
    <div class="wrap">
      <div class="row">
        <div class="brand">
          <img id="brandLogo" src="assets/logo.png" alt="$SOS" onerror="this.style.display='none'">
          <div class="bt">
            <div class="t">$SOS</div>
            <div class="s">Contract Scanner • Token Risk • Clusters</div>
          </div>
        </div>

        <div class="actions">
          <a class="btn" href="https://solanax1.com/" rel="noreferrer">← Back to Main</a>
          <button class="btn ghost" id="btnKeys" type="button">API Keys</button>
          <button class="btn grad" id="btnScan" type="button">Run Guardian Check</button>
          <button class="btn grad" id="btnExport" type="button" disabled>Download Scan Report</button>
        </div>
      </div>
    </div>
  </div>

  <main class="wrap">
    <section class="card hero">
      <div class="inner">
        <div class="classified">
          <div class="stamp">GUARDIAN SYSTEM • MAINNET • BEST-EFFORT VERIFIED</div>
          <div class="stamp" id="stampTime">—</div>
        </div>

        <h1 class="h1" style="margin-top:12px;">
          <span class="gradText">Guardian Contract</span> Scanner
        </h1>

        <div class="sub">
          Multi-chain scan: Solana + ETH + BNB + Base — now with
          <span class="gradText">clusters</span>, <span class="gradText">bubble map</span>, and <span class="gradText">linked wallets</span> (best-effort).
        </div>

        <div class="layout">
          <!-- INPUT -->
          <div class="panel">
            <div class="panelHead">
              <div>
                <div class="panelTitle">Scan Input</div>
                <div class="panelSub">Paste token address. We auto-validate per chain. Tip: press Enter to scan.</div>
              </div>
              <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
                <span class="badge" id="netStamp">—</span>
              </div>
            </div>

            <label>Choose Chain</label>
            <div class="chainRow" id="chainRow"></div>
            <div class="chainMiniHint" id="chainHint">—</div>

            <label for="mint" style="margin-top:14px;" id="addrLabel">Token Address</label>
            <input id="mint" placeholder="Paste token address..." autocomplete="off" spellcheck="false" inputmode="text" />
            <div style="display:flex; gap:10px; flex-wrap:wrap; margin-top:12px;">
              <button class="btn grad" id="btnScanInline" type="button" style="flex:1 1 220px;">Run Guardian Check</button>
              <button class="btn" id="btnPaste" type="button" style="flex:0 0 auto;">Paste</button>
              <button class="btn" id="btnClear" type="button" style="flex:0 0 auto;">Clear</button>
            </div>

            <div class="statusLine" id="status"></div>
          </div>

          <!-- RESULTS -->
          <div class="panel" id="resultsPanel">
            <div class="resultTop">
              <div style="min-width:0">
                <div class="tokenHead">
                  <div class="tokenLogoWrap" id="tokenLogoWrap" aria-hidden="false">
                    <img id="tokenLogo" alt="" style="display:none">
                    <svg class="identicon" id="tokenIdenticon" viewBox="0 0 44 44" aria-hidden="true"></svg>
                  </div>
                  <div style="min-width:0">
                    <div class="tokenName" id="tokenName">—</div>
                    <div class="tokenSymbol" id="tokenSymbol">—</div>
                  </div>
                </div>

                <h3 class="resultTitle" id="verdictTitle">—</h3>
                <div class="mono" id="mintShort">—</div>
              </div>

              <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                <span class="badge" id="verdictBadge">—</span>
                <span class="badge good" id="scoreBadge">—</span>
              </div>
            </div>

            <div class="metricStack" id="metrics"></div>
            <div class="statusLine" id="summary">—</div>

            <!-- KEY SIGNALS -->
            <div class="metricStack" id="keySignals"></div>
          </div>
        </div>

        <div class="analysisGrid">
          <!-- Bubble Map / Graph -->
          <div class="panel" id="vizPanel">
            <div class="panelHead">
              <div>
                <div class="panelTitle">
                  <span class="badge">LIVE</span>
                  Bubble Map • Wallet Graph
                </div>
                <div class="panelSub" id="vizSub">
                  Shows holder bubbles + linked wallet edges (best-effort). Run a scan to populate.
                </div>
              </div>

              <div class="vizControls">
                <div class="seg" role="tablist" aria-label="Visualization mode">
                  <button type="button" id="vizModeBubbles" class="active" aria-selected="true">Bubbles</button>
                  <button type="button" id="vizModeGraph" aria-selected="false" disabled>Graph</button>
                </div>
                <button class="btn" id="btnVizReset" type="button">Reset View</button>
              </div>
            </div>

            <div class="vizWrap">
              <div class="vizTop">
                <div style="min-width:0">
                  <div class="vizTitle">Holders & Clusters (Live)</div>
                  <div class="vizHint" id="vizHint">
                    Tip: Hover for wallet info. Click to open explorer. Zoom with trackpad/wheel.
                  </div>
                </div>
                <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end;">
                  <span class="badge" id="vizStamp">—</span>
                  <span class="badge" id="vizLegend">—</span>
                </div>
              </div>

              <div class="vizStage" id="vizStage">
                <canvas class="vizCanvas" id="vizCanvas"></canvas>
                <div class="vizOverlay" id="vizOverlay">
                  No visualization data yet. Run a scan.
                </div>
              </div>
            </div>
          </div>

          <!-- Cluster Summary -->
          <div class="panel" id="clusterPanel">
            <div class="panelHead">
              <div>
                <div class="panelTitle">
                  <span class="badge">NEW</span>
                  Cluster Intelligence
                </div>
                <div class="panelSub" id="clusterSub">
                  Detects linked wallets, split-wallet patterns, shared funders (best-effort).
                </div>
              </div>
              <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
                <span class="badge" id="clusterStamp">—</span>
              </div>
            </div>

            <div class="clusterGrid" id="clusterGrid">
              <div class="clusterCard">
                <div class="clusterLeft">
                  <div class="clusterT"><span class="dot warn"></span> No scan yet</div>
                  <div class="clusterD">Run a scan to generate cluster groups, linked wallets, and bundle/split heuristics.</div>
                </div>
                <div class="clusterRight">
                  <span class="badge warn">WAIT</span>
                </div>
              </div>
            </div>

            <div class="statusLine" id="clusterFoot" style="margin-top:12px;">—</div>
          </div>
        </div>

        <!-- Checks -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">GUARDIAN CHECKS</div>
            <div class="stamp" id="scanHint">—</div>
          </div>
          <ul class="list" id="checksList" style="margin-top:10px;"></ul>
        </div>

        <!-- Launch readiness -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">LAUNCH READINESS</div>
            <div class="stamp">ACTION LIST</div>
          </div>
          <ul class="list" id="todoList" style="margin-top:10px;"></ul>
        </div>

        <!-- Token standard details -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOKEN STANDARD DETAILS</div>
            <div class="stamp">ON-CHAIN</div>
          </div>
          <ul class="list" id="extList" style="margin-top:10px;"></ul>
        </div>

        <!-- Metadata -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOKEN METADATA</div>
            <div class="stamp">RPC / ON-CHAIN</div>
          </div>
          <ul class="list" id="metaList" style="margin-top:10px;"></ul>
        </div>

        <!-- Top holders -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOP HOLDERS (PREVIEW)</div>
            <div class="stamp" id="holdersStamp">MAINNET</div>
          </div>
          <ul class="list" id="holdersList" style="margin-top:10px;"></ul>
        </div>
      </div>
    </section>

    <footer>© <span id="y"></span> $SOS • Guardian Check</footer>
  </main>

  <!-- Modal -->
  <div class="modalWrap" id="modalWrap" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle" id="modalTitle">Guardian Details</div>
        <button class="btn" id="modalClose" type="button">Close</button>
      </div>
      <div class="modalBody" id="modalBody"></div>
    </div>
  </div>

  <script>
    /* =========================================================
       $SOS GUARDIAN SCANNER — CLEAN REWRITE (single-file)
       - Stable UI + safer scanning + better export (offline)
       - Export includes: brand logo + coin logo + viz snapshot
       - Graph mode enabled only when real edges exist
       ========================================================= */

    /* ========== DOM helpers ========== */
    const qs = (id) => document.getElementById(id);
    const setText = (id, v) => { const el = qs(id); if (el) el.textContent = (v ?? ""); };
    const setHTML = (id, v) => { const el = qs(id); if (el) el.innerHTML = (v ?? ""); };
    const on = (id, ev, fn) => { const el = qs(id); if (el) el.addEventListener(ev, fn); };

    const esc = (x) => String(x ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;");

    function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }
    function shortAddr(a){ return a ? (a.slice(0,4) + "…" + a.slice(-4)) : "—"; }

    function formatUsd(n){
      const x = Number(n);
      if(!Number.isFinite(x)) return "—";
      if(x >= 1e9) return (x/1e9).toFixed(2) + "B";
      if(x >= 1e6) return (x/1e6).toFixed(2) + "M";
      if(x >= 1e3) return (x/1e3).toFixed(2) + "K";
      return x.toFixed(2);
    }

    function fmtInt(n){
      if(n === null || n === undefined || Number.isNaN(n)) return "—";
      try { return new Intl.NumberFormat("en-US").format(Math.round(Number(n))); }
      catch { return String(n); }
    }
    function fmtPct(n){
      if(n === null || n === undefined || Number.isNaN(n)) return "—";
      return `${Number(n).toFixed(2)}%`;
    }

    function pillLabel(sev){ return sev==="ok" ? "PASS" : sev==="bad" ? "FAIL" : "WATCH"; }
    function pillClass(sev){ return sev==="ok" ? "pill ok" : sev==="bad" ? "pill bad" : "pill warn"; }

    /* ========== App State ========== */
    const APP = {
      ACTIVE_CHAIN_ID: "sol",
      SCANNING: false,
      LAST_SCAN: null,
      ABORT: null,            // AbortController for any in-flight scan
      CACHE: new Map(),       // simple memo cache (per run)
      INFO_MAP: new Map(),    // modal content registry
      BRAND_LOGO_DATAURL: "", // cached for export
    };

    /* ========== Icons ========== */
    const ICONS = {
      sol: `
        <svg viewBox="0 0 64 64" aria-hidden="true">
          <defs>
            <linearGradient id="solg" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0" stop-color="${getComputedStyle(document.documentElement).getPropertyValue('--sol-g1').trim() || '#14F195'}"/>
              <stop offset="0.5" stop-color="${getComputedStyle(document.documentElement).getPropertyValue('--sol-g2').trim() || '#00D1FF'}"/>
              <stop offset="1" stop-color="${getComputedStyle(document.documentElement).getPropertyValue('--sol-g3').trim() || '#9945FF'}"/>
            </linearGradient>
          </defs>
          <path d="M14 18c1.6-1.8 3.5-2.7 5.7-2.7h33.6c3.3 0 5 4 2.8 6.5l-6.1 6.8c-1.6 1.8-3.5 2.7-5.7 2.7H10.7c-3.3 0-5-4-2.8-6.5L14 18Z" fill="url(#solg)"/>
          <path d="M14 38.9c1.6-1.8 3.5-2.7 5.7-2.7h33.6c3.3 0 5 4 2.8 6.5l-6.1 6.8c-1.6 1.8-3.5 2.7-5.7 2.7H10.7c-3.3 0-5-4-2.8-6.5L14 38.9Z" fill="url(#solg)" opacity=".7"/>
          <path d="M50 28.5c-1.6 1.8-3.5 2.7-5.7 2.7H10.7c-3.3 0-5-4-2.8-6.5L14 17.9c1.6-1.8 3.5-2.7 5.7-2.7h33.6c3.3 0 5 4 2.8 6.5L50 28.5Z" fill="url(#solg)" opacity=".9"/>
        </svg>
      `,
      eth: `
        <svg viewBox="0 0 64 64" aria-hidden="true">
          <path d="M32 6l16 26-16 9-16-9L32 6Z" fill="currentColor" opacity=".95"/>
          <path d="M32 58l16-22-16 9-16-9 16 22Z" fill="currentColor" opacity=".75"/>
        </svg>
      `,
      bnb: `
        <svg viewBox="0 0 64 64" aria-hidden="true">
          <path fill="${getComputedStyle(document.documentElement).getPropertyValue('--bnb-yellow').trim() || '#F0B90B'}"
            d="M32 6l8.6 8.6L32 23.2l-8.6-8.6L32 6Zm15.4 15.4L56 30l-8.6 8.6-8.6-8.6L47.4 21.4ZM16.6 21.4 25.2 30l-8.6 8.6L8 30l8.6-8.6ZM32 32.8l8.6 8.6L32 50l-8.6-8.6L32 32.8Zm0-6.9 5.1 5.1L32 36.2 26.9 31 32 25.9Z"/>
        </svg>
      `,
      base: `
        <svg viewBox="0 0 64 64" aria-hidden="true">
          <circle cx="32" cy="32" r="26" fill="${getComputedStyle(document.documentElement).getPropertyValue('--base-blue').trim() || '#0052FF'}"/>
          <path d="M27.5 22h8.1c6.2 0 11.2 5 11.2 11.1S41.8 44.2 35.6 44.2h-8.1V22Zm5.3 5.1v12h2.4c3.3 0 6-2.7 6-6s-2.7-6-6-6h-2.4Z"
                fill="#fff"/>
        </svg>
      `
    };

    const CHAINS = [
      { id:"sol",  name:"Solana",   kind:"solana", stamp:"SOL MAINNET",  addrLabel:"Token Mint Address",        placeholder:"Paste token mint (Solana)..." },
      { id:"eth",  name:"Ethereum", kind:"evm",    stamp:"ETH MAINNET",  addrLabel:"Token Contract Address",    placeholder:"Paste ERC-20 contract (0x...)" },
      { id:"bnb",  name:"BNB",      kind:"evm",    stamp:"BNB MAINNET",  addrLabel:"Token Contract Address",    placeholder:"Paste BEP-20 contract (0x...)" },
      { id:"base", name:"Base",     kind:"evm",    stamp:"BASE MAINNET", addrLabel:"Token Contract Address",    placeholder:"Paste Base token contract (0x...)" }
    ];
    function chainObj(){
      return CHAINS.find(c => c.id === APP.ACTIVE_CHAIN_ID) || CHAINS[0];
    }

    /* ========== Live time stamp (Berlin) ========== */
    let STAMP_TIMER = null;
    function updateStampTime(){
      const el = qs("stampTime");
      if(!el) return;
      const now = new Date();
      el.textContent = new Intl.DateTimeFormat("de-DE", {
        timeZone: "Europe/Berlin",
        year: "numeric", month: "2-digit", day: "2-digit",
        hour: "2-digit", minute: "2-digit", second: "2-digit"
      }).format(now);
    }
    function startLiveStampTime(){
      if(STAMP_TIMER) clearInterval(STAMP_TIMER);
      updateStampTime();
      STAMP_TIMER = setInterval(updateStampTime, 1000);
    }

    /* ========== Toast + Modal ========== */
    function showToast(title){
      const t = qs("toast");
      if(!t) return;
      setText("toastTitle", title || "");
      t.style.display = "block";
    }
    function hideToast(){
      const t = qs("toast");
      if(!t) return;
      t.style.display = "none";
    }
    function openModal(title, bodyHtml){
      setText("modalTitle", title || "Guardian Details");
      setHTML("modalBody", bodyHtml || "");
      const w = qs("modalWrap");
      if(w){ w.style.display = "flex"; w.setAttribute("aria-hidden","false"); }
    }
    function closeModal(){
      const w = qs("modalWrap");
      if(w){ w.style.display = "none"; w.setAttribute("aria-hidden","true"); }
    }

    /* ========== Info registry ========== */
    function newInfoId(){ return "i_" + Math.random().toString(36).slice(2) + Date.now().toString(36); }
    function registerInfo(html){ const id = newInfoId(); APP.INFO_MAP.set(id, html); return id; }
    function getInfo(id){ return APP.INFO_MAP.get(id) || ""; }

    function explain(title, bullets){
      const body = (bullets||[]).map(b => `<div style="margin:6px 0">${esc(b)}</div>`).join("");
      return `
        <div style="font-weight:1000; font-size:18px; margin-bottom:10px">${esc(title)}</div>
        <div style="color:rgba(255,255,255,.72); font-weight:850; line-height:1.55">${body}</div>
      `;
    }

    /* ========== Modal click wiring for info pills ========== */
    (function wireInfoClicks(){
      document.addEventListener("click", (e) => {
        const t = e.target;
        const openEl = t?.closest?.("[data-open='1']");
        if(openEl){
          const title = openEl.getAttribute("data-title") || "Details";
          const infoId = openEl.getAttribute("data-info") || "";
          const html = getInfo(infoId);
          if(html) openModal(title, html);
        }
      });
      document.addEventListener("keydown", (e) => {
        if(e.key !== "Enter" && e.key !== " ") return;
        const a = document.activeElement;
        if(a && a.matches && a.matches("[data-open='1']")){
          e.preventDefault();
          const title = a.getAttribute("data-title") || "Details";
          const infoId = a.getAttribute("data-info") || "";
          const html = getInfo(infoId);
          if(html) openModal(title, html);
        }
      });
    })();

    /* ========== Identicon (fallback) ========== */
    function hash32(str){
      let h = 2166136261 >>> 0;
      const s = String(str || "");
      for(let i=0;i<s.length;i++){
        h ^= s.charCodeAt(i);
        h = Math.imul(h, 16777619) >>> 0;
      }
      return h >>> 0;
    }
    function identiconSvg(el, seed){
      if(!el) return;
      const h = hash32(seed || "—");
      const c1 = `hsl(${(h % 360)}, 90%, 55%)`;
      const c2 = `hsl(${((h>>>8) % 360)}, 90%, 45%)`;
      const c3 = `hsl(${((h>>>16) % 360)}, 90%, 60%)`;

      const size = 44;
      const cell = 44 / 5;
      let bits = h ^ (h>>>13) ^ (h>>>7);

      let rects = "";
      for(let y=0;y<5;y++){
        for(let x=0;x<3;x++){
          const on = (bits & 1) === 1;
          bits = (bits >>> 1) | (bits << 31);
          if(on){
            const xx = x * cell;
            const yy = y * cell;
            const fill = ((x+y)%3===0?c1:((x+y)%3===1?c2:c3));
            rects += `<rect x="${xx}" y="${yy}" width="${cell}" height="${cell}" rx="4" fill="${fill}" opacity="0.95"/>`;
            const mx = (4-x) * cell;
            rects += `<rect x="${mx}" y="${yy}" width="${cell}" height="${cell}" rx="4" fill="${fill}" opacity="0.95"/>`;
          }
        }
      }

      el.innerHTML = `
        <defs>
          <linearGradient id="ig" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="${c1}" stop-opacity="0.65"/>
            <stop offset="1" stop-color="${c3}" stop-opacity="0.20"/>
          </linearGradient>
        </defs>
        <rect x="0" y="0" width="${size}" height="${size}" rx="12" fill="rgba(0,0,0,.12)" />
        <rect x="0" y="0" width="${size}" height="${size}" rx="12" fill="url(#ig)" />
        <g>${rects}</g>
      `;
    }

    function applyTokenHeader(meta, addr){
      const nameEl = qs("tokenName");
      const symEl  = qs("tokenSymbol");
      const img    = qs("tokenLogo");
      const ico    = qs("tokenIdenticon");

      const name = (meta?.name || "Token").trim() || "Token";
      const sym  = (meta?.symbol || "").trim();

      if(nameEl) nameEl.textContent = name;
      if(symEl)  symEl.textContent  = sym ? `$${sym}` : `Addr: ${addr ? shortAddr(addr) : "—"}`;

      if(img && ico){
        const hasImg = !!(meta?.image && String(meta.image).trim());
        if(hasImg){
          img.style.display = "block";
          img.src = meta.image;
          img.alt = name;
          ico.style.display = "none";
          img.onerror = () => {
            img.style.display = "none";
            ico.style.display = "block";
            identiconSvg(ico, addr || name);
          };
        }else{
          img.removeAttribute("src");
          img.alt = "";
          img.style.display = "none";
          ico.style.display = "block";
          identiconSvg(ico, addr || name);
        }
      }
    }

    /* ========== Chain UI ========== */
    function renderChainButtons(){
      const row = qs("chainRow");
      if(!row) return;
      row.innerHTML = "";
      for(const c of CHAINS){
        const b = document.createElement("button");
        b.type = "button";
        b.className = "chainBtn" + (c.id === APP.ACTIVE_CHAIN_ID ? " active" : "");
        b.innerHTML = `<span class="chainIcon">${ICONS[c.id] || ""}</span><span>${esc(c.name)}</span>`;
        b.addEventListener("click", () => setActiveChain(c.id, true));
        row.appendChild(b);
      }
    }

    function resetUiForNewChain(){
      setText("status", "");
      setText("mintShort", "—");
      setText("verdictTitle", "—");
      setText("verdictBadge", "—");
      setText("scoreBadge", "—");
      setText("summary", "—");
      setText("scanHint", "—");
      setText("vizStamp", "—");
      setText("vizLegend", "—");
      setText("vizSub", "Shows holder bubbles + linked wallet edges (best-effort). Run a scan to populate.");
      setText("clusterFoot", "—");

      const idsToClear = ["metrics","checksList","todoList","extList","metaList","holdersList","keySignals"];
      for(const id of idsToClear){
        const el = qs(id);
        if(el) el.innerHTML = "";
      }

      const overlay = qs("vizOverlay");
      if(overlay){
        overlay.style.display = "flex";
        overlay.textContent = "No visualization data yet. Run a scan.";
      }

      // disable graph
      setGraphAvailability(false);
      setVizMode("bubbles", true);

      const grid = qs("clusterGrid");
      if(grid){
        grid.innerHTML = `
          <div class="clusterCard">
            <div class="clusterLeft">
              <div class="clusterT"><span class="dot warn"></span> No scan yet</div>
              <div class="clusterD">Run a scan to generate cluster groups, linked wallets, and bundle/split heuristics.</div>
            </div>
            <div class="clusterRight">
              <span class="badge warn">WAIT</span>
            </div>
          </div>
        `;
      }

      applyTokenHeader({name:"—", symbol:"", image:""}, "");
      APP.LAST_SCAN = null;
      const exBtn = qs("btnExport");
      if(exBtn) exBtn.disabled = true;
    }

    function setActiveChain(chainId, pushUrl){
      const found = CHAINS.find(x => x.id === chainId) || CHAINS[0];
      APP.ACTIVE_CHAIN_ID = found.id;

      renderChainButtons();
      setText("holdersStamp", found.stamp || "MAINNET");
      setText("clusterStamp", found.stamp || "MAINNET");
      setText("scanHint", found.stamp || "MAINNET");
      setText("addrLabel", found.addrLabel || "Token Address");
      setText("netStamp", found.stamp || "MAINNET");

      const mint = qs("mint");
      if(mint) mint.placeholder = found.placeholder || "Paste token address...";

      setText("chainHint",
        found.kind === "solana"
          ? "Solana: validates base58 mint. On-chain checks via RPC; holders via largest accounts."
          : "EVM: validates 0x address. On-chain reads via public RPC. Holders/Transfers need an indexer key."
      );

      resetUiForNewChain();

      if(pushUrl){
        const url = new URL(location.href);
        url.searchParams.set("chain", found.id);
        history.replaceState({}, "", url.toString());
      }
    }

    /* ========== Render helpers ========== */
    function renderList(listEl, items, defaultTitle){
      if(!listEl) return;
      listEl.innerHTML = "";
      const arr = Array.isArray(items) ? items : [];

      for(const it of arr){
        const sev = it.sev || "warn";
        const title = it.t || defaultTitle || "Details";
        const desc = it.d || "—";
        const infoTitle = it.infoTitle || title;
        const html = (it.infoHtml && String(it.infoHtml).trim())
          ? String(it.infoHtml)
          : explain(infoTitle, [
              desc,
              it.why ? ("Why: " + it.why) : "Why: best-effort.",
              "Status: " + pillLabel(sev)
            ]);

        const infoId = registerInfo(html);

        const li = document.createElement("li");
        li.className = "li";
        li.innerHTML = `
          <div class="left">
            <div class="t">${esc(title)}</div>
            <div class="d">${esc(desc)}</div>
          </div>
          <div class="pillRow">
            <span class="${pillClass(sev)}" role="button" tabindex="0"
                  data-open="1" data-title="${esc(infoTitle)}" data-info="${esc(infoId)}">${pillLabel(sev)}</span>
            <button class="infoBtn" type="button" aria-label="Info"
                    data-open="1" data-title="${esc(infoTitle)}" data-info="${esc(infoId)}"><span>i</span></button>
          </div>
        `;
        listEl.appendChild(li);
      }

      if(!arr.length){
        const li = document.createElement("li");
        li.className = "li";
        li.innerHTML = `
          <div class="left">
            <div class="t">${esc(defaultTitle || "No data")}</div>
            <div class="d">—</div>
          </div>
          <div class="pillRow"><span class="pill warn">WATCH</span></div>
        `;
        listEl.appendChild(li);
      }
    }

    function renderMetrics(rows){
      const wrap = qs("metrics");
      if(!wrap) return;
      wrap.innerHTML = "";

      const arr = Array.isArray(rows) ? rows : [];
      for(const r of arr){
        const d = document.createElement("div");
        d.className = "metric";
        const bar = (typeof r.barPct === "number")
          ? `<div class="bar"><div style="width:${clamp(r.barPct,0,100)}%"></div></div>`
          : "";
        d.innerHTML = `
          <div class="metricK">
            <span>${esc(r.label || "—")}</span>
            <span class="badge" style="opacity:.9">${esc(r.badge || r.value || "—")}</span>
          </div>
          <div class="metricV">${esc(r.value || "—")}</div>
          <div class="metricMini">${esc(r.mini || "")}</div>
          ${bar}
        `;
        wrap.appendChild(d);
      }
    }

    function srcBadge(src){
      const s = String(src || "heur").toLowerCase();
      const cls =
        s.includes("on") ? "onchain" :
        s.includes("index") ? "indexer" :
        s.includes("api") ? "api" : "heur";
      const label =
        cls === "onchain" ? "On-chain verified" :
        cls === "indexer" ? "Indexer required" :
        cls === "api" ? "API signal" : "Heuristic";
      return `<span class="badge src ${cls}">${esc(label)}</span>`;
    }
    function sevToBadge(sev){
  const ok = sev === "ok";
  const bad = sev === "bad";
  const cls = ok ? "badge good" : bad ? "badge bad" : "badge warn";
  const icon = ok ? "↑" : bad ? "↓" : "→";
  const label = ok ? "YES" : bad ? "NO" : "UNKNOWN";
  return `<span class="${cls}">${icon} ${label}</span>`;
}
    function renderKeySignals(signals){
      const wrap = qs("keySignals");
      if(!wrap) return;
      wrap.innerHTML = "";

      const rows = Array.isArray(signals) ? signals : [];
      for(const s of rows){
        const div = document.createElement("div");
        div.className = "signalCard";
        div.innerHTML = `
          <div class="signalTop">
            <div class="signalK">${esc(s.k || "Signal")}</div>
            <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
              ${srcBadge(s.src || "heur")}
              ${sevToBadge(s.sev || "warn")}
            </div>
          </div>
          <div class="signalV">${esc(s.v || "—")}</div>
          <div class="signalMini">${esc(s.mini || "")}</div>
        `;
        wrap.appendChild(div);
      }

      if(!rows.length){
        wrap.innerHTML = `<div class="signalCard"><div class="signalK">Key Signals</div><div class="signalV">—</div></div>`;
      }
    }

    /* ========== Verdict ========== */
    function setVerdict(score, critical){
      const badge = qs("verdictBadge");
      const scoreEl = qs("scoreBadge");
      if(scoreEl) scoreEl.textContent = `SCORE ${score}/100`;

      let title = "WATCHLIST";
      let sev = "warn";
      if(score >= 85 && !critical){ title = "GUARDIAN APPROVED"; sev = "ok"; }
      else if(score >= 70){ title = "CONDITIONAL PASS"; sev = "warn"; }
      else { title = "HIGH RISK"; sev = "bad"; }

      setText("verdictTitle", title);
      if(badge){
        badge.className = "badge " + (sev==="ok" ? "good" : sev==="bad" ? "bad" : "warn");
        badge.textContent = sev==="ok" ? "APPROVED" : sev==="bad" ? "RISK" : "WATCH";
      }
      if(scoreEl){
        scoreEl.className = "badge " + (score >= 85 ? "good" : score >= 60 ? "warn" : "bad");
      }
    }

    function setScanButtons(disabled){
      const b1 = qs("btnScan");
      const b2 = qs("btnScanInline");
      if(b1) b1.disabled = !!disabled;
      if(b2) b2.disabled = !!disabled;
      const b3 = qs("btnExport");
      if(b3 && disabled) b3.disabled = true;
    }

    function setStatus(msg){ setText("status", msg || ""); }

    /* =========================================================
       CONFIG (keys stored locally — DO NOT hardcode secrets in prod)
       ========================================================= */
    const CFG_DEFAULT = {
  HELIUS_KEY: "b566a086-57d4-4433-8661-faed9ad07ba0",
  GOLDRUSH_API_KEY: "cqt_rQVTMTXwYkPJBrwf7ff6JWmdkywR",
      EVM_RPCS: {
        1:    ["https://ethereum.publicnode.com", "https://rpc.ankr.com/eth", "https://cloudflare-eth.com"],
        56:   ["https://bsc.publicnode.com", "https://rpc.ankr.com/bsc", "https://bsc-dataseed.binance.org"],
        8453: ["https://base.publicnode.com", "https://mainnet.base.org", "https://rpc.ankr.com/base"]
      },
      TOKEN_PROGRAM: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
      TOKEN_2022_PROGRAM: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb"
    };

    const CFG = loadCfg();

    function loadCfg(){
      try{
        const raw = localStorage.getItem("sos_guardian_cfg_v1");
        if(!raw) return {...CFG_DEFAULT};
        const j = JSON.parse(raw);
        return {
          ...CFG_DEFAULT,
          ...j,
          EVM_RPCS: {...CFG_DEFAULT.EVM_RPCS, ...(j?.EVM_RPCS || {})}
        };
      }catch{
        return {...CFG_DEFAULT};
      }
    }
    function saveCfg(next){
      try{
        localStorage.setItem("sos_guardian_cfg_v1", JSON.stringify(next));
      }catch{}
    }

    function openKeysModal(){
      const html = `
        ${explain("API Keys (local only)", [
          "Keys are stored in your browser (localStorage).",
          "For production: move calls to a backend to avoid exposing keys publicly.",
          "You can run without keys, but EVM holder/transfer graph needs GoldRush; Solana RPC needs Helius for best results."
        ])}

        <div class="field">
          <label>Helius (b566a086-57d4-4433-8661-faed9ad07ba0)</label>
          <input id="k_helius" placeholder="paste helius key..." value="${esc(CFG.HELIUS_KEY || "")}">
          <div class="help">Used for Solana RPC methods like getAccountInfo / getAsset. Without it, Solana scan may fail.</div>
        </div>

        <div class="field">
          <label>GoldRush / Covalent key (EVM holders + transfers)</label>
          <input id="k_goldrush" placeholder="paste goldrush key..." value="${esc(CFG.GOLDRUSH_API_KEY || "")}">
          <div class="help">Used for EVM top holders + transfer graph. Without it, EVM holder list & graph will be limited.</div>
        </div>

        <div class="modalActions">
          <button class="btn" type="button" id="k_cancel">Cancel</button>
          <button class="btn grad" type="button" id="k_save">Save</button>
        </div>
      `;
      openModal("API Keys", html);

      setTimeout(() => {
        const bCancel = document.getElementById("k_cancel");
        const bSave = document.getElementById("k_save");
        if(bCancel) bCancel.onclick = closeModal;
        if(bSave) bSave.onclick = () => {
          const helius = (document.getElementById("k_helius")?.value || "").trim();
          const gold = (document.getElementById("k_goldrush")?.value || "").trim();
          CFG.HELIUS_KEY = helius;
          CFG.GOLDRUSH_API_KEY = gold;
          saveCfg({
            HELIUS_KEY: CFG.HELIUS_KEY,
            GOLDRUSH_API_KEY: CFG.GOLDRUSH_API_KEY,
            EVM_RPCS: CFG.EVM_RPCS
          });
          closeModal();
          showToast("Saved keys locally.");
        };
      }, 0);
    }

    /* =========================================================
       ADDRESS VALIDATION + EXPLORERS
       ========================================================= */
    function looksBase58(s){
      return typeof s === "string" && s.length >= 32 && s.length <= 52 && /^[1-9A-HJ-NP-Za-km-z]+$/.test(s);
    }
    function looksEvmAddress(s){
      return typeof s === "string" && /^0x[0-9a-fA-F]{40}$/.test(s.trim());
    }
    function explorerBase(chainId){
      if(chainId === "sol")  return {name:"Solscan", base:"https://solscan.io/account/"};
      if(chainId === "eth")  return {name:"Etherscan", base:"https://etherscan.io/address/"};
      if(chainId === "bnb")  return {name:"BscScan", base:"https://bscscan.com/address/"};
      if(chainId === "base") return {name:"BaseScan", base:"https://basescan.org/address/"};
      return {name:"Explorer", base:"#"};
    }

    /* =========================================================
       NETWORK: SAFE FETCH + CACHING + ABORT
       ========================================================= */
    async function safeFetch(url, opts = {}, { timeoutMs = 15000, key = "" } = {}){
  const cacheKey = key || (opts?.method || "GET") + "::" + url;

  // Always return a fresh clone from cache
  const cached = APP.CACHE.get(cacheKey);
  if(cached){
    try { return cached.clone(); } catch { /* fallthrough */ }
  }

  const ctrl = new AbortController();
  const t = setTimeout(() => ctrl.abort(), timeoutMs);

  const signals = [];
  if(opts.signal) signals.push(opts.signal);
  signals.push(ctrl.signal);

  const combined = new AbortController();
  const onAbort = () => combined.abort();

  for(const s of signals){
    if(!s) continue;
    if(s.aborted){ combined.abort(); break; }
    s.addEventListener("abort", onAbort, { once:true });
  }

  try{
    const res = await fetch(url, { ...opts, signal: combined.signal });
    if(!res.ok){
      const tx = await res.text().catch(()=> "");
      throw new Error(`HTTP ${res.status}: ${tx.slice(0,140)}`);
    }

    // Cache ORIGINAL (unread), return a clone to callers
    APP.CACHE.set(cacheKey, res);
    return res.clone();
  } finally {
    clearTimeout(t);
    for(const s of signals){
      try{ s.removeEventListener("abort", onAbort); }catch{}
    }
  }
}

    /* =========================================================
       DEXSCREENER
       ========================================================= */
    async function fetchDexscreenerToken(addr, signal){
      try{
        const r = await safeFetch(`https://api.dexscreener.com/latest/dex/tokens/${encodeURIComponent(addr)}`, { signal }, { timeoutMs: 14000 });
        const j = await r.json();
        const pairs = Array.isArray(j?.pairs) ? j.pairs : [];
        if(!pairs.length) return { pairs: [] };
        const best = pairs.slice().sort((a,b)=> (Number(b?.liquidity?.usd||0) - Number(a?.liquidity?.usd||0)))[0] || pairs[0];
        return { best, pairs };
      }catch{
        return null;
      }
    }

    /* =========================================================
       SOLANA ENGINE (Helius RPC)
       ========================================================= */
    function SOL_RPC_URLS(){
  const urls = [];
  if(CFG.HELIUS_KEY && CFG.HELIUS_KEY.trim()){
    urls.push(`https://mainnet.helius-rpc.com/?api-key=${encodeURIComponent(CFG.HELIUS_KEY.trim())}`);
  }
  // Fallbacks (best-effort, CORS/rate limits können je nach Provider variieren)
  urls.push(
    "https://api.mainnet-beta.solana.com",
    "https://rpc.ankr.com/solana"
  );
  return urls;
}

async function solRpc(method, params, signal){
  const urls = SOL_RPC_URLS();
  const errors = [];

  for(const url of urls){
    try{
      const res = await safeFetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ jsonrpc:"2.0", id:1, method, params }),
        signal
      }, { timeoutMs: 20000, key: `${url}::${method}::${JSON.stringify(params)}` });

      const j = await res.json();
      if(j?.error){
        const msg = String(j.error?.message || "Solana RPC error");
        errors.push(`${url.split("/")[2]}: ${msg}`);
        // wenn Helius 403 -> probier direkt Fallback
        continue;
      }
      return j.result;
    }catch(e){
      errors.push(`${url.split("/")[2]}: ${String(e?.message||e).slice(0,120)}`);
    }
  }
  throw new Error(`All Solana RPCs failed. ${errors.slice(-3).join(" • ")}`);
}

    async function getMintParsed(mint, signal){
      const r = await solRpc("getAccountInfo", [mint, { encoding:"jsonParsed", commitment:"confirmed" }], signal);
      const v = r?.value;
      if(!v) return null;
      const owner = v.owner;
      const parsed = (v.data && typeof v.data === "object") ? v.data.parsed : null;
      const info = parsed?.info || null;
      return { owner, info, rawParsed: parsed };
    }
    async function getTokenSupply(mint, signal){
      const r = await solRpc("getTokenSupply", [mint], signal);
      return r?.value || null;
    }
    async function getLargest(mint, signal){
      const r = await solRpc("getTokenLargestAccounts", [mint], signal);
      return r?.value || [];
    }
    async function getMultipleAccounts(addrs, signal){
      const res = await solRpc("getMultipleAccounts", [addrs, { encoding:"jsonParsed", commitment:"confirmed" }], signal);
      return Array.isArray(res?.value) ? res.value : [];
    }
    async function getTokenAccountOwners(tokenAccountAddrs, signal){
      const addrs = (tokenAccountAddrs || []).filter(Boolean);
      if(!addrs.length) return [];
      const values = await getMultipleAccounts(addrs, signal);
      return values.map(v => v?.data?.parsed?.info?.owner || null);
    }
    async function getAsset(mint, signal){
      try { return await solRpc("getAsset", [mint], signal); }
      catch { return null; }
    }
    function pickTokenMetaFromAsset(asset){
      if(!asset) return null;
      const md = asset?.content?.metadata || {};
      const name = (md?.name || asset?.metadata?.name || "").trim();
      const symbol = (md?.symbol || asset?.metadata?.symbol || "").trim();

      let image = "";
      const linksImg = asset?.content?.links?.image;
      if(typeof linksImg === "string") image = linksImg;
      if(!image && Array.isArray(asset?.content?.files)){
        const f = asset.content.files.find(x => (x?.mime || "").includes("image") && x?.uri);
        if(f?.uri) image = f.uri;
      }

      const uri = (asset?.content?.json_uri || asset?.content?.links?.external_url || "").trim();
      const description = (md?.description || asset?.content?.metadata?.description || "").trim();
      return { name, symbol, image, uri, description };
    }

    /* =========================================================
       EVM ENGINE (public RPC best-effort)
       ========================================================= */
    async function evmRpc(chainId, method, params, signal){
      const urls = CFG.EVM_RPCS[chainId] || [];
      if(!urls.length) throw new Error("No RPC configured for this chain.");

      const errors = [];
      for(const url of urls){
        try{
          const res = await safeFetch(url, {
            method:"POST",
            headers:{ "Content-Type":"application/json" },
            body: JSON.stringify({ jsonrpc:"2.0", id:1, method, params }),
            signal
          }, { timeoutMs: 14000, key: `${url}::${method}::${JSON.stringify(params)}` });

          const j = await res.json();
          if(j?.error){
            errors.push(String(j.error?.message || "RPC error").slice(0,120));
            continue;
          }
          return j.result;
        }catch(e){
          errors.push(String(e?.message || e).slice(0,120));
        }
      }
      throw new Error(`All RPCs failed. ${errors.slice(-3).join(" • ")}`);
    }

    async function ethCall(chainId, to, data, signal){
      return await evmRpc(chainId, "eth_call", [{to, data}, "latest"], signal);
    }
    async function getCode(chainId, addr, signal){
      return await evmRpc(chainId, "eth_getCode", [addr, "latest"], signal);
    }
    async function getStorageAt(chainId, addr, slot, signal){
      return await evmRpc(chainId, "eth_getStorageAt", [addr, slot, "latest"], signal);
    }

    const SEL = {
      name: "0x06fdde03",
      symbol: "0x95d89b41",
      decimals: "0x313ce567",
      totalSupply: "0x18160ddd",
      owner: "0x8da5cb5b",
      paused: "0x5c975abb"
    };

    function strip0x(h){ return (h||"").startsWith("0x") ? h.slice(2) : (h||""); }
    function decodeUint256(hex){
      const h = strip0x(hex);
      if(!h) return null;
      const padded = h.padStart(64,"0").slice(-64);
      try { return BigInt("0x"+padded); } catch { return null; }
    }
    function decodeAddressFrom32(hex){
      const h = strip0x(hex);
      if(!h) return null;
      const padded = h.padStart(64,"0").slice(-40);
      return "0x" + padded;
    }
    function bytes32ToAscii(hex){
      const h = strip0x(hex);
      if(h.length !== 64) return "";
      try{
        const bytes = new Uint8Array(h.match(/.{1,2}/g).map(b => parseInt(b,16)));
        let s = new TextDecoder().decode(bytes).replace(/\0/g,"").trim();
        if(!s) return "";
        if(/^[\x20-\x7E]+$/.test(s)) return s;
        return "";
      }catch{ return ""; }
    }
    function decodeString(hex){
      const data = strip0x(hex);
      if(!data) return "";
      if(data.length === 64){
        const b = bytes32ToAscii("0x"+data);
        if(b) return b;
      }
      if(data.length < 128) return "";
      const lenHex = data.slice(64,128);
      let len = 0;
      try { len = Number(BigInt("0x"+lenHex)); } catch { return ""; }
      if(!Number.isFinite(len) || len <= 0) return "";
      const strData = data.slice(128, 128 + len*2);
      if(!strData) return "";
      try{
        const bytes = new Uint8Array(strData.match(/.{1,2}/g).map(b => parseInt(b,16)));
        return new TextDecoder().decode(bytes).replace(/\0/g,"").trim();
      }catch{ return ""; }
    }

    async function getErc20Meta(chainId, addr, signal){
      const out = { name:"", symbol:"", decimals:null, totalSupply:null };
      try { out.name = decodeString(await ethCall(chainId, addr, SEL.name, signal)); } catch {}
      try { out.symbol = decodeString(await ethCall(chainId, addr, SEL.symbol, signal)); } catch {}
      try {
        const v = decodeUint256(await ethCall(chainId, addr, SEL.decimals, signal));
        out.decimals = (v === null) ? null : Number(v);
        if(!Number.isFinite(out.decimals)) out.decimals = null;
      } catch {}
      try { out.totalSupply = decodeUint256(await ethCall(chainId, addr, SEL.totalSupply, signal)); } catch {}
      return out;
    }
    async function getOwner(chainId, addr, signal){
      try{ return decodeAddressFrom32(await ethCall(chainId, addr, SEL.owner, signal)); }
      catch{ return null; }
    }
    async function getPaused(chainId, addr, signal){
      try{
        const r = await ethCall(chainId, addr, SEL.paused, signal);
        const v = decodeUint256(r || "0x");
        if(v === null) return null;
        return v !== 0n;
      }catch{
        return null;
      }
    }

    /* Proxy detection (EIP-1967) */
    const SLOT_IMPL  = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
    const SLOT_ADMIN = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103";
    async function detectProxy(chainId, addr, signal){
      try{
        const [implRaw, adminRaw] = await Promise.all([
          getStorageAt(chainId, addr, SLOT_IMPL, signal),
          getStorageAt(chainId, addr, SLOT_ADMIN, signal)
        ]);
        const impl  = decodeAddressFrom32(implRaw  || "0x");
        const admin = decodeAddressFrom32(adminRaw || "0x");
        const zero = "0x0000000000000000000000000000000000000000";
        const implNonZero  = impl  && impl.toLowerCase()  !== zero;
        const adminNonZero = admin && admin.toLowerCase() !== zero;
        return { isProxy: implNonZero || adminNonZero, implementation: implNonZero ? impl : null, admin: adminNonZero ? admin : null };
      }catch{
        return {isProxy:false, implementation:null, admin:null};
      }
    }

    /* TrustWallet logo fallback (EVM) */
    function trustWalletLogo(chainId, addr){
      const a = String(addr || "").trim();
      if(!a) return [];
      const lower = a.toLowerCase();
      const base =
        chainId === 1    ? "ethereum"
        : chainId === 56 ? "smartchain"
        : chainId === 8453 ? "base"
        : "ethereum";
      return [
        `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/${base}/assets/${a}/logo.png`,
        `https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/${base}/assets/${lower}/logo.png`
      ];
    }

    function applyTokenHeaderWithEvmLogo(meta, addr, evmChainId){
      const m = { ...(meta||{}) };
      const imgCandidates = [];
      if(m.image) imgCandidates.push(String(m.image).trim());
      for(const u of trustWalletLogo(evmChainId, addr)) imgCandidates.push(u);

      const img  = qs("tokenLogo");
      const ico  = qs("tokenIdenticon");

      const name = (m?.name || "Token").trim() || "Token";
      const symbol = (m?.symbol || "").trim();

      setText("tokenName", name);
      setText("tokenSymbol", symbol ? `$${symbol}` : `Addr: ${shortAddr(addr)}`);

      let idx = 0;
      function tryNext(){
        if(!img || !ico) return;
        if(idx >= imgCandidates.length){
          img.style.display = "none";
          ico.style.display = "block";
          identiconSvg(ico, addr || name);
          return;
        }
        const u = imgCandidates[idx++];
        img.style.display = "block";
        ico.style.display = "none";
        img.src = u;
        img.alt = name;
      }

      if(img){
        img.onerror = () => tryNext();
      }
      tryNext();
    }

    /* =========================================================
       INDEXER (GoldRush) — holders + transfers
       ========================================================= */
    function goldrushChain(chainId){
      if(chainId === 1) return "eth-mainnet";
      if(chainId === 56) return "bsc-mainnet";
      if(chainId === 8453) return "base-mainnet";
      return "eth-mainnet";
    }
    async function goldrushHolders(chainId, addr, signal){
      if(!CFG.GOLDRUSH_API_KEY) return [];
      const url = `https://api.covalenthq.com/v1/${goldrushChain(chainId)}/tokens/${addr}/token_holders/?page-size=10&key=${encodeURIComponent(CFG.GOLDRUSH_API_KEY)}`;
      try{
        const r = await safeFetch(url, { signal }, { timeoutMs: 20000 });
        const j = await r.json();
        return Array.isArray(j?.data?.items) ? j.data.items : [];
      }catch{
        return [];
      }
    }
    async function goldrushTransfers(chainId, tokenAddr, pageSize=200, signal){
      if(!CFG.GOLDRUSH_API_KEY) return [];
      const url = `https://api.covalenthq.com/v1/${goldrushChain(chainId)}/tokens/${tokenAddr}/token_transfers/?page-size=${pageSize}&key=${encodeURIComponent(CFG.GOLDRUSH_API_KEY)}`;
      try{
        const r = await safeFetch(url, { signal }, { timeoutMs: 22000 });
        const j = await r.json();
        return Array.isArray(j?.data?.items) ? j.data.items : [];
      }catch{
        return [];
      }
    }

    function pctFromRaw(balanceRaw, totalSupplyRaw){
      try{
        const bal = BigInt(balanceRaw);
        const sup = BigInt(totalSupplyRaw);
        if(sup <= 0n) return 0;
        const scaled = (bal * 1000000n) / sup; // percent * 10000
        return Number(scaled) / 10000;
      }catch{
        return 0;
      }
    }
    function normalizePct(p){
      const x = Number(p);
      if(!Number.isFinite(x) || x < 0) return 0;
      if(x > 0 && x <= 1) return x * 100;
      if(x > 1000) return x / 100;
      return x;
    }

    /* =========================================================
       VIZ ENGINE — stable coordinate system (CSS px)
       ========================================================= */
    const VIZ = {
      mode: "bubbles",
      nodes: [],
      edges: [],
      panX: 0, panY: 0,
      zoom: 1,
      dragging: false,
      lastX: 0, lastY: 0,
      hoverAddr: ""
    };

    function setGraphAvailability(hasEdges){
      const g = qs("vizModeGraph");
      if(!g) return;
      g.disabled = !hasEdges;
      if(!hasEdges && (VIZ.mode === "graph")){
        setVizMode("bubbles");
      }
    }

    function setVizMode(mode, silent){
      const next = (mode === "graph") ? "graph" : "bubbles";
      if(next === "graph"){
        const g = qs("vizModeGraph");
        if(g && g.disabled){
          if(!silent) showToast("Graph mode is disabled until real relationship edges exist.");
          return;
        }
      }
      VIZ.mode = next;
      const b1 = qs("vizModeBubbles");
      const b2 = qs("vizModeGraph");
      if(b1 && b2){
        b1.classList.toggle("active", VIZ.mode === "bubbles");
        b2.classList.toggle("active", VIZ.mode === "graph");
        b1.setAttribute("aria-selected", VIZ.mode === "bubbles" ? "true" : "false");
        b2.setAttribute("aria-selected", VIZ.mode === "graph" ? "true" : "false");
      }
      drawViz();
    }

    function resetViz(){
      VIZ.panX = 0;
      VIZ.panY = 0;
      VIZ.zoom = 1;
      VIZ.hoverAddr = "";
      drawViz();
    }

    function resizeCanvas(){
      const canvas = qs("vizCanvas");
      const stage  = qs("vizStage");
      if(!canvas || !stage) return;
      const rect = stage.getBoundingClientRect();
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(rect.width * dpr);
      canvas.height = Math.floor(rect.height * dpr);
      canvas.dataset.dpr = String(dpr);
      drawViz();
    }

    function packNoOverlap(nodes, W, H){
      const cx = W/2, cy = H/2;
      const ITER = 220;

      for(const n of nodes){
        if(!Number.isFinite(n.x)) n.x = cx + (Math.random()-0.5)*W*0.6;
        if(!Number.isFinite(n.y)) n.y = cy + (Math.random()-0.5)*H*0.6;
      }

      const maxR = nodes.reduce((m,n)=>Math.max(m, n.r||14), 14);
      const cellSize = Math.max(28, Math.floor((maxR*2)+10));

      for(let k=0;k<ITER;k++){
        const grid = new Map();
        function key(ix,iy){ return ix+"|"+iy; }
        function put(i, x, y){
          const ix = Math.floor(x / cellSize);
          const iy = Math.floor(y / cellSize);
          const kk = key(ix,iy);
          if(!grid.has(kk)) grid.set(kk, []);
          grid.get(kk).push(i);
        }

        for(let i=0;i<nodes.length;i++) put(i, nodes[i].x, nodes[i].y);

        for(const n of nodes){
          n.x += (cx - n.x) * 0.0032;
          n.y += (cy - n.y) * 0.0032;
        }

        for(let i=0;i<nodes.length;i++){
          const a = nodes[i];
          const aix = Math.floor(a.x / cellSize);
          const aiy = Math.floor(a.y / cellSize);

          for(let oy=-1; oy<=1; oy++){
            for(let ox=-1; ox<=1; ox++){
              const kk = key(aix+ox, aiy+oy);
              const list = grid.get(kk);
              if(!list) continue;

              for(const j of list){
                if(j <= i) continue;
                const b = nodes[j];
                const dx = b.x - a.x;
                const dy = b.y - a.y;
                const dist = Math.sqrt(dx*dx + dy*dy) || 0.001;
                const min = (a.r + b.r) + 6;
                if(dist < min){
                  const push = (min - dist) / dist * 0.52;
                  const px = dx * push;
                  const py = dy * push;
                  a.x -= px; a.y -= py;
                  b.x += px; b.y += py;
                }
              }
            }
          }
        }

        for(const n of nodes){
          n.x = clamp(n.x, 40, W-40);
          n.y = clamp(n.y, 40, H-40);
        }
      }
    }

    function buildBubblesFromHolders(holderItems){
      const stage = qs("vizStage");
      if(!stage) return;

      const rect = stage.getBoundingClientRect();
      const W = Math.max(520, rect.width || 820);
      const H = Math.max(360, rect.height || 420);

      const items = Array.isArray(holderItems) ? holderItems : [];
      const nodes = [];

      for(const it of items){
        const pct = Number(it.pct || 0);
        const r = clamp(10 + (pct * 2.4), 12, 52);
        nodes.push({
          x: NaN, y: NaN,
          r,
          sev: it.sev || "ok",
          addr: it.addr || "",
          label: it.label || shortAddr(it.addr || ""),
          sub: it.sub || (pct ? (pct.toFixed(2)+"%") : ""),
          pct
        });
      }

      packNoOverlap(nodes, W, H);

      VIZ.nodes = nodes;
      VIZ.edges = [];
      VIZ.panX = 0;
      VIZ.panY = 0;
      VIZ.zoom = 1;
      VIZ.hoverAddr = "";

      const overlay = qs("vizOverlay");
      if(overlay) overlay.style.display = nodes.length ? "none" : "flex";

      setGraphAvailability(false);
      drawViz();
    }

    function drawViz(){
      const canvas = qs("vizCanvas");
      const stage  = qs("vizStage");
      if(!canvas || !stage) return;
      const ctx = canvas.getContext("2d");
      if(!ctx) return;

      const dpr = Number(canvas.dataset.dpr || 1);
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0,0,w,h);

      const rect = stage.getBoundingClientRect();
      const W = rect.width || 1;
      const H = rect.height || 1;

      const nodes = VIZ.nodes || [];
      const edges = VIZ.edges || [];

      if(!nodes.length){
        ctx.save();
        ctx.globalAlpha = 0.22;
        for(let y=20*dpr;y<h;y+=34*dpr){
          for(let x=20*dpr;x<w;x+=34*dpr){
            ctx.beginPath();
            ctx.arc(x,y,1.2*dpr,0,Math.PI*2);
            ctx.fillStyle = "rgba(255,255,255,0.18)";
            ctx.fill();
          }
        }
        ctx.restore();
        return;
      }

      // transform (CSS px -> canvas px)
      ctx.save();
      ctx.translate((VIZ.panX)*dpr, (VIZ.panY)*dpr);
      ctx.scale(VIZ.zoom, VIZ.zoom);

      // edges first
      if(VIZ.mode === "graph" && edges.length){
        ctx.globalAlpha = 0.35;
        ctx.lineWidth = 1.2*dpr;
        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        for(const e of edges){
          const a = nodes[e.a];
          const b = nodes[e.b];
          if(!a || !b) continue;
          ctx.beginPath();
          ctx.moveTo((a.x||0)*dpr, (a.y||0)*dpr);
          ctx.lineTo((b.x||0)*dpr, (b.y||0)*dpr);
          ctx.stroke();
        }
      }

      // nodes
      for(const n of nodes){
        const fill = n.sev === "bad" ? "rgba(255,120,150,0.30)"
                   : n.sev === "warn" ? "rgba(255,220,130,0.24)"
                   : "rgba(20,241,149,0.22)";

        ctx.globalAlpha = 0.95;
        ctx.beginPath();
        ctx.arc((n.x||0)*dpr, (n.y||0)*dpr, (n.r||14)*dpr, 0, Math.PI*2);
        ctx.fillStyle = fill;
        ctx.fill();

        // hover ring
        const isHover = !!(VIZ.hoverAddr && n.addr && String(n.addr).toLowerCase() === String(VIZ.hoverAddr).toLowerCase());
        ctx.globalAlpha = 0.9;
        ctx.lineWidth = (isHover ? 2.2 : 1.2) * dpr;
        ctx.strokeStyle = isHover ? "rgba(255,255,255,0.35)" : "rgba(255,255,255,0.14)";
        ctx.stroke();

        // labels
        const showLabel =
          (typeof n.pct === "number" && n.pct >= 2.0) ||
          isHover ||
          (VIZ.zoom >= 1.6);

        const label = showLabel ? (n.sub || "") : "";
        if(label){
          ctx.globalAlpha = 0.9;
          ctx.fillStyle = "rgba(255,255,255,0.82)";
          ctx.font = `${12*dpr}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(label, (n.x||0)*dpr, ((n.y||0) + (n.r||14) + 12)*dpr);
        }
      }

      ctx.restore();
    }

    // tooltip
    let VIZ_TIP = null;
    function ensureVizTooltip(){
      const stage = qs("vizStage");
      if(!stage) return null;
      if(VIZ_TIP) return VIZ_TIP;

      const d = document.createElement("div");
      d.style.position = "absolute";
      d.style.left = "0";
      d.style.top = "0";
      d.style.transform = "translate(-9999px,-9999px)";
      d.style.pointerEvents = "none";
      d.style.padding = "10px 10px";
      d.style.borderRadius = "14px";
      d.style.border = "1px solid rgba(255,255,255,.14)";
      d.style.background = "rgba(7,7,17,.92)";
      d.style.backdropFilter = "blur(10px)";
      d.style.color = "rgba(255,255,255,.92)";
      d.style.fontWeight = "900";
      d.style.fontSize = "12.5px";
      d.style.lineHeight = "1.35";
      d.style.maxWidth = "260px";
      d.style.boxShadow = "0 16px 50px rgba(0,0,0,.45)";
      d.style.zIndex = "5";
      stage.appendChild(d);

      VIZ_TIP = d;
      return d;
    }
    function showVizTip(clientX, clientY, html){
      const tip = ensureVizTooltip();
      const stage = qs("vizStage");
      if(!tip || !stage) return;
      const rect = stage.getBoundingClientRect();
      tip.innerHTML = html || "";
      const x = clientX - rect.left + 12;
      const y = clientY - rect.top + 12;
      tip.style.transform = `translate(${x}px, ${y}px)`;
    }
    function hideVizTip(){
      const tip = ensureVizTooltip();
      if(!tip) return;
      tip.style.transform = "translate(-9999px,-9999px)";
    }

    function hitTestViz(clientX, clientY){
      const canvas = qs("vizCanvas");
      const stage  = qs("vizStage");
      if(!canvas || !stage) return null;

      const rect = stage.getBoundingClientRect();
      // mouse in CSS px (stage)
      const mx = (clientX - rect.left);
      const my = (clientY - rect.top);

      // invert pan/zoom (stored in CSS px)
      const x = (mx - VIZ.panX) / (VIZ.zoom || 1);
      const y = (my - VIZ.panY) / (VIZ.zoom || 1);

      for(let i = VIZ.nodes.length - 1; i >= 0; i--){
        const n = VIZ.nodes[i];
        const dx = x - (n.x || 0);
        const dy = y - (n.y || 0);
        const rr = (n.r || 14);
        if(dx*dx + dy*dy <= rr*rr) return { node:n, index:i };
      }
      return null;
    }

        function wireVizInteractions(){
      if(VIZ._wired) return;
      VIZ._wired = true;

      const stage  = qs("vizStage");
      const canvas = qs("vizCanvas");
      if(!stage || !canvas) return;

      const explorer = () => explorerBase(APP.ACTIVE_CHAIN_ID);

      // ----- pointer drag (pan) -----
      const state = {
        pointerId: null,
        downX: 0,
        downY: 0,
        startPanX: 0,
        startPanY: 0,
        moved: false,
        lastTap: 0,
        touchMode: false,
        pinch: {
          active: false,
          id1: null,
          id2: null,
          d0: 0,
          z0: 1,
          cx0: 0,
          cy0: 0,
          panX0: 0,
          panY0: 0
        }
      };

      function setCursor(type){
        stage.style.cursor = type || "default";
      }

      function clampZoom(z){
        return clamp(z, 0.55, 3.2);
      }

      function stagePointFromClient(clientX, clientY){
        const rect = stage.getBoundingClientRect();
        return { x: clientX - rect.left, y: clientY - rect.top };
      }

      function zoomAt(clientX, clientY, nextZoom){
        const z1 = clampZoom(nextZoom);
        const z0 = VIZ.zoom || 1;

        const p = stagePointFromClient(clientX, clientY);
        // world coords before
        const wx = (p.x - VIZ.panX) / z0;
        const wy = (p.y - VIZ.panY) / z0;

        // adjust pan to keep point stable
        VIZ.zoom = z1;
        VIZ.panX = p.x - wx * z1;
        VIZ.panY = p.y - wy * z1;

        drawViz();
      }

      function updateHoverFromEvent(e){
        const hit = hitTestViz(e.clientX, e.clientY);
        if(hit?.node?.addr){
          const addr = hit.node.addr;
          if(String(VIZ.hoverAddr || "").toLowerCase() !== String(addr).toLowerCase()){
            VIZ.hoverAddr = addr;
            drawViz();
          }

          const s = hit.node.sub ? esc(hit.node.sub) : "";
          const a = esc(shortAddr(addr));
          const pct = (typeof hit.node.pct === "number") ? `${hit.node.pct.toFixed(2)}%` : "";
          showVizTip(e.clientX, e.clientY, `
            <div style="font-weight:1000; font-size:13px; margin-bottom:4px">${a}</div>
            <div style="color:rgba(255,255,255,.72); font-weight:850">
              ${s ? `Holder: <span style="color:rgba(255,255,255,.92)">${s}</span><br/>` : ""}
              ${pct ? `Share: <span style="color:rgba(255,255,255,.92)">${esc(pct)}</span><br/>` : ""}
              Mode: <span style="color:rgba(255,255,255,.92)">${esc(VIZ.mode)}</span>
            </div>
          `);
          setCursor("pointer");
          return true;
        }else{
          if(VIZ.hoverAddr){
            VIZ.hoverAddr = "";
            drawViz();
          }
          hideVizTip();
          setCursor(state.pointerId ? "grabbing" : "grab");
          return false;
        }
      }

      // default cursor
      setCursor("grab");

      // ----- pointer events -----
      stage.addEventListener("pointerdown", (e) => {
        // capture pointer for smooth dragging
        stage.setPointerCapture?.(e.pointerId);

        // handle pinch start if 2 touches
        if(e.pointerType === "touch"){
          state.touchMode = true;
        }

        // if pinch already active, just record second pointer
        if(state.touchMode){
          // build pinch pair
          if(!state.pinch.active){
            if(state.pinch.id1 === null){
              state.pinch.id1 = e.pointerId;
            }else if(state.pinch.id2 === null && e.pointerId !== state.pinch.id1){
              state.pinch.id2 = e.pointerId;
              state.pinch.active = true;

              const p1 = stagePointFromClient(e.clientX, e.clientY);
              // we need other pointer position; we’ll approximate until next move updates
              state.pinch.cx0 = p1.x;
              state.pinch.cy0 = p1.y;
              state.pinch.d0 = 40; // fallback until we measure real distance
              state.pinch.z0 = VIZ.zoom || 1;
              state.pinch.panX0 = VIZ.panX;
              state.pinch.panY0 = VIZ.panY;
            }
          }
        }

        // start pan drag
        state.pointerId = e.pointerId;
        state.downX = e.clientX;
        state.downY = e.clientY;
        state.startPanX = VIZ.panX;
        state.startPanY = VIZ.panY;
        state.moved = false;

        setCursor("grabbing");
      });

      stage.addEventListener("pointermove", (e) => {
        // hover/tooltip first when not dragging
        const isDragging = !!state.pointerId;
        if(!isDragging){
          updateHoverFromEvent(e);
          return;
        }

        // dragging pan OR pinch zoom
        const dx = e.clientX - state.downX;
        const dy = e.clientY - state.downY;

        if(Math.abs(dx) > 2 || Math.abs(dy) > 2) state.moved = true;

        // pinch: if we have 2 pointers, use pinch zoom (best-effort)
        if(state.touchMode && state.pinch.active){
          // We can’t directly query the other pointer position without tracking both moves;
          // so we track two latest points via a map.
          if(!VIZ._ptr) VIZ._ptr = new Map();
          VIZ._ptr.set(e.pointerId, { x:e.clientX, y:e.clientY });

          const p1 = VIZ._ptr.get(state.pinch.id1);
          const p2 = VIZ._ptr.get(state.pinch.id2);

          if(p1 && p2){
            const a = stagePointFromClient(p1.x, p1.y);
            const b = stagePointFromClient(p2.x, p2.y);

            const cx = (a.x + b.x) / 2;
            const cy = (a.y + b.y) / 2;
            const ddx = (b.x - a.x);
            const ddy = (b.y - a.y);
            const d = Math.sqrt(ddx*ddx + ddy*ddy) || 0.001;

            // init baseline properly once we can measure
            if(state.pinch.d0 === 40){
              state.pinch.d0 = d;
              state.pinch.cx0 = cx;
              state.pinch.cy0 = cy;
              state.pinch.z0  = VIZ.zoom || 1;
              state.pinch.panX0 = VIZ.panX;
              state.pinch.panY0 = VIZ.panY;
            }

            const scale = d / (state.pinch.d0 || 1);
            const nextZ = clampZoom(state.pinch.z0 * scale);

            // zoom around pinch center
            const rect = stage.getBoundingClientRect();
            const clientCX = rect.left + cx;
            const clientCY = rect.top + cy;
            zoomAt(clientCX, clientCY, nextZ);

            return;
          }
        }

        // regular pan drag
        VIZ.panX = state.startPanX + dx;
        VIZ.panY = state.startPanY + dy;
        drawViz();
      });

      stage.addEventListener("pointerup", (e) => {
        // tap/click on node opens explorer if not dragging
        const wasMoved = state.moved;

        // clean pointer tracking
        if(VIZ._ptr) VIZ._ptr.delete(e.pointerId);

        // end pinch pointers
        if(state.touchMode){
          if(e.pointerId === state.pinch.id1) state.pinch.id1 = null;
          if(e.pointerId === state.pinch.id2) state.pinch.id2 = null;
          if(state.pinch.id1 === null || state.pinch.id2 === null){
            state.pinch.active = false;
            state.pinch.d0 = 40;
          }
        }

        state.pointerId = null;
        setCursor("grab");

        if(!wasMoved){
          const hit = hitTestViz(e.clientX, e.clientY);
          if(hit?.node?.addr){
            const { base, name } = explorer();
            const url = base + hit.node.addr;
            window.open(url, "_blank", "noreferrer");
            showToast(`Opened in ${name}`);
          }else{
            hideVizTip();
          }
        }

        // double-tap to reset (touch)
        if(e.pointerType === "touch"){
          const now = Date.now();
          if(now - state.lastTap < 320){
            resetViz();
            showToast("View reset.");
            state.lastTap = 0;
          }else{
            state.lastTap = now;
          }
        }
      });

      stage.addEventListener("pointercancel", (e) => {
        if(VIZ._ptr) VIZ._ptr.delete(e.pointerId);
        state.pointerId = null;
        state.pinch.active = false;
        state.pinch.id1 = null;
        state.pinch.id2 = null;
        state.pinch.d0 = 40;
        setCursor("grab");
        hideVizTip();
      });

      stage.addEventListener("pointerleave", () => {
        if(!state.pointerId){
          VIZ.hoverAddr = "";
          hideVizTip();
          drawViz();
        }
      });

      // ----- wheel zoom (trackpad/mouse) -----
      stage.addEventListener("wheel", (e) => {
        e.preventDefault();
        const delta = e.deltaY;
        const z = VIZ.zoom || 1;

        // smooth zoom factor
        const factor = Math.exp(-delta * 0.0012);
        const next = clampZoom(z * factor);

        zoomAt(e.clientX, e.clientY, next);
      }, { passive:false });

      // ----- mode buttons -----
      on("vizModeBubbles", "click", () => setVizMode("bubbles"));
      on("vizModeGraph",   "click", () => setVizMode("graph"));
      on("btnVizReset",    "click", () => { resetViz(); showToast("View reset."); });

      // resize handling
      window.addEventListener("resize", () => resizeCanvas(), { passive:true });
    }
    
    // wire it now that the DOM exists
    // (moved into init() so a viz error can't kill the whole app)


        /* =========================================================
       CLUSTERS + GRAPH (best-effort)
       ========================================================= */

    function makeVizLegend(){
      const n = VIZ.nodes?.length || 0;
      const e = VIZ.edges?.length || 0;
      const mode = VIZ.mode;
      return `${n} nodes • ${e} edges • ${mode}`;
    }

    function setVizStamps(){
      const c = chainObj();
      const now = new Date();
      const stamp = `${c.stamp || "MAINNET"} • ${now.toLocaleTimeString("de-DE",{timeZone:"Europe/Berlin"})}`;
      setText("vizStamp", stamp);
      setText("vizLegend", makeVizLegend());
      setText("clusterStamp", c.stamp || "MAINNET");
    }

    function computeEdgesFromTransfers_EVM(transfers, topAddrsSet){
      // Build edges between addresses that appear in transfers
      // (best-effort, keep only those within our shown nodes)
      const nodesIndex = new Map();
      (VIZ.nodes || []).forEach((n, i) => {
        const a = String(n.addr || "").toLowerCase();
        if(a) nodesIndex.set(a, i);
      });

      const edgeMap = new Map(); // key "a|b" -> weight
      for(const t of (transfers || [])){
        const from = String(t?.from_address || "").toLowerCase();
        const to   = String(t?.to_address   || "").toLowerCase();
        if(!from || !to || from === to) continue;
        if(topAddrsSet && topAddrsSet.size){
          if(!topAddrsSet.has(from) && !topAddrsSet.has(to)) continue;
        }
        const ia = nodesIndex.get(from);
        const ib = nodesIndex.get(to);
        if(ia === undefined || ib === undefined) continue;

        const a = Math.min(ia, ib);
        const b = Math.max(ia, ib);
        const key = a + "|" + b;
        edgeMap.set(key, (edgeMap.get(key) || 0) + 1);
      }

      const edges = [];
      for(const [key, w] of edgeMap.entries()){
        const [a,b] = key.split("|").map(Number);
        edges.push({ a, b, w });
      }

      // keep strongest edges only to avoid clutter
      edges.sort((x,y)=> (y.w - x.w));
      return edges.slice(0, 80);
    }

    function buildClustersFromEdges(){
      // connected components over VIZ.edges
      const n = VIZ.nodes?.length || 0;
      const adj = Array.from({length:n}, ()=>[]);
      for(const e of (VIZ.edges || [])){
        if(e.a == null || e.b == null) continue;
        adj[e.a].push(e.b);
        adj[e.b].push(e.a);
      }

      const seen = new Array(n).fill(false);
      const comps = [];
      for(let i=0;i<n;i++){
        if(seen[i]) continue;
        const stack = [i];
        seen[i] = true;
        const comp = [];
        while(stack.length){
          const u = stack.pop();
          comp.push(u);
          for(const v of adj[u]){
            if(!seen[v]){
              seen[v] = true;
              stack.push(v);
            }
          }
        }
        comps.push(comp);
      }

      // sort largest first, ignore singletons unless few nodes
      comps.sort((a,b)=> b.length - a.length);

      const clusters = [];
      for(const comp of comps){
        if(comp.length < 2 && n > 8) continue;
        const nodes = comp.map(i => VIZ.nodes[i]).filter(Boolean);

        // severity heuristic: if any bad -> bad, else if any warn -> warn, else ok
        let sev = "ok";
        if(nodes.some(x=>x.sev==="bad")) sev = "bad";
        else if(nodes.some(x=>x.sev==="warn")) sev = "warn";

        const pctSum = nodes.reduce((s,x)=> s + (Number(x.pct)||0), 0);
        const addrList = nodes.map(x => x.addr).filter(Boolean);

        clusters.push({
          sev,
          size: nodes.length,
          pct: pctSum,
          addrs: addrList
        });
      }
      return clusters;
    }

    function renderClusters(clusters){
      const grid = qs("clusterGrid");
      if(!grid) return;

      if(!clusters || !clusters.length){
        grid.innerHTML = `
          <div class="clusterCard">
            <div class="clusterLeft">
              <div class="clusterT"><span class="dot warn"></span> No clusters detected</div>
              <div class="clusterD">No strong wallet relationships found (best-effort). Try enabling GoldRush for EVM transfers.</div>
            </div>
            <div class="clusterRight"><span class="badge warn">WATCH</span></div>
          </div>
        `;
        setText("clusterFoot","Clusters are best-effort. Edges require transfers/holders data.");
        return;
      }

      grid.innerHTML = "";
      const { name: exName, base: exBase } = explorerBase(APP.ACTIVE_CHAIN_ID);

      clusters.slice(0, 8).forEach((c, idx) => {
        const dotCls = c.sev === "bad" ? "dot bad" : c.sev === "warn" ? "dot warn" : "dot good";
        const badgeCls = c.sev === "bad" ? "badge bad" : c.sev === "warn" ? "badge warn" : "badge good";
        const badgeTxt = c.sev === "bad" ? "RISK" : c.sev === "warn" ? "WATCH" : "OK";

        const top = c.addrs.slice(0, 3).map(a =>
          `<a class="explorerBtn" target="_blank" rel="noreferrer" href="${exBase}${encodeURIComponent(a)}">${esc(shortAddr(a))}</a>`
        ).join("");

        const card = document.createElement("div");
        card.className = "clusterCard";
        card.innerHTML = `
          <div class="clusterLeft">
            <div class="clusterT"><span class="${dotCls}"></span> Cluster #${idx+1} • ${c.size} wallets • ~${c.pct.toFixed(2)}%</div>
            <div class="clusterD">
              Linked wallets (best-effort). Open in ${esc(exName)}:
              <div style="margin-top:8px; display:flex; gap:8px; flex-wrap:wrap;">${top}</div>
            </div>
          </div>
          <div class="clusterRight">
            <span class="${badgeCls}">${badgeTxt}</span>
          </div>
        `;
        grid.appendChild(card);
      });

      setText("clusterFoot", `Showing ${Math.min(8, clusters.length)} clusters. Relationships based on available transfer/holder data.`);
    }

    /* =========================================================
       CHECKS + SCORING (simple, stable)
       ========================================================= */
    function scoreFromChecks(checks){
      // checks: [{sev:"ok|warn|bad", weight:int}]
      let score = 100;
      let critical = false;
      for(const c of (checks||[])){
        const w = Number(c.weight || 8);
        if(c.sev === "bad"){ score -= w; if(w >= 18) critical = true; }
        if(c.sev === "warn"){ score -= Math.max(4, Math.floor(w/2)); }
      }
      score = clamp(Math.round(score), 0, 100);
      return { score, critical };
    }

    function buildTodoFromChecks(checks){
      // simple action list derived from warn/bad
      const todos = [];
      for(const c of (checks||[])){
        if(c.sev === "bad"){
          todos.push({ sev:"warn", t:`Fix: ${c.t || "Critical issue"}`, d:`Action: ${c.fix || "Mitigate risk before launch."}` });
        }else if(c.sev === "warn"){
          todos.push({ sev:"warn", t:`Improve: ${c.t || "Potential issue"}`, d:`Action: ${c.fix || "Review and harden."}` });
        }
      }
      if(!todos.length){
        todos.push({ sev:"ok", t:"Ready checklist", d:"No major blockers detected (best-effort). Still verify manually." });
      }
      return todos.slice(0, 10);
    }

    /* =========================================================
       RENDER RESULT SECTIONS
       ========================================================= */
    function setSummaryLine(lines){
      setText("summary", lines || "—");
    }

    function renderHoldersList(rows){
      const ul = qs("holdersList");
      if(!ul) return;
      ul.innerHTML = "";

      const { name: exName, base: exBase } = explorerBase(APP.ACTIVE_CHAIN_ID);

      const arr = Array.isArray(rows) ? rows : [];
      for(const r of arr){
        const addr = r.addr || "";
        const li = document.createElement("li");
        li.className = "li";
        li.innerHTML = `
          <div class="left">
            <div class="t">${esc(r.label || shortAddr(addr))}</div>
            <div class="d">Share: <b>${esc(fmtPct(r.pct||0))}</b> • ${esc(r.sub || "")}</div>
          </div>
          <div class="pillRow">
            <a class="explorerBtn" target="_blank" rel="noreferrer" href="${exBase}${encodeURIComponent(addr)}">Open ${esc(exName)}</a>
          </div>
        `;
        ul.appendChild(li);
      }
      if(!arr.length){
        const li = document.createElement("li");
        li.className = "li";
        li.innerHTML = `<div class="left"><div class="t">No holder data</div><div class="d">Run scan with required keys/indexer.</div></div>`;
        ul.appendChild(li);
      }
    }

    /* =========================================================
       SCAN: SOLANA
       ========================================================= */
    async function scanSolana(mint, signal){
      const checks = [];
      const metaList = [];
      const extList = [];
      const keySignals = [];

      // mint + supply
      const parsed = await getMintParsed(mint, signal);
      if(!parsed || !parsed.info){
        checks.push({ sev:"bad", weight:24, t:"Invalid mint / not found", d:"Mint account not found.", fix:"Verify mint address and RPC key." });
        return { checks, metaList, extList, keySignals, holders:[], holdersNodes:[], edges:[], tokenMeta:{name:"—",symbol:"",image:""} };
      }

      const ownerProg = parsed.owner || "";
      const mintAuth  = parsed?.info?.mintAuthority ?? null;
const freezeAuth = parsed?.info?.freezeAuthority ?? null;

if(!mintAuth){
  checks.push({ sev:"ok", weight:10, t:"Mint authority revoked", d:"mintAuthority is null (no further minting).", fix:"Verify token supply and emissions are truly fixed." });
  keySignals.push({ k:"Mint authority", v:"REVOKED", mini:"mintAuthority = null", src:"onchain", sev:"ok" });
}else{
  checks.push({ sev:"warn", weight:14, t:"Mint authority active", d:`mintAuthority: ${shortAddr(mintAuth)}`, fix:"Revoke mint authority if supply should be fixed." });
  keySignals.push({ k:"Mint authority", v:"ACTIVE", mini: mintAuth, src:"onchain", sev:"warn" });
}

if(!freezeAuth){
  checks.push({ sev:"ok", weight:8, t:"Freeze authority revoked", d:"freezeAuthority is null (freeze disabled).", fix:"—" });
  keySignals.push({ k:"Freeze authority", v:"REVOKED", mini:"freezeAuthority = null", src:"onchain", sev:"ok" });
}else{
  checks.push({ sev:"warn", weight:10, t:"Freeze authority active", d:`freezeAuthority: ${shortAddr(freezeAuth)}`, fix:"Revoke freeze authority if you don’t want account freezes." });
  keySignals.push({ k:"Freeze authority", v:"ACTIVE", mini: freezeAuth, src:"onchain", sev:"warn" });
}
      const isToken2022 = ownerProg === CFG.TOKEN_2022_PROGRAM;
      const isToken = ownerProg === CFG.TOKEN_PROGRAM;

      extList.push({
        sev: isToken || isToken2022 ? "ok" : "warn",
        t: "Token program",
        d: isToken2022 ? "Token-2022 program" : isToken ? "SPL Token program" : `Unknown owner program: ${ownerProg}`,
        weight: isToken || isToken2022 ? 6 : 12,
        fix: "Verify token standard program owner."
      });

      const supply = await getTokenSupply(mint, signal).catch(()=> null);
      const decimals = Number(supply?.decimals ?? parsed.info?.decimals ?? 0);
      const uiSupply = supply?.uiAmountString || "—";

      keySignals.push({ k:"Supply", v:String(uiSupply), mini:`Decimals: ${Number.isFinite(decimals)?decimals:"—"}`, src:"onchain", sev:"ok" });

      // metadata via getAsset (best effort)
      const asset = await getAsset(mint, signal);
      const meta = pickTokenMetaFromAsset(asset) || {name:"Token", symbol:"", image:""};
      applyTokenHeader(meta, mint);

      metaList.push({ sev:"ok", t:"Name", d: meta.name || "—" });
      metaList.push({ sev:"ok", t:"Symbol", d: meta.symbol || "—" });
      metaList.push({ sev: meta.uri ? "ok":"warn", t:"Metadata URI", d: meta.uri || "—", fix:"Ensure metadata JSON is accessible." });

      // top holders (largest token accounts) + owners
      const largest = await getLargest(mint, signal).catch(()=> []);
      const topTA = largest.slice(0, 10).map(x => x?.address).filter(Boolean);
      const owners = topTA.length ? await getTokenAccountOwners(topTA, signal).catch(()=>[]) : [];

      // compute pct (Solana RPC gives uiAmount & supply info)
      const totalUi = Number(supply?.uiAmount ?? 0);
      const holders = largest.slice(0, 10).map((x, i) => {
        const ui = Number(x?.uiAmount ?? 0);
        const pct = (totalUi > 0) ? (ui / totalUi * 100) : 0;
        const addr = owners[i] || x?.address || "";
        return {
          addr,
          label: `Holder #${i+1}`,
          pct,
          sub: `~${fmtInt(ui)} tokens`,
          sev: (pct >= 15) ? "warn" : "ok"
        };
      }).filter(x=>x.addr);

      renderHoldersList(holders);
      buildBubblesFromHolders(holders);

      // basic concentration checks
      const top1 = holders[0]?.pct || 0;
      const top5 = holders.slice(0,5).reduce((s,h)=>s+(h.pct||0),0);
      if(top1 >= 25) checks.push({ sev:"bad", weight:22, t:"High whale concentration", d:`Top holder ~${top1.toFixed(2)}%`, fix:"Verify if treasury/LP/lock wallets are excluded. Consider distribution/vesting." });
      else if(top1 >= 15) checks.push({ sev:"warn", weight:12, t:"Concentration watch", d:`Top holder ~${top1.toFixed(2)}%`, fix:"Review top holders, label known wallets." });
      else checks.push({ sev:"ok", weight:6, t:"Top holder concentration", d:`Top holder ~${top1.toFixed(2)}%` });

      if(top5 >= 60) checks.push({ sev:"warn", weight:12, t:"Top 5 concentration", d:`Top 5 ~${top5.toFixed(2)}%`, fix:"Review distribution and lockups." });
      else checks.push({ sev:"ok", weight:6, t:"Top 5 concentration", d:`Top 5 ~${top5.toFixed(2)}%` });

      // Fill UI sections
      renderList(qs("checksList"), checks.map(c=>({sev:c.sev,t:c.t,d:c.d,fix:c.fix})), "Checks");
      renderList(qs("todoList"), buildTodoFromChecks(checks), "Launch readiness");
      renderList(qs("extList"), extList, "Token standard details");
      renderList(qs("metaList"), metaList, "Token metadata");
      renderKeySignals(keySignals);

      setVizStamps();
      return {
        tokenMeta: meta,
        checks, metaList, extList, keySignals,
        holders,
        edges: [],
        clusters: []
      };
    }

    /* =========================================================
       SCAN: EVM (ETH/BNB/Base)
       ========================================================= */
    function evmChainIdFromActive(){
      if(APP.ACTIVE_CHAIN_ID === "eth") return 1;
      if(APP.ACTIVE_CHAIN_ID === "bnb") return 56;
      if(APP.ACTIVE_CHAIN_ID === "base") return 8453;
      return 1;
    }

    async function scanEvm(tokenAddr, signal){
      const chainId = evmChainIdFromActive();
      const checks = [];
      const metaList = [];
      const extList = [];
      const keySignals = [];

      // contract code?
      const code = await getCode(chainId, tokenAddr, signal).catch(()=> "0x");
      if(!code || code === "0x"){
        checks.push({ sev:"bad", weight:26, t:"Not a contract", d:"Address has no contract bytecode.", fix:"Verify contract address." });
        applyTokenHeaderWithEvmLogo({name:"—",symbol:"",image:""}, tokenAddr, chainId);
        renderList(qs("checksList"), checks.map(c=>({sev:c.sev,t:c.t,d:c.d,fix:c.fix})), "Checks");
        renderList(qs("todoList"), buildTodoFromChecks(checks), "Launch readiness");
        renderKeySignals(keySignals);
        setVizStamps();
        return { tokenMeta:{name:"—",symbol:"",image:""}, checks, metaList, extList, keySignals, holders:[], edges:[], clusters:[] };
      }

      const proxy = await detectProxy(chainId, tokenAddr, signal);
      if(proxy.isProxy){
        checks.push({ sev:"warn", weight:14, t:"Proxy detected (EIP-1967)", d:`Implementation: ${shortAddr(proxy.implementation||"")}`, fix:"Verify implementation contract + admin privileges." });
        extList.push({ sev:"warn", t:"Proxy", d:`Implementation: ${proxy.implementation || "—"} • Admin: ${proxy.admin || "—"}` });
      }else{
        extList.push({ sev:"ok", t:"Proxy", d:"No EIP-1967 proxy signals detected." });
      }

      const meta = await getErc20Meta(chainId, tokenAddr, signal);
      applyTokenHeaderWithEvmLogo(meta, tokenAddr, chainId);

      metaList.push({ sev: meta.name ? "ok":"warn", t:"Name", d: meta.name || "—", fix:"ERC-20 name() should be readable." });
      metaList.push({ sev: meta.symbol ? "ok":"warn", t:"Symbol", d: meta.symbol || "—", fix:"ERC-20 symbol() should be readable." });
      metaList.push({ sev: Number.isFinite(meta.decimals) ? "ok":"warn", t:"Decimals", d: Number.isFinite(meta.decimals)?String(meta.decimals):"—" });

      let totalSupplyUi = "—";
      if(meta.totalSupply != null && Number.isFinite(meta.decimals)){
        const denom = 10n ** BigInt(meta.decimals);
        const whole = meta.totalSupply / denom;
        totalSupplyUi = whole.toString();
      }
      keySignals.push({ k:"Total supply", v: totalSupplyUi, mini:`Decimals: ${Number.isFinite(meta.decimals)?meta.decimals:"—"}`, src:"onchain", sev:"ok" });


      const paused = await getPaused(chainId, tokenAddr, signal);
if(paused === true){
  checks.push({ sev:"bad", weight:18, t:"Contract is paused", d:"Transfers may be blocked.", fix:"Verify pause control and whether it’s intended." });
  keySignals.push({ k:"Paused", v:"YES", mini:"paused() returned true", src:"onchain", sev:"bad" });
}else if(paused === false){
  checks.push({ sev:"ok", weight:6, t:"Paused()", d:"Not paused (best-effort)." });
  keySignals.push({ k:"Paused", v:"NO", mini:"paused() returned false", src:"onchain", sev:"ok" });
}else{
  checks.push({ sev:"warn", weight:8, t:"Paused()", d:"Unknown (method not found or unreadable).", fix:"Verify if contract has pause features." });
  keySignals.push({ k:"Paused", v:"UNKNOWN", mini:"paused() missing/unreadable", src:"onchain", sev:"warn" });
}

// ✅ OWNER MUSS HIER DEFINIERT WERDEN:
const owner = await getOwner(chainId, tokenAddr, signal);

const ZERO = "0x0000000000000000000000000000000000000000";
const DEAD = "0x000000000000000000000000000000000000dead";

if(owner){
  const o = owner.toLowerCase();

  // show as key signal
  keySignals.push({
    k:"Owner",
    v: (o === ZERO || o === DEAD) ? "RENOUNCED" : shortAddr(owner),
    mini: owner,
    src:"onchain",
    sev: (o === ZERO || o === DEAD) ? "ok" : "warn"
  });

  if(o === ZERO || o === DEAD){
    checks.push({
      sev:"ok", weight:10,
      t:"Ownership renounced",
      d:`Owner is ${o === ZERO ? "0x0" : "0xdead"} (best-effort via owner()).`,
      fix:"Still verify privileged roles (mint/pause/fees) in contract."
    });
    extList.push({ sev:"ok", t:"Owner", d: owner });
  }else{
    checks.push({
      sev:"warn", weight:12,
      t:"Ownership NOT renounced",
      d:`Owner: ${shortAddr(owner)}`,
      fix:"If you expect renounce: transfer ownership to 0x0. If not: verify owner trust + multisig."
    });
    extList.push({ sev:"warn", t:"Owner", d: owner });
  }
}else{
  checks.push({
    sev:"warn", weight:8,
    t:"Owner() unknown",
    d:"No owner() method detected or unreadable.",
    fix:"Contract may use custom roles. Verify admin privileges manually."
  });
  keySignals.push({ k:"Owner", v:"UNKNOWN", mini:"owner() missing/unreadable", src:"onchain", sev:"warn" });
}
      // DEX Screener best pair
      const ds = await fetchDexscreenerToken(tokenAddr, signal);
      if(ds?.best){
        const liq = Number(ds.best?.liquidity?.usd || 0);
        const fdv = Number(ds.best?.fdv || 0);
        const price = Number(ds.best?.priceUsd || 0);
        keySignals.push({ k:"Liquidity (best pair)", v:`$${formatUsd(liq)}`, mini:`FDV: $${formatUsd(fdv)} • Price: $${price?price.toPrecision(4):"—"}`, src:"api", sev: liq > 50000 ? "ok" : "warn" });
        if(liq < 5000) checks.push({ sev:"warn", weight:10, t:"Low liquidity", d:`Best pair liquidity ~$${formatUsd(liq)}`, fix:"Low LP increases volatility and rug risk." });
        else checks.push({ sev:"ok", weight:6, t:"Liquidity", d:`Best pair liquidity ~$${formatUsd(liq)}` });
      }else{
        checks.push({ sev:"warn", weight:8, t:"DEX data unavailable", d:"No Dexscreener pair found (best-effort).", fix:"Token may be new or not tracked." });
      }

      // If we don't have an image yet, try Dexscreener token logo
if(ds?.best?.info?.imageUrl){
  // meta is the object from getErc20Meta(). We can attach an image field.
  if(!meta.image) meta.image = ds.best.info.imageUrl;
  // re-apply header so it can use the image
  applyTokenHeaderWithEvmLogo(meta, tokenAddr, chainId);
}

      // Holders + Transfers (GoldRush)
      const holdersRaw = await goldrushHolders(chainId, tokenAddr, signal);
      let holders = [];
      if(holdersRaw.length){
        // GoldRush token_holders items have address + balance + etc
        // We'll approximate pct if totalSupply is known.
        const totalRaw = meta.totalSupply;
        const totalStr = (totalRaw != null) ? totalRaw.toString() : "";
        holders = holdersRaw.slice(0, 10).map((h, i) => {
          const addr = String(h?.address || "");
          const bal = String(h?.balance || h?.balance_24h || "0");
          const pct = totalStr ? pctFromRaw(bal, totalStr) : normalizePct(h?.percentage || 0);
          return {
            addr,
            label: `Holder #${i+1}`,
            pct,
            sub: `${pct.toFixed(2)}%`,
            sev: (pct >= 15) ? "warn" : "ok"
          };
        }).filter(x=>x.addr);

        renderHoldersList(holders);
        buildBubblesFromHolders(holders);

        const top1 = holders[0]?.pct || 0;
        const top5 = holders.slice(0,5).reduce((s,h)=>s+(h.pct||0),0);
        if(top1 >= 25) checks.push({ sev:"bad", weight:22, t:"High whale concentration", d:`Top holder ~${top1.toFixed(2)}%`, fix:"Review holder labels, LP/treasury exclusions." });
        else if(top1 >= 15) checks.push({ sev:"warn", weight:12, t:"Concentration watch", d:`Top holder ~${top1.toFixed(2)}%`, fix:"Review top holders and distribution." });
        else checks.push({ sev:"ok", weight:6, t:"Top holder concentration", d:`Top holder ~${top1.toFixed(2)}%` });

        if(top5 >= 60) checks.push({ sev:"warn", weight:12, t:"Top 5 concentration", d:`Top 5 ~${top5.toFixed(2)}%`, fix:"Review distribution and lockups." });
        else checks.push({ sev:"ok", weight:6, t:"Top 5 concentration", d:`Top 5 ~${top5.toFixed(2)}%` });
      }else{
        renderHoldersList([]);
        buildBubblesFromHolders([]);
        checks.push({ sev:"warn", weight:10, t:"Holder data unavailable", d:"Enable GoldRush key for EVM holders/transfers.", fix:"Add GoldRush key in API Keys." });
      }

      // Transfers → edges → graph mode
      const transfers = await goldrushTransfers(chainId, tokenAddr, 200, signal);
      const topSet = new Set(holders.map(h=>String(h.addr||"").toLowerCase()));
      const edges = transfers.length ? computeEdgesFromTransfers_EVM(transfers, topSet) : [];
      VIZ.edges = edges;

      setGraphAvailability(edges.length > 0);
      if(edges.length > 0){
        // clusters from edges
        const clusters = buildClustersFromEdges();
        renderClusters(clusters);
        setText("vizSub","Shows holder bubbles + linked wallet edges (best-effort). Graph is enabled.");
        setText("clusterSub","Linked wallets & transfer relationships (best-effort).");
      }else{
        renderClusters([]);
        setText("vizSub","Shows holder bubbles (best-effort). Graph needs transfer edges (GoldRush).");
      }

      drawViz();
      setVizStamps();

      renderList(qs("checksList"), checks.map(c=>({sev:c.sev,t:c.t,d:c.d,fix:c.fix})), "Checks");
      renderList(qs("todoList"), buildTodoFromChecks(checks), "Launch readiness");
      renderList(qs("extList"), extList, "Token standard details");
      renderList(qs("metaList"), metaList, "Token metadata");
      renderKeySignals(keySignals);

      return { tokenMeta: meta, checks, metaList, extList, keySignals, holders, edges, clusters: buildClustersFromEdges() };
    }

    /* =========================================================
       EXPORT REPORT (single HTML download with snapshot)
       ========================================================= */
    async function blobToDataURL(blob){
      return await new Promise((resolve) => {
        const fr = new FileReader();
        fr.onload = () => resolve(String(fr.result || ""));
        fr.onerror = () => resolve("");
        fr.readAsDataURL(blob);
      });
    }

    async function preloadBrandLogo(){
  if(APP.BRAND_LOGO_DATAURL) return APP.BRAND_LOGO_DATAURL;

  const imgEl = qs("brandLogo");
  const src = imgEl?.getAttribute("src") || "assets/logo.png";

  // 1) Prefer drawing the already-loaded DOM image (most reliable)
  try{
    if(imgEl && imgEl.complete && imgEl.naturalWidth > 0){
      const c = document.createElement("canvas");
      c.width = imgEl.naturalWidth;
      c.height = imgEl.naturalHeight;
      const ctx = c.getContext("2d");
      ctx.drawImage(imgEl, 0, 0);
      APP.BRAND_LOGO_DATAURL = c.toDataURL("image/png");
      return APP.BRAND_LOGO_DATAURL;
    }
  }catch{}

  // 2) Fallback to fetch -> blob -> dataURL
  try{
    const r = await fetch(src, { cache:"force-cache" });
    const b = await r.blob();
    const d = await blobToDataURL(b);
    APP.BRAND_LOGO_DATAURL = d;
    return d;
  }catch{
    APP.BRAND_LOGO_DATAURL = "";
    return "";
  }
}

    function canvasToDataURL(){
      const c = qs("vizCanvas");
      if(!c) return "";
      try{ return c.toDataURL("image/png"); }catch{ return ""; }
    }

    function downloadText(filename, text){
      const blob = new Blob([text], { type:"text/html;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=> URL.revokeObjectURL(url), 2000);
    }

    async function exportReport(){
      if(!APP.LAST_SCAN){
        showToast("Nothing to export yet. Run a scan first.");
        return;
      }
      const c = chainObj();
      const brandLogo = await preloadBrandLogo();
      const tokenNameTxt = (qs("tokenName")?.textContent || "—").trim();
const tokenSymTxt  = (qs("tokenSymbol")?.textContent || "—").trim();
const tokenIdentSvg = qs("tokenIdenticon") ? qs("tokenIdenticon").outerHTML : "";
      let tokenImg = "";
const tokenSrc = (qs("tokenLogo")?.style.display !== "none") ? (qs("tokenLogo")?.src || "") : "";

if(tokenSrc){
  try{
    const r = await fetch(tokenSrc, { cache:"force-cache" });
    const b = await r.blob();
    tokenImg = await blobToDataURL(b);
  }catch{
    tokenImg = ""; // fallback, report works without it
  }
}
      const vizImg = canvasToDataURL();

      const addr = APP.LAST_SCAN.addr || "";
      const title = `${c.name} Guardian Report — ${addr ? shortAddr(addr) : ""}`;
      const when = new Date().toLocaleString("de-DE",{timeZone:"Europe/Berlin"});

      // lightweight report html (same vibe)
      const html = `<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>${esc(title)}</title>
<style>
  :root{ --bg:#070711; --text:rgba(255,255,255,.92); --muted:rgba(255,255,255,.70); --panel:rgba(255,255,255,.06); --stroke:rgba(255,255,255,.12);
    --g:#14F195; --c:#00D1FF; --p:#9945FF; --radius:22px; --shadow:0 12px 32px rgba(0,0,0,.45); }
  *{box-sizing:border-box} body{margin:0;font:15px/1.55 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text);}
  .wrap{max-width:980px;margin:0 auto;padding:18px;}
  .card{background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.05));border:1px solid var(--stroke);border-radius:var(--radius);box-shadow:var(--shadow);overflow:hidden;}
  .inner{padding:18px}
  .top{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  .brand{display:flex;gap:12px;align-items:center}
  .brand img{width:44px;height:44px;object-fit:contain}
  .h1{margin:10px 0 0;font-weight:1000;letter-spacing:-.6px;font-size:28px}
  .grad{background:linear-gradient(90deg,var(--g),var(--c),var(--p));-webkit-background-clip:text;background-clip:text;color:transparent}
  .muted{color:var(--muted);font-weight:850}
  .grid{display:grid;grid-template-columns:1fr;gap:12px;margin-top:14px}
  .box{border:1px solid var(--stroke);background:rgba(0,0,0,.18);border-radius:16px;padding:12px}
  .k{font-weight:1000;text-transform:uppercase;letter-spacing:.35px;font-size:12px;color:rgba(255,255,255,.72)}
  .v{margin-top:6px;font-weight:1000;font-size:16px}
  .imgRow{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-top:10px}
  .token{width:44px;height:44px;border-radius:12px;overflow:hidden;border:1px solid var(--stroke);background:rgba(0,0,0,.18)}
  .token img{width:100%;height:100%;object-fit:cover}
  .token svg{width:100%;height:100%;display:block}
  .viz{margin-top:10px;border-radius:16px;overflow:hidden;border:1px solid var(--stroke);background:rgba(0,0,0,.18)}
  .viz img{width:100%;display:block}
  ul{margin:10px 0 0;padding:0;list-style:none;display:grid;gap:10px}
  li{border:1px solid var(--stroke);background:rgba(0,0,0,.14);border-radius:16px;padding:12px}
  .pill{display:inline-block;padding:6px 10px;border-radius:999px;font-weight:1000;font-size:12px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06)}
</style>
</head>
<body>
<script>
  try { history.scrollRestoration = "manual"; } catch(e){}
  function forceTop(){
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    window.scrollTo(0,0);
  }
  window.addEventListener("pageshow", forceTop);
  forceTop();
  requestAnimationFrame(forceTop);
  setTimeout(forceTop, 50);
  setTimeout(forceTop, 200);
</script>
  <div class="wrap">
    <div class="card">
      <div class="inner">
        <div class="top">
          <div class="brand">
            ${brandLogo ? `<img src="${brandLogo}" alt="Brand"/>` : ``}
            <div>
              <div class="muted">${esc(c.name)} • ${esc(c.stamp || "MAINNET")}</div>
              <div class="h1"><span class="grad">Guardian</span> Scan Report</div>
              <div class="muted">${esc(when)}</div>
            </div>
          </div>
          <div class="muted">${esc(addr)}</div>
        </div>

        <div class="imgRow">
  <div class="token">
    ${
      tokenImg
        ? `<img src="${esc(tokenImg)}" alt="Token"/>`
        : (tokenIdentSvg || "")
    }
  </div>

  <div style="min-width:0">
    <div style="font-weight:1000; font-size:16px; line-height:1.15">${esc(tokenNameTxt)}</div>
    <div class="muted" style="margin-top:2px">${esc(tokenSymTxt)}</div>
  </div>

  <div class="box" style="flex:1 1 260px">
    <div class="k">Verdict</div>
    <div class="v">${esc(qs("verdictTitle")?.textContent || "—")} • ${esc(qs("scoreBadge")?.textContent || "—")}</div>
  </div>
</div>


        ${vizImg ? `<div class="viz"><img src="${vizImg}" alt="Viz snapshot"/></div>` : ``}

        <div class="grid">
          <div class="box">
            <div class="k">Summary</div>
            <div class="v">${esc(qs("summary")?.textContent || "—")}</div>
          </div>

          <div class="box">
            <div class="k">Key Signals</div>
            ${qs("keySignals")?.innerText ? `<div class="muted" style="margin-top:6px; white-space:pre-wrap">${esc(qs("keySignals").innerText)}</div>` : `<div class="muted">—</div>`}
          </div>

          <div class="box">
            <div class="k">Checks</div>
            <div class="muted" style="margin-top:6px; white-space:pre-wrap">${esc(qs("checksList")?.innerText || "—")}</div>
          </div>

          <div class="box">
            <div class="k">Launch Readiness</div>
            <div class="muted" style="margin-top:6px; white-space:pre-wrap">${esc(qs("todoList")?.innerText || "—")}</div>
          </div>

          <div class="box">
            <div class="k">Top Holders</div>
            <div class="muted" style="margin-top:6px; white-space:pre-wrap">${esc(qs("holdersList")?.innerText || "—")}</div>
          </div>
        </div>

      </div>
    </div>
  </div>
</body>
</html>`;

      const ts = new Date().toISOString().replaceAll(":","-").replaceAll(".","-");
      const filename = `guardian-report-${APP.ACTIVE_CHAIN_ID}-${addr ? addr.slice(0,8) : "scan"}-${ts}.html`;
      downloadText(filename, html);
      showToast("Report downloaded.");
    }

    /* =========================================================
       RUN SCAN (dispatcher)
       ========================================================= */
    function abortScan(){
      try{ APP.ABORT?.abort?.(); }catch{}
      APP.ABORT = null;
      APP.SCANNING = false;
      setScanButtons(false);
    }

    async function runScan(){
      const mintEl = qs("mint");
      const raw = (mintEl?.value || "").trim();
      const c = chainObj();

      // validate
      if(c.kind === "solana"){
        if(!looksBase58(raw)){
          setStatus("Invalid Solana mint (base58).");
          showToast("Invalid Solana mint address.");
          return;
        }
      }else{
        if(!looksEvmAddress(raw)){
          setStatus("Invalid EVM address (must be 0x + 40 hex).");
          showToast("Invalid EVM contract address.");
          return;
        }
      }

      abortScan(); // cancel any in-flight
      APP.ABORT = new AbortController();
      APP.SCANNING = true;
      setScanButtons(true);
      setStatus("Scanning…");
      setText("scanHint", `${c.stamp || "MAINNET"} • scanning…`);
      setText("vizStamp","—");
      setText("vizLegend","—");

      // clear caches per scan (avoid stale)
      APP.CACHE = new Map();
      APP.INFO_MAP = new Map();

      try{
        let result;
        if(c.kind === "solana"){
          result = await scanSolana(raw, APP.ABORT.signal);
        }else{
          result = await scanEvm(raw, APP.ABORT.signal);
        }

        // score + verdict
        const scored = scoreFromChecks(result.checks || []);
        setVerdict(scored.score, scored.critical);
        setSummaryLine(`Best-effort scan completed on ${c.name}. Always verify manually before trading or deploying.`);

        // metrics cards
        const metrics = [
          { label:"Chain", value:c.name, badge:c.stamp || "MAINNET", mini:"Active network" },
          { label:"Address", value:shortAddr(raw), badge:"Copy", mini: raw },
          { label:"Visualization", value:`${(VIZ.nodes?.length||0)} nodes`, badge:`${(VIZ.edges?.length||0)} edges`, mini:"Bubbles show top holders. Graph shows transfer edges (if available).", barPct: clamp((VIZ.nodes?.length||0)*10, 0, 100) },
          { label:"Risk Score", value:`${scored.score}/100`, badge: (scored.score>=85?"APPROVED":scored.score>=70?"WATCH":"RISK"), mini:"Score derived from on-chain + best-effort signals.", barPct: scored.score }
        ];
        renderMetrics(metrics);

        // mint short
        setText("mintShort", raw);
        APP.LAST_SCAN = { chain: APP.ACTIVE_CHAIN_ID, addr: raw, result };
        const exBtn = qs("btnExport");
        if(exBtn) exBtn.disabled = false;

        setStatus("Done.");
        setText("scanHint", `${c.stamp || "MAINNET"} • scan finished`);
        setVizStamps();
        showToast("Scan completed.");
      }catch(e){
        if(String(e?.name||"") === "AbortError"){
          setStatus("Scan canceled.");
        }else{
          setStatus("Error: " + (e?.message || e));
          showToast("Scan error. Check keys/RPC.");
        }
      }finally{
        APP.SCANNING = false;
        setScanButtons(false);
      }
    }

    /* =========================================================
       UI WIRING + INIT
       ========================================================= */
    function init(){
      startLiveStampTime();
      setText("y", String(new Date().getFullYear()));

      // chain from URL
      try{
        const url = new URL(location.href);
        const q = (url.searchParams.get("chain") || "").trim().toLowerCase();
        if(CHAINS.some(x=>x.id===q)) APP.ACTIVE_CHAIN_ID = q;
      }catch{}

      renderChainButtons();
      setActiveChain(APP.ACTIVE_CHAIN_ID, false);

      on("toastClose","click", hideToast);
      on("modalClose","click", closeModal);
      on("modalWrap","click", (e)=>{ if(e.target === qs("modalWrap")) closeModal(); });

      on("btnKeys","click", openKeysModal);
      on("btnScan","click", runScan);
      on("btnScanInline","click", runScan);
      on("btnExport","click", exportReport);

      on("btnPaste","click", async ()=>{
        try{
          const t = await navigator.clipboard.readText();
          if(t){ qs("mint").value = t.trim(); showToast("Pasted from clipboard."); }
        }catch{
          showToast("Clipboard blocked. Paste manually.");
        }
      });

      on("btnClear","click", ()=>{
        qs("mint").value = "";
        resetUiForNewChain();
        showToast("Cleared.");
      });

      // enter key triggers scan
      const mint = qs("mint");
      if(mint){
        mint.addEventListener("keydown", (e)=>{
          if(e.key === "Enter"){
            e.preventDefault();
            runScan();
          }
        });
      }

      // Escape closes modal
      document.addEventListener("keydown", (e)=>{
        if(e.key === "Escape"){
          closeModal();
          hideToast();
        }
      });

            // initial header
      applyTokenHeader({name:"—",symbol:"",image:""}, "");
      setText("summary","Run a scan to generate a full Guardian report.");
      setVizStamps();

      // viz wiring (don't let viz errors kill the UI)
      try{
        wireVizInteractions();
        resizeCanvas();
      }catch(e){
        console.warn("Viz init failed:", e);
      }
    }

    init();
  </script>
</body>
</html>
