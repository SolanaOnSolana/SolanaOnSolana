<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <meta name="theme-color" content="#070711" />
  <title>$SOS â€” Chart</title>
  <style>
    :root{
      --bg:#070711;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.085);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.68);
      --g:#14F195;
      --r:#ff4d6d;
      --c:#00D1FF;
      --p:#9945FF;
      --radius:22px;
      --shadow:0 12px 32px rgba(0,0,0,.45);
      --max:1240px;

      --sol:#9945FF;
      --eth:#627EEA;
      --bnb:#F3BA2F;
      --base:#0052FF;

      --tickerSpeedDesktop: 13.5s;
      --tickerSpeedMobile: 16.5s;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 50% -10%, rgba(153,69,255,.12), transparent 60%),
        radial-gradient(1200px 600px at 10% 20%, rgba(0,209,255,.10), transparent 55%),
        var(--bg);
      color:var(--text);
      font:15.5px/1.55 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      overflow-x:hidden;
    }
    a{color:inherit; text-decoration:none}

    .wrap{max-width:var(--max); margin:0 auto; padding:18px 16px 44px;}

    /* Top header */
    .top{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      position:sticky; top:0; z-index:20;
      padding:12px 12px;
      margin:-18px -16px 12px;
      background: linear-gradient(to bottom, rgba(7,7,17,.94), rgba(7,7,17,.72), rgba(7,7,17,0));
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .brand{display:flex; align-items:center; gap:10px; font-weight:900; letter-spacing:.2px; cursor:pointer}
    .logo{width:34px; height:34px; border-radius:12px; background: linear-gradient(135deg, rgba(153,69,255,.75), rgba(0,209,255,.65)); box-shadow: 0 0 0 1px rgba(255,255,255,.10), 0 10px 26px rgba(153,69,255,.18); display:grid; place-items:center}
    .logo span{font-size:14px; opacity:.95}
    .brandTxt{line-height:1}
    .brandTxt .sup{font-size:13px; color:rgba(255,255,255,.74); font-weight:850}
    .brandTxt .ttl{font-size:18px; font-weight:950; margin-top:2px}

    .actions{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end}
    .btn{
      border:1px solid var(--stroke);
      background: rgba(255,255,255,.04);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      font-weight:850;
      cursor:pointer;
      user-select:none;
      transition:.15s transform, .15s background, .15s border-color, .15s box-shadow;
      display:inline-flex; align-items:center; gap:8px;
      white-space:nowrap;
    }
    .btn:hover{transform: translateY(-1px); background: rgba(255,255,255,.06)}
    .btn:active{transform: translateY(0px)}
    .btn.buy{border-color: rgba(20,241,149,.30); background: linear-gradient(135deg, rgba(20,241,149,.24), rgba(0,209,255,.12));}
    .btn.grad{border-color: rgba(153,69,255,.34); background: linear-gradient(135deg, rgba(153,69,255,.30), rgba(0,209,255,.16));}

    /* Trending ticker (same vibe as main) */
    .tickerBar{
      border:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.045));
      border-radius: 18px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
      margin: 6px 0 14px;
    }
    .tickerHd{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.02);
    }
    .tickerHd .l{display:flex; align-items:center; gap:10px; min-width:0}
    .badge{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border-radius:999px; border:1px solid rgba(153,69,255,.30); background: rgba(153,69,255,.12); font-weight:950; letter-spacing:.2px; font-size:12.5px}
    .badge .fire{filter: drop-shadow(0 6px 18px rgba(243,186,47,.25));}

    .netPills{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}
    .net{
      padding:7px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      font-weight:950;
      font-size:12.5px;
      cursor:pointer;
      color: rgba(255,255,255,.92);
      display:inline-flex; align-items:center; gap:8px;
    }
    .net .dot{width:10px; height:10px; border-radius:50%; background: rgba(255,255,255,.18); box-shadow: 0 0 18px rgba(255,255,255,.12)}
    .net.active{box-shadow: 0 0 0 1px rgba(255,255,255,.06), 0 12px 28px rgba(0,0,0,.25)}
    .net.active[data-net="solana"]{border-color: rgba(153,69,255,.50); background: rgba(153,69,255,.14)}
    .net.active[data-net="eth"]{border-color: rgba(98,126,234,.55); background: rgba(98,126,234,.12)}
    .net.active[data-net="bsc"]{border-color: rgba(243,186,47,.55); background: rgba(243,186,47,.12)}
    .net.active[data-net="base"]{border-color: rgba(0,82,255,.55); background: rgba(0,82,255,.12)}
    .net.active[data-net="solana"] .dot{background: var(--sol); box-shadow: 0 0 16px rgba(153,69,255,.45)}
    .net.active[data-net="eth"] .dot{background: var(--eth); box-shadow: 0 0 16px rgba(98,126,234,.45)}
    .net.active[data-net="bsc"] .dot{background: var(--bnb); box-shadow: 0 0 16px rgba(243,186,47,.45)}
    .net.active[data-net="base"] .dot{background: var(--base); box-shadow: 0 0 16px rgba(0,82,255,.45)}

    .tickerWrap{position:relative; overflow:hidden; padding:10px 0;}
    .tickerTrack{display:flex; gap:14px; width:max-content; animation: scroll var(--tickerSpeedDesktop) linear infinite; padding:0 12px;}
    @keyframes scroll{from{transform:translateX(0)} to{transform:translateX(-50%)} }

    .tickerItem{
      display:flex; align-items:center; gap:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      border-radius: 999px;
      padding:7px 10px;
      cursor:pointer;
      user-select:none;
      transition: .15s transform, .15s background, .15s border-color;
      white-space:nowrap;
    }
    .tickerItem:hover{transform: translateY(-1px); background: rgba(255,255,255,.06)}
    .rank{font-weight:950; font-size:12.5px; opacity:.92; padding:4px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.04)}
    .rank.top1{border-color: rgba(243,186,47,.55); background: rgba(243,186,47,.14)}
    .tLogo{width:26px; height:26px; border-radius: 10px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); overflow:hidden; display:grid; place-items:center; flex:0 0 auto}
    .tLogo img{width:100%; height:100%; object-fit:cover; display:block}
    .tLogo .fb{font-weight:950; font-size:12px; opacity:.92}
    .sym{font-weight:950; letter-spacing:.2px}
    .pct{font-weight:950; font-size:12.5px; padding:4px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.04)}
    .pct.up{border-color: rgba(20,241,149,.30); background: rgba(20,241,149,.12); color: rgba(20,241,149,.95)}
    .pct.down{border-color: rgba(255,77,109,.30); background: rgba(255,77,109,.12); color: rgba(255,77,109,.95)}

    /* Search */
    .searchRow{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      margin: 0 0 14px;
    }
    .searchBox{
      flex: 1 1 420px;
      display:flex; align-items:center; gap:10px;
      padding:12px 12px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      box-shadow: 0 10px 26px rgba(0,0,0,.25);
    }
    .searchBox .ic{opacity:.85}
    .searchBox input{
      flex:1;
      background:transparent;
      border:none;
      outline:none;
      color:var(--text);
      font-weight:850;
      font-size:15px;
      min-width:160px;
    }
    .searchBox input::placeholder{color: rgba(255,255,255,.45)}

    .results{margin-top:10px}
    .resCard{
      border:1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.045));
      border-radius: 18px;
      overflow:hidden;
    }
    .resItem{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:12px 12px;
      border-top:1px solid rgba(255,255,255,.06);
    }
    .resItem:first-child{border-top:none}
    .resL{display:flex; align-items:center; gap:10px; min-width:0}
    .resLogo{width:40px; height:40px; border-radius:14px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); overflow:hidden; display:grid; place-items:center; flex:0 0 auto}
    .resLogo img{width:100%; height:100%; object-fit:cover; display:block}
    .resLogo .fb{font-weight:950; opacity:.9}
    .resTxt{min-width:0}
    .resName{font-weight:950; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .resMeta{font-size:12.5px; color: var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}

    .resR{display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:flex-end}
    .chip{font-size:12.5px; font-weight:950; padding:6px 9px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.04)}
    .chip.up{border-color: rgba(20,241,149,.30); background: rgba(20,241,149,.12); color: rgba(20,241,149,.95)}
    .chip.down{border-color: rgba(255,77,109,.30); background: rgba(255,77,109,.12); color: rgba(255,77,109,.95)}

    /* Chart layout */
    .grid{display:grid; grid-template-columns: 1.55fr .85fr; gap:14px; align-items:start;}
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.045));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .cardHd{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:14px 14px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.02);
    }
    .pair{display:flex; align-items:center; gap:10px; min-width:0}
    .pair .tlogo{width:42px; height:42px; border-radius:14px; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); display:grid; place-items:center; overflow:hidden; flex:0 0 auto}
    .pair .tlogo img{width:100%; height:100%; object-fit:cover; display:block}
    .pair .tlogo .fb{font-weight:950; opacity:.9}
    .pairTxt{min-width:0}
    .pairName{font-weight:950; font-size:16px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .pairMeta{font-size:12.5px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}

    .stats{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}
    .pill{padding:7px 10px; border-radius:999px; font-size:12.5px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.04); color: rgba(255,255,255,.86); font-weight:950}
    .pill.up{border-color: rgba(20,241,149,.25); background: rgba(20,241,149,.10); color: rgba(20,241,149,.95)}
    .pill.down{border-color: rgba(255,77,109,.25); background: rgba(255,77,109,.10); color: rgba(255,77,109,.95)}

    #chartWrap{height:560px;}
    #chart{height:100%;}

    
    .viewRow{display:flex;gap:8px;align-items:center}
    .btn.tiny{padding:8px 10px;border-radius:999px;font-size:12px;letter-spacing:.08em;text-transform:uppercase;opacity:.85}
    .btn.tiny.active{opacity:1;box-shadow:0 0 0 1px rgba(255,255,255,.18) inset, 0 10px 24px rgba(0,0,0,.28)}
    .controls{
      display:flex; gap:8px; flex-wrap:wrap;
      padding:12px 14px;
      border-top:1px solid rgba(255,255,255,.08);
      background: rgba(255,255,255,.02);
      align-items:center;
      justify-content:space-between;
    }
    .tfRow{display:flex; gap:8px; flex-wrap:wrap}
    .tf{padding:8px 10px; border-radius: 12px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.04); font-weight:950; font-size:12.5px; cursor:pointer; color: rgba(255,255,255,.90)}
    .tf.active{border-color: rgba(153,69,255,.35); background: linear-gradient(135deg, rgba(153,69,255,.24), rgba(0,209,255,.14)); box-shadow: 0 0 0 1px rgba(153,69,255,.18)}
    .rightCtl{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}

    .sel{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color: rgba(255,255,255,.90);
      padding:10px 10px;
      border-radius:14px;
      font-weight:950;
      font-size:12.5px;
      outline:none;
      max-width: 280px;
      appearance:none;
      -webkit-appearance:none;
    }
    .sel:focus{box-shadow: 0 0 0 1px rgba(153,69,255,.25)}

    .side{display:flex; flex-direction:column; gap:14px;}
    .tableHd{padding:12px 14px; border-bottom:1px solid rgba(255,255,255,.08); background: rgba(255,255,255,.02); display:flex; align-items:center; justify-content:space-between; gap:10px}
    .tableHd .ttl{font-weight:950}
    .tableHd .sub{font-size:12.5px; color:var(--muted)}

    .trades{max-height: 680px; overflow:auto;}
    .trade{display:flex; align-items:center; justify-content:space-between; gap:10px; padding:10px 14px; border-bottom:1px solid rgba(255,255,255,.06)}
    .trade:last-child{border-bottom:none}
    .tL{min-width:0}
    .tType{font-weight:950; font-size:12.5px; letter-spacing:.2px}
    .tType.buy{color:rgba(20,241,149,.95)}
    .tType.sell{color:rgba(255,77,109,.95)}
    .tMeta{font-size:12px; color:var(--muted); display:flex; gap:10px; flex-wrap:wrap}
    .tMeta a{color: rgba(255,255,255,.74)}
    .tR{text-align:right}
    .tAmt{font-weight:950; font-size:12.5px}
    .tUsd{font-size:12px; color:var(--muted)}

    .toast{position:fixed; left:50%; bottom:22px; transform:translateX(-50%); background: rgba(0,0,0,.72); border:1px solid rgba(255,255,255,.14); padding:10px 12px; border-radius: 14px; color: rgba(255,255,255,.92); font-weight:850; opacity:0; pointer-events:none; transition:.18s opacity, .18s transform; z-index:50}
    .toast.show{opacity:1; transform:translateX(-50%) translateY(-2px)}

    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr;}
      #chartWrap{height:460px;}
      .trades{max-height: 420px;}
      .tickerTrack{animation-duration: var(--tickerSpeedMobile);}
      .resR{justify-content:flex-start}
    }

    /* safety for android horizontal scroll */
    .wrap,.top,.tickerBar,.card,.searchRow,#chartWrap,#chart{max-width:100%}
  
    .brandBanner{height:34px;width:auto;display:block;filter:drop-shadow(0 8px 22px rgba(0,0,0,.45));}
    .topActions{display:flex;gap:10px;align-items:center;}
    .btn.ghost{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);color:rgba(255,255,255,.9);}
    .btn.ghost:hover{background:rgba(255,255,255,.09);}

    .seg{display:inline-flex;gap:6px;align-items:center;padding:6px;border-radius:999px;background:rgba(255,255,255,.045);border:1px solid rgba(255,255,255,.10);}
    .segBtn{cursor:pointer;border:0;background:rgba(255,255,255,.06);color:rgba(255,255,255,.88);padding:8px 10px;border-radius:999px;font-weight:800;font-size:12px;line-height:1;letter-spacing:.02em;}
    .segBtn:hover{background:rgba(255,255,255,.10);}
    .segBtn.active{background:linear-gradient(90deg, rgba(20,241,149,.35), rgba(153,69,255,.35));border:1px solid rgba(255,255,255,.12);box-shadow:0 10px 26px rgba(0,0,0,.35) inset;}

    /* Color tune to match main */
    body{background:radial-gradient(1200px 700px at 15% 0%, rgba(153,69,255,.22), transparent 55%),
                 radial-gradient(1100px 800px at 85% 10%, rgba(0,209,255,.18), transparent 55%),
                 radial-gradient(900px 700px at 70% 90%, rgba(20,241,149,.12), transparent 55%),
                 var(--bg);}

    /* Mobile: true layout */
    @media (max-width: 900px){
      .topbar{position:sticky;top:0;z-index:50;backdrop-filter: blur(18px);-webkit-backdrop-filter: blur(18px);}
      .brandBanner{height:30px;}
      .topActions{gap:8px;}
      .btn{padding:10px 12px;font-size:13px;border-radius:16px;}
      .page{padding:14px 14px 26px;}
      .tickerBar{padding:12px;}
      .tickerRow{gap:10px;}
      .searchRow{margin-top:12px;}
      .grid{display:block;}
      .chartWrap{margin-top:12px;}
      .tradesWrap{margin-top:12px;}
      .chartHdr{flex-direction:column;align-items:flex-start;gap:10px;}
      .chartHdrRight{width:100%;display:flex;flex-wrap:wrap;gap:10px;justify-content:flex-start;}
      .seg{width:100%;justify-content:space-between;}
      .segBtn{flex:1;text-align:center;}
      .tvBox{min-height:360px;}
    }

</style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <a class="brand" href="/" aria-label="Back to main">
        <img class="brandBanner" src="assets/dexguard.png" alt="DexGuard" />
      </a>
      <div class="actions">
        <a class="btn" id="btnBack" href="/">Back to Main</a>
        <a class="btn" id="btnX" href="https://www.x.com/Solana_x1" target="_blank" rel="noreferrer">X</a>
        <a class="btn buy" id="btnBuy" href="#" target="_blank" rel="noreferrer">Buy</a>
      </div>
    </div>

    <!-- Trending -->
    <div class="tickerBar" id="tickerBar">
      <div class="tickerHd">
        <div class="l">
          <div class="badge"><span class="fire">ðŸ”¥</span> Live Trending</div>
          <div style="font-size:12.5px;color:rgba(255,255,255,.65);font-weight:850" id="trendStatus">Loadingâ€¦</div>
        </div>
        <div class="netPills" id="netPills"></div>
      </div>
      <div class="tickerWrap">
        <div class="tickerTrack" id="trendTrack"></div>
      </div>
    </div>

    <!-- Search -->
    <div class="searchRow">
      <div class="searchBox">
        <div class="ic">ðŸ”Ž</div>
        <input id="q" placeholder="Search token name or contractâ€¦" autocomplete="off" spellcheck="false" />
        <div style="font-size:12.5px;color:rgba(255,255,255,.55);font-weight:850" id="qHint">auto</div>
      </div>
    </div>
    <div class="results" id="results" style="display:none"></div>

    <!-- Chart + Trades -->
    <div class="grid">
      <div class="card">
        <div class="cardHd">
          <div class="pair">
            <div class="tlogo" id="tokenLogo"><span class="fb" id="tokenLogoFb">$</span></div>
            <div class="pairTxt">
              <div class="pairName" id="pairName">Loadingâ€¦</div>
              <div class="pairMeta" id="pairMeta">Not found</div>
            </div>
          </div>
          <div class="stats" id="stats"></div>
        </div>
        <div id="chartWrap"><div id="chart"></div></div>
        <div class="controls">
          <div class="tfRow" id="tfRow"></div>
          <div class="viewRow" id="viewRow">
            <button class="btn tiny active" data-view="price" id="viewPrice">Price</button>
            <button class="btn tiny" data-view="mcap" id="viewMcap">MCap</button>
          </div>
          <div class="rightCtl">
            <button class="btn" id="btnFit">Fit</button>
            <button class="btn" id="btnRefresh">Refresh</button>
            <select class="sel" id="poolSel" style="display:none" title="Pool"></select>
          </div>
        </div>
      </div>

      <div class="side">
        <div class="card">
          <div class="tableHd">
            <div>
              <div class="ttl">Live Trades</div>
              <div class="sub" id="tradesSub">Buys / Sells</div>
            </div>
            <div class="sub" id="status">Loadingâ€¦</div>
          </div>
          <div class="trades" id="trades"></div>
        </div>
      </div>
    </div>

  </div>

  <div class="toast" id="toast"> </div>

  <script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js"></script>
  <script>
  (function(){
    // -------------------- Helpers
    const GECKO = 'https://api.geckoterminal.com/api/v2';
    const $ = (id)=>document.getElementById(id);
    const qs = new URLSearchParams(location.search);
    const SCANNER_PAGE = '/scanner';

    // Network labels + API slug mapping
    const NET_LABEL = { solana:'SOL', eth:'ETH', bsc:'BNB', base:'BASE' };
    const NET_GECKO = { solana:'solana', eth:'ethereum', bsc:'bsc', base:'base' };
    const DEFAULT_TOKEN = {
  solana: 'So11111111111111111111111111111111111111112',
  ethereum: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',
  bsc: '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',
  base: '0x4200000000000000000000000000000000000006' // WETH on Base
};

  // Preferred stable-coin quote tokens (used to pick "real" native charts like SOL/USDC)
  // Internal only: we do not show data sources, this is just for pool selection.
  const STABLE_QUOTES = {
    solana: [
      'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' // USDC
    ],
    eth: [
      '0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC
      '0xdAC17F958D2ee523a2206206994597C13D831ec7'  // USDT
    ],
    bsc: [
      '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d', // USDC
      '0x55d398326f99059fF775485246999027B3197955'  // USDT
    ],
    base: [
      '0x833589fCD6eDb6E08f4c7C32D4f71b54bda02913' // USDC
    ]
  };

  const lc = (v)=>String(v||'').toLowerCase();

    const geckoNet = (n)=> NET_GECKO[n] || n;


    const rawChain = (qs.get('chain') || qs.get('net') || 'solana').trim();
    let addr = (qs.get('addr') || qs.get('address') || qs.get('ca') || '').trim();

    function normalizeChain(x){
      x = (x||'').toLowerCase().trim();
      if(!x) return 'solana';
      if(x==='sol' || x==='solana') return 'solana';
      if(x==='eth' || x==='ethereum') return 'eth';
      if(x==='bnb' || x==='bsc') return 'bsc';
      if(x==='base') return 'base';
      return 'solana';
    }

    function esc(s){
      return String(s==null?'':s)
        .replaceAll('&','&amp;').replaceAll('<','&lt;')
        .replaceAll('>','&gt;').replaceAll('"','&quot;')
        .replaceAll("'",'&#39;');
    }
    function shortAddr(a){
      const s=String(a||'');
      if(s.length<=12) return s;
      return s.slice(0,6)+'â€¦'+s.slice(-4);
    }
    function num(x){
      const n = Number(x);
      return Number.isFinite(n) ? n : NaN;
    }
    function clamp(n,a,b){return Math.max(a,Math.min(b,n));}

    function formatCompact(n){
      const x = Number(n);
      if(!Number.isFinite(x)) return 'â€”';
      const abs = Math.abs(x);
      const sign = x<0?'-':'';
      const fmt = (v,d)=>{
        const s = v.toFixed(d);
        return s.replace(/\.0+$|(?<=\.[0-9]*?)0+$/,'');
      };
      if(abs>=1e12) return sign+fmt(abs/1e12,2)+'T';
      if(abs>=1e9)  return sign+fmt(abs/1e9,2)+'B';
      if(abs>=1e6)  return sign+fmt(abs/1e6,2)+'M';
      if(abs>=1e3)  return sign+fmt(abs/1e3,2)+'K';
      return sign+fmt(abs,2);
    }

    function calcPricePrecision(x){
      x = Math.abs(Number(x)||0);
      if(!isFinite(x) || x===0) return 6;
      if(x >= 1000) return 2;
      if(x >= 1) return 6;
      // enough decimals to show ~3 significant digits
      const d = Math.ceil(-Math.log10(x)) + 3;
      return Math.min(Math.max(d, 6), 12);
    }

    function formatPrice(p){
      const x = Number(p);
      if(!isFinite(x)) return 'â€”';
      if(x===0) return '0';
      const prec = calcPricePrecision(x);
      let s = x.toFixed(prec);
      // trim trailing zeros
      s = s.replace(/0+$/,'').replace(/\.$/,'');
      return s;
    }

    function timeAgo(ms){
      const d = Date.now() - ms;
      if(d<0) return 'now';
      const s = Math.floor(d/1000);
      if(s<60) return s+'s';
      const m = Math.floor(s/60);
      if(m<60) return m+'m';
      const h = Math.floor(m/60);
      if(h<24) return h+'h';
      const days = Math.floor(h/24);
      return days+'d';
    }

    let toastT=null;
    function toast(msg){
      const t=$('toast');
      t.textContent = msg;
      t.classList.add('show');
      clearTimeout(toastT);
      toastT=setTimeout(()=>t.classList.remove('show'), 1400);
    }

    async function safeJson(url){
      const r = await fetch(url, {headers:{'accept':'application/json'}});
      if(!r.ok) throw new Error('Not found');
      return await r.json();
    }

    function explorerTx(chain, tx){
      if(!tx) return null;
      if(chain==='solana') return 'https://solscan.io/tx/'+tx;
      if(chain==='eth') return 'https://etherscan.io/tx/'+tx;
      if(chain==='bsc') return 'https://bscscan.com/tx/'+tx;
      if(chain==='base') return 'https://basescan.org/tx/'+tx;
      return null;
    }

    function buildBuyUrl(chain, tokenAddr){
      const a = tokenAddr;
      if(!a) return '#';
      if(chain==='solana'){
        // Jupiter swap deep link (works well with Phantom)
        return 'https://jup.ag/swap/SOL-'+encodeURIComponent(a);
      }
      if(chain==='bsc'){
        return 'https://pancakeswap.finance/swap?outputCurrency='+encodeURIComponent(a);
      }
      if(chain==='base'){
        return 'https://app.uniswap.org/swap?chain=base&outputCurrency='+encodeURIComponent(a);
      }
      // eth default
      return 'https://app.uniswap.org/swap?outputCurrency='+encodeURIComponent(a);
    }

    function sanitizeSymbol(s){
      // keep letters, numbers, $ and a few safe symbols
      const t = String(s||'').trim();
      const cleaned = t.replace(/[^A-Za-z0-9\$\-_.]/g,'');
      return cleaned || 'TOKEN';
    }

    // -------------------- UI elements
    const btnBack = $('btnBack');
    const btnX = $('btnX');
    const btnBuy = $('btnBuy');
    const btnFit = $('btnFit');
    const btnRefresh = $('btnRefresh');
    const poolSel = $('poolSel');

    const pairNameEl = $('pairName');
    const pairMetaEl = $('pairMeta');
    const statsEl = $('stats');
    const logoWrap = $('tokenLogo');
    const logoFb = $('tokenLogoFb');
    const statusEl = $('status');
    const tradesEl = $('trades');
    const tradesSub = $('tradesSub');

    const trendStatus = $('trendStatus');
    const trendTrack = $('trendTrack');
    const netPills = $('netPills');

    const q = $('q');
    const qHint = $('qHint');
    const results = $('results');

    // -------------------- Network state
    let activeNet = normalizeChain(rawChain);

    // Net pills
    const NETS = [
      {k:'solana', label:'SOL', dot:'sol'},
      {k:'eth', label:'ETH', dot:'eth'},
      {k:'bsc', label:'BNB', dot:'bnb'},
      {k:'base', label:'BASE', dot:'base'},
    ];
    NETS.forEach(n=>{
      const b=document.createElement('button');
      b.className='net'+(n.k===activeNet?' active':'');
      b.dataset.net=n.k;
      b.innerHTML = `<span class="dot"></span>${esc(n.label)}`;
      b.onclick=()=>{
        // Clicking a chain always loads the *native* chart for that chain (SOL, ETH, BNB, BASE)
        activeNet = n.k;
        [...netPills.children].forEach(x=>x.classList.toggle('active', x.dataset.net===activeNet));
        startTrending(activeNet);
        addr = DEFAULT_TOKEN[activeNet] || DEFAULT_TOKEN.solana;
        navigateTo(activeNet, addr);
      };
      netPills.appendChild(b);
    });

    // -------------------- Chart
    const chart = LightweightCharts.createChart($('chart'), {
      layout: { background: { type: 'solid', color: 'rgba(0,0,0,0)' }, textColor: 'rgba(255,255,255,.86)' },
      grid: { vertLines: { color: 'rgba(255,255,255,.06)' }, horzLines: { color: 'rgba(255,255,255,.06)' } },
      rightPriceScale: { borderColor: 'rgba(255,255,255,.12)' },
      timeScale: { borderColor: 'rgba(255,255,255,.12)', timeVisible: true, secondsVisible: false },
      crosshair: { mode: 1 },
      handleScroll: { mouseWheel: true, pressedMouseMove: true, horzTouchDrag: true, vertTouchDrag: true },
      handleScale: { axisPressedMouseMove: true, mouseWheel: true, pinch: true },
    });

    const candleSeries = chart.addCandlestickSeries({
      priceFormat:{type:'price', precision: 10, minMove: 1e-10},
      upColor: 'rgba(20,241,149,.95)', downColor: 'rgba(255,77,109,.95)',
      wickUpColor: 'rgba(20,241,149,.95)', wickDownColor: 'rgba(255,77,109,.95)',
      borderVisible: false,
    });
    const volumeSeries = chart.addHistogramSeries({
      priceFormat: { type: 'volume' },
      priceScaleId: '',
      lastValueVisible: false,
      base: 0,
    });
    chart.priceScale('').applyOptions({ scaleMargins: { top: 0.85, bottom: 0 } });

    // Live (seconds) line for "LIVE" timeframe
    const liveSeries = chart.addLineSeries({
      color: 'rgba(0,209,255,.92)',
      lineWidth: 2,
      lastValueVisible: true,
      priceLineVisible: true,
    });
    liveSeries.setData([]);
    let livePoints = [];
    let liveLastTs = 0;
    let liveLastPoint = 0;

    window.addEventListener('resize', ()=>{
      chart.applyOptions({ width: $('chart').clientWidth });
    });

    // -------------------- Timeframes (more like real platforms)
    const TF = [
      {k:'LIVE', live:true},
      {k:'1m', api:{tf:'minute', agg:1}, points: 720},
      {k:'5m', api:{tf:'minute', agg:5}, points: 720},
      {k:'15m', api:{tf:'minute', agg:15}, points: 720},
      {k:'1h', api:{tf:'hour', agg:1}, points: 720},
      {k:'4h', api:{tf:'hour', agg:4}, points: 720},
      {k:'1d', api:{tf:'day', agg:1}, points: 900},
      {k:'1w', api:{tf:'day', agg:1}, points: 1200, postAgg:7},
      {k:'1M', api:{tf:'day', agg:1}, points: 1600, postAgg:30},
      {k:'ALL', api:{tf:'day', agg:1}, points: 2500},
    ];

    // Default to a longer view so old coins don't look like they only existed for days.
    let activeTF = TF.find(x=>x.k==='ALL') || TF.find(x=>x.k==='1d') || TF[0];
    const tfRow = $('tfRow');
    TF.forEach(t=>{
      const b=document.createElement('button');
      b.className='tf'+(t.k===activeTF.k?' active':'');
      b.textContent=t.k;
      b.onclick=()=>{
        activeTF = t;
        [...tfRow.children].forEach(x=>x.classList.toggle('active', x.textContent===t.k));
        if(!t.live){
          livePoints = [];
          liveLastTs = 0;
          liveSeries.setData([]);
        }
        loadCandles(true);
      };
      tfRow.appendChild(b);
    });

    // View toggle (Price vs MarketCap)
    const viewRow = $('viewRow');
    const viewButtons = viewRow ? Array.from(viewRow.querySelectorAll('button')) : [];
    function setViewMode(mode){
      viewMode = mode;
      viewButtons.forEach(btn=>btn.classList.toggle('active', btn.dataset.view===mode));
      applyChartData(true);
      // update header pill text to match view
      // header stays the same; only chart y-axis changes
    }
    if(viewRow){
      viewRow.addEventListener('click', (e)=>{
        const b = e.target.closest('button');
        if(!b) return;
        setViewMode(b.dataset.view);
      });
    }

    btnFit.onclick = ()=>chart.timeScale().fitContent();
    btnRefresh.onclick = ()=>{ loadCandles(true); loadTrades(true); };

    // -------------------- Core state
    let poolAddress = null;
    let poolInfo = null;
    let tokenSide = 'base';
    let poolChoices = [];
    let tradesSeen = new Set();
    let searchReqId = 0;
    let viewMode = 'price';
    let supplyFactor = null;
    let rawCandleData = [];


    // -------------------- Buttons    function syncLinks(){
            btnBuy.href = buildBuyUrl(activeNet, addr);
    }

    // -------------------- Navigation
    // Soft navigation: update URL + reload data without a full page refresh.
    function updateUrl(chain, address){
      const url = new URL(location.href);
      url.searchParams.set('chain', chain);
      url.searchParams.set('addr', address);
      history.replaceState({}, '', url.toString());
    }

    // Backwards-compatible helper (older handlers call navigateTo)
    // Soft navigation: switch chain/address and reload chart/trades without a full page refresh.
    async function navigateTo(chain, address){
      activeNet = normalizeChain(chain);
      addr = (address||'').trim();
      updateUrl(activeNet, addr);
      // refresh UI state
      $all('.netBtn').forEach(b=>b.classList.toggle('active', (b.dataset.net||'')===activeNet));
      renderTimeframes();
      // load
      await loadToken(activeNet, addr);
    }

    // -------------------- Trending
    let trendTimer=null;
    function startTrending(net){
      clearInterval(trendTimer);
      loadTrending(net, true);
      trendTimer = setInterval(()=>loadTrending(net, false), 30000);
    }

    function trendCacheKey(net){ return `sos_trend_${net}_v3`; }

    let lastTrending = [];

    function renderTrending(items){
      lastTrending = Array.isArray(items)?items:[];
      if(!items || !items.length){
        trendTrack.innerHTML = `<span class="tickerItem" style="opacity:.75"><span class="rank">!</span><span class="sym">Not found</span></span>`;
        return;
      }

      // duplicate for seamless loop
      const doubled = items.concat(items);
      trendTrack.innerHTML = doubled.map((it, i)=>{
        const rank = (i % items.length) + 1;
        const top1 = rank===1;
        const logo = it.logo || '';
        const sym = '$' + sanitizeSymbol(it.symbol);
        const pct = Number.isFinite(it.h24) ? it.h24 : NaN;
        const pctClass = pct>0 ? 'up' : (pct<0 ? 'down' : '');
        const pctTxt = Number.isFinite(pct) ? `${pct>0?'+':''}${pct.toFixed(2)}%` : 'â€”';

        const safeLogo = esc(logo);
        const fb = esc((sanitizeSymbol(it.symbol)||'T').slice(0,1).toUpperCase());

        return `
        <div class="tickerItem" data-addr="${esc(it.addr)}" data-chain="${esc(activeNet)}" title="Open chart">
          <span class="rank ${top1?'top1':''}">${top1?'ðŸ”¥ 1':rank}</span>
          <span class="tLogo">${logo?`<img src="${safeLogo}" alt="" referrerpolicy="no-referrer" onerror="this.remove(); this.parentNode.textContent='${fb}';">`:`<span class="fb">${fb}</span>`}</span>
          <span class="sym">${esc(sym)}</span>
          <span class="pct ${pctClass}">${esc(pctTxt)}</span>
        </div>`;
      }).join('');

      // click -> go chart
      [...trendTrack.querySelectorAll('.tickerItem')].forEach(el=>{
        el.onclick = ()=>{
          const a = el.getAttribute('data-addr') || '';
          if(a) navigateTo(activeNet, a);
        };
      });

      trendStatus.textContent = 'Live';
    }

    async function loadTrending(net, immediate){
      // show cache immediately
      try{
        const cached = JSON.parse(localStorage.getItem(trendCacheKey(net)) || 'null');
        if(cached && Array.isArray(cached.items) && cached.items.length){
          renderTrending(cached.items);
          if(immediate) trendStatus.textContent = 'Live';
        } else {
          if(immediate) trendStatus.textContent = 'Loadingâ€¦';
        }
      }catch(e){ /* ignore */ }

      try{
        const url = `https://api.geckoterminal.com/api/v2/networks/${encodeURIComponent(geckoNet(net))}/trending_pools?include=base_token,quote_token&page=1`;
        const j = await safeJson(url);
        const pools = j?.data || [];
        const inc = j?.included || [];
        const idToTok = new Map();
        for(const x of inc){
          if(x?.type==='token' && x?.id) idToTok.set(x.id, x.attributes||{});
        }

        const items = pools.slice(0, 10).map((p)=>{
          const a = p?.attributes || {};
          const baseId = p?.relationships?.base_token?.data?.id;
          const quoteId = p?.relationships?.quote_token?.data?.id;
          const base = baseId ? idToTok.get(baseId) : null;
          const quote = quoteId ? idToTok.get(quoteId) : null;
          const tok = base || quote || {};

          const symbol = (tok.symbol || a?.name || 'TOKEN');
          const logo = tok.image_url || tok.logo_uri || tok.logoURI || tok.image || '';

          const h24 = num(a?.price_change_percentage?.h24);

          // Prefer token address for chart route
          const tokenAddr = base?.address || tok.address || '';

          return { symbol, logo, h24, addr: tokenAddr };
        }).filter(x=>x.addr);

        if(items.length){
          localStorage.setItem(trendCacheKey(net), JSON.stringify({t:Date.now(), items}));
          renderTrending(items);
        } else {
          trendStatus.textContent = 'Not found';
        }
      }catch(e){
        // Never show provider / error details
        const cached = JSON.parse(localStorage.getItem(trendCacheKey(net)) || 'null');
        if(cached && cached.items && cached.items.length){
          renderTrending(cached.items);
          trendStatus.textContent = 'Live';
        } else {
          trendStatus.textContent = 'Not found';
          trendTrack.innerHTML = `<span class="tickerItem" style="opacity:.75"><span class="rank">!</span><span class="sym">Not found</span></span>`;
        }
      }
    }

    // -------------------- Search (DexScreener, UI yours)
    const DS_SEARCH = 'https://api.dexscreener.com/latest/dex/search/?q=';

    q.addEventListener('input', ()=>{
      const val = q.value.trim();
      qHint.textContent = val ? 'search' : 'auto';
      if(!val){ results.style.display='none'; results.innerHTML=''; return; }
      debouncedSearch(val);
    });

    let searchTimer=null;
    function debouncedSearch(val){
      clearTimeout(searchTimer);
      searchTimer=setTimeout(()=>runSearch(val), 240);
    }

    async function runSearch(val){
      const myId = ++searchReqId;
      try{
        const j = await safeJson(DS_SEARCH + encodeURIComponent(val));
        if(myId !== searchReqId) return;
        const pairs = (j?.pairs || []).slice(0, 12);
        if(!pairs.length){
          results.style.display='block';
          results.innerHTML = `<div class="resCard"><div class="resItem"><div style="color:rgba(255,255,255,.72);font-weight:900">Not found</div></div></div>`;
          return;
        }

        const mapped = pairs.map(p=>mapDexPair(p)).filter(Boolean);
        results.style.display='block';
        results.innerHTML = `<div class="resCard">${mapped.map(renderResult).join('')}</div>`;

        // click handlers
        [...results.querySelectorAll('[data-go]')].forEach(el=>{
          el.onclick = ()=>{
            const chain = el.getAttribute('data-chain');
            const addr = el.getAttribute('data-addr');
            if(chain && addr) navigateTo(chain, addr);
          };
        });

      }catch(e){
        if(myId !== searchReqId) return;
        results.style.display='block';
        results.innerHTML = `<div class="resCard"><div class="resItem"><div style="color:rgba(255,255,255,.72);font-weight:900">Not found</div></div></div>`;
      }
    }

    function mapDexPair(p){
      // normalize chain
      const chainId = String(p?.chainId||'').toLowerCase();
      let net = null;
      if(chainId==='solana') net='solana';
      else if(chainId==='ethereum') net='eth';
      else if(chainId==='bsc' || chainId==='binance') net='bsc';
      else if(chainId==='base') net='base';
      else return null;

      const base = p?.baseToken || {};
      const quote = p?.quoteToken || {};
      const symbol = sanitizeSymbol(base?.symbol || base?.name || 'TOKEN');
      const pairLabel = symbol + (quote?.symbol?('/'+sanitizeSymbol(quote.symbol)):'');
      const addr = base?.address || '';
      if(!addr) return null;

      const img = p?.info?.imageUrl || p?.info?.image_url || base?.logoURI || base?.icon || base?.image || '';
      const ch24 = num(p?.priceChange?.h24);
      const mcap = num(p?.marketCap);
      const fdv = num(p?.fdv);

      return { net, addr, pairLabel, img, ch24, mcap, fdv };
    }

    function renderResult(it){
      const pct = Number.isFinite(it.ch24) ? it.ch24 : NaN;
      const pctClass = pct>0 ? 'up' : (pct<0 ? 'down' : '');
      const pctTxt = Number.isFinite(pct) ? `${pct>0?'+':''}${pct.toFixed(2)}%` : 'â€”';
      const m = Number.isFinite(it.mcap) ? it.mcap : (Number.isFinite(it.fdv)?it.fdv:NaN);
      const mTxt = Number.isFinite(m) ? '$'+formatCompact(m) : 'â€”';

      const fb = esc(it.pairLabel.slice(0,1).toUpperCase());
      const logoHtml = it.img ? `<img src="${esc(it.img)}" alt="" referrerpolicy="no-referrer" onerror="this.remove(); this.parentNode.textContent='${fb}';">` : `<span class="fb">${fb}</span>`;

      return `
        <div class="resItem" data-go="1" data-chain="${esc(it.net)}" data-addr="${esc(it.addr)}" style="cursor:pointer">
          <div class="resL">
            <div class="resLogo">${logoHtml}</div>
            <div class="resTxt">
              <div class="resName">${esc(it.pairLabel)}</div>
              <div class="resMeta">${esc(it.net.toUpperCase())} â€¢ ${esc(shortAddr(it.addr))}</div>
            </div>
          </div>
          <div class="resR">
            <span class="chip ${pctClass}">24h ${esc(pctTxt)}</span>
            <span class="chip">MCap ${esc(mTxt)}</span>
          </div>
        </div>`;
    }

    // -------------------- Gecko Pool resolution
    function poolCreatedMs(p){
      const a = p?.attributes || {};
      const v = a.pool_created_at || a.created_at || a.createdAt || a.creation_time || '';
      const ms = Date.parse(v);
      return Number.isFinite(ms) ? ms : NaN;
    }

    function poolLiqUsd(p){
      const a = p?.attributes || {};
      const liq = num(a.reserve_in_usd || a.liquidity_in_usd || a.liquidity_usd || a.reserveUsd);
      return Number.isFinite(liq) ? liq : 0;
    }

    function poolDexName(p){
      const a = p?.attributes || {};
      return String(a.dex_name || a.dex || a.exchange || '').trim() || 'DEX';
    }

    function poolAddr(p){
      return p?.attributes?.address || (String(p?.id||'').split('_').pop()) || '';
    }

    function fmtAge(ms){
      if(!Number.isFinite(ms)) return 'â€”';
      const d = Math.max(0, Date.now()-ms);
      const days = Math.floor(d/86400000);
      if(days<1){
        const h = Math.floor(d/3600000);
        return (h<=0?'0h':h+'h');
      }
      if(days<30) return days+'d';
      const m = Math.floor(days/30);
      if(m<12) return m+'mo';
      const y = Math.floor(m/12);
      return y+'y';
    }

    function makePoolLabel(p){
      const a = p?.attributes || {};
      const dex = poolDexName(p);
      const liq = poolLiqUsd(p);
      const age = fmtAge(poolCreatedMs(p));
      const name = String(a.name || a.pool_name || a.identifier || '').trim();
      const nice = name ? name : shortAddr(poolAddr(p));
      return `${dex} â€¢ ${nice} â€¢ Liq $${formatCompact(liq)} â€¢ ${age}`;
    }

    async function resolveBestPool(net, tokenAddr){
    // We prefer pools where the requested token is the *base* token.
    // If we can, we also prefer stable-coin quotes (SOL/USDC, ETH/USDC, ...).
    const tokL = lc(tokenAddr);
    const preferSet = new Set((STABLE_QUOTES[normalizeChain(net)]||[]).map(lc));

    // First, fetch candidate pools for this token
    const url = `${GECKO}/networks/${geckoNet(net)}/tokens/${tokenAddr}/pools?page=1`;
    const j = await safeJson(url);
    const pools = (j?.data||[]).slice();
    // Sort by on-chain reserve (USD) descending
    pools.sort((a,b)=>Number(b?.attributes?.reserve_in_usd||0)-Number(a?.attributes?.reserve_in_usd||0));

    // Fast fallback (best by reserve)
    const fallback = poolAddr(pools[0]);

    // Helper to check token roles via pool detail
    async function poolRoleScore(p){
      const id = poolAddr(p);
      if(!id) return null
    }

    let bestStable = null; let bestStableScore = -1;
    let bestBase = null; let bestBaseScore = -1;

    const candidates = pools.slice(0, 25);
    for(const p of candidates){
      const pAddr = poolAddr(p);
      if(!pAddr) continue;
      let pj;
      try{
        pj = await getPool(net, pAddr);
      }catch(_){
        continue;
      }
      const baseTok = pickToken(pj, 'base_token');
      const quoteTok = pickToken(pj, 'quote_token');
      const baseA = lc(baseTok?.address);
      const quoteA = lc(quoteTok?.address);
      const liq = Number(p?.attributes?.reserve_in_usd||0);
      // Token may be base or quote (EVM often has stable as base and token as quote)
      const tokenIsBase = (baseA === tokL);
      const tokenIsQuote = (quoteA === tokL);
      if(!tokenIsBase && !tokenIsQuote) continue;
      const otherA = tokenIsBase ? quoteA : baseA;

      if(liq > bestBaseScore){ bestBaseScore = liq; bestBase = pAddr; }
      if(preferSet.size && preferSet.has(otherA) && liq > bestStableScore){
        bestStableScore = liq; bestStable = pAddr;
      }
    }

    return { best: (bestStable || bestBase || fallback || null), pools };
  }

  async function getPool(net, poolAddr){
      const url = `https://api.geckoterminal.com/api/v2/networks/${encodeURIComponent(geckoNet(net))}/pools/${encodeURIComponent(poolAddr)}?include=base_token,quote_token`;
      return await safeJson(url);
    }

    function pickToken(pool, rel){
      const relId = pool?.data?.relationships?.[rel]?.data?.id;
      if(!relId) return null;
      const inc = pool?.included || [];
      const tok = inc.find(x=>x.type==='token' && x.id===relId);
      return tok?.attributes || null;
    }

    function computeTokenSide(pool, tokenAddr){
      try{
        const t = lc(tokenAddr);
        const b = pickToken(pool, 'base_token');
        const q = pickToken(pool, 'quote_token');
        if(lc(b?.address) === t) return 'base';
        if(lc(q?.address) === t) return 'quote';
      }catch(e){}
      return 'base';
    }

    // -------------------- Candles (backfill so coins older than a year show properly)
    async function fetchCandlesBackfill(net, poolAddr, tf, points, tokenSide){
      const out=[];
      let before = Math.floor(Date.now()/1000);
      let guard = 0;
      const maxPer = 1000;
      while(out.length < points && guard < 10){
        guard++;
        const need = Math.min(maxPer, points - out.length);
        const url = `https://api.geckoterminal.com/api/v2/networks/${encodeURIComponent(geckoNet(net))}/pools/${encodeURIComponent(poolAddr)}/ohlcv/${encodeURIComponent(tf.tf)}?aggregate=${tf.agg}&before_timestamp=${before}&limit=${need}&currency=usd&token=${encodeURIComponent(tokenSide||"base")}`;
        const j = await safeJson(url);
        const arr = j?.data?.attributes?.ohlcv_list || [];
        if(!arr.length) break;
        for(const x of arr){
          const t = Number(x[0]);
          const o = Number(x[1]);
          const h = Number(x[2]);
          const l = Number(x[3]);
          const c = Number(x[4]);
          const v = Number(x[5]);
          if(Number.isFinite(t) && Number.isFinite(o)) out.push({time:t, open:o, high:h, low:l, close:c, volume:Number.isFinite(v)?v:0});
        }
        // move cursor older
        const oldest = Number(arr[arr.length-1][0]);
        if(!Number.isFinite(oldest)) break;
        before = oldest - 1;
        // if endpoint returns newest->oldest, we're good.
      }
      // dedupe + sort
      const m = new Map();
      for(const c of out){ m.set(c.time, c); }
      const candles = [...m.values()].sort((a,b)=>a.time-b.time);
      return candles;
    }

    function aggregateCandles(candles, group){
      if(group<=1) return candles;
      const out=[];
      let bucket=[];
      for(const c of candles){
        bucket.push(c);
        if(bucket.length===group){
          out.push(bucketToCandle(bucket));
          bucket=[];
        }
      }
      if(bucket.length>=Math.max(2, Math.floor(group*0.6))) out.push(bucketToCandle(bucket));
      return out;
    }

    function bucketToCandle(bucket){
      const first=bucket[0], last=bucket[bucket.length-1];
      let high=-Infinity, low=Infinity, vol=0;
      for(const c of bucket){
        if(c.high>high) high=c.high;
        if(c.low<low) low=c.low;
        vol += (c.volume||0);
      }
      // align time to first
      return {time:first.time, open:first.open, high, low, close:last.close, volume:vol};
    }

    async function loadCandles(fit){
      if(!poolAddress) return;
      // LIVE timeframe is built from trades (seconds-ish). No candle fetch.
      if(activeTF && activeTF.live){
        chart.applyOptions({ timeScale: { timeVisible: true, secondsVisible: true } });
        candleSeries.setData([]);
        volumeSeries.setData([]);
        if(fit) chart.timeScale().fitContent();
        statusEl.textContent = 'Live';
        return;
      }
      try{
        statusEl.textContent = 'Loadingâ€¦';
        chart.applyOptions({ timeScale: { timeVisible: true, secondsVisible: false } });
        const raw = await fetchCandlesBackfill(activeNet, poolAddress, activeTF.api, activeTF.points, tokenSide);
        let candles = raw;
        if(activeTF.postAgg) candles = aggregateCandles(raw, activeTF.postAgg);
        if(candles.length){
          candleSeries.setData(candles.map(c=>({time:c.time, open:c.open, high:c.high, low:c.low, close:c.close})));
          volumeSeries.setData(candles.map(c=>({time:c.time, value:c.volume, color: (c.close>=c.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'})));
          if(fit) chart.timeScale().fitContent();
        }
        statusEl.textContent = 'Live';
      }catch(e){
        statusEl.textContent = 'Not found';
      }
    }

    // -------------------- Trades (real live feed: append new, show wallet + tx link)
    async function loadTrades(full){
      if(!poolAddress) return;
      try{
        const url = `https://api.geckoterminal.com/api/v2/networks/${encodeURIComponent(geckoNet(activeNet))}/pools/${encodeURIComponent(poolAddress)}/trades?limit=80`;
        const j = await safeJson(url);
        const rows = (j?.data || []).map(x=>({id:x?.id || (x?.attributes?.tx_hash||''), a:x?.attributes||{}})).filter(x=>x.id);
        if(!rows.length){
          if(full) tradesEl.innerHTML = emptyTrades('Not found');
          return;
        }
        // newest first
        rows.sort((x,y)=>Number(y.a?.block_timestamp||0)-Number(x.a?.block_timestamp||0));

        // Feed LIVE chart from the most recent trade
        const newest = rows[0]?.a || null;
        const newestTs = num(newest?.block_timestamp);
        const newestPx = tradePriceUsd(newest);
        if(activeTF && activeTF.live && Number.isFinite(newestTs) && Number.isFinite(newestPx)){
          pushLivePoint(newestTs, newestPx);
          // keep view tight on live points
          chart.timeScale().fitContent();
        }

        if(full){ tradesSeen.clear(); }

        const html=[];
        let newCount=0;
        for(const r of rows.slice(0, 60)){
          const key = r.id;
          if(!full && tradesSeen.has(key)) continue;
          tradesSeen.add(key);
          newCount++;
        }

        // Re-render lightweight but stable: keep top 60 from latest set
        const latestKeys = new Set(rows.slice(0,60).map(r=>r.id));
        tradesSeen = new Set([...tradesSeen].filter(k=>latestKeys.has(k)));

        tradesEl.innerHTML = rows.slice(0, 60).map(r=>renderTrade(r.a)).join('');
        const stamp = newestTs ? `${timeAgo(newestTs*1000)} ago` : '';
        if(newCount && !full) tradesSub.textContent = `Buys / Sells â€¢ +${newCount}${stamp?` â€¢ ${stamp}`:''}`;
        else tradesSub.textContent = `Buys / Sells${stamp?` â€¢ ${stamp}`:''}`;
      }catch(e){
        if(full) tradesEl.innerHTML = emptyTrades('Not found');
      }
    }

    function renderTrade(t){
      const kind = String(t?.kind||'').toLowerCase();
      const isBuy = kind==='buy';
      const isSell = kind==='sell';
      const css = isBuy?'buy':(isSell?'sell':'');
      const ts = num(t?.block_timestamp);
      const when = Number.isFinite(ts) ? timeAgo(ts*1000) : 'â€”';

      const amountUsd = num(t?.volume_in_usd);
      const baseAmt = num(t?.base_token_amount);

      const tx = t?.tx_hash || t?.txHash || t?.transaction_hash || '';
      const who = t?.tx_from_address || t?.from_address || t?.wallet || t?.wallet_address || t?.user_address || t?.trader_address || t?.trader || t?.maker_address || t?.taker_address || (t?.attributes&& (t.attributes.tx_from_address||t.attributes.from_address||t.attributes.trader_address||t.attributes.wallet_address)) || '';
      const txUrl = explorerTx(activeNet, tx);

      return `<div class="trade">
        <div class="tL">
          <div class="tType ${css}">${isBuy?'BUY':(isSell?'SELL':'TRADE')}</div>
          <div class="tMeta">
            <span>${esc(when)}</span>
            ${who?`<span>${esc(shortAddr(who))}</span>`:''}
            ${txUrl?`<a href="${esc(txUrl)}" target="_blank" rel="noreferrer">tx</a>`:''}
          </div>
        </div>
        <div class="tR">
          <div class="tAmt">${Number.isFinite(baseAmt)?formatCompact(baseAmt):'â€”'}</div>
          <div class="tUsd">${Number.isFinite(amountUsd)?`$${formatCompact(amountUsd)}`:'â€”'}</div>
        </div>
      </div>`;
    }

    function emptyTrades(txt){
      return `<div style="padding:16px 14px; color:rgba(255,255,255,.70); font-weight:850">${esc(txt)}</div>`;
    }

    function tradePriceUsd(t){
      // Gecko varies by network/DEX; try multiple keys.
      return num(
        t?.price_in_usd ?? t?.price_usd ?? t?.priceUsd ?? t?.base_token_price_usd ?? t?.token_price_usd ?? t?.price
      );
    }

    function pushLivePoint(tsSec, priceUsd){
      if(!Number.isFinite(tsSec) || !Number.isFinite(priceUsd)) return;
      const t = Math.floor(tsSec);
      if(t<=0) return;
      // avoid duplicate timestamps
      if(t <= liveLastTs){
        // replace last point if same second
        if(livePoints.length){
          livePoints[livePoints.length-1] = {time: t, value: priceUsd};
        }else{
          livePoints.push({time: t, value: priceUsd});
        }
      }else{
        livePoints.push({time: t, value: priceUsd});
        liveLastTs = t;
      }
      // keep last ~8 minutes (480 points) so it stays snappy
      if(livePoints.length > 480) livePoints = livePoints.slice(-480);
      liveSeries.setData(livePoints);
    }

    // -------------------- Header rendering
    function renderHeader(pool){
      const a = pool?.data?.attributes || {};
      const base = pickToken(pool, 'base_token');
      const quote = pickToken(pool, 'quote_token');

      const baseSymRaw = sanitizeSymbol(base?.symbol || base?.name || 'TOKEN');
      const quoteSym = sanitizeSymbol(quote?.symbol || quote?.name || '');

      // Make native chain charts look like SOL/USDC, ETH/USDC, BNB/USDT, etc.
      const nativeAddr = (DEFAULT_TOKEN[activeNet] || '').toLowerCase();
      const baseAddr = (base?.address || base?.id || '').toLowerCase();
      const isNative = !!nativeAddr && baseAddr === nativeAddr;
      const nativeSymbol = ({ solana:'SOL', ethereum:'ETH', bsc:'BNB', base:'ETH' })[activeNet] || baseSymRaw;
      const baseSym = isNative ? nativeSymbol : baseSymRaw;

      const prefix = isNative ? '' : '$';
      const title = quoteSym ? `${prefix}${baseSym}/${quoteSym}` : `${prefix}${baseSym}`;
      pairNameEl.textContent = title;
      pairMetaEl.textContent = `${activeNet.toUpperCase()} â€¢ ${shortAddr(addr)} â€¢ Pool ${shortAddr(poolAddress)}`;

      const img = base?.image_url || base?.logo_uri || base?.logoURI || base?.image || '';
      if(img){
        const fb = esc((baseSym||'T').slice(0,1).toUpperCase());
        logoWrap.innerHTML = `<img src="${esc(img)}" alt="" referrerpolicy="no-referrer" onerror="this.remove(); this.parentNode.textContent='${fb}';">`;
      }else{
        logoWrap.innerHTML = `<span class="fb">${esc((baseSym||'T').slice(0,1).toUpperCase())}</span>`;
      }

      // Stats
      const ch24 = num(a?.price_change_percentage?.h24);
      const price = num(a?.base_token_price_usd || a?.token_price_usd || a?.price_usd);
      const vol24 = num(a?.volume_usd?.h24);
      const mcap = num(a?.market_cap_usd);
      const fdv = num(a?.fdv_usd);

      const pills = [];
      if(Number.isFinite(ch24)) pills.push(`<span class="pill ${ch24>0?'up':(ch24<0?'down':'')}">24h ${ch24>0?'+':''}${ch24.toFixed(2)}%</span>`);
      if(Number.isFinite(price)) pills.push(`<span class="pill">Price $${formatPrice(price)}</span>`);
      if(Number.isFinite(vol24)) pills.push(`<span class="pill">Vol $${formatCompact(vol24)}</span>`);
      if(Number.isFinite(mcap)) pills.push(`<span class="pill">MCap $${formatCompact(mcap)}</span>`);
      else if(Number.isFinite(fdv)) pills.push(`<span class="pill">FDV $${formatCompact(fdv)}</span>`);

      statsEl.innerHTML = pills.join('') || `<span class="pill">Not found</span>`;
    }

    // -------------------- Init
    activeNet = normalizeChain(rawChain);
    addr = addr.trim();

    // Default: always show the real native chart for the selected chain on first visit
    if(!addr){
      addr = DEFAULT_TOKEN[activeNet] || DEFAULT_TOKEN.solana;
      try{
        const u = new URL(location.href);
        u.pathname = '/chart';
        u.searchParams.set('chain', activeNet);
        u.searchParams.set('addr', addr);
        history.replaceState({}, '', u.toString());
      }catch(e){}
    }

    syncLinks();
    startTrending(activeNet);
    boot();

    async function boot(){
      try{
        statusEl.textContent = 'Loadingâ€¦';
        let rp = await resolveBestPool(activeNet, addr);
        if(typeof rp === 'string'){ rp = { best: rp, pools: [] }; }
        poolChoices = rp.pools || [];
        poolAddress = rp.best;
        if(!poolAddress) throw new Error('Not found');

        // Pool dropdown (lets user switch pools to get older history / better liquidity)
        if(poolChoices.length > 1){
          poolSel.style.display = '';
          poolSel.innerHTML = poolChoices.map(p=>{
            const v = poolAddr(p);
            const lab = makePoolLabel(p);
            return `<option value="${esc(v)}">${esc(lab)}</option>`;
          }).join('');
          poolSel.value = poolAddress;
          poolSel.onchange = async ()=>{
            const v = poolSel.value;
            if(!v || v===poolAddress) return;
            poolAddress = v;
            tradesSeen.clear();
            statusEl.textContent = 'Loadingâ€¦';
            try{
              poolInfo = await getPool(activeNet, poolAddress);
        tokenSide = computeTokenSide(poolInfo, addr);
        renderHeader(poolInfo);
              await loadCandles(true);
              await loadTrades(true);
              statusEl.textContent = 'Live';
            }catch(e){
              statusEl.textContent = 'Not found';
            }
          };
        }else{
          poolSel.style.display = 'none';
        }
        poolInfo = await getPool(activeNet, poolAddress);
        renderHeader(poolInfo);
        syncLinks();

        await loadCandles(true);
        await loadTrades(true);

        setInterval(()=>loadTrades(false), 3500);
        setInterval(()=>loadCandles(false), 25000);

        statusEl.textContent = 'Live';
      }catch(e){
        pairNameEl.textContent = 'Not found';
        pairMetaEl.textContent = `${activeNet.toUpperCase()} â€¢ ${shortAddr(addr)}`;
        statusEl.textContent = 'Not found';
        tradesEl.innerHTML = emptyTrades('Not found');
      }
    }

  })();
  </script>
</body>
</html>
