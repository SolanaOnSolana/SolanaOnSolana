<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#070711" />
  <title>$SOS â€” DEX Terminal (Multi-Chain)</title>
  <meta name="description" content="$SOS DEX Terminal â€” native chart + live trades across Solana, Ethereum, BNB, Base." />

  <style>
    :root{
      --bg:#070711;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.085);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --muted2: rgba(255,255,255,.55);
      --g:#14F195;
      --r:#FF4D6D;
      --c:#00D1FF;
      --p:#9945FF;
      --radius: 22px;
      --shadow: 0 14px 40px rgba(0,0,0,.55);
      --max: 1280px;
      --glass: blur(14px);
      --t: .18s ease;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:
        radial-gradient(1200px 600px at 20% 0%, rgba(153,69,255,.22), transparent 60%),
        radial-gradient(1200px 600px at 85% 25%, rgba(0,209,255,.14), transparent 60%),
        radial-gradient(1200px 600px at 50% 90%, rgba(20,241,149,.12), transparent 65%),
        var(--bg);
      color:var(--text);
      font: 15.5px/1.55 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow-x:hidden;
    }

    a{color:inherit; text-decoration:none}
    button,input,select{font:inherit}

    .wrap{max-width:var(--max); margin:0 auto; padding:18px 16px 28px}

    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:12px 12px;
      border:1px solid var(--stroke);
      background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.04));
      border-radius: 26px;
      box-shadow: var(--shadow);
      backdrop-filter: var(--glass);
      position:sticky; top:10px; z-index:20;
    }

    .brand{display:flex; align-items:center; gap:10px; min-width:0}
    .logo{
      width:38px; height:38px; border-radius:14px;
      display:grid; place-items:center;
      background:
        radial-gradient(14px 14px at 35% 30%, rgba(20,241,149,.9), transparent 60%),
        radial-gradient(14px 14px at 70% 35%, rgba(0,209,255,.9), transparent 60%),
        radial-gradient(14px 14px at 50% 80%, rgba(153,69,255,.9), transparent 60%),
        rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
    }
    .logo span{font-weight:900; letter-spacing:-.02em}

    .brandTxt{min-width:0}
    .brandTxt .t1{font-weight:900; letter-spacing:-.02em; font-size:15px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .brandTxt .t2{font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}

    .actions{display:flex; align-items:center; gap:10px}

    .pillRow{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
    .pill{
      display:inline-flex; align-items:center; gap:7px;
      padding:9px 12px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.85);
      cursor:pointer;
      user-select:none;
      transition: transform var(--t), background var(--t), border-color var(--t);
    }
    .pill:hover{transform: translateY(-1px); background: rgba(255,255,255,.07)}
    .pill.active{border-color: rgba(153,69,255,.55); background: rgba(153,69,255,.14)}
    .pill .dot{width:10px; height:10px; border-radius:50%; background: rgba(255,255,255,.18); box-shadow: inset 0 0 0 1px rgba(255,255,255,.14)}
    .pill.active .dot{background: var(--p)}

    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px;
      padding:10px 14px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      cursor:pointer;
      transition: transform var(--t), background var(--t), border-color var(--t);
    }
    .btn:hover{transform: translateY(-1px); background: rgba(255,255,255,.085)}
    .btn.primary{background: rgba(20,241,149,.14); border-color: rgba(20,241,149,.32)}
    .btn.ghost{background: rgba(255,255,255,.03)}

    .panel{
      margin-top:14px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: var(--glass);
      overflow:hidden;
    }

    .tickerHd{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:14px 16px;
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    .tickerHd .left{display:flex; align-items:center; gap:10px}
    .tag{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 12px;
      border-radius:999px;
      border:1px solid rgba(153,69,255,.35);
      background: rgba(153,69,255,.14);
      font-weight:800;
    }
    .tag small{font-weight:700; color: var(--muted)}

    .ticker{
      position:relative;
      overflow:hidden;
      padding:10px 0 12px;
      border-top:1px solid rgba(255,255,255,.06);
    }
    .tickerTrack{
      display:flex; gap:12px;
      width:max-content;
      animation: marquee 26s linear infinite;
      padding: 0 14px;
    }
    @keyframes marquee{
      from{transform: translateX(0)}
      to{transform: translateX(-50%)}
    }

    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      white-space:nowrap;
      cursor:pointer;
      transition: transform var(--t), background var(--t), border-color var(--t);
    }
    .chip:hover{transform: translateY(-1px); background: rgba(255,255,255,.075)}
    .chip .rank{
      width:26px; height:26px; border-radius:999px;
      display:grid; place-items:center;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      font-weight:900; font-size:12px;
    }
    .chip .img{width:22px; height:22px; border-radius:8px; overflow:hidden; display:grid; place-items:center; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10)}
    .chip .img img{width:100%; height:100%; object-fit:cover}
    .chip .nm{font-weight:900; letter-spacing:-.01em}
    .chip .pct{font-weight:900}
    .pct.up{color: rgba(20,241,149,.95)}
    .pct.down{color: rgba(255,77,109,.95)}

    .searchBar{
      display:flex; align-items:center; gap:10px;
      padding:14px 16px;
      border-top:1px solid rgba(255,255,255,.06);
      background: rgba(0,0,0,.10);
    }
    .search{
      flex:1;
      position:relative;
    }
    .search input{
      width:100%;
      padding:14px 44px 14px 44px;
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color: var(--text);
      outline:none;
    }
    .search input:focus{border-color: rgba(0,209,255,.35)}
    .search .icon{
      position:absolute; left:14px; top:50%; transform: translateY(-50%);
      width:22px; height:22px; opacity:.75
    }
    .search .hint{
      position:absolute; right:12px; top:50%; transform: translateY(-50%);
      font-size:12px; color: var(--muted2);
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.12);
    }

    .results{
      position:absolute; left:0; right:0; top:calc(100% + 8px);
      background: rgba(10,10,18,.92);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      box-shadow: 0 20px 70px rgba(0,0,0,.65);
      backdrop-filter: blur(14px);
      overflow:hidden;
      display:none;
      z-index:30;
      max-height: 360px;
      overflow:auto;
    }
    .resItem{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:12px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      cursor:pointer;
    }
    .resItem:hover{background: rgba(255,255,255,.06)}
    .resL{display:flex; align-items:center; gap:10px; min-width:0}
    .resLogo{width:34px; height:34px; border-radius:12px; overflow:hidden; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10); display:grid; place-items:center}
    .resLogo img{width:100%; height:100%; object-fit:cover}
    .resTxt{min-width:0}
    .resName{font-weight:900; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .resMeta{font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .resR{display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:flex-end}

    .grid{
      display:grid;
      grid-template-columns: 1.8fr 1fr;
      gap:14px;
      padding:14px;
    }

    .card{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.045);
      border-radius: 20px;
      overflow:hidden;
    }

    .cardHd{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:14px 14px;
      border-bottom:1px solid rgba(255,255,255,.07);
    }
    .pair{display:flex; align-items:center; gap:10px; min-width:0}
    .tlogo{width:38px; height:38px; border-radius:14px; overflow:hidden; display:grid; place-items:center; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10)}
    .tlogo img{width:100%; height:100%; object-fit:cover}
    .tlogo .fb{font-weight:900; opacity:.9}
    .pairTxt{min-width:0}
    .pairName{font-weight:950; letter-spacing:-.02em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .pairMeta{font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}

    .stats{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}
    .statPill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.10);
      font-size:12px;
      color: rgba(255,255,255,.86);
      white-space:nowrap;
    }
    .statPill.up{border-color: rgba(20,241,149,.30); background: rgba(20,241,149,.10); color: rgba(20,241,149,.92)}
    .statPill.down{border-color: rgba(255,77,109,.28); background: rgba(255,77,109,.10); color: rgba(255,77,109,.92)}

    #chartWrap{height: 520px; position:relative}
    #chart{position:absolute; inset:0}

    .controls{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:12px 12px;
      border-top:1px solid rgba(255,255,255,.07);
      background: rgba(0,0,0,.10);
      flex-wrap:wrap;
    }

    .tfRow{display:flex; gap:6px; flex-wrap:wrap}
    .tf{padding:8px 10px; border-radius: 999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); cursor:pointer; font-weight:850; font-size:12px}
    .tf.active{border-color: rgba(0,209,255,.42); background: rgba(0,209,255,.14)}

    .rightCtl{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .sel{padding:9px 10px; border-radius: 999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); color: var(--text)}

    .tableHd{
      display:flex; align-items:flex-end; justify-content:space-between;
      padding:14px 14px;
      border-bottom:1px solid rgba(255,255,255,.07);
    }
    .ttl{font-weight:950; letter-spacing:-.02em}
    .sub{font-size:12px; color:var(--muted)}

    .trades{
      height: 600px;
      overflow:auto;
    }

    .tradeHead, .tradeRow{
      display:grid;
      grid-template-columns: 90px 70px 90px 1fr 110px 1fr 34px;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      font-size:13px;
    }
    .tradeHead{
      position:sticky; top:0; z-index:5;
      background: rgba(12,12,20,.92);
      backdrop-filter: blur(12px);
      font-size:12px;
      color: rgba(255,255,255,.72);
      font-weight:900;
    }
    .tradeRow:hover{background: rgba(255,255,255,.05)}
    .typeBadge{
      display:inline-flex; align-items:center; justify-content:center;
      padding:6px 10px;
      border-radius:999px;
      font-weight:950;
      font-size:12px;
      letter-spacing:-.01em;
      border:1px solid rgba(255,255,255,.10);
      width:fit-content;
    }
    .typeBadge.buy{background: rgba(20,241,149,.10); border-color: rgba(20,241,149,.30); color: rgba(20,241,149,.95)}
    .typeBadge.sell{background: rgba(255,77,109,.10); border-color: rgba(255,77,109,.28); color: rgba(255,77,109,.95)}

    .mono{font-variant-numeric: tabular-nums; font-feature-settings: "tnum" 1}
    .maker{display:flex; align-items:center; gap:8px; min-width:0}
    .maker .addr{white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color: rgba(255,255,255,.85)}
    .maker .new{font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid rgba(153,69,255,.30); background: rgba(153,69,255,.12); color: rgba(153,69,255,.95); font-weight:900}

    .iconBtn{width:30px; height:30px; border-radius: 999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); display:grid; place-items:center; cursor:pointer}
    .iconBtn:hover{background: rgba(255,255,255,.08)}

    .toast{
      position:fixed;
      left:50%; transform: translateX(-50%);
      bottom:18px;
      background: rgba(10,10,18,.92);
      border:1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.92);
      padding:12px 14px;
      border-radius: 14px;
      box-shadow: 0 14px 60px rgba(0,0,0,.65);
      backdrop-filter: blur(14px);
      display:none;
      z-index:60;
      max-width: calc(100% - 24px);
    }

    /* Mobile-first: keep it clean */
    .mobileTabs{display:none}
    .tabBar{
      display:flex; gap:8px;
      padding:12px 12px;
      border-top:1px solid rgba(255,255,255,.06);
      background: rgba(0,0,0,.12);
    }
    .tab{
      flex:1;
      padding:10px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      font-weight:950;
      cursor:pointer;
      text-align:center;
    }
    .tab.active{border-color: rgba(153,69,255,.55); background: rgba(153,69,255,.14)}

    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr}
      .trades{height: 420px}
      #chartWrap{height: 420px}
      .topbar{position:sticky; top:10px}
    }

    @media (max-width: 640px){
      .wrap{padding:14px 12px 22px}
      .topbar{padding:10px 10px}
      .brandTxt .t2{display:none}
      .pillRow{gap:6px}
      .pill{padding:8px 10px}
      .tickerTrack{animation-duration: 22s}
      .grid{padding:12px}
      .stats{justify-content:flex-start}

      /* Mobile tabs: show chart OR trades, not both */
      .desktopOnly{display:none}
      .mobileTabs{display:block}
      #chartWrap{height: 440px}
      .trades{height: 520px}

      .tradeHead, .tradeRow{grid-template-columns: 62px 64px 78px 1fr 0 0 34px}
      .tradeHead .hideM, .tradeRow .hideM{display:none}
      .maker .new{display:none}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <div class="logo"><span>SOS</span></div>
        <div class="brandTxt">
          <div class="t1">$SOS â€” DEX Terminal</div>
          <div class="t2">Native chart + live trades â€¢ Multi-chain</div>
        </div>
      </div>

      <div class="actions">
        <div class="pillRow" id="netPills"></div>
        <a class="btn ghost" id="btnBack" href="/">Back to Main</a>
        <button class="btn" id="btnClose" type="button">X</button>
        <a class="btn primary" id="btnBuy" href="#" target="_blank" rel="noreferrer">Buy</a>
      </div>
    </div>

    <div class="panel">
      <div class="tickerHd">
        <div class="left">
          <div class="tag">ðŸ”¥ Live Trending <small id="trendSub">(auto)</small></div>
          <div class="sub" id="status">Bootingâ€¦</div>
        </div>
        <div class="sub" id="clock"></div>
      </div>

      <div class="ticker">
        <div class="tickerTrack" id="tickerTrack"></div>
      </div>

      <div class="searchBar">
        <div class="search">
          <svg class="icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 18a7.5 7.5 0 1 1 0-15 7.5 7.5 0 0 1 0 15Z" stroke="rgba(255,255,255,.75)" stroke-width="2"/><path d="M16.5 16.5 21 21" stroke="rgba(255,255,255,.75)" stroke-width="2" stroke-linecap="round"/></svg>
          <input id="q" placeholder="Search token name or paste contract (SOL / ETH / BNB / BASE)â€¦" autocomplete="off" spellcheck="false" />
          <div class="hint" id="modeHint">auto</div>
          <div class="results" id="results"></div>
        </div>
        <button class="btn" id="btnGo" type="button">Open</button>
      </div>

      <div class="grid">
        <div class="card" id="chartCard">
          <div class="cardHd">
            <div class="pair">
              <div class="tlogo" id="tokenLogo"><span class="fb" id="tokenLogoFb">$</span></div>
              <div class="pairTxt">
                <div class="pairName" id="pairName">â€”</div>
                <div class="pairMeta" id="pairMeta">Paste a token / choose a trending token</div>
              </div>
            </div>
            <div class="stats" id="stats"></div>
          </div>

          <div id="chartWrap"><div id="chart"></div></div>

          <div class="controls">
            <div class="tfRow" id="tfRow"></div>
            <div class="rightCtl">
              <button class="btn" id="btnFit" type="button">Fit</button>
              <button class="btn" id="btnRefresh" type="button">Refresh</button>
              <select class="sel" id="poolSel" title="Pool"></select>
            </div>
          </div>

          <div class="mobileTabs">
            <div class="tabBar">
              <button class="tab active" id="tabChart" type="button">Chart</button>
              <button class="tab" id="tabTrades" type="button">Trades</button>
            </div>
          </div>
        </div>

        <div class="card desktopOnly" id="tradesCard">
          <div class="tableHd">
            <div>
              <div class="ttl">Live Trades</div>
              <div class="sub" id="tradesSub">Buys / Sells (live)</div>
            </div>
            <div class="sub" id="tradesStat">â€”</div>
          </div>

          <div class="trades" id="trades">
            <div class="tradeHead">
              <div class="col age">Age</div>
              <div class="col type">Type</div>
              <div class="col usd">USD</div>
              <div class="col amt">Amount</div>
              <div class="col price hideM">Price</div>
              <div class="col maker hideM">Maker</div>
              <div class="col links"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="grid mobileTabs" id="mobileTradesWrap" style="display:none; padding-top:0">
        <div class="card" style="grid-column:1/-1">
          <div class="tableHd">
            <div>
              <div class="ttl">Live Trades</div>
              <div class="sub" id="tradesSubM">Buys / Sells (live)</div>
            </div>
            <div class="sub" id="tradesStatM">â€”</div>
          </div>
          <div class="trades" id="tradesM">
            <div class="tradeHead">
              <div class="col age">Age</div>
              <div class="col type">Type</div>
              <div class="col usd">USD</div>
              <div class="col amt">Amount</div>
              <div class="col price hideM">Price</div>
              <div class="col maker hideM">Maker</div>
              <div class="col links"></div>
            </div>
          </div>
        </div>
      </div>

    </div>

    <div class="toast" id="toast"></div>
  </div>

  <script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js"></script>
  <script>
  (function(){
    // =========================================================
    //  $SOS DEX Terminal â€” from scratch
    //  Data sources:
    //   - Token discovery: DexScreener public API (search + token pairs)
    //   - OHLCV + trades: GeckoTerminal API (pools)
    //  No embeds. No third-party iframes.
    // =========================================================

    // -------------------- Constants
    const GECKO = 'https://api.geckoterminal.com/api/v2';
    const DS = 'https://api.dexscreener.com/latest/dex';

    const NET_LABEL = { solana:'SOL', eth:'ETH', bsc:'BNB', base:'BASE' };
    const NET_DS = { solana:'solana', eth:'ethereum', bsc:'bsc', base:'base' };
    const NET_GECKO = { solana:'solana', eth:'ethereum', bsc:'bsc', base:'base' };

    const DEFAULT_TOKEN = {
      solana: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC
      eth:    '0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',  // USDC
      bsc:    '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d',  // USDC
      base:   '0x833589fCD6eDb6E08f4c7C32D4f71b54bda02913'   // USDC
    };

    // Prefer stable quote pools for chart correctness
    const STABLE_QUOTES = {
      solana: ['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'],
      eth: ['0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48','0xdAC17F958D2ee523a2206206994597C13D831ec7'],
      bsc: ['0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d','0x55d398326f99059fF775485246999027B3197955'],
      base:['0x833589fCD6eDb6E08f4c7C32D4f71b54bda02913']
    };

    // Chart timeframes -> Gecko candle granularity
    const TF = [
      {k:'1m',  gecko:'minute',   agg:60,    live:true},
      {k:'5m',  gecko:'minute',   agg:300},
      {k:'15m', gecko:'minute',   agg:900},
      {k:'1h',  gecko:'hour',     agg:3600},
      {k:'4h',  gecko:'hour',     agg:14400},
      {k:'1d',  gecko:'day',      agg:86400},
      {k:'ALL', gecko:'day',      agg:86400}
    ];

    // -------------------- DOM
    const $ = (id)=>document.getElementById(id);
    const netPills = $('netPills');
    const statusEl = $('status');
    const clockEl = $('clock');
    const tickerTrack = $('tickerTrack');
    const q = $('q');
    const results = $('results');
    const btnGo = $('btnGo');
    const modeHint = $('modeHint');

    const pairNameEl = $('pairName');
    const pairMetaEl = $('pairMeta');
    const statsEl = $('stats');
    const tokenLogo = $('tokenLogo');
    const tokenLogoFb = $('tokenLogoFb');

    const poolSel = $('poolSel');
    const tfRow = $('tfRow');
    const btnFit = $('btnFit');
    const btnRefresh = $('btnRefresh');

    const tradesDesk = $('trades');
    const tradesMob = $('tradesM');
    const tradesStat = $('tradesStat');
    const tradesStatM = $('tradesStatM');

    const btnBack = $('btnBack');
    const btnClose = $('btnClose');
    const btnBuy = $('btnBuy');

    const tabChart = $('tabChart');
    const tabTrades = $('tabTrades');
    const mobileTradesWrap = $('mobileTradesWrap');
    const chartCard = $('chartCard');
    const tradesCard = $('tradesCard');

    const toastEl = $('toast');

    // -------------------- Helpers
    const sleep = (ms)=>new Promise(r=>setTimeout(r, ms));
    const lc = (v)=>String(v||'').toLowerCase();

    function toast(msg, ms=2200){
      toastEl.textContent = msg;
      toastEl.style.display='block';
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=>toastEl.style.display='none', ms);
    }

    function esc(s){
      return String(s??'').replace(/[&<>"]/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[m]));
    }

    function shortAddr(a){
      a = String(a||'');
      if(a.length<=14) return a;
      return a.slice(0,6)+'â€¦'+a.slice(-4);
    }

    function num(v){
      const n = Number(v);
      return Number.isFinite(n) ? n : NaN;
    }

    function formatCompact(n){
      n = Number(n);
      if(!Number.isFinite(n)) return 'â€”';
      const abs = Math.abs(n);
      const s = (x)=> (Math.round(x*100)/100).toString();
      if(abs>=1e12) return s(n/1e12)+'T';
      if(abs>=1e9)  return s(n/1e9)+'B';
      if(abs>=1e6)  return s(n/1e6)+'M';
      if(abs>=1e3)  return s(n/1e3)+'K';
      if(abs>=1)    return (Math.round(n*10000)/10000).toString();
      return n.toPrecision(3);
    }

    function formatPrice(v){
      v = Number(v);
      if(!Number.isFinite(v)) return 'â€”';
      if(v===0) return '0';
      if(v>=1) return v.toFixed(6).replace(/0+$/,'').replace(/\.$/,'');
      // small price
      const s = v.toPrecision(6);
      return s;
    }

    function nowClock(){
      const d = new Date();
      clockEl.textContent = d.toLocaleString(undefined, {hour:'2-digit', minute:'2-digit', second:'2-digit'});
    }

    // fetch with timeout + retry + CORS fallback via allorigins
    async function fetchJson(url, {timeout=12000, retries=1}={}){
      const proxy = (u)=>'https://api.allorigins.win/raw?url=' + encodeURIComponent(u);
      let lastErr=null;
      for(let i=0;i<=retries;i++){
        const ctl = new AbortController();
        const t = setTimeout(()=>ctl.abort(), timeout);
        try{
          const r = await fetch(url, {
            headers:{'accept':'application/json'},
            signal: ctl.signal,
            cache: 'no-store'
          });
          clearTimeout(t);
          if(!r.ok) throw new Error('HTTP '+r.status);
          return await r.json();
        }catch(e){
          clearTimeout(t);
          lastErr=e;
          // try proxy for CORS / network error
          try{
            const msg = String(e&&e.message||e||'');
            const isCors = (e instanceof TypeError) || /Failed to fetch|NetworkError|CORS/i.test(msg);
            if(isCors){
              const r2 = await fetch(proxy(url), {cache:'no-store'});
              if(r2.ok){
                const txt = await r2.text();
                return JSON.parse(txt);
              }
            }
          }catch(_){ }
          if(i<retries) await sleep(250*(i+1));
        }
      }
      throw lastErr || new Error('Network');
    }

    function normalizeChain(x){
      x = lc(x);
      if(x==='sol' || x==='solana') return 'solana';
      if(x==='eth' || x==='ethereum') return 'eth';
      if(x==='bnb' || x==='bsc') return 'bsc';
      if(x==='base') return 'base';
      return 'solana';
    }

    function isEvmAddr(s){
      return /^0x[a-fA-F0-9]{40}$/.test(String(s||'').trim());
    }

    function isSolAddr(s){
      // best-effort base58 length
      s = String(s||'').trim();
      return s.length>=32 && s.length<=50 && /^[1-9A-HJ-NP-Za-km-z]+$/.test(s);
    }

    // robust pool address extraction from gecko pool object
    function poolAddressFromPool(p){
      const a = p?.attributes || {};
      if(a.address) return String(a.address);
      const id = String(p?.id||'');
      // examples:
      //  - "solana_..._POOL"
      //  - "ethereum:0xPOOL"
      //  - "bsc/0xPOOL"
      const last = id.split('_').pop();
      const last2 = last.split(':').pop();
      const last3 = last2.split('/').pop();
      return last3;
    }

    function tokenIdToAddr(id){
      id = String(id||'').trim();
      if(!id) return '';
      // Gecko often uses ids like 'solana_<addr>' or 'ethereum_<addr>'
      if(id.includes('_')) return id.split('_').pop();
      if(id.includes(':')) return id.split(':').pop();
      if(id.includes('/')) return id.split('/').pop();
      return id;
    }

    function tokenAddrFromPool(p, which){
      const a = p?.attributes || {};
      let v = a[`${which}_token_address`] || a[`${which}_token_id`] || '';
      if(!v){
        const rel = p?.relationships?.[`${which}_token`]?.data?.id || '';
        v = rel;
      }
      return tokenIdToAddr(v);
    }

    function tokenSymFromPool(p, which){
      const a = p?.attributes || {};
      const k = `${which}_token_symbol`;
      const sym = a[k] || a[`${which}_symbol`] || '';
      return String(sym||'').replace(/\s+/g,'').slice(0,12);
    }

    function tokenImgFromPool(p, which){
      const a = p?.attributes || {};
      // Some responses include image urls per token
      const direct = a[`${which}_token_image_url`] || a[`${which}_token_logo`] || '';
      if(direct) return String(direct);
      // Best-effort fallback: sometimes nested token object is present (not always)
      const nested = a?.[`${which}_token`]?.data?.attributes?.image_url || a?.[`${which}_token`]?.data?.attributes?.imageUrl || '';
      return String(nested||'');
    }

    function tokenPriceFromPool(p, which){
      const a = p?.attributes || {};
      const v = (which==='base') ? (a.base_token_price_usd || a.token_price_usd || a.price_usd) : (a.quote_token_price_usd || a.quote_price_usd);
      const n = Number(v);
      return Number.isFinite(n) ? n : NaN;
    }

    function poolLiqUsd(p){
      const a = p?.attributes || {};
      const v = num(a.reserve_in_usd || a.liquidity_in_usd || a.liquidity_usd || a.reserveUsd);
      return Number.isFinite(v) ? v : 0;
    }

    function poolCreatedMs(p){
      const a = p?.attributes || {};
      const t = Date.parse(a.pool_created_at || a.created_at || a.createdAt || a.creation_time || '');
      return Number.isFinite(t) ? t : NaN;
    }

    function fmtAge(ms){
      if(!Number.isFinite(ms)) return 'â€”';
      const d = Math.max(0, Date.now()-ms);
      const s = Math.floor(d/1000);
      if(s<60) return s+'s';
      const m = Math.floor(s/60);
      if(m<60) return m+'m';
      const h = Math.floor(m/60);
      if(h<24) return h+'h';
      const days = Math.floor(h/24);
      return days+'d';
    }

    function explorerTx(net, sig){
      net = normalizeChain(net);
      if(net==='solana') return 'https://solscan.io/tx/'+sig;
      if(net==='eth') return 'https://etherscan.io/tx/'+sig;
      if(net==='bsc') return 'https://bscscan.com/tx/'+sig;
      if(net==='base') return 'https://basescan.org/tx/'+sig;
      return '#';
    }

    function explorerAddr(net, a){
      net = normalizeChain(net);
      if(net==='solana') return 'https://solscan.io/account/'+a;
      if(net==='eth') return 'https://etherscan.io/address/'+a;
      if(net==='bsc') return 'https://bscscan.com/address/'+a;
      if(net==='base') return 'https://basescan.org/address/'+a;
      return '#';
    }

    // Buy link (best-effort) â€” can be replaced later per your preference
    function buildBuyUrl(net, tokenAddr){
      net = normalizeChain(net);
      if(net==='solana') return 'https://jup.ag/swap/SOL-' + encodeURIComponent(tokenAddr);
      if(net==='eth') return 'https://app.uniswap.org/#/swap?outputCurrency=' + encodeURIComponent(tokenAddr);
      if(net==='bsc') return 'https://pancakeswap.finance/swap?outputCurrency=' + encodeURIComponent(tokenAddr);
      if(net==='base') return 'https://app.uniswap.org/#/swap?chain=base&outputCurrency=' + encodeURIComponent(tokenAddr);
      return '#';
    }

    // -------------------- State
    const qs = new URLSearchParams(location.search);
    let activeNet = normalizeChain(qs.get('chain') || 'solana');
    let addr = String(qs.get('addr')||'').trim();

    let activeTF = TF.find(x=>x.k==='ALL');
    let poolChoices = [];
    let poolId = '';
    let poolAddr = '';
    let tokenSide = 'base';
    let curTokenSymbol = 'TOKEN';
    let curQuoteSymbol = '';
    let seenMakers = new Set();
    let tradesSeen = new Set();

    let pollTradesTimer = null;
    let pollMetaTimer = null;
    let pollCandleTimer = null;
    let trendingTimer = null;
    let ageTimer = null;

    // -------------------- Chart
    const chartEl = $('chart');
    const chart = LightweightCharts.createChart(chartEl, {
      width: chartEl.clientWidth || 800,
      height: chartEl.clientHeight || 520,
      layout: { background: { type:'solid', color:'rgba(0,0,0,0)' }, textColor:'rgba(255,255,255,.86)' },
      grid: { vertLines:{color:'rgba(255,255,255,.06)'}, horzLines:{color:'rgba(255,255,255,.06)'} },
      rightPriceScale: { borderColor:'rgba(255,255,255,.12)' },
      timeScale: { borderColor:'rgba(255,255,255,.12)', timeVisible:true, secondsVisible:false },
      crosshair: { mode: 1 },
      handleScroll: { mouseWheel:true, pressedMouseMove:true, horzTouchDrag:true, vertTouchDrag:true },
      handleScale: { axisPressedMouseMove:true, mouseWheel:true, pinch:true },
    });

    const candleSeries = chart.addCandlestickSeries({
      upColor: 'rgba(20,241,149,.95)',
      downColor:'rgba(255,77,109,.95)',
      wickUpColor:'rgba(20,241,149,.95)',
      wickDownColor:'rgba(255,77,109,.95)',
      borderVisible:false,
      priceFormat:{ type:'price', precision: 10, minMove: 1e-10 }
    });

    const volumeSeries = chart.addHistogramSeries({
      priceFormat: { type:'volume' },
      priceScaleId: '',
      lastValueVisible:false,
      base:0,
    });
    chart.priceScale('').applyOptions({ scaleMargins:{ top:0.84, bottom:0 } });

    const ro = new ResizeObserver(()=>{
      chart.applyOptions({ width: chartEl.clientWidth, height: chartEl.clientHeight });
    });
    ro.observe(chartEl);

    btnFit.onclick = ()=>chart.timeScale().fitContent();

    // -------------------- UI boot
    function renderNetPills(){
      netPills.innerHTML='';
      const nets=[{k:'solana',label:'SOL'},{k:'eth',label:'ETH'},{k:'bsc',label:'BNB'},{k:'base',label:'BASE'}];
      nets.forEach(n=>{
        const b=document.createElement('div');
        b.className='pill'+(activeNet===n.k?' active':'');
        b.innerHTML = `<span class="dot"></span>${esc(n.label)}`;
        b.onclick=()=>{
          activeNet=n.k;
          renderNetPills();
          toast('Chain: '+n.label);
          // keep current addr if it matches chain type; otherwise default
          if(!addr){ addr = DEFAULT_TOKEN[activeNet]; }
          navigate(activeNet, addr);
        };
        netPills.appendChild(b);
      });
    }

    function renderTimeframes(){
      tfRow.innerHTML='';
      TF.forEach(t=>{
        const b=document.createElement('button');
        b.className='tf'+(t.k===activeTF.k?' active':'');
        b.textContent=t.k;
        b.onclick=()=>{
          activeTF=t;
          [...tfRow.children].forEach(x=>x.classList.toggle('active', x.textContent===t.k));
          if(poolAddr){
            loadCandles(true);
          }
        };
        tfRow.appendChild(b);
      });
    }

    function setMobileTab(which){
      if(!tabChart || !tabTrades) return;
      const isTrades = which==='trades';
      tabChart.classList.toggle('active', !isTrades);
      tabTrades.classList.toggle('active', isTrades);
      mobileTradesWrap.style.display = isTrades ? 'block' : 'none';
      chartCard.style.display = isTrades ? 'none' : 'block';
    }

    if(tabChart && tabTrades){
      tabChart.onclick=()=>setMobileTab('chart');
      tabTrades.onclick=()=>setMobileTab('trades');
    }

    btnClose.onclick=()=>{
      try{ window.close(); }catch(e){}
      // if browser blocks close
      toast('Close blocked by browser');
    };

    btnRefresh.onclick=()=>{
      if(!poolAddr){ toast('Pick a token first'); return; }
      loadCandles(true);
      loadTrades(true);
      loadMeta(true);
    };

    // -------------------- Search
    let searchTimer=null;
    let searchReq=0;

    function showResults(html){
      results.innerHTML = html;
      results.style.display = html ? 'block' : 'none';
    }

    function hideResults(){
      results.style.display = 'none';
    }

    async function dsSearch(query){
      // DexScreener search is used ONLY for discovery. We do not embed anything.
      const url = DS + '/search/?q=' + encodeURIComponent(query);
      const j = await fetchJson(url, {timeout:12000, retries:1});
      return Array.isArray(j?.pairs) ? j.pairs : [];
    }

    async function dsTokenPairsV1(net, tokenAddr){
      const chain = NET_DS[normalizeChain(net)] || 'solana';
      const url = `https://api.dexscreener.com/token-pairs/v1/${chain}/${encodeURIComponent(tokenAddr)}`;
      try{
        const j = await fetchJson(url, {timeout:14000, retries:1});
        return Array.isArray(j) ? j : [];
      }catch(_){
        return [];
      }
    }

    function bestPairAnyNet(pairs){
      const list = (pairs||[]).slice();
      if(!list.length) return null;
      list.sort((a,b)=>{
        const la = Number(a?.liquidity?.usd||0);
        const lb = Number(b?.liquidity?.usd||0);
        if(lb!==la) return lb-la;
        const va = Number(a?.volume?.h24||0);
        const vb = Number(b?.volume?.h24||0);
        return vb-va;
      });
      return list[0];
    }

    function bestPairForNet(pairs, net){
      const want = NET_DS[normalizeChain(net)];
      const list = (pairs||[]).filter(p=>lc(p?.chainId)===want);
      if(!list.length) return null;
      list.sort((a,b)=>{
        const la = Number(a?.liquidity?.usd||0);
        const lb = Number(b?.liquidity?.usd||0);
        if(lb!==la) return lb-la;
        const va = Number(a?.volume?.h24||0);
        const vb = Number(b?.volume?.h24||0);
        return vb-va;
      });
      return list[0];
    }


    function netFromDsChainId(chainId){
      const c = lc(chainId);
      if(c==='solana') return 'solana';
      if(c==='ethereum') return 'eth';
      if(c==='bsc') return 'bsc';
      if(c==='base') return 'base';
      return null;
    }

    function bestPairAnyNet(pairs){
      const list = (pairs||[]).filter(p=>netFromDsChainId(p?.chainId));
      if(!list.length) return null;
      list.sort((a,b)=>{
        const la = Number(a?.liquidity?.usd||0);
        const lb = Number(b?.liquidity?.usd||0);
        if(lb!==la) return lb-la;
        const va = Number(a?.volume?.h24||0);
        const vb = Number(b?.volume?.h24||0);
        return vb-va;
      });
      return list[0];
    }

    function renderSearchResults(pairs){
      const best = bestPairForNet(pairs, activeNet);
      // show top 12 for chain
      const want = NET_DS[activeNet];
      const list = (pairs||[]).filter(p=>lc(p?.chainId)===want).slice(0, 12);
      if(!list.length){
        showResults(`<div style="padding:12px; color:rgba(255,255,255,.75)">No results on ${esc(NET_LABEL[activeNet])}. Try another chain.</div>`);
        return;
      }
      const html = list.map(p=>{
        const base = p?.baseToken || {};
        const sym = String(base.symbol || base.name || 'TOKEN');
        const name = String(base.name || sym);
        const addr = String(base.address || '');
        const img = p?.info?.imageUrl || p?.info?.image_url || '';
        const pct = num(p?.priceChange?.h24);
        const mc = num(p?.marketCap || p?.fdv);
        const pctTxt = Number.isFinite(pct) ? (pct>0?'+':'')+pct.toFixed(2)+'%' : 'â€”';
        const pctClass = Number.isFinite(pct) ? (pct>0?'up':(pct<0?'down':'')) : '';
        const logo = img ? `<img src="${esc(img)}" referrerpolicy="no-referrer" onerror="this.remove();"/>` : `<span class="fb">${esc(sym.slice(0,1).toUpperCase())}</span>`;
        return `
          <div class="resItem" data-addr="${esc(addr)}" data-name="${esc(sym)}">
            <div class="resL">
              <div class="resLogo">${logo}</div>
              <div class="resTxt">
                <div class="resName">$${esc(sym)} <span style="opacity:.65">(${esc(name)})</span></div>
                <div class="resMeta">${esc(NET_LABEL[activeNet])} â€¢ ${esc(shortAddr(addr))} â€¢ Liq $${esc(formatCompact(p?.liquidity?.usd))}</div>
              </div>
            </div>
            <div class="resR">
              <span class="statPill ${pctClass}">24h ${esc(pctTxt)}</span>
              <span class="statPill">MCap ${esc(formatCompact(mc))}</span>
            </div>
          </div>
        `;
      }).join('');
      showResults(html);

      // click bind
      [...results.querySelectorAll('.resItem')].forEach(el=>{
        el.onclick=()=>{
          const a = el.getAttribute('data-addr')||'';
          hideResults();
          q.value = a;
          openToken(a);
        };
      });
    }

    q.addEventListener('input', ()=>{
      clearTimeout(searchTimer);
      const v = q.value.trim();

      // mode hint
      if(isEvmAddr(v)) modeHint.textContent = 'EVM';
      else if(isSolAddr(v)) modeHint.textContent = 'SOL';
      else modeHint.textContent = 'auto';

      if(v.length<2){ hideResults(); return; }
      searchTimer = setTimeout(async ()=>{
        const id = ++searchReq;
        try{
          const pairs = await dsSearch(v);
          if(id!==searchReq) return;
          renderSearchResults(pairs);
        }catch(e){
          if(id!==searchReq) return;
          showResults(`<div style="padding:12px; color:rgba(255,255,255,.75)">Search error. Try again.</div>`);
        }
      }, 220);
    });

    q.addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){
        e.preventDefault();
        hideResults();
        openToken(q.value.trim());
      }
    });

    document.addEventListener('click', (e)=>{
      if(!results.contains(e.target) && e.target!==q) hideResults();
    });

    btnGo.onclick=()=>openToken(q.value.trim());

    // -------------------- Gecko: pool selection
    function geckoNet(){ return NET_GECKO[activeNet]; }

    async function resolvePoolsFromGecko(tokenAddr){
      // /networks/{network}/tokens/{token}/pools?include=base_token,quote_token&page=1
      const url = `${GECKO}/networks/${encodeURIComponent(geckoNet())}/tokens/${encodeURIComponent(tokenAddr)}/pools?include=base_token,quote_token&page[number]=1&page[size]=50`;
      const j = await fetchJson(url, {timeout:14000, retries:1});
      return Array.isArray(j?.data) ? j.data : [];
    }

    function chooseBestPool(pools, tokenAddr){
      const tok = lc(tokenAddr);
      const preferSet = new Set((STABLE_QUOTES[activeNet]||[]).map(lc));

      // rank pools
      const ranked = (pools||[]).map(p=>{
        const a = p?.attributes || {};
        const base = lc(tokenAddrFromPool(p,'base'));
        const quote = lc(tokenAddrFromPool(p,'quote'));
        const liq = poolLiqUsd(p);
        const created = poolCreatedMs(p);
        const isBase = base===tok;
        const isQuote = quote===tok;
        const stableQuote = isBase && preferSet.has(quote);
        const score =
          (stableQuote? 9e15 : 0) +
          (isBase? 7e15 : 0) +
          (isQuote? 4e15 : 0) +
          (Number.isFinite(liq)? liq*1e6 : 0) +
          (Number.isFinite(created)? created : 0);
        return {p, score, isBase, isQuote, liq};
      }).sort((a,b)=>b.score-a.score);

      return ranked[0]?.p || null;
    }

    function renderPoolSelect(pools){
      poolSel.innerHTML='';
      const opts = pools.slice(0, 25).map((p,i)=>{
        const a = p?.attributes || {};
        const dex = String(a.dex_name || a.dex || 'DEX');
        const name = String(a.name || a.pool_name || '').trim();
        const liq = poolLiqUsd(p);
        const age = fmtAge(poolCreatedMs(p));
        const label = `${dex} â€¢ ${name?name:shortAddr(poolAddressFromPool(p))} â€¢ Liq $${formatCompact(liq)} â€¢ ${age}`;
        const id = String(p?.id||'');
        return `<option value="${esc(id)}">${esc(label)}</option>`;
      }).join('');
      poolSel.innerHTML = opts;
      poolSel.style.display = opts ? 'inline-flex' : 'none';
      poolSel.disabled = !opts;

      poolSel.onchange = ()=>{
        const id = poolSel.value;
        const picked = pools.find(x=>String(x?.id||'')===id);
        if(picked){
          applyPool(picked);
          loadCandles(true);
          loadTrades(true);
          loadMeta(true);
        }
      };
    }

    function applyTokenHeader(meta){
      const sym = meta?.symbol || 'TOKEN';
      const quote = meta?.quoteSymbol || '';
      curTokenSymbol = sym;
      curQuoteSymbol = quote;

      pairNameEl.textContent = quote ? `$${sym}/${quote}` : `$${sym}`;
      pairMetaEl.textContent = `${NET_LABEL[activeNet]} â€¢ ${shortAddr(addr)} â€¢ Native chart + live trades`;

      const img = meta?.image || '';
      if(img){
        tokenLogo.innerHTML = `<img src="${esc(img)}" alt="" referrerpolicy="no-referrer" onerror="this.remove(); this.parentNode.innerHTML='<span class=\"fb\">${esc(sym.slice(0,1).toUpperCase())}</span>';" />`;
      }else{
        tokenLogo.innerHTML = `<span class="fb">${esc(sym.slice(0,1).toUpperCase())}</span>`;
      }
    }

    function applyStats(st){
      const pills=[];
      if(Number.isFinite(st.price)) pills.push(`<span class="statPill">Price $${esc(formatPrice(st.price))}</span>`);
      if(Number.isFinite(st.liq)) pills.push(`<span class="statPill">Liq $${esc(formatCompact(st.liq))}</span>`);
      if(Number.isFinite(st.mcap)) pills.push(`<span class="statPill">MCap $${esc(formatCompact(st.mcap))}</span>`);
      if(Number.isFinite(st.h24)) pills.push(`<span class="statPill ${st.h24>0?'up':(st.h24<0?'down':'')}">24h ${esc((st.h24>0?'+':'')+st.h24.toFixed(2)+'%')}</span>`);
      statsEl.innerHTML = pills.join('') || `<span class="statPill">â€”</span>`;
    }

    function applyPool(p){
      const a = p?.attributes || {};
      poolId = String(p?.id||'');
      poolAddr = poolAddressFromPool(p);

      // Determine side: if token matches base -> buys are quote->base? We use Gecko trade_type.
      const base = lc(tokenAddrFromPool(p,'base'));
      const quote = lc(tokenAddrFromPool(p,'quote'));
      tokenSide = (base===lc(addr)) ? 'base' : ((quote===lc(addr)) ? 'quote' : 'base');

      // Meta (pick correct token side)
      const baseSym = tokenSymFromPool(p,'base') || 'TOKEN';
      const quoteSym = tokenSymFromPool(p,'quote') || '';
      const sym = tokenSide==='base' ? baseSym : (quoteSym || baseSym || 'TOKEN');
      const quoteShown = tokenSide==='base' ? quoteSym : baseSym;
      const img = tokenSide==='base' ? tokenImgFromPool(p,'base') : tokenImgFromPool(p,'quote');
      applyTokenHeader({symbol: sym, quoteSymbol: quoteShown, image: img});

      // initial stats best-effort (pick correct side price)
      const price = tokenSide==='base' ? tokenPriceFromPool(p,'base') : tokenPriceFromPool(p,'quote');
      const liq = num(a.reserve_in_usd || a.liquidity_in_usd || a.liquidity_usd);
      const mcap = num(a.market_cap_usd || a.fdv_usd);
      const h24 = num(a.price_change_percentage?.h24 || a.price_change_percentage_24h || a.price_change_24h);
      applyStats({price, liq, mcap, h24});

      btnBuy.href = buildBuyUrl(activeNet, addr);
    }

    // -------------------- Candles
    let rawCandles=[];

    function geckoCandlesUrl(gran, before){
      // /networks/{network}/pools/{pool}/ohlcv/{timeframe}?aggregate=...&before_timestamp=...&limit=1000&currency=usd
      const agg = (activeTF.k==='ALL' ? 1 : Math.max(1, Math.floor(activeTF.agg / (gran==='minute'?60:(gran==='hour'?3600:86400)) )));
      const params = new URLSearchParams();
      params.set('aggregate', String(agg));
      params.set('limit', '1000');
      params.set('currency','usd');
      if(before) params.set('before_timestamp', String(before));
      return `${GECKO}/networks/${encodeURIComponent(geckoNet())}/pools/${encodeURIComponent(poolAddr)}/ohlcv/${encodeURIComponent(gran)}?`+params.toString();
    }

    function mapGeckoOhlcv(j){
      const list = j?.data?.attributes?.ohlcv_list;
      if(!Array.isArray(list)) return [];
      // each row: [timestamp, open, high, low, close, volume]
      // Gecko timestamps should be unix seconds, but some proxies may return ms.
      return list.map(r=>{
        const ts = Number(r[0]) || 0;
        const time = ts>1e12 ? Math.floor(ts/1000) : Math.floor(ts);
        const open = Number(r[1]);
        const high = Number(r[2]);
        const low  = Number(r[3]);
        const close= Number(r[4]);
        const volume = Number(r[5]);
        return {time, open, high, low, close, volume};
      }).filter(x=>x.time>0 && Number.isFinite(x.open) && Number.isFinite(x.high) && Number.isFinite(x.low) && Number.isFinite(x.close));
    }

    function applyCandlesToChart(fit){
      const src = rawCandles;
      candleSeries.setData(src.map(c=>({time:c.time, open:c.open, high:c.high, low:c.low, close:c.close})));
      volumeSeries.setData(src.map(c=>({time:c.time, value:c.volume, color:(c.close>=c.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'})));
      if(fit) chart.timeScale().fitContent();
    }

    function applyTradeToCandles(tr){
      if(!rawCandles || !rawCandles.length) return;
      if(!Number.isFinite(tr?.price)) return;
      if(!Number.isFinite(tr?.tsMs)) return;

      const tsSec = Math.floor(tr.tsMs/1000);
      const bucket = Math.floor(tsSec / activeTF.agg) * activeTF.agg;

      const last = rawCandles[rawCandles.length-1];
      const usdVol = Number.isFinite(tr.usd) ? tr.usd : 0;

      if(bucket < last.time - activeTF.agg*3){
        // too old for current visible timeframe; ignore
        return;
      }

      if(bucket === last.time){
        last.close = tr.price;
        if(tr.price > last.high) last.high = tr.price;
        if(tr.price < last.low) last.low = tr.price;
        if(usdVol) last.volume = (Number.isFinite(last.volume)?last.volume:0) + usdVol;
        candleSeries.update({time:last.time, open:last.open, high:last.high, low:last.low, close:last.close});
        volumeSeries.update({time:last.time, value:last.volume, color:(last.close>=last.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
        return;
      }

      if(bucket > last.time){
        const open = Number.isFinite(last.close) ? last.close : tr.price;
        const c = {
          time: bucket,
          open,
          high: Math.max(open, tr.price),
          low: Math.min(open, tr.price),
          close: tr.price,
          volume: usdVol
        };
        rawCandles.push(c);
        candleSeries.update({time:c.time, open:c.open, high:c.high, low:c.low, close:c.close});
        volumeSeries.update({time:c.time, value:c.volume, color:(c.close>=c.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
      }
    }

    async function refreshLatestCandles(){
      if(!poolAddr) return;
      try{
        const gran = activeTF.gecko;
        const url = geckoCandlesUrl(gran, null);
        const j = await fetchJson(url, {timeout:16000, retries:1});
        const part = mapGeckoOhlcv(j);
        if(!part.length) return;
        part.sort((a,b)=>a.time-b.time);

        // Merge by time, keeping history
        const earliest = part[0].time;
        const keep = rawCandles.filter(c=>c.time < earliest);
        const map = new Map();
        for(const c of part) map.set(c.time, c);
        rawCandles = keep.concat(Array.from(map.values()).sort((a,b)=>a.time-b.time));

        applyCandlesToChart(false);
      }catch(e){
        // ignore
      }
    }


    async function loadCandles(fit){
      if(!poolAddr) return;
      statusEl.textContent = 'Loading chartâ€¦';
      rawCandles=[];
      candleSeries.setData([]);
      volumeSeries.setData([]);

      try{
        const gran = activeTF.gecko;

        // backfill loop to get full history (until no older candles)
        let before = null;
        let all = [];
        let guard = 0;
        while(guard++ < (activeTF.k==='ALL' ? 12 : 4)){
          const url = geckoCandlesUrl(gran, before);
          const j = await fetchJson(url, {timeout:16000, retries:1});
          const part = mapGeckoOhlcv(j);
          if(!part.length) break;
          // gecko returns newest->oldest sometimes; normalize
          part.sort((a,b)=>a.time-b.time);
          // prepend
          all = part.concat(all);
          // next before = oldest timestamp - 1
          before = part[0].time - 1;
          if(part.length < 990) break; // no more pages
        }

        // dedupe by time
        const map = new Map();
        all.forEach(c=>map.set(c.time, c));
        rawCandles = Array.from(map.values()).sort((a,b)=>a.time-b.time);

        if(!rawCandles.length){
          statusEl.textContent = 'Chart not available for this pool.';
          return;
        }

        applyCandlesToChart(fit);
        statusEl.textContent = 'Live.';

      }catch(e){
        statusEl.textContent = 'Chart error.';
        console.error(e);
      }
    }

    // -------------------- Trades
    function tradesContainer(){
      // write to both desktop + mobile
      return [tradesDesk, tradesMob];
    }

    function ensureTradeHead(){
      // head exists in markup
    }

    function timeAgo(tsMs){
      const d = Math.max(0, Date.now() - tsMs);
      const s = Math.floor(d/1000);
      if(s<60) return s+'s';
      const m = Math.floor(s/60);
      if(m<60) return m+'m';
      const h = Math.floor(m/60);
      if(h<24) return h+'h';
      const days = Math.floor(h/24);
      return days+'d';
    }

    function parseTrade(t){
      const a = t?.attributes || {};
      const id = String(t?.id || a.tx_hash || a.transaction_hash || a.signature || a.transaction_id || '') || '';
      const side = String(a.trade_type || a.side || a.taker_side || a.kind || '').toLowerCase();
      const type = side.includes('sell') ? 'sell' : (side.includes('buy') ? 'buy' : (a.is_buy===true?'buy':(a.is_sell===true?'sell':'')));

      const tx = String(a.tx_hash || a.transaction_hash || a.signature || a.transaction_id || id || '').trim();
      const maker = String(
        a.taker || a.trader || a.wallet_address || a.from_address || a.maker || a.maker_address || a.tx_from_address || a.user_address || ''
      ).trim();

      const rawTs = (a.block_timestamp ?? a.timestamp ?? a.time ?? a.created_at ?? a.mined_at ?? a.block_time ?? 0);
      let tsMs = NaN;
      if(typeof rawTs==='number'){
        tsMs = rawTs>1e12 ? rawTs : rawTs*1000;
      }else{
        const tsv = String(rawTs||'').trim();
        if(tsv && /^\d+(\.\d+)?$/.test(tsv)){
          const n = Number(tsv);
          tsMs = n>1e12 ? n : n*1000;
        }else{
          const d = Date.parse(tsv);
          if(Number.isFinite(d)) tsMs = d;
        }
      }
      if(!Number.isFinite(tsMs)) tsMs = Date.now();

      const usd = num(a.volume_in_usd || a.usd_value || a.volume_usd || a.amount_usd || a.total_usd);
      const price = num(a.price_in_usd || a.price_usd || a.price);
      const baseAmt = num(a.base_token_amount || a.amount_base || a.base_amount || a.base_token_volume || a.base_volume);
      const quoteAmt = num(a.quote_token_amount || a.amount_quote || a.quote_amount || a.quote_token_volume || a.quote_volume);
      const amount = Number.isFinite(baseAmt) ? baseAmt : (Number.isFinite(quoteAmt)? quoteAmt : NaN);

      return { id, type, tx, maker, tsMs, usd, price, amount };
    }

    function tradeRowHtml(tr){
      const age = timeAgo(tr.tsMs);
      const usdTxt = Number.isFinite(tr.usd) ? '$'+formatCompact(tr.usd) : 'â€”';
      const amtTxt = Number.isFinite(tr.amount) ? formatCompact(tr.amount)+' '+esc(curTokenSymbol) : 'â€”';
      const priceTxt = Number.isFinite(tr.price) ? '$'+formatPrice(tr.price) : 'â€”';

      const isNew = tr.maker ? (!seenMakers.has(tr.maker)) : false;
      if(tr.maker) seenMakers.add(tr.maker);

      const makerHtml = tr.maker
        ? `<div class="maker"><span class="addr mono" title="${esc(tr.maker)}">${esc(shortAddr(tr.maker))}</span>${isNew?'<span class="new">NEW</span>':''}</div>`
        : `<span class="mono" style="opacity:.7">â€”</span>`;

      const txUrl = tr.tx ? explorerTx(activeNet, tr.tx) : '#';
      const addrUrl = tr.maker ? explorerAddr(activeNet, tr.maker) : '#';

      return `
        <div class=\"tradeRow\" data-id=\"${esc(tr.id)}\" data-ts=\"${Number.isFinite(tr.tsMs)?tr.tsMs:0}\" data-price=\"${Number.isFinite(tr.price)?tr.price:''}\" data-usd=\"${Number.isFinite(tr.usd)?tr.usd:''}\" data-type=\"${esc(tr.type||'')}\">
          <div class=\"mono age\">${esc(age)}</div>
          <div><span class="typeBadge ${tr.type==='sell'?'sell':'buy'}">${tr.type==='sell'?'SELL':'BUY'}</span></div>
          <div class="mono">${esc(usdTxt)}</div>
          <div class="mono">${amtTxt}</div>
          <div class="mono hideM">${esc(priceTxt)}</div>
          <div class="hideM">${makerHtml}</div>
          <div>
            <a class="iconBtn" href="${esc(txUrl)}" target="_blank" rel="noreferrer" title="Open Tx">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14 3h7v7" stroke="rgba(255,255,255,.80)" stroke-width="2" stroke-linecap="round"/><path d="M21 3 10 14" stroke="rgba(255,255,255,.80)" stroke-width="2" stroke-linecap="round"/><path d="M10 5H7a4 4 0 0 0-4 4v8a4 4 0 0 0 4 4h8a4 4 0 0 0 4-4v-3" stroke="rgba(255,255,255,.55)" stroke-width="2" stroke-linecap="round"/></svg>
            </a>
          </div>
        </div>
      `;
    }

    async function geckoTrades(limit=80){
      const base = `${GECKO}/networks/${encodeURIComponent(geckoNet())}/pools/${encodeURIComponent(poolAddr)}/trades`;
      // GeckoTerminal often uses JSON:API pagination. Try page params first, then fallback to limit.
      try{
        const url1 = base + `?page[number]=1&page[size]=${encodeURIComponent(limit)}`;
        const j1 = await fetchJson(url1, {timeout:14000, retries:1});
        if(Array.isArray(j1?.data) && j1.data.length) return j1.data;
      }catch(e){ /* ignore */ }

      try{
        const url2 = base + `?limit=${encodeURIComponent(limit)}`;
        const j2 = await fetchJson(url2, {timeout:14000, retries:1});
        if(Array.isArray(j2?.data)) return j2.data;
      }catch(e){ /* ignore */ }

      return [];
    }

    function renderTrades(trades, {reset=false}={}){
      const parsed = (trades||[]).map(parseTrade).filter(x=>x.id && Number.isFinite(x.tsMs));
      parsed.sort((a,b)=>b.tsMs-a.tsMs);

      if(reset){
        tradesSeen = new Set();
        seenMakers = new Set();
        // clear existing rows (keep header)
        tradesContainer().forEach(el=>{
          const head = el.querySelector('.tradeHead');
          el.innerHTML='';
          el.appendChild(head);
        });
      }

      const newly = [];

      // Only add unseen trades (prepend)
      for(const tr of parsed){
        if(tradesSeen.has(tr.id)) continue;
        tradesSeen.add(tr.id);
        newly.push(tr);

        const html = tradeRowHtml(tr);
        tradesContainer().forEach(el=>{
          const head = el.querySelector('.tradeHead');
          const wrapper = document.createElement('div');
          wrapper.innerHTML = html;
          const row = wrapper.firstElementChild;
          // insert after head
          el.insertBefore(row, head.nextSibling);
          // cap rows
          const rows = [...el.querySelectorAll('.tradeRow')];
          if(rows.length>120){
            rows.slice(120).forEach(r=>r.remove());
          }
        });
      }

      const total = tradesDesk.querySelectorAll('.tradeRow').length;
      tradesStat.textContent = `${total} trades`;
      tradesStatM.textContent = `${total} trades`;

      updateAges();
      return newly;
    }

    function updateAges(){
      tradesContainer().forEach(el=>{
        [...el.querySelectorAll('.tradeRow')].forEach(row=>{
          const ts = Number(row.getAttribute('data-ts')||0);
          if(!ts) return;
          const ageEl = row.querySelector('.age');
          if(ageEl) ageEl.textContent = timeAgo(ts);
        });
      });
    }

    function applyTradeToCandles(tr){
      if(!rawCandles || !rawCandles.length) return;
      if(!Number.isFinite(tr.price)) return;
      if(!Number.isFinite(activeTF?.agg) || activeTF.agg<=0) return;

      const tsSec = Math.floor(tr.tsMs/1000);
      const bucket = Math.floor(tsSec / activeTF.agg) * activeTF.agg;

      const last = rawCandles[rawCandles.length-1];
      const usdVol = Number.isFinite(tr.usd) ? tr.usd : 0;

      // ignore very old trades (keeps chart stable)
      if(bucket < last.time - activeTF.agg*5) return;

      if(bucket === last.time){
        last.close = tr.price;
        last.high = Math.max(last.high, tr.price);
        last.low  = Math.min(last.low, tr.price);
        last.volume = (Number(last.volume)||0) + usdVol;
        candleSeries.update({time:last.time, open:last.open, high:last.high, low:last.low, close:last.close});
        volumeSeries.update({time:last.time, value:last.volume, color:(last.close>=last.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
        return;
      }

      if(bucket > last.time){
        const open = Number.isFinite(last.close) ? last.close : tr.price;
        const close = tr.price;
        const high = Math.max(open, close);
        const low = Math.min(open, close);
        const c = {time: bucket, open, high, low, close, volume: usdVol};
        rawCandles.push(c);
        candleSeries.update({time:c.time, open:c.open, high:c.high, low:c.low, close:c.close});
        volumeSeries.update({time:c.time, value:c.volume, color:(c.close>=c.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
      }
    }

    async function loadTrades(reset=false){
      if(!poolAddr) return;
      try{
        const data = await geckoTrades(80);
        const newly = renderTrades(data, {reset}) || [];
        if(newly.length){
          // Apply oldest->newest so candle updates are correct
          newly.slice().sort((a,b)=>a.tsMs-b.tsMs).forEach(applyTradeToCandles);
        }

    function startLiveLoops(){
      if(tradesTimer) clearInterval(tradesTimer);
      tradesTimer = setInterval(async ()=>{ try{ await loadTrades(false); }catch(_){ } }, 2500);

      if(candlesTimer) clearInterval(candlesTimer);
      candlesTimer = setInterval(async ()=>{ try{ await refreshLatestCandles(); }catch(_){ } }, 5000);
    }
        statusEl.textContent = 'Live.';
      }catch(e){
        console.error(e);
        statusEl.textContent = 'Trades error.';
      }
    }

// -------------------- Meta (refresh price/liquidity/24h)
    async function geckoPool(){
      const url = `${GECKO}/networks/${encodeURIComponent(geckoNet())}/pools/${encodeURIComponent(poolAddr)}?include=base_token,quote_token`;
      const j = await fetchJson(url, {timeout:14000, retries:1});
      return j?.data || null;
    }

    async function loadMeta(){
      if(!poolAddr) return;
      try{
        const p = await geckoPool();
        if(!p) return;
        applyPool(p);
      }catch(e){
        // ignore
      }
    }

    // -------------------- Trending
    async function geckoTrending(){
      // Top pools by 24h volume (per network)
      const url = `${GECKO}/networks/${encodeURIComponent(geckoNet())}/pools?sort=-volume_usd_24h&page[number]=1&page[size]=50&include=base_token`;
      const j = await fetchJson(url, {timeout:14000, retries:1});
      const data = Array.isArray(j?.data) ? j.data : [];
      const inc  = Array.isArray(j?.included) ? j.included : [];
      const incMap = {};
      for(const it of inc){
        if(!it?.id) continue;
        incMap[it.id] = it;
      }
      return { data, incMap };
    }

    function renderTicker(items, incMap={}){
      const top = (items||[]).slice(0, 10);
      if(!top.length){
        tickerTrack.innerHTML = `<div class="tickerEmpty">Trending unavailable.</div>`;
        return;
      }

      function tokenMetaFromPool(p){
        const rel = p?.relationships?.base_token?.data;
        const id = rel?.id;
        const it = id ? incMap[id] : null;
        const a = it?.attributes || {};
        const sym = (a?.symbol || a?.name || '').toString().trim();
        const img = (a?.image_url || a?.image || '').toString().trim();
        const addr = tokenIdToAddr(id||'') || '';
        return { sym, img, addr };
      }

      const chips = top.map((p,i)=>{
        const a = p?.attributes||{};
        const chg = num(a?.price_change_percentage_24h);
        const pct = Number.isFinite(chg) ? (chg>=0?`+${chg.toFixed(2)}%`:`${chg.toFixed(2)}%`) : 'â€”';
        const up = Number.isFinite(chg) ? (chg>=0) : false;
        const meta = tokenMetaFromPool(p);
        const name = meta.sym ? `$${meta.sym}` : 'Token';
        const img = meta.img ? `<img alt="" src="${esc(meta.img)}" loading="lazy" />` : `<span class="dot"></span>`;
        const addr = meta.addr;
        return `<button class="chip" data-addr="${esc(addr)}" title="Open ${esc(name)}">
          <span class="rank">${i+1}</span>
          <span class="ico">${img}</span>
          <span class="nm">${esc(name)}</span>
          <span class="pct ${up?'up':'dn'}">${esc(pct)}</span>
        </button>`;
      }).join('');

      tickerTrack.innerHTML = `<div class="tickerRow">${chips}</div>`;
    }).join('');

      // duplicate for seamless loop
      tickerTrack.innerHTML = top + top;

      [...tickerTrack.querySelectorAll('.chip')].forEach(ch=>{
        ch.onclick=()=>{
          const a = ch.getAttribute('data-addr')||'';
          if(!a) return;
          q.value = a;
          openToken(a);
        };
      });
    }

    
    async function startTrending(){
      const load = async ()=>{
        try{
          const res = await geckoTrending();
          renderTicker(res.data, res.incMap);
        }catch(e){
          tickerTrack.innerHTML = `<div class="tickerEmpty">Trending unavailable.</div>`;
        }
      };

      load();
      if(trendingTimer) clearInterval(trendingTimer);
      trendingTimer = setInterval(load, 25000);

      tickerTrack.onclick = (e)=>{
        const b = e.target.closest('.chip');
        if(!b) return;
        const addr = b.getAttribute('data-addr') || '';
        if(addr) openToken(addr, {skipInput:true});
      };
    }catch(e){
        tickerTrack.innerHTML = `<div style="padding:0 14px; color:rgba(255,255,255,.65)">Trending unavailable.</div>`;
      }

      // keep it live
      if(trendingTimer) clearInterval(trendingTimer);
      trendingTimer = setInterval(async ()=>{
        try{
          const items = await geckoTrending();
          renderTicker(items);
        }catch(e){ /* ignore */ }
      }, 30000);
    }

    // -------------------- Navigation + Boot
    function updateUrl(){
      const u = new URL(location.href);
      u.searchParams.set('chain', activeNet);
      if(addr) u.searchParams.set('addr', addr);
      history.replaceState({}, '', u.toString());
    }

    function navigate(chain, address){
      activeNet = normalizeChain(chain);
      addr = String(address||'').trim();
      updateUrl();
      renderNetPills();
      startTrending();
      // if address exists, load it
      if(addr){
        openToken(addr, {skipInput:true});
      }
    }

    async function openToken(input, {skipInput=false}={}){
      let v = String(input||'').trim();
      if(!v){ toast('Paste a token name or address'); return; }
      if(!skipInput) q.value = v;

      // reset view
      statusEl.textContent = 'Loadingâ€¦';
      pairNameEl.textContent = 'Loadingâ€¦';
      pairMetaEl.textContent = 'Resolving best poolâ€¦';
      results.innerHTML = '';

      let dsPair = null;

      // If user typed a name/symbol (not an address), resolve via DexScreener search (auto across chains)
      if(!isEvmAddr(v) && !isSolAddr(v)){
        statusEl.textContent = 'Searchingâ€¦';
        pairNameEl.textContent = 'Searchingâ€¦';
        pairMetaEl.textContent = 'Finding best matchâ€¦';
        try{
          const pairs = await dsSearch(v);
          if(!pairs.length){
            statusEl.textContent = 'Not found.';
            pairNameEl.textContent = 'Not found';
            pairMetaEl.textContent = 'Try a contract address.';
            toast('No results. Try contract address.');
            return;
          }
          const best = bestPairAnyNet(pairs);
          if(!best){
            toast('No usable pair found.');
            return;
          }
          // switch net to best match chain
          const chainId = lc(best?.chainId||'');
          const newNet = (chainId==='solana') ? 'solana' : (chainId==='ethereum' ? 'eth' : (chainId==='bsc' ? 'bsc' : (chainId==='base' ? 'base' : activeNet)));
          if(newNet !== activeNet){
            activeNet = newNet;
            renderNetPills();
            startTrending();
          }

          dsPair = best;
          v = String(best?.baseToken?.address || '').trim() || v;
          if(!skipInput) q.value = v;
        }catch(e){
          statusEl.textContent = 'Search error.';
          toast('Search failed. Try again.');
          return;
        }
      }

      // If it's an EVM address and no dsPair yet, try all EVM nets and pick best liquidity
      if(isEvmAddr(v) && !dsPair){
        const nets = ['eth','bsc','base'];
        let best = null;
        for(const n of nets){
          const arr = await dsTokenPairsV1(n, v);
          const cand = bestPairAnyNet(arr);
          if(cand && (!best || Number(cand?.liquidity?.usd||0) > Number(best?.liquidity?.usd||0))) best = cand;
        }
        if(best){
          const chainId = lc(best?.chainId||'');
          const newNet = (chainId==='ethereum') ? 'eth' : (chainId==='bsc' ? 'bsc' : (chainId==='base' ? 'base' : activeNet));
          if(newNet !== activeNet){
            activeNet = newNet;
            renderNetPills();
            startTrending();
          }
          dsPair = best;
        }
      }

      // If it's Solana address and no dsPair yet, fetch DS token-pairs on Solana
      if(isSolAddr(v) && !dsPair){
        const arr = await dsTokenPairsV1('solana', v);
        const best = bestPairAnyNet(arr);
        if(best) dsPair = best;
      }

      // preferred pool address (pairAddress is usually the AMM pool address)
      let preferredPool = dsPair?.pairAddress || dsPair?.pair_address || '';

      // Fill header from DexScreener meta (fast symbols/logos/stats)
      if(dsPair){
        const base = dsPair?.baseToken || {};
        const quote = dsPair?.quoteToken || {};
        const title = `${(base?.symbol||'TOKEN')}/${(quote?.symbol||'')}`.replace(/\/$/,'');
        pairNameEl.textContent = title || (base?.symbol||'TOKEN');
        pairMetaEl.textContent = `${NET_LABEL[activeNet] || activeNet} â€¢ ${shortAddr(v)} â€¢ Native chart + live trades`;

        const img = base?.logoURI || base?.icon || base?.image || '';
        if(img){
          tokenLogo.innerHTML = `<img alt="" src="${esc(img)}" loading="lazy" />`;
        }else{
          tokenLogoFb.textContent = (base?.symbol||'T').slice(0,1).toUpperCase();
        }

        applyStats({
          price: num(dsPair?.priceUsd),
          liq: num(dsPair?.liquidity?.usd),
          mcap: num(dsPair?.fdv),
          h24: num(dsPair?.priceChange?.h24),
        });

        curTokenSymbol = (base?.symbol||'TOKEN');
        curQuoteSymbol = (quote?.symbol||'');
      }else{
        pairNameEl.textContent = '$TOKEN';
        pairMetaEl.textContent = `${NET_LABEL[activeNet] || activeNet} â€¢ ${shortAddr(v)} â€¢ Native chart + live trades`;
        applyStats({});
      }

      // reset caches/timers
      tradesSeen = new Set();
      seenMakers = new Set();

      try{
        // 1) preferred pool first (when available via DexScreener)
        if(preferredPool){
          poolAddr = preferredPool;
          const p = await geckoPool();
          if(p){
            applyPool(p);
            statusEl.textContent = 'Loading chartâ€¦';
            await loadCandles(true);
            statusEl.textContent = 'Loading tradesâ€¦';
            await loadTrades(true);
            statusEl.textContent = 'Live.';
            startLiveLoops();
            return;
          }
        }

        // 2) fallback: Gecko token pools -> choose best
        const pools = await resolvePoolsFromGecko(v);
        if(!pools.length){
          statusEl.textContent = 'Not found.';
          pairNameEl.textContent = 'Not found';
          pairMetaEl.textContent = 'Try a different token or chain.';
          toast('Token not found on this chain.');
          return;
        }

        const best = chooseBestPool(pools, v);
        poolChoices = pools;
        poolAddr = poolAddressFromPool(best);

        const p = await geckoPool();
        if(!p) throw new Error('Pool fetch failed');
        applyPool(p);

        statusEl.textContent = 'Loading chartâ€¦';
        await loadCandles(true);
        statusEl.textContent = 'Loading tradesâ€¦';
        await loadTrades(true);
        statusEl.textContent = 'Live.';
        startLiveLoops();
      }catch(e){
        console.error(e);
        statusEl.textContent = 'Load error.';
        toast('Failed to load chart/trades. API blocked or pool unsupported.');
      }
    }

    // Boot trending
    startTrending();

    // Open initial token if present
    if(!addr) addr = DEFAULT_TOKEN[activeNet];
    // auto-open default
    openToken(addr, {skipInput:true});

  })();
  </script>
</body>
</html>
