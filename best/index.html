<!doctype html>
<!--
DexGuard DexLike LiveChart v1

(1) Endpoints used:
- DexScreener (no key):
  - Search: https://api.dexscreener.com/latest/dex/search?q=...
  - Pair info: https://api.dexscreener.com/latest/dex/pairs/{chainId}/{pairId}
  - Token pools: https://api.dexscreener.com/token-pairs/v1/{chainId}/{tokenAddress}
  - Boosted/Trending tokens (for Trending row): https://api.dexscreener.com/token-boosts/top/v1 (fallback: token-boosts/latest/v1)
- GeckoTerminal (no key, used for candles + trades):
  - OHLCV: https://api.geckoterminal.com/api/v2/networks/{network}/pools/{poolAddress}/ohlcv/{timeframe}?aggregate=...
  - Trades: https://api.geckoterminal.com/api/v2/networks/{network}/pools/{poolAddress}/trades

(2) Optional Proxy URL (Settings):
- If set, ALL API requests go through your proxy to bypass CORS.
- Supported formats:
  a) If Proxy contains "{url}", it will be replaced with encodeURIComponent(targetUrl)
  b) Otherwise: PROXY + ( "?" or "&" ) + "url=" + encodeURIComponent(targetUrl)

(3) Optional keys (stored locally in your browser only):
- BIRDEYE_API_KEY (Solana-only enrichment/candles fallback; app still works without it)
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#070711" />
  <title>DexGuard ‚Äî DexLike Live</title>

  <link rel="preconnect" href="https://api.dexscreener.com" crossorigin />
  <link rel="preconnect" href="https://api.geckoterminal.com" crossorigin />
  <link rel="preconnect" href="https://public-api.birdeye.so" crossorigin />
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />

  <style>
    :root{
      --bg:#070711;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.085);
      --stroke: rgba(255,255,255,.12);

      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.68);
      --muted2: rgba(255,255,255,.56);

      --g:#14F195;
      --c:#00D1FF;
      --p:#9945FF;

      --good: rgba(20,241,149,.90);
      --bad: rgba(255,104,121,.86);
      --warn: rgba(255,205,98,.85);

      --radius: 22px;
      --radius2: 18px;
      --shadow: 0 14px 44px rgba(0,0,0,.45);
      --shadowSoft: 0 10px 28px rgba(0,0,0,.28);
      --ring: 0 0 0 6px rgba(20,241,149,.08);

      --max: 1240px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html{height:100%; scroll-behavior:smooth}
    body{
      min-height:100%;
      min-height:100dvh;
      margin:0;
      font: 14px/1.55 var(--sans);
      color:var(--text);
      background:var(--bg);
      overflow-x:hidden;
    }
    body::before{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      background:
        radial-gradient(1200px 760px at 10% 5%, rgba(153,69,255,.24), transparent 60%),
        radial-gradient(1000px 720px at 90% 10%, rgba(20,241,149,.18), transparent 58%),
        radial-gradient(900px 640px at 72% 92%, rgba(0,209,255,.14), transparent 58%),
        radial-gradient(900px 640px at 0% 95%, rgba(0,209,255,.06), transparent 60%),
        var(--bg);
      transform: translateZ(0);
    }

    a{color:inherit; text-decoration:none}
    button,input{font:inherit}
    img{max-width:100%; height:auto; display:block}

    :focus-visible{outline:none; box-shadow:var(--ring); border-radius:14px}

    .wrap{max-width:var(--max); margin:0 auto; padding:0 16px}
    .header{
      position:sticky;
      top:0;
      z-index:50;
      backdrop-filter: blur(14px);
      background: rgba(7,7,17,.70);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }

    .headerRow{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:12px;
      align-items:center;
      padding:12px 0;
    }

    .brand{
      display:flex; align-items:center; gap:12px;
      min-width: 0;
    }
    .logo{
      width:40px; height:40px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.05));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
      display:grid; place-items:center;
      position:relative;
      overflow:hidden;
    }
    .logo::before{
      content:"";
      position:absolute; inset:-40%;
      background: conic-gradient(from 180deg, rgba(20,241,149,.0), rgba(20,241,149,.45), rgba(0,209,255,.35), rgba(153,69,255,.35), rgba(20,241,149,.0));
      filter: blur(10px);
      opacity:.65;
      animation: spin 6s linear infinite;
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    .logo span{
      position:relative;
      font-weight: 1000;
      letter-spacing: .08em;
      font-size: 12px;
      color: rgba(255,255,255,.92);
      text-shadow: 0 10px 30px rgba(0,0,0,.6);
    }
    .brandText{min-width:0}
    .brandTop{
      display:flex; align-items:center; gap:10px;
      line-height:1.1;
      flex-wrap:wrap;
    }
    .brandName{
      font-weight:1000;
      letter-spacing:.04em;
      text-transform:uppercase;
      font-size:12px;
      opacity:.92;
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      white-space:nowrap;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .pill b{
      font-size:11px;
      letter-spacing:.08em;
      text-transform:uppercase;
      opacity:.82;
    }
    .liveDot{
      width:8px; height:8px;
      border-radius:999px;
      background: var(--good);
      box-shadow: 0 0 0 6px rgba(20,241,149,.10);
      animation: pulse 1.4s ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{transform:scale(1); opacity:1}
      50%{transform:scale(1.12); opacity:.72}
    }
    .sub{
      color: var(--muted);
      font-size: 12px;
      margin-top: 2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .actions{display:flex; gap:10px; align-items:center; justify-content:flex-end; flex-wrap:wrap}
    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      padding:9px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.90);
      font-weight:900;
      font-size:13px;
      transition: transform .15s ease, background .15s ease, box-shadow .15s ease, border-color .15s ease, opacity .15s ease;
      white-space: nowrap;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor:pointer;
    }
    .btn:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .btn:active{transform: translateY(0px) scale(.99)}
    .btn:disabled{opacity:.5; cursor:not-allowed}
    .btn.grad{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 14px 28px rgba(0,0,0,.28);
    }
    .btn.ghost{ background: rgba(255,255,255,.06); }
    .btn.icon{ width:44px; padding:9px 0; letter-spacing:2px; font-weight:1000; }

    .main{ padding:16px 0 28px; }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.075), rgba(255,255,255,.045));
      border: 1px solid rgba(255,255,255,.11);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position: relative;
      overflow:hidden;
    }
    .card::before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(500px 240px at 10% 10%, rgba(20,241,149,.12), transparent 70%),
                  radial-gradient(520px 260px at 90% 20%, rgba(0,209,255,.10), transparent 70%),
                  radial-gradient(520px 260px at 60% 110%, rgba(153,69,255,.10), transparent 70%);
      pointer-events:none;
      opacity:.9;
    }
    .card > *{position:relative}

    .toolbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
      gap:12px;
      padding:14px 14px 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
    }

    .chainTabs{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .tab{
      padding:8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.86);
      font-weight:1000;
      letter-spacing:.06em;
      font-size:12px;
      text-transform:uppercase;
      cursor:pointer;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .tab:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .tab.active{
      border:0;
      background: linear-gradient(90deg, rgba(20,241,149,.90), rgba(0,209,255,.85), rgba(153,69,255,.85));
      color:#061012;
      box-shadow: 0 14px 26px rgba(0,0,0,.28);
    }

    .searchWrap{ display:flex; gap:10px; align-items:center; flex:1; min-width: 240px; }
    .search{ position:relative; flex:1; min-width: 200px; }
    .search input{
      width:100%;
      padding:11px 14px 11px 40px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.92);
      outline:none;
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
    }
    .search input::placeholder{color: rgba(255,255,255,.42)}
    .searchIcon{
      position:absolute;
      left:14px;
      top:50%;
      transform: translateY(-50%);
      opacity:.72;
      font-weight:1000;
      letter-spacing:.06em;
      font-size: 12px;
      user-select:none;
      pointer-events:none;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:12px;
      padding: 12px;
    }
    @media (max-width: 980px){ .grid{grid-template-columns: 1fr;} }

    .panel{
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius2);
      overflow:hidden;
      min-width:0;
    }
    .panelHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px 12px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .title{
      display:flex; align-items:center; gap:10px;
      font-weight: 1000;
      letter-spacing:.06em;
      text-transform:uppercase;
      font-size:12px;
      color: rgba(255,255,255,.86);
      min-width:0;
    }
    .hint{
      font-size: 12px;
      color: var(--muted);
      display:flex;
      align-items:center;
      gap:10px;
      white-space:nowrap;
    }
    .kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 7px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.86);
    }

    .trendingRow{
      display:flex;
      gap:10px;
      overflow:auto;
      padding: 12px;
      scroll-snap-type: x mandatory;
      -webkit-overflow-scrolling: touch;
    }
    .trendingRow::-webkit-scrollbar{height:8px}
    .trendingRow::-webkit-scrollbar-thumb{background: rgba(255,255,255,.10); border-radius:999px}

    .tokenCard{
      flex: 0 0 240px;
      scroll-snap-align:start;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.075), rgba(255,255,255,.04));
      box-shadow: 0 10px 24px rgba(0,0,0,.24);
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .15s ease, border-color .15s ease, background .15s ease;
      min-height: 84px;
    }
    .tokenCard:hover{transform: translateY(-2px); border-color: rgba(255,255,255,.22)}
    .tokenCard:active{transform: translateY(0px) scale(.995)}
    .tokenCardTop{
      display:flex;
      gap:10px;
      padding: 12px 12px 10px;
      align-items:center;
    }
    .tLogo{
      width:36px; height:36px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      overflow:hidden;
      display:grid; place-items:center;
      flex: 0 0 auto;
    }
    .tLogo img{width:100%; height:100%; object-fit:cover}
    .tText{min-width:0}
    .tName{
      font-weight: 1000;
      font-size: 13px;
      line-height: 1.15;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .tMeta{
      display:flex;
      align-items:center;
      gap:8px;
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .chip{
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size: 11px;
      font-weight: 900;
      letter-spacing:.06em;
      text-transform: uppercase;
      color: rgba(255,255,255,.84);
    }
    .chip.good{border-color: rgba(20,241,149,.35); background: rgba(20,241,149,.08); color: rgba(20,241,149,.95)}
    .chip.bad{border-color: rgba(255,104,121,.35); background: rgba(255,104,121,.08); color: rgba(255,104,121,.92)}

    .metricRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px;
      padding: 0 12px 12px;
    }
    .metric{
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      padding: 8px 10px;
      min-width:0;
    }
    .metric .k{
      font-size: 10px;
      letter-spacing: .10em;
      text-transform: uppercase;
      color: rgba(255,255,255,.56);
      margin-bottom: 3px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .metric .v{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,.90);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .results{ padding: 10px 12px 12px; display:none; }
    .results.show{display:block}
    .resultItem{
      display:grid;
      grid-template-columns: auto 1fr auto;
      gap:12px;
      align-items:center;
      padding: 10px 10px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      margin-bottom: 8px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .resultItem:hover{background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.18); transform: translateY(-1px)}
    .resultItem:last-child{margin-bottom:0}
    .rMain{min-width:0}
    .rTop{display:flex; align-items:center; gap:8px; min-width:0}
    .rName{font-weight:1000; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .rSub{
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      margin-top: 2px;
    }

    .tokenView{padding:12px}
    .tokenHeader{
      padding: 14px 14px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .tokenLeft{display:flex; gap:12px; align-items:center; min-width: 0;}
    .bigLogo{
      width:44px; height:44px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      overflow:hidden;
      display:grid; place-items:center;
      flex: 0 0 auto;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .bigLogo img{width:100%; height:100%; object-fit:cover}
    .tokenNames{min-width:0}
    .tokenNames .sym{
      font-weight: 1100;
      letter-spacing:.04em;
      font-size: 16px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .tokenNames .addr{
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .tokenRight{ display:flex; flex-direction:column; gap:8px; align-items:flex-end; }
    .linksRow{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}
    .linkPill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight: 900;
      font-size: 12px;
      color: rgba(255,255,255,.86);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .15s ease, background .15s ease;
    }
    .linkPill:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .linkPill:active{transform: translateY(0px) scale(.99)}

    .statsGrid{
      display:grid;
      grid-template-columns: repeat(6, minmax(0,1fr));
      gap:8px;
      padding: 12px 14px 14px;
    }
    @media (max-width: 980px){ .statsGrid{grid-template-columns: repeat(3, minmax(0,1fr));} }
    @media (max-width: 520px){ .statsGrid{grid-template-columns: repeat(2, minmax(0,1fr));} }
    .stat{
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      padding: 10px 12px;
      min-width:0;
    }
    .stat .k{
      font-size: 10px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color: rgba(255,255,255,.56);
      margin-bottom: 6px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .stat .v{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,.92);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .delta.good{color: var(--good)}
    .delta.bad{color: var(--bad)}

    .chartPanel{display:flex; flex-direction:column; min-width:0}
    .chartTop{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .tfRow{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    .tf{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      font-weight: 1000;
      font-size: 12px;
      letter-spacing:.06em;
      color: rgba(255,255,255,.86);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .12s ease, background .12s ease;
    }
    .tf:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .tf.active{border:0; background: linear-gradient(90deg, rgba(20,241,149,.92), rgba(0,209,255,.86), rgba(153,69,255,.86)); color:#061012}
    .chartMeta{
      display:flex; align-items:center; gap:10px;
      color: var(--muted);
      font-size: 12px;
      font-family: var(--mono);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 100%;
    }
    .chartWrap{
      height: 420px;
      min-height: 320px;
      position:relative;
      touch-action: pan-y pinch-zoom;
    }
    @media (max-width: 980px){ .chartWrap{height: 380px} }
    @media (max-width: 520px){ .chartWrap{height: 330px} }
    #chart{ position:absolute; inset:0; width:100%; height:100%; }

    .chartFooter{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
      padding: 10px 12px 12px;
      border-top: 1px solid rgba(255,255,255,.08);
      color: var(--muted);
      font-size: 12px;
    }
    .status{ display:flex; align-items:center; gap:10px; white-space:nowrap; }
    .status .dot{
      width:8px; height:8px; border-radius:999px;
      background: rgba(255,255,255,.35);
      box-shadow: 0 0 0 6px rgba(255,255,255,.06);
    }
    .status.live .dot{ background: var(--good); box-shadow: 0 0 0 6px rgba(20,241,149,.08); }
    .status.warn .dot{ background: var(--warn); box-shadow: 0 0 0 6px rgba(255,205,98,.08); }
    .status.bad .dot{ background: var(--bad); box-shadow: 0 0 0 6px rgba(255,104,121,.08); }

    .table{ width:100%; border-collapse:separate; border-spacing:0; font-size: 12px; }
    .table th, .table td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,.07);
      text-align:left;
      vertical-align:middle;
      white-space:nowrap;
    }
    .table th{
      font-size: 10px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color: rgba(255,255,255,.56);
      font-weight: 1000;
      background: rgba(255,255,255,.03);
      position:sticky;
      top:0;
      z-index:2;
    }
    .tableWrap{
      max-height: 520px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }
    @media (max-width: 980px){ .tableWrap{max-height: 360px} }

    .side{
      font-weight: 1000;
      letter-spacing:.06em;
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,.04);
    }
    .side.buy{border-color: rgba(20,241,149,.34); background: rgba(20,241,149,.08); color: rgba(20,241,149,.95)}
    .side.sell{border-color: rgba(255,104,121,.34); background: rgba(255,104,121,.08); color: rgba(255,104,121,.92)}

    .mono{font-family: var(--mono)}
    .muted{color: var(--muted)}
    .muted2{color: var(--muted2)}
    .right{ text-align:right }
    .center{ text-align:center }
    .ellipsis{overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width: 100%}

    .empty{
      padding: 14px 12px 16px;
      color: var(--muted);
      font-size: 13px;
      display:flex;
      gap:10px;
      align-items:flex-start;
    }
    .empty b{color: rgba(255,255,255,.86)}
    .sep{ opacity:.35; margin: 0 6px; }

    /* Modal */
    .modalBack{
      position: fixed;
      inset: 0;
      z-index: 1000;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    .modalBack.show{display:flex}
    .modal{
      width: min(640px, 100%);
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.04));
      box-shadow: 0 26px 90px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modalHead{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding: 14px 14px;
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .modalTitle{
      font-weight: 1000;
      letter-spacing:.06em;
      text-transform: uppercase;
      font-size: 12px;
      color: rgba(255,255,255,.86);
    }
    .modalBody{padding: 14px}
    .field{
      display:grid;
      grid-template-columns: 1fr;
      gap:8px;
      margin-bottom: 12px;
    }
    .label{
      font-size: 11px;
      letter-spacing:.12em;
      text-transform: uppercase;
      color: rgba(255,255,255,.60);
      font-weight: 1000;
    }
    .input{
      width:100%;
      padding: 11px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.92);
      outline:none;
      font-family: var(--mono);
      font-size: 12px;
    }
    .help{ font-size: 12px; color: var(--muted); line-height: 1.45; }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .footerBtns{display:flex; gap:10px; justify-content:flex-end; padding: 12px 14px 14px; border-top: 1px solid rgba(255,255,255,.08)}

    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      z-index: 1200;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(7,7,17,.72);
      backdrop-filter: blur(12px);
      box-shadow: 0 18px 55px rgba(0,0,0,.45);
      color: rgba(255,255,255,.88);
      font-size: 12px;
      display:none;
      align-items:center;
      gap:10px;
      max-width: min(92vw, 840px);
    }
    .toast.show{display:flex}
    .toast .tDot{
      width:8px; height:8px; border-radius:999px;
      background: var(--warn);
      box-shadow: 0 0 0 6px rgba(255,205,98,.08);
      flex:0 0 auto;
    }
  
    /* Trades: subtle "new row" animation (no overlays) */
    @keyframes dgTradeIn{
      from{ opacity:.55; background-color: rgba(20,241,149,.10); }
      to  { opacity:1; background-color: transparent; }
    }
    tr.tradeNew{
      animation: dgTradeIn .55s ease both;
    }
    tr.tradeNew td{
      transition: background-color .6s ease;
    }

    /* Row tint like DexScreener (do not tint Age column) */
    tbody tr.tradeBuy td:not(:nth-child(5)){
      background: rgba(20,241,149,.055);
    }
    tbody tr.tradeSell td:not(:nth-child(5)){
      background: rgba(255,104,121,.055);
    }
    /* Keep a clean hover without breaking tint */
    tbody tr.tradeBuy:hover td:not(:nth-child(5)){
      background: rgba(20,241,149,.085);
    }
    tbody tr.tradeSell:hover td:not(:nth-child(5)){
      background: rgba(255,104,121,.085);
    }

  </style>
</head>

<body>
  <header class="header">
    <div class="wrap">
      <div class="headerRow">
        <div class="brand" aria-label="DexGuard">
          <div class="logo" aria-hidden="true"><span>DG</span></div>
          <div class="brandText">
            <div class="brandTop">
              <div class="pill" title="Live feeds are enabled (quiet mode)">
                <span class="liveDot" aria-hidden="true"></span>
                <b>LIVE TRENDING</b>
              </div>
              <div class="brandName">DexGuard ‚Ä¢ DexLike</div>
            </div>
            <div id="subline" class="sub">Search + Trending + Live chart + Live trades. No ads. No overlays.</div>
          </div>
        </div>

        <div class="actions">
          <button id="btnSettings" class="btn ghost" title="Settings">Settings</button>
          <button id="btnClear" class="btn" title="Clear view">Clear</button>
          <a id="btnDS" class="btn grad" href="#" target="_blank" rel="noreferrer noopener" title="Open current pool on DexScreener">Open on DexScreener</a>
        </div>
      </div>
    </div>
  </header>

  <main class="main">
    <div class="wrap">
      <div class="card">
        <div class="toolbar">
          <div class="chainTabs" role="tablist" aria-label="Chains">
            <button class="tab active" data-chain="solana" role="tab" aria-selected="true">SOL</button>
            <button class="tab" data-chain="ethereum" role="tab" aria-selected="false">ETH</button>
            <button class="tab" data-chain="bsc" role="tab" aria-selected="false">BNB</button>
            <button class="tab" data-chain="base" role="tab" aria-selected="false">BASE</button>
          </div>

          <div class="searchWrap">
            <div class="search" role="search">
              <span class="searchIcon">‚åï</span>
              <input id="q" autocomplete="off" spellcheck="false" placeholder="Search token name / symbol / contract‚Ä¶" />
            </div>
            <button id="btnSearch" class="btn" title="Search">Search</button>
          </div>
        </div>

        <div class="grid">
          <section class="panel" aria-label="Trending">
            <div class="panelHead">
              <div class="title">Trending</div>
              <div class="hint"><span class="kbd">15m</span> default timeframe</div>
            </div>
            <div id="trending" class="trendingRow" aria-label="Trending row"></div>
            <div id="trendingEmpty" class="empty" style="display:none">
              <div>üõ°Ô∏è</div>
              <div><b>No trending yet.</b> If an API is CORS-blocked in your environment, set a Proxy URL in Settings.</div>
            </div>
          </section>

          <section class="panel" aria-label="Search results">
            <div class="panelHead">
              <div class="title">Search Results</div>
              <div class="hint"><span class="kbd">Enter</span> to search</div>
            </div>
            <div id="results" class="results"></div>
            <div id="resultsEmpty" class="empty">
              <div>üîé</div>
              <div><b>Search a token.</b> Results show logo, name, symbol, chain and an ‚ÄúOpen‚Äù action.</div>
            </div>
          </section>
        </div>

        <section class="panel" aria-label="Token view">
          <div class="tokenView">
            <div id="tokenEmpty" class="empty">
              <div>üß≠</div>
              <div><b>Select a trending token</b> or search and open a pair to load the live chart + trades.</div>
            </div>

            <div id="tokenBlock" style="display:none">
              <div class="tokenHeader">
                <div class="tokenLeft">
                  <div class="bigLogo" id="tokenLogo"><span class="muted mono">DG</span></div>
                  <div class="tokenNames">
                    <div id="tokenTitle" class="sym">‚Äî</div>
                    <div id="tokenSub" class="addr">‚Äî</div>
                  </div>
                </div>
                <div class="tokenRight">
                  <div class="linksRow">
                    <a id="lnkExplorer" class="linkPill" href="#" target="_blank" rel="noreferrer noopener">Explorer</a>
                    <a id="lnkPair" class="linkPill" href="#" target="_blank" rel="noreferrer noopener">Pair</a>
                    <a id="lnkDex" class="linkPill" href="#" target="_blank" rel="noreferrer noopener">DexScreener</a>
                  </div>
                </div>
              </div>

              <div class="statsGrid">
                <div class="stat"><div class="k">Price</div><div id="stPrice" class="v">‚Äî</div></div>
                <div class="stat"><div class="k">24h Change</div><div id="stChg" class="v">‚Äî</div></div>
                <div class="stat"><div class="k">24h Volume</div><div id="stVol" class="v">‚Äî</div></div>
                <div class="stat"><div class="k">Liquidity</div><div id="stLiq" class="v">‚Äî</div></div>
                <div class="stat"><div class="k">Market Cap</div><div id="stMcap" class="v">‚Äî</div></div>
                <div class="stat"><div class="k">Pool</div><div id="stPool" class="v">‚Äî</div></div>
              </div>

              <div class="grid" style="padding-top:0">
                <section class="panel chartPanel" aria-label="Live chart">
                  <div class="chartTop">
                    <div class="tfRow" aria-label="Timeframes">
                      <button class="tf" data-tf="1m">1m</button>
                      <button class="tf" data-tf="5m">5m</button>
                      <button class="tf active" data-tf="15m">15m</button>
                      <button class="tf" data-tf="1h">1h</button>
                      <button class="tf" data-tf="4h">4h</button>
                      <button class="tf" data-tf="1d">1d</button>
                    </div>
                    <div id="chartMeta" class="chartMeta ellipsis">‚Äî</div>
                  </div>

                  <div class="chartWrap" id="chartWrap">
                    <div id="chart"></div>
                  </div>

                  <div class="chartFooter">
                    <div id="status" class="status"><span class="dot"></span><span id="statusTxt">Idle</span></div>
                    <div class="muted2">Live: trades ‚Üí last price ‚Üí safe fallback. Quiet errors (console only).</div>
                  </div>
                </section>

                <section class="panel" aria-label="Live trades">
                  <div class="panelHead">
                    <div class="title">Live Trades</div>
                    <div class="hint"><span id="tradeCount" class="kbd">0</span> latest</div>
                  </div>
                  <div class="tableWrap">
                    <table class="table">
                      <thead>
                        <tr>
                          <th class="center">Side</th>
                          <th>Amount</th>
                          <th class="right">Price</th>
                          <th class="right">USD</th>
                          <th class="right">Age</th>
                          <th>Wallet</th>
                          <th class="center">Tx</th>
                        </tr>
                      </thead>
                      <tbody id="tradesBody"></tbody>
                    </table>
                  </div>
                  <div id="tradesEmpty" class="empty" style="display:none">
                    <div>‚è±Ô∏è</div>
                    <div><b>No trades yet.</b> We'll keep polling quietly. If blocked, set Proxy URL in Settings.</div>
                  </div>
                </section>
              </div>
            </div>
          </div>
        </section>
      </div>
    </div>
  </main>

  <!-- Settings Modal -->
  <div id="modalBack" class="modalBack" role="dialog" aria-modal="true" aria-label="Settings">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle">Settings</div>
        <button id="btnCloseModal" class="btn icon" aria-label="Close">√ó</button>
      </div>
      <div class="modalBody">
        <div class="field">
          <div class="label">Proxy URL (optional)</div>
          <input id="proxyUrl" class="input" placeholder="https://your-worker.example.com/?url=" />
          <div class="help">
            Use this if your environment blocks API calls via CORS. You can use <span class="kbd">{url}</span> placeholder,
            e.g. <span class="kbd">https://worker.tld/fetch?u={url}</span>.
          </div>
        </div>

        <div class="field">
          <div class="label">BIRDEYE_API_KEY (optional, Solana only)</div>
          <input id="birdeyeKey" class="input" placeholder="(stored locally ‚Äî never hardcoded)" />
          <div class="help">
            Optional Solana enrichment / candle fallback. App works without it.
          </div>
        </div>

        <div class="field">
          <div class="label">Polling</div>
          <div class="row">
            <button id="btnResetPolling" class="btn">Reset to defaults</button>
            <span class="help">Trades/price: <span class="kbd" id="pollLive">2.5s</span> ‚Ä¢ When tab hidden: <span class="kbd" id="pollHidden">12s</span></span>
          </div>
        </div>

        <div class="field" style="margin-bottom:0">
          <div class="label">Local cache</div>
          <div class="row">
            <button id="btnClearCache" class="btn">Clear local cache</button>
            <span class="help">Trending + candles cached briefly to reduce rate limits.</span>
          </div>
        </div>
      </div>
      <div class="footerBtns">
        <button id="btnSaveSettings" class="btn grad">Save</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite">
    <span class="tDot" aria-hidden="true"></span>
    <span id="toastTxt">‚Äî</span>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>

  <script>
  (() => {
    'use strict';

    // ========= Utilities =========
    const $ = (sel, root=document) => root.querySelector(sel);
    const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
    const nowSec = () => Math.floor(Date.now()/1000);
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    const fmtNum = (n, digits=2) => {
      if (n === null || n === undefined || !isFinite(n)) return '‚Äî';
      const abs = Math.abs(n);
      const d = abs >= 1000 ? 0 : digits;
      return n.toLocaleString(undefined, {maximumFractionDigits:d});
    };
    const fmtUSD = (n) => {
      if (n === null || n === undefined || !isFinite(n)) return '‚Äî';
      const abs = Math.abs(n);
      const digits = abs >= 1000 ? 0 : abs >= 1 ? 2 : abs >= 0.01 ? 4 : abs >= 0.0001 ? 6 : 10;
      return '$' + n.toLocaleString(undefined, {maximumFractionDigits:digits});
    };
    const fmtPrice = (n) => {
      if (n === null || n === undefined || !isFinite(n)) return '‚Äî';
      const abs = Math.abs(n);
      const digits = abs >= 1 ? 6 : abs >= 0.01 ? 8 : 10;
      return n.toLocaleString(undefined, {maximumFractionDigits:digits});
    };

    // Trade formatting (DexScreener-like; fixed separators & decimals)
    const fmtAmt = (n) => {
      if (n === null || n === undefined || !isFinite(n)) return '‚Äî';
      const abs = Math.abs(n);
      let digits = 0;
      if (abs >= 10000) digits = 0;
      else if (abs >= 1000) digits = 2;
      else if (abs >= 1) digits = 3;
      else if (abs >= 0.01) digits = 6;
      else digits = 8;
      return n.toLocaleString('en-US', { maximumFractionDigits: digits });
    };

    const fmtUsd2 = (n) => {
      if (n === null || n === undefined || !isFinite(n)) return '‚Äî';
      const abs = Math.abs(n);
      const digits = abs >= 0.01 ? 2 : 4;
      return '$' + n.toLocaleString('en-US', { minimumFractionDigits: digits, maximumFractionDigits: digits });
    };

    const shortAddr = (a) => {
      if (!a) return '‚Äî';
      if (a.length <= 12) return a;
      return a.slice(0,6) + '‚Ä¶' + a.slice(-4);
    };
    const timeAgo = (tsSec) => {
      if (!tsSec || !isFinite(tsSec)) return '‚Äî';
      const d = Math.max(0, nowSec() - Math.floor(tsSec));
      if (d < 60) return d + 's';
      const m = Math.floor(d/60);
      if (m < 60) return m + 'm';
      const h = Math.floor(m/60);
      if (h < 48) return h + 'h';
      const days = Math.floor(h/24);
      return days + 'd';
    };
    const escapeHtml = (s) => String(s ?? '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    const toNum = (x) => {
      const n = typeof x === 'string' ? parseFloat(x) : (typeof x === 'number' ? x : NaN);
      return isFinite(n) ? n : null;
    };

    // ========= Quiet toast (only user-triggered) =========
    let toastTimer = null;
    function toast(msg){
      const el = $('#toast');
      $('#toastTxt').textContent = msg;
      el.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=> el.classList.remove('show'), 2200);
    }

    // ========= Settings (local only) =========
    const LS = {
      proxy: 'dg_proxy_url_v1',
      birdeye: 'dg_birdeye_key_v1',
      cache: 'dg_cache_v1',
    };
    const settings = {
      proxyUrl: localStorage.getItem(LS.proxy) || '',
      birdeyeKey: localStorage.getItem(LS.birdeye) || '',
      pollLiveMs: 2500,
      pollHiddenMs: 12000,
    };

    // ========= Simple cache (mem + localStorage TTL) =========
    const memCache = new Map(); // key -> {t, ttl, v}
    function cacheGet(key){
      const m = memCache.get(key);
      if (m && (Date.now()-m.t) < m.ttl) return m.v;
      try{
        const raw = localStorage.getItem(LS.cache);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        const ent = obj[key];
        if (!ent) return null;
        if ((Date.now() - ent.t) > ent.ttl) return null;
        return ent.v;
      }catch(e){ return null; }
    }
    function cacheSet(key, v, ttl){
      memCache.set(key, {t:Date.now(), ttl, v});
      try{
        const raw = localStorage.getItem(LS.cache);
        const obj = raw ? JSON.parse(raw) : {};
        obj[key] = {t:Date.now(), ttl, v};
        const keys = Object.keys(obj);
        if (keys.length > 140){
          keys.sort((a,b)=> (obj[a].t||0) - (obj[b].t||0));
          for (let i=0;i<keys.length-140;i++) delete obj[keys[i]];
        }
        localStorage.setItem(LS.cache, JSON.stringify(obj));
      }catch(e){}
    }
    function cacheClear(){
      memCache.clear();
      try{ localStorage.removeItem(LS.cache); }catch(e){}
    }

    // ========= Proxy wrapper =========
    function applyProxy(url){
      const p = (settings.proxyUrl || '').trim();
      if (!p) return url;
      const enc = encodeURIComponent(url);
      if (p.includes('{url}')) return p.split('{url}').join(enc);
      const join = p.includes('?') ? '&' : '?';
      return p + join + 'url=' + enc;
    }

    // ========= Fetch (Abort + backoff + dedupe) =========
    const inflight = new Map(); // finalUrl -> promise
    async function fetchJson(url, {ttl=0, signal=null, headers=null}={}){
      const finalUrl = applyProxy(url);
      const cacheKey = finalUrl;
      if (ttl > 0){
        const cached = cacheGet(cacheKey);
        if (cached) return cached;
      }
      if (inflight.has(cacheKey)) return inflight.get(cacheKey);

      const p = (async ()=>{
        const res = await fetch(finalUrl, {
          method:'GET',
          headers: Object.assign({'accept':'application/json'}, headers || {}),
          signal,
          cache:'no-store',
          mode:'cors',
        });
        if (!res.ok) {
          const txt = await res.text().catch(()=> '');
          const err = new Error('HTTP '+res.status+' '+res.statusText);
          err.status = res.status;
          err.body = txt.slice(0,200);
          throw err;
        }
        const data = await res.json();
        if (ttl > 0) cacheSet(cacheKey, data, ttl);
        return data;
      })();

      inflight.set(cacheKey, p);
      try{ return await p; }
      finally{ inflight.delete(cacheKey); }
    }

    async function withBackoff(fn, {tries=3, baseMs=350, maxMs=2800, signal=null}={}){
      let lastErr = null;
      for (let i=0;i<tries;i++){
        if (signal?.aborted) throw new DOMException('Aborted','AbortError');
        try{ return await fn(); }
        catch(e){
          lastErr = e;
          const msg = String(e && (e.message||e));
          if (msg.includes('AbortError')) throw e;
          const wait = clamp(baseMs * (2**i) + Math.random()*120, baseMs, maxMs);
          await sleep(wait);
        }
      }
      throw lastErr;
    }

    // ========= Chain mappings =========
    const CHAINS = {
      solana:  {label:'SOL', ds:'solana', gt:'solana', explorer:'https://solscan.io'},
      ethereum:{label:'ETH', ds:'ethereum', gt:'eth', explorer:'https://etherscan.io'},
      bsc:     {label:'BNB', ds:'bsc', gt:'bsc', explorer:'https://bscscan.com'},
      base:    {label:'BASE',ds:'base', gt:'base', explorer:'https://basescan.org'},
    };

    // ========= API helpers =========
    const dsSearchUrl = (q) => `https://api.dexscreener.com/latest/dex/search?q=${encodeURIComponent(q)}`;
    const dsPairsUrl = (chainId, pairId) => `https://api.dexscreener.com/latest/dex/pairs/${encodeURIComponent(chainId)}/${encodeURIComponent(pairId)}`;
    const dsTokenPairsUrl = (chainId, token) => `https://api.dexscreener.com/token-pairs/v1/${encodeURIComponent(chainId)}/${encodeURIComponent(token)}`;

    const dsTradesUrl = (chainId, pairId, limit=60) => `https://io.dexscreener.com/dex/trades/v1/${encodeURIComponent(chainId)}/${encodeURIComponent(pairId)}?limit=${limit}&ts=${Date.now()}`;
    const dsBoostTopUrl = () => `https://api.dexscreener.com/token-boosts/top/v1`;
    const dsBoostLatestUrl = () => `https://api.dexscreener.com/token-boosts/latest/v1`;

    const gtPoolUrl = (network, pool) => `https://api.geckoterminal.com/api/v2/networks/${encodeURIComponent(network)}/pools/${encodeURIComponent(pool)}`;
    const gtTradesUrl = (network, pool) => `https://api.geckoterminal.com/api/v2/networks/${encodeURIComponent(network)}/pools/${encodeURIComponent(pool)}/trades?page=1&ts=${Date.now()}`;
    function tfToGT(tf){
      switch(tf){
        case '1m': return {timeframe:'minute', aggregate:1, sec:60};
        case '5m': return {timeframe:'minute', aggregate:5, sec:300};
        case '15m': return {timeframe:'minute', aggregate:15, sec:900};
        case '1h': return {timeframe:'hour', aggregate:1, sec:3600};
        case '4h': return {timeframe:'hour', aggregate:4, sec:14400};
        case '1d': return {timeframe:'day', aggregate:1, sec:86400};
        default: return {timeframe:'minute', aggregate:15, sec:900};
      }
    }
    function gtOhlcvUrl(network, pool, tf, token='base', before, limitOverride){
      const map = tfToGT(tf);
      const limit = limitOverride || (map.timeframe === 'day' ? 260 : map.timeframe === 'hour' ? 520 : 700);
      const cutoff = before || nowSec();
      const currency = 'usd';
      // Gecko supports token=base|quote; some pools only have one side priced reliably in USD.
      return `https://api.geckoterminal.com/api/v2/networks/${encodeURIComponent(network)}/pools/${encodeURIComponent(pool)}/ohlcv/${encodeURIComponent(map.timeframe)}?aggregate=${map.aggregate}&before_timestamp=${cutoff}&limit=${limit}&currency=${currency}&token=${encodeURIComponent(token)}`;
    }

    const birdeyeTokenOverviewUrl = (token) => `https://public-api.birdeye.so/defi/token_overview?address=${encodeURIComponent(token)}`;
    const birdeyeOhlcvUrl = (token, tf) => {
      const interval = tf === '1m' ? '1m' : tf === '5m' ? '5m' : tf === '15m' ? '15m' : tf === '1h' ? '1H' : tf === '4h' ? '4H' : '1D';
      const limit = tf === '1d' ? 260 : tf === '4h' ? 520 : tf === '1h' ? 700 : 900;
      const to = nowSec();
      const secs = tf === '1m' ? 60 : tf === '5m' ? 300 : tf === '15m' ? 900 : tf === '1h' ? 3600 : tf === '4h' ? 14400 : 86400;
      const from = to - secs * limit;
      return `https://public-api.birdeye.so/defi/ohlcv?address=${encodeURIComponent(token)}&type=token&time_from=${from}&time_to=${to}&interval=${encodeURIComponent(interval)}`;
    };

    function explorerLink(chain, address, kind='token'){
      const base = CHAINS[chain]?.explorer || '';
      if (!base) return '#';
      if (chain === 'solana'){
        if (kind === 'tx') return `${base}/tx/${address}`;
        return `${base}/address/${address}`;
      }
      if (kind === 'tx') return `${base}/tx/${address}`;
      return `${base}/address/${address}`;
    }
    function dexLink(chain, pairId){
      const dsChain = CHAINS[chain]?.ds || chain;
      return `https://dexscreener.com/${dsChain}/${pairId}`;
    }

    // ========= DOM =========
    const el = {
      btnSettings: $('#btnSettings'),
      btnClear: $('#btnClear'),
      btnDS: $('#btnDS'),
      tabs: $$('.tab'),
      q: $('#q'),
      btnSearch: $('#btnSearch'),
      trending: $('#trending'),
      trendingEmpty: $('#trendingEmpty'),
      results: $('#results'),
      resultsEmpty: $('#resultsEmpty'),
      tokenEmpty: $('#tokenEmpty'),
      tokenBlock: $('#tokenBlock'),
      tokenLogo: $('#tokenLogo'),
      tokenTitle: $('#tokenTitle'),
      tokenSub: $('#tokenSub'),
      stPrice: $('#stPrice'),
      stChg: $('#stChg'),
      stVol: $('#stVol'),
      stLiq: $('#stLiq'),
      stMcap: $('#stMcap'),
      stPool: $('#stPool'),
      lnkExplorer: $('#lnkExplorer'),
      lnkDex: $('#lnkDex'),
      lnkPair: $('#lnkPair'),
      tfs: $$('.tf'),
      chartWrap: $('#chartWrap'),
      chartMeta: $('#chartMeta'),
      status: $('#status'),
      statusTxt: $('#statusTxt'),
      tradesBody: $('#tradesBody'),
      tradesEmpty: $('#tradesEmpty'),
      tradeCount: $('#tradeCount'),
      modalBack: $('#modalBack'),
      btnCloseModal: $('#btnCloseModal'),
      btnSaveSettings: $('#btnSaveSettings'),
      proxyUrl: $('#proxyUrl'),
      birdeyeKey: $('#birdeyeKey'),
      btnClearCache: $('#btnClearCache'),
      btnResetPolling: $('#btnResetPolling'),
      pollLive: $('#pollLive'),
      pollHidden: $('#pollHidden'),
    };

    // ========= App State =========
    const state = {
      chain: 'solana',
      tf: '15m',
      sessionId: 0,
      current: null, // meta

      // Trades state
      lastTradeId: null,
      tradesMap: new Map(),   // id -> trade
      tradesList: [],         // sorted desc (max 60)
      ageTimer: null,         // 1s age updater

      liveTimer: null,
      _onVis: null,
      abort: null,

      chart: null,
      series: null,
      ro: null,
      lastCandle: null,
      candles: [],
      lastPriceByPool: new Map(),
      candleRetryAt: new Map(),
      candleRefreshLock: false,
    };

    

    function inferPriceFormat(price){
      if (!isFinite(price) || price <= 0) return {precision: 2, minMove: 0.01};
      const abs = Math.abs(price);
      // Target ~2 significant decimals for >=1, more for micro prices (up to 12)
      const log10 = Math.floor(Math.log10(abs));
      const precision = clamp((log10 >= 0) ? 6 : (-log10 + 4), 2, 12);
      const minMove = Math.pow(10, -precision);
      return {precision, minMove};
    }

    function applySeriesPrecision(price){
      if (!state.series) return;
      const pf = inferPriceFormat(price);
      try{
        state.series.applyOptions({ priceFormat: { type: 'price', precision: pf.precision, minMove: pf.minMove } });
      }catch(e){}
    }
function setStatus(kind, txt){
      el.status.className = 'status ' + (kind || '');
      el.statusTxt.textContent = txt || '';
    }
    function setTradesEmpty(mode){
      if (!el.tradesEmpty) return;
      if (mode === 'hide'){
        el.tradesEmpty.style.display = 'none';
        return;
      }
      if (mode === 'loading'){
        el.tradesEmpty.innerHTML = `
          <div>‚è≥</div>
          <div><b>Loading trades‚Ä¶</b> Fetching the latest activity now.</div>
        `;
      } else {
        el.tradesEmpty.innerHTML = `
          <div>‚è±Ô∏è</div>
          <div><b>No trades yet.</b> We'll keep polling quietly. If blocked, set Proxy URL in Settings.</div>
        `;
      }
      el.tradesEmpty.style.display = '';
    }
    function poolKey(meta){ return `${meta.chain}|${meta.pool}`; }
    function primeChart(meta){
      const ck = candleCacheKey(meta, state.tf);
      const cached = candleCache.get(ck);
      if (cached && cached.data && cached.data.length){
        applyCandlesToChart(cached.data);
        return true;
      }
      const hintPrice = (meta && isFinite(meta.priceUsd) && meta.priceUsd > 0)
        ? meta.priceUsd
        : state.lastPriceByPool.get(poolKey(meta));
      if (isFinite(hintPrice) && hintPrice > 0){
        applyCandlesToChart(generateFlatCandles(hintPrice, state.tf, 220));
        return true;
      }
      return false;
    }

    // ========= Chart init =========
    function initChart(){
      if (state.chart) return;
      const wrap = el.chartWrap;
      const w = wrap.clientWidth|0;
      const h = wrap.clientHeight|0;
      if (w < 40 || h < 160) return;

      state.chart = LightweightCharts.createChart($('#chart'), {
        width: w,
        height: h,
        layout: {
          background: { type:'solid', color:'rgba(0,0,0,0)' },
          textColor: 'rgba(255,255,255,0.82)',
          fontSize: 12,
          fontFamily: getComputedStyle(document.documentElement).getPropertyValue('--mono') || 'monospace',
        },
        grid: {
          vertLines: { color:'rgba(255,255,255,0.06)' },
          horzLines: { color:'rgba(255,255,255,0.06)' },
        },
        rightPriceScale: {
          borderColor:'rgba(255,255,255,0.08)',
          scaleMargins: { top: 0.10, bottom: 0.12 },
        },
        timeScale: {
          borderColor:'rgba(255,255,255,0.08)',
          timeVisible: true,
          secondsVisible: false,
        },
        crosshair: {
          vertLine: { color:'rgba(255,255,255,0.16)', width:1 },
          horzLine: { color:'rgba(255,255,255,0.16)', width:1 },
        },
        handleScroll: { mouseWheel:true, pressedMouseMove:true, horzTouchDrag:true, vertTouchDrag:false },
        handleScale: { axisPressedMouseMove:true, pinch:true, mouseWheel:true },
      });

      state.series = state.chart.addCandlestickSeries({
        priceFormat: { type:'price', precision: 8, minMove: 0.00000001 },
        upColor: 'rgba(20,241,149,0.88)',
        downColor: 'rgba(255,104,121,0.82)',
        borderUpColor: 'rgba(20,241,149,0.88)',
        borderDownColor: 'rgba(255,104,121,0.82)',
        wickUpColor: 'rgba(20,241,149,0.70)',
        wickDownColor: 'rgba(255,104,121,0.70)',
      });

      // ResizeObserver with rAF throttle + suppress noisy RO errors
      let raf = 0;
      state.ro = new ResizeObserver(() => {
        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => {
          try{
            const w2 = wrap.clientWidth|0;
            const h2 = wrap.clientHeight|0;
            if (!state.chart || w2 < 40 || h2 < 160) return;
            state.chart.resize(w2, h2);
          }catch(e){
            const msg = String(e && e.message || e);
            if (!msg.includes('ResizeObserver')) console.warn('[DexGuard] resize', msg);
          }
        });
      });
      state.ro.observe(wrap);
    }

    // ========= UI builders =========
    function clearResults(){
      el.results.classList.remove('show');
      el.results.innerHTML = '';
      el.resultsEmpty.style.display = '';
    }

    function renderTrending(items){
      el.trending.innerHTML = '';
      if (!items || !items.length){
        el.trendingEmpty.style.display = '';
        return;
      }
      el.trendingEmpty.style.display = 'none';
      for (const it of items){
        const card = document.createElement('div');
        card.className = 'tokenCard';
        card.tabIndex = 0;

        const logoUrl = it.logoUrl || '';
        const chg = it.change24h;
        const chgChip = isFinite(chg) ? (chg>=0 ? `<span class="chip good">+${fmtNum(chg,2)}%</span>` : `<span class="chip bad">${fmtNum(chg,2)}%</span>`) : `<span class="chip">‚Äî</span>`;

        card.innerHTML = `
          <div class="tokenCardTop">
            <div class="tLogo">${logoUrl ? `<img src="${escapeHtml(logoUrl)}" alt="">` : `<span class="muted mono">DG</span>`}</div>
            <div class="tText">
              <div class="tName">${escapeHtml(it.baseName || it.baseSymbol || '‚Äî')}</div>
              <div class="tMeta">
                <span class="chip">${escapeHtml((it.baseSymbol||'').slice(0,10) || '‚Äî')}</span>
                ${chgChip}
                <span class="muted ellipsis">${escapeHtml(it.dexId || '')}</span>
              </div>
            </div>
          </div>
          <div class="metricRow">
            <div class="metric"><div class="k">Price</div><div class="v">${it.priceUsd!=null ? fmtUSD(it.priceUsd) : '‚Äî'}</div></div>
            <div class="metric"><div class="k">24h Vol</div><div class="v">${it.volume24hUsd!=null ? fmtUSD(it.volume24hUsd) : '‚Äî'}</div></div>
          </div>
        `;

        const open = () => openPool({chain: state.chain, pairId: it.pairId, tokenAddress: it.tokenAddress, hint: 'trending'});
        card.addEventListener('click', open);
        card.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); open(); }});
        el.trending.appendChild(card);
      }
    }

    function renderResults(pairs){
      el.results.innerHTML = '';
      el.results.classList.add('show');
      el.resultsEmpty.style.display = 'none';

      if (!pairs || !pairs.length){
        el.results.innerHTML = `<div class="empty"><div>üõ°Ô∏è</div><div><b>No results.</b> Try symbol, name or a contract address.</div></div>`;
        return;
      }

      const chainId = CHAINS[state.chain].ds;
      const filtered = pairs.filter(p => (p?.chainId || '').toLowerCase() === chainId);

      const list = filtered.length ? filtered : pairs.slice(0, 18);
      const max = Math.min(18, list.length);

      for (let i=0;i<max;i++){
        const p = list[i];
        const logo = p?.info?.imageUrl || p?.baseToken?.logoURI || p?.baseToken?.icon || '';
        const name = p?.baseToken?.name || '‚Äî';
        const sym = p?.baseToken?.symbol || '‚Äî';
        const pair = p?.pairAddress || p?.pairId || p?.pair || '';
        const token = p?.baseToken?.address || '';
        const dexId = p?.dexId || '';
        const priceUsd = toNum(p?.priceUsd);
        const chg24 = toNum(p?.priceChange?.h24);
        const itemChain = (p?.chainId || '').toLowerCase();

        const item = document.createElement('div');
        item.className = 'resultItem';
        item.tabIndex = 0;

        item.innerHTML = `
          <div class="tLogo">${logo ? `<img src="${escapeHtml(logo)}" alt="">` : `<span class="muted mono">DG</span>`}</div>
          <div class="rMain">
            <div class="rTop">
              <div class="rName ellipsis">${escapeHtml(name)} <span class="muted">(${escapeHtml(sym)})</span></div>
              <span class="chip">${escapeHtml((itemChain||'').toUpperCase().slice(0,4) || CHAINS[state.chain].label)}</span>
            </div>
            <div class="rSub">${escapeHtml(shortAddr(token))}<span class="sep">‚Ä¢</span>${escapeHtml(dexId)}<span class="sep">‚Ä¢</span>Price ${fmtUSD(priceUsd)}<span class="sep">‚Ä¢</span>24h ${chg24!=null ? fmtNum(chg24,2) : '‚Äî'}%</div>
          </div>
          <button class="btn" style="padding:8px 12px" aria-label="Open">Open</button>
        `;

        const open = () => {
          // If result is other chain, switch chain then open.
          const targetChain = Object.keys(CHAINS).find(k => CHAINS[k].ds === itemChain) || state.chain;
          if (targetChain !== state.chain){
            setChain(targetChain, {silent:true});
          }
          openPool({chain: targetChain, pairId: pair, tokenAddress: token, hint: 'search'});
        };

        item.addEventListener('click', open);
        item.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); open(); }});
        el.results.appendChild(item);
      }
    }

    function setTokenUI(meta){
      const logoUrl = meta.logoUrl || '';
      el.tokenLogo.innerHTML = logoUrl ? `<img src="${escapeHtml(logoUrl)}" alt="">` : `<span class="muted mono">DG</span>`;

      const sym = (meta.baseSymbol || '‚Äî');
      const quote = (meta.quoteSymbol || '‚Äî');
      el.tokenTitle.textContent = `${meta.baseName || sym}  (${sym}/${quote})`;
      el.tokenSub.textContent = `${CHAINS[meta.chain].label} ‚Ä¢ Contract: ${meta.token ? meta.token : '‚Äî'} ‚Ä¢ Pool: ${meta.pool || '‚Äî'}`;

      el.stPrice.textContent = meta.priceUsd!=null ? fmtUSD(meta.priceUsd) : '‚Äî';
      const chg = meta.change24h;
      el.stChg.innerHTML = isFinite(chg)
        ? `<span class="delta ${chg>=0?'good':'bad'}">${(chg>=0?'+':'') + fmtNum(chg,2)}%</span>`
        : '‚Äî';
      el.stVol.textContent = meta.volume24hUsd!=null ? fmtUSD(meta.volume24hUsd) : '‚Äî';
      el.stLiq.textContent = meta.liquidityUsd!=null ? fmtUSD(meta.liquidityUsd) : '‚Äî';
      el.stMcap.textContent = meta.marketCapUsd!=null ? fmtUSD(meta.marketCapUsd) : '‚Äî';
      el.stPool.textContent = shortAddr(meta.pool);

      el.lnkExplorer.href = meta.token ? explorerLink(meta.chain, meta.token, 'token') : '#';
      el.lnkPair.href = dexLink(meta.chain, meta.pool);
      el.lnkDex.href = dexLink(meta.chain, meta.pool);
      el.btnDS.href = dexLink(meta.chain, meta.pool);
      el.chartMeta.textContent = `${sym}/${quote} ‚Ä¢ ${CHAINS[meta.chain].label} ‚Ä¢ pool ${shortAddr(meta.pool)}`;
    }

    function showTokenView(show){
      el.tokenEmpty.style.display = show ? 'none' : '';
      el.tokenBlock.style.display = show ? '' : 'none';
      if (show) initChart();
    }

    // ========= Trending via DexScreener Boosts =========
    async function loadTrending(){
      const sid = ++state.sessionId;
      if (state.abort) state.abort.abort();
      state.abort = new AbortController();
      const signal = state.abort.signal;

      setStatus('', 'Loading trending‚Ä¶');

      try{
        const primary = await withBackoff(() => fetchJson(dsBoostTopUrl(), {ttl: 15_000, signal}), {tries:2, signal});
        if (sid !== state.sessionId) return;
        let items = normalizeBoosts(primary, state.chain);
        if (!items.length){
          const fallback = await withBackoff(() => fetchJson(dsBoostLatestUrl(), {ttl: 15_000, signal}), {tries:2, signal});
          if (sid !== state.sessionId) return;
          items = normalizeBoosts(fallback, state.chain);
        }

        // Enrich trending with best pool + price info (limited concurrency 2, in idle)
        const enriched = await enrichTrending(items, {sid, signal});
        if (sid !== state.sessionId) return;

        renderTrending(enriched);
        setStatus('live', 'Trending live');
      }catch(e){
        if (signal.aborted) return;
        console.warn('[DexGuard] trending error', e);
        renderTrending([]);
        setStatus('warn', 'Trending unavailable (set Proxy)');
      }
    }

    function normalizeBoosts(data, chain){
      // DexScreener token-boosts/top|latest: usually {tokens:[...]} or array. Be defensive.
      const arr = Array.isArray(data) ? data : (data?.tokens || data?.data || data?.results || []);
      const dsChain = CHAINS[chain].ds;
      const out = [];
      for (const t of arr){
        const c = (t?.chainId || t?.chain || '').toLowerCase();
        if (c !== dsChain) continue;
        out.push({
          tokenAddress: t?.tokenAddress || t?.address || t?.token || null,
          baseSymbol: t?.tokenSymbol || t?.symbol || null,
          baseName: t?.tokenName || t?.name || null,
          logoUrl: t?.icon || t?.logoURI || t?.imageUrl || t?.image || null,
          boosts: t?.totalAmount || t?.amount || t?.boosts || null,
        });
      }
      return out.slice(0, 16);
    }

    async function enrichTrending(items, {sid, signal}){
      // For each token, pick best pool via token-pairs. Concurrency limit 2.
      const chainId = CHAINS[state.chain].ds;
      const queue = items.slice();
      const out = [];
      let active = 0;

      const runOne = async () => {
        if (!queue.length) return;
        const it = queue.shift();
        active++;
        try{
          if (!it.tokenAddress){
            out.push(Object.assign({pairId:null, dexId:null, priceUsd:null, change24h:null, volume24hUsd:null, liquidityUsd:null}, it));
            return;
          }

          const pairs = await withBackoff(() => fetchJson(dsTokenPairsUrl(chainId, it.tokenAddress), {ttl: 12_000, signal}), {tries:2, signal});
          if (sid !== state.sessionId) return;

          const best = pickBestPair(Array.isArray(pairs) ? pairs : (pairs?.pairs||[]));
          const pairId = best?.pairAddress || best?.pairId || best?.pair || null;

          let metaLite = {};
          if (pairId){
            try{
              const ds = await withBackoff(() => fetchJson(dsPairsUrl(chainId, pairId), {ttl: 10_000, signal}), {tries:2, signal});
              const p = ds?.pairs?.[0] || null;
              if (p){
                metaLite = {
                  pairId,
                  dexId: p?.dexId || null,
                  priceUsd: toNum(p?.priceUsd),
                  change24h: toNum(p?.priceChange?.h24),
                  volume24hUsd: toNum(p?.volume?.h24),
                  liquidityUsd: toNum(p?.liquidity?.usd),
                  logoUrl: it.logoUrl || p?.info?.imageUrl || null,
                  baseSymbol: it.baseSymbol || p?.baseToken?.symbol || null,
                  baseName: it.baseName || p?.baseToken?.name || null,
                };
              } else {
                metaLite = {pairId};
              }
            }catch(e){
              metaLite = {pairId};
            }
          }

          out.push(Object.assign({pairId:null, dexId:null, priceUsd:null, change24h:null, volume24hUsd:null, liquidityUsd:null}, it, metaLite));
        }catch(e){
          // keep trending responsive even if enrichment fails
          out.push(Object.assign({pairId:null, dexId:null, priceUsd:null, change24h:null, volume24hUsd:null, liquidityUsd:null}, it));
        }finally{
          active--;
        }
      };

      const idle = window.requestIdleCallback || ((cb)=> setTimeout(()=>cb({timeRemaining:()=>0}), 40));
      await new Promise(resolve => idle(() => {
        (async ()=>{
          while (active < 2 && queue.length) runOne();
          while (active > 0){
            await sleep(40);
            while (active < 2 && queue.length) runOne();
          }
          resolve();
        })();
      }));

      // keep order stable-ish
      return out.slice(0, 16);
    }

    function pickBestPair(arr){
      if (!arr || !arr.length) return null;
      const scored = arr.map(p => {
        const liq = toNum(p?.liquidity?.usd ?? p?.liquidityUsd ?? p?.liquidity_in_usd ?? p?.reserve_in_usd);
        const vol = toNum(p?.volume?.h24 ?? p?.volume24hUsd ?? p?.volume_usd_24h);
        return {p, score: (liq||0)*10 + (vol||0)};
      });
      scored.sort((a,b)=> (b.score||0) - (a.score||0));
      return scored[0]?.p || arr[0];
    }

    // ========= Search =========
    let searchTimer = 0;
    async function doSearch(userTriggered=false){
      const q = (el.q.value || '').trim();
      if (!q){ clearResults(); return; }

      const sid = ++state.sessionId;
      if (state.abort) state.abort.abort();
      state.abort = new AbortController();
      const signal = state.abort.signal;

      if (userTriggered) toast('Searching‚Ä¶');
      setStatus('', 'Searching‚Ä¶');

      try{
        const data = await withBackoff(() => fetchJson(dsSearchUrl(q), {ttl: 0, signal}), {tries:2, signal});
        if (sid !== state.sessionId) return;
        renderResults(data?.pairs || []);
        setStatus('live', 'Search ready');
      }catch(e){
        if (signal.aborted) return;
        console.warn('[DexGuard] search error', e);
        setStatus('warn', 'Search unavailable (set Proxy)');
        if (userTriggered) toast('Search failed (try Proxy)');
        renderResults([]);
      }
    }

    function debounceSearch(){
      clearTimeout(searchTimer);
      searchTimer = setTimeout(()=> doSearch(false), 260);
    }

    // ========= Open pool / token =========
    async function openPool({chain, pairId, tokenAddress, hint=''}){
      if (!pairId && tokenAddress){
        await openByToken(chain, tokenAddress);
        return;
      }
      if (!pairId){ toast('No pool found'); return; }

      const sid = ++state.sessionId;
      if (state.abort) state.abort.abort();
      state.abort = new AbortController();
      const signal = state.abort.signal;

      stopLive();
      state.lastTradeId = null;
      state.candles = [];
      state.lastCandle = null;
      el.tradesBody.innerHTML = '';
      el.tradeCount.textContent = '0';
      state.tradesMap = new Map();
      state.tradesList = [];

      if (state.tf !== '15m'){
        state.tf = '15m';
        el.tfs.forEach(b => b.classList.toggle('active', b.dataset.tf === state.tf));
      }

      setTradesEmpty('loading');

      showTokenView(true);
      setStatus('', 'Loading token‚Ä¶');

      const dsChain = CHAINS[chain].ds;
      const gtNet = CHAINS[chain].gt;

      const meta = {
        chain, dsChain, gtNet,
        pool: pairId,
        token: tokenAddress || null,
        baseSymbol: null,
        quoteSymbol: null,
        baseName: null,
        logoUrl: null,
        dexId: null,
        priceUsd: null,
        change24h: null,
        volume24hUsd: null,
        liquidityUsd: null,
        marketCapUsd: null,
      };

      el.btnDS.href = dexLink(chain, pairId);
      primeChart(meta);

      // DexScreener meta
      try{
        const ds = await withBackoff(() => fetchJson(dsPairsUrl(dsChain, pairId), {ttl: 8_000, signal}), {tries:2, signal});
        if (sid !== state.sessionId) return;
        const p = ds?.pairs?.[0] || null;
        if (p){
          meta.token = meta.token || p?.baseToken?.address || null;
          meta.baseSymbol = p?.baseToken?.symbol || null;
          meta.baseName = p?.baseToken?.name || null;
          meta.quoteSymbol = p?.quoteToken?.symbol || null;
          meta.logoUrl = p?.info?.imageUrl || null;
          meta.dexId = p?.dexId || null;

          meta.priceUsd = toNum(p?.priceUsd);
          meta.change24h = toNum(p?.priceChange?.h24);
          meta.volume24hUsd = toNum(p?.volume?.h24);
          meta.liquidityUsd = toNum(p?.liquidity?.usd);
          meta.marketCapUsd = toNum(p?.fdv);
        }
      }catch(e){
        if (!signal.aborted) console.warn('[DexGuard] ds meta failed', e);
      }

      if (!state.candles.length) primeChart(meta);

      // Gecko pool enrich (optional)
      try{
        const gt = await withBackoff(() => fetchJson(gtPoolUrl(gtNet, pairId), {ttl: 8_000, signal}), {tries:2, signal});
        if (sid !== state.sessionId) return;
        const a = gt?.data?.attributes || {};
        meta.priceUsd = meta.priceUsd ?? toNum(a?.base_token_price_usd ?? a?.price_usd);
        meta.volume24hUsd = meta.volume24hUsd ?? toNum(a?.volume_usd?.h24 ?? a?.volume_usd_24h);
        meta.liquidityUsd = meta.liquidityUsd ?? toNum(a?.reserve_in_usd ?? a?.liquidity_in_usd);
        meta.change24h = meta.change24h ?? toNum(a?.price_change_percentage?.h24 ?? a?.price_change_percentage_24h);
        meta.logoUrl = meta.logoUrl ?? (a?.base_token?.image_url || a?.base_token_image_url || a?.image_url);
        meta.baseSymbol = meta.baseSymbol ?? (a?.base_token?.symbol || a?.base_token_symbol);
        meta.baseName = meta.baseName ?? (a?.base_token?.name || a?.base_token_name);
        meta.quoteSymbol = meta.quoteSymbol ?? (a?.quote_token?.symbol || a?.quote_token_symbol);
        meta.token = meta.token ?? (a?.base_token?.address || a?.base_token_address);
        meta.marketCapUsd = meta.marketCapUsd ?? toNum(a?.market_cap_usd ?? a?.fdv_usd);
      }catch(e){
        if (!signal.aborted) console.warn('[DexGuard] gt meta failed', e);
      }

      // Birdeye enrich (Solana only; optional key)
      if (chain === 'solana' && settings.birdeyeKey && meta.token){
        try{
          const be = await withBackoff(() => fetchJson(birdeyeTokenOverviewUrl(meta.token), {
            ttl: 20_000,
            signal,
            headers: {'X-API-KEY': settings.birdeyeKey},
          }), {tries:2, signal});
          if (sid !== state.sessionId) return;
          const d = be?.data || be?.data?.data || be?.data?.items || be?.data?.token || be?.data || null;
          meta.marketCapUsd = meta.marketCapUsd ?? toNum(d?.market_cap ?? d?.marketCap ?? d?.mc ?? d?.mcap);
          meta.logoUrl = meta.logoUrl ?? (d?.logoURI || d?.logo || d?.icon);
          meta.baseName = meta.baseName ?? (d?.name);
          meta.baseSymbol = meta.baseSymbol ?? (d?.symbol);
          meta.priceUsd = meta.priceUsd ?? toNum(d?.price ?? d?.priceUsd);
        }catch(e){
          if (!signal.aborted) console.warn('[DexGuard] birdeye overview failed', e);
        }
      }

      state.current = meta;
      setTokenUI(meta);
      showTokenView(true);

      startLive(meta, {sid});

      await loadCandles(meta, state.tf, {sid, signal});
      if (sid !== state.sessionId) return;
      if (shouldRetryCandles(meta)){
        setTimeout(() => {
          if (sid !== state.sessionId) return;
          void refreshCandles(meta, {sid, signal, reason:'post-load retry'});
        }, 900);
      }
      setStatus('live', 'Live');
    }

    async function openByToken(chain, token){
      const sid = ++state.sessionId;
      if (state.abort) state.abort.abort();
      state.abort = new AbortController();
      const signal = state.abort.signal;

      showTokenView(true);
      setStatus('', 'Resolving token‚Ä¶');

      try{
        const dsChain = CHAINS[chain].ds;
        const pairs = await withBackoff(() => fetchJson(dsTokenPairsUrl(dsChain, token), {ttl: 8_000, signal}), {tries:2, signal});
        if (sid !== state.sessionId) return;
        const best = pickBestPair(Array.isArray(pairs) ? pairs : (pairs?.pairs||[]));
        const pairId = best?.pairAddress || best?.pairId || best?.pair || best?.id || null;
        if (!pairId){
          setStatus('warn', 'No pool found for token');
          toast('No pool found for this contract on this chain');
          return;
        }
        await openPool({chain, pairId, tokenAddress: token, hint:'token'});
      }catch(e){
        if (signal.aborted) return;
        console.warn('[DexGuard] openByToken failed', e);
        setStatus('warn', 'Token resolve failed');
        toast('Resolve failed (try Proxy)');
      }
    }

    // ========= Candles =========
    const candleCache = new Map(); // key -> {t, data}
    const candleCacheKey = (meta, tf) => `${meta.chain}|${meta.pool}|${tf}`;
    const refPriceFor = (meta) => meta?.priceUsd ?? state.lastPriceByPool.get(poolKey(meta)) ?? null;
    async function waitForRefPrice(meta, timeoutMs=1400){
      const start = Date.now();
      let px = refPriceFor(meta);
      while ((!isFinite(px) || px <= 0) && (Date.now() - start) < timeoutMs){
        await sleep(120);
        px = refPriceFor(meta);
      }
      return px;
    }
    function maxCandlesForTf(tf){
      switch(tf){
        case '1m': return 8000;
        case '5m': return 12000;
        case '15m': return 20000;
        case '1h': return 4000;
        case '4h': return 3000;
        case '1d': return 2000;
        default: return 8000;
      }
    }
    async function fetchGTOhlcvPaged(meta, tf, token, {sid, signal}){
      const map = tfToGT(tf);
      const limit = map.timeframe === 'day' ? 260 : map.timeframe === 'hour' ? 520 : 700;
      const max = maxCandlesForTf(tf);
      let before = nowSec();
      let out = [];
      let pages = 0;

      while (out.length < max && pages < 50){
        pages++;
        let data = null;
        try{
          data = await withBackoff(() => fetchJson(gtOhlcvUrl(meta.gtNet, meta.pool, tf, token, before, limit), {ttl: 8_000, signal}), {tries:2, signal});
        }catch(e){
          const msg = String(e && (e.message || e));
          if (!msg.includes('AbortError')) console.warn('[DexGuard] gt ohlcv page failed', msg);
          break;
        }
        if (sid !== state.sessionId) return null;
        const chunk = normalizeGTOhlcv(data);
        if (!chunk.length) break;
        out = out.concat(chunk);
        const oldest = chunk.reduce((min, c) => (min === null || c.time < min ? c.time : min), null);
        if (!oldest || oldest >= before) break;
        before = oldest - 1;
        if (chunk.length < limit) break;
      }
      return out;
    }

    async function loadCandles(meta, tf, {sid, signal}){
      setStatus('', 'Loading candles‚Ä¶');

      const ck = candleCacheKey(meta, tf);
      const cached = candleCache.get(ck);
      if (cached && (Date.now()-cached.t) < 25_000){
        state.candles = cached.data.slice();
        applyCandlesToChart(state.candles);
        setStatus('live', 'Live (cached)');
        return;
      }

      let candles = null;
      let refPrice = refPriceFor(meta);
      const needBothSides = !(isFinite(refPrice) && refPrice > 0);

      function scoreCandles(list){
        const rp = refPrice;
        if (!list || !list.length || !isFinite(rp) || rp <= 0) return null;
        const last = list[list.length-1];
        const close = last?.close;
        if (!isFinite(close) || close <= 0) return null;
        const ratio = Math.max(close, rp) / Math.max(1e-12, Math.min(close, rp));
        return ratio;
      }
      function pickBestCandles(a, b){
        if (a && a.length && b && b.length){
          const sa = scoreCandles(a);
          const sb = scoreCandles(b);
          if (sa != null && sb != null) return (sa <= sb) ? a : b;
          return a.length >= b.length ? a : b;
        }
        return (a && a.length) ? a : (b && b.length ? b : null);
      }

      // 1) GeckoTerminal OHLCV (try base, then quote if base looks empty/zero)
      try{
        let baseCandles = null;
        let quoteCandles = null;
        baseCandles = await fetchGTOhlcvPaged(meta, tf, 'base', {sid, signal});
        if (baseCandles && baseCandles.length){
          const bad = baseCandles.every(c => !c || !isFinite(c.close) || c.close === 0);
          if (bad) baseCandles = null;
        }

        if (needBothSides || (!baseCandles || baseCandles.length < 20) || (refPrice && baseCandles && scoreCandles(baseCandles) > 50)){
          quoteCandles = await fetchGTOhlcvPaged(meta, tf, 'quote', {sid, signal});
          if (quoteCandles && quoteCandles.length){
            const bad2 = quoteCandles.every(c => !c || !isFinite(c.close) || c.close === 0);
            if (bad2) quoteCandles = null;
          }
        }

        if (needBothSides){
          refPrice = await waitForRefPrice(meta, 1400);
        }

        candles = pickBestCandles(baseCandles, quoteCandles);
      }catch(e){
        if (!signal.aborted) console.warn('[DexGuard] gt ohlcv failed', e);
      }

      // 2) Birdeye fallback (Solana only)
      if ((!candles || candles.length < 30) && meta.chain === 'solana' && settings.birdeyeKey && meta.token){
        try{
          const data = await withBackoff(() => fetchJson(birdeyeOhlcvUrl(meta.token, tf), {
            ttl: 8_000,
            signal,
            headers: {'X-API-KEY': settings.birdeyeKey},
          }), {tries:2, signal});
          if (sid !== state.sessionId) return;
          candles = normalizeBirdeyeOhlcv(data);
        }catch(e){
          if (!signal.aborted) console.warn('[DexGuard] birdeye ohlcv failed', e);
        }
      }

      // 3) Safe fallback: generate flat candles from last known price so chart never crashes
      if (!candles || !candles.length){
        const px = meta.priceUsd ?? state.candles?.[state.candles.length-1]?.close ?? 0;
        candles = generateFlatCandles(px || 0.0000001, tf, 220);
      }

      // sort + dedup
      candles.sort((a,b)=> a.time - b.time);
      const dedup = [];
      let lastT = 0;
      for (const c of candles){
        if (!c || !isFinite(c.time)) continue;
        if (c.time === lastT) { dedup[dedup.length-1] = c; continue; }
        lastT = c.time;
        dedup.push(c);
      }

      state.candles = dedup;
      candleCache.set(ck, {t:Date.now(), data: dedup.slice()});
      applyCandlesToChart(dedup);

      // If header price is missing, seed it from the most recent candle close.
      const last = dedup && dedup.length ? dedup[dedup.length-1] : null;
      if (last && isFinite(last.close)){
        if (state.current && state.current.pool === meta.pool){
          if (state.current.priceUsd == null) state.current.priceUsd = last.close;
        }
        state.lastPriceByPool.set(poolKey(meta), last.close);
        if (el.stPrice.textContent === '‚Äî') el.stPrice.textContent = fmtUSD(last.close);
      }

      setStatus('live', 'Live');
    }

    function normalizeGTOhlcv(data){
      const list = data?.data?.attributes?.ohlcv_list || data?.data?.attributes?.ohlcv || [];
      const out = [];
      for (const row of list){
        if (!Array.isArray(row) || row.length < 5) continue;
        let t = row[0];
        // normalize timestamp: seconds preferred; handle ms or string
        t = (typeof t === 'string') ? parseFloat(t) : t;
        if (!isFinite(t)) continue;
        t = t > 1e12 ? Math.floor(t/1000) : Math.floor(t);
        const o = (typeof row[1] === 'string') ? parseFloat(row[1]) : +row[1];
        const h = (typeof row[2] === 'string') ? parseFloat(row[2]) : +row[2];
        const l = (typeof row[3] === 'string') ? parseFloat(row[3]) : +row[3];
        const c = (typeof row[4] === 'string') ? parseFloat(row[4]) : +row[4];
        if (![t,o,h,l,c].every(isFinite)) continue;
        // guard against negative/zero-only garbage
        if (o < 0 || h < 0 || l < 0 || c < 0) continue;
        out.push({time:t, open:o, high:h, low:l, close:c});
      }
      return out;
    }
    function normalizeBirdeyeOhlcv(data){
      const items = data?.data?.items || data?.data?.data?.items || data?.items || [];
      const out = [];
      for (const it of items){
        const t = Math.floor(it?.unixTime ?? it?.time ?? it?.t ?? 0);
        const o = +it?.o, h = +it?.h, l = +it?.l, c = +it?.c;
        if (![t,o,h,l,c].every(isFinite)) continue;
        out.push({time:t, open:o, high:h, low:l, close:c});
      }
      return out;
    }

    function generateFlatCandles(price, tf, count){
      const {sec} = tfToGT(tf);
      const end = Math.floor(nowSec()/sec)*sec;
      const out = [];
      for (let i=count-1;i>=0;i--){
        const t = end - i*sec;
        out.push({time:t, open:price, high:price, low:price, close:price});
      }
      return out;
    }

    function applyCandlesToChart(candles){
      // guard: chart container may be zero-sized right after view switches
      initChart();
      if (!state.series) {
        // retry once shortly
        setTimeout(() => { initChart(); if (state.series) applyCandlesToChart(candles); }, 60);
        return;
      }
      try{
        state.series.setData(candles || []);
        const fit = () => {
          if (!state.chart || !state.series) return;
          const w = el.chartWrap.clientWidth|0;
          const h = el.chartWrap.clientHeight|0;
          if (w < 40 || h < 160) return;
          state.chart.timeScale().fitContent();
        };
        requestAnimationFrame(fit);
        setTimeout(fit, 180);
        if (candles && candles.length){
          const last = candles[candles.length-1];
          if (last && isFinite(last.close)) applySeriesPrecision(last.close);
        }
      }catch(e){
        console.warn('[DexGuard] setData failed', e);
      }
      if (candles && candles.length){
        state.lastCandle = candles[candles.length-1];
      } else {
        state.lastCandle = null;
      }
    }

    function isFlatCandles(list){
      if (!Array.isArray(list) || list.length < 12) return true;
      let min = Infinity;
      let max = -Infinity;
      for (const c of list){
        if (!c || !isFinite(c.close)) continue;
        if (c.close < min) min = c.close;
        if (c.close > max) max = c.close;
      }
      if (!isFinite(min) || !isFinite(max) || min <= 0 || max <= 0) return true;
      const ratio = max / min;
      return ratio < 1.001;
    }
    function shouldRetryCandles(meta){
      const key = poolKey(meta);
      const last = state.candleRetryAt.get(key) || 0;
      if ((Date.now() - last) < 20_000) return false;
      const flat = isFlatCandles(state.candles);
      if (!flat) return false;
      state.candleRetryAt.set(key, Date.now());
      return true;
    }
    async function refreshCandles(meta, {sid, signal, reason=''}){
      if (state.candleRefreshLock) return;
      state.candleRefreshLock = true;
      try{
        await loadCandles(meta, state.tf, {sid, signal});
        if (sid !== state.sessionId) return;
        if (reason) console.debug('[DexGuard] candle refresh', reason);
      } finally {
        state.candleRefreshLock = false;
      }
    }

    // ========= Live trades + candle growth =========
    function stopLive(){
      if (state.liveTimer){ clearInterval(state.liveTimer); state.liveTimer = null; }
      if (state.ageTimer){ clearInterval(state.ageTimer); state.ageTimer = null; }
      if (state._onVis){
        document.removeEventListener('visibilitychange', state._onVis);
        state._onVis = null;
      }
    }

    function startLive(meta, {sid}){
      stopLive();
      state.lastTradeId = null;

      // fresh trade cache per pool
      state.tradesMap = new Map();
      state.tradesList = [];

      const run = async () => {
        if (sid !== state.sessionId) return;
        if (!state.current || state.current.pool !== meta.pool) return;

        if (state._liveRunning) return;
        state._liveRunning = true;

        const hidden = document.visibilityState === 'hidden';
        const interval = hidden ? settings.pollHiddenMs : settings.pollLiveMs;

        try{
          await tickLive(meta, {sid});
          setStatus(hidden ? 'warn' : 'live', hidden ? 'Live (paused)' : 'Live');
        }catch(e){
          const msg = String(e && e.message || e);
          if (!msg.includes('AbortError')) console.warn('[DexGuard] live tick failed', e);
          setStatus(hidden ? 'warn' : 'warn', hidden ? 'Live (paused)' : 'Live (degraded)');
        }finally{
          state._liveRunning = false;
        }

        // ensure timer uses correct interval (rebuild if changed)
        if (state.liveTimer && state.liveTimer._ms !== interval){
          clearInterval(state.liveTimer);
          state.liveTimer = setInterval(run, interval);
          state.liveTimer._ms = interval;
        }
      };

      // start immediately, then poll
      run();
      const initial = (document.visibilityState === 'hidden') ? settings.pollHiddenMs : settings.pollLiveMs;
      state.liveTimer = setInterval(run, initial);
      state.liveTimer._ms = initial;

      // Visibility change: trigger an immediate tick; interval adjusts inside run
      state._onVis = () => { run(); };
      document.addEventListener('visibilitychange', state._onVis, {passive:true});

      // Keep ages ticking even between polls
      startAgeTicker();
    }

    async function tickLive(meta, {sid}){
      // Preferred: DexScreener live trades (matches what you see on DexScreener UI).
      // Fallback: GeckoTerminal trades.
      const urls = [
        dsTradesUrl(meta.dsChain, meta.pool, 60),
        gtTradesUrl(meta.gtNet, meta.pool),
      ];

      const ctrl = new AbortController();
      const signal = ctrl.signal;

      const guard = setInterval(() => {
        if (sid !== state.sessionId) ctrl.abort();
      }, 250);

      try{
        let trades = null;
        let used = '';
        for (const u of urls){
          try{
            const data = await withBackoff(() => fetchJson(u, {ttl: 0, signal}), {tries:2, signal});
            if (sid !== state.sessionId) return;

            if (u.includes('dex/trades/v1')){
              trades = normalizeDSTrades(data);
              used = 'ds';
            } else {
              trades = normalizeGTTrades(data);
              used = 'gt';
            }

            if (Array.isArray(trades) && trades.length) break;
          }catch(e){
            const msg = String(e && e.message || e);
            if (msg.includes('AbortError')) throw e;
            // try next source quietly
          }
        }

        if (sid !== state.sessionId) return;

        if (Array.isArray(trades) && trades.length){
          // Sort by timestamp desc (fallback: id). Newest always on top.
          trades = trades
            .filter(t => t && t.id)
            .sort((a,b)=> ((b.tsSec||0)-(a.tsSec||0)) || String(b.id).localeCompare(String(a.id)));

          if (!state.tradesMap) state.tradesMap = new Map();

          const newIds = new Set();
          for (const t of trades){
            if (!state.tradesMap.has(t.id)){
              state.tradesMap.set(t.id, t);
              newIds.add(t.id);
            } else {
              state.tradesMap.set(t.id, {...state.tradesMap.get(t.id), ...t});
            }
          }

          const list = Array.from(state.tradesMap.values())
            .sort((a,b)=> ((b.tsSec||0)-(a.tsSec||0)) || String(b.id).localeCompare(String(a.id)))
            .slice(0, 60);

          state.tradesList = list;
          const keep = new Set(list.map(t=>t.id));
          for (const id of Array.from(state.tradesMap.keys())){
            if (!keep.has(id)) state.tradesMap.delete(id);
          }

          setTradesEmpty(list.length ? 'hide' : 'empty');
          renderTradesTable(list, meta.chain, newIds);
          el.tradeCount.textContent = String(list.length);
          state.lastTradeId = list[0]?.id || state.lastTradeId;

          // Update header price + grow candle from newest trade
          const top = list[0];
          if (top && isFinite(top.priceUsd)){
            el.stPrice.textContent = fmtUSD(top.priceUsd);
            growLastCandle(top.priceUsd, top.tsSec || nowSec());
            if (state.current && state.current.pool === meta.pool){
              state.lastPriceByPool.set(poolKey(meta), top.priceUsd);
            }
          }

          if (shouldRetryCandles(meta)){
            void refreshCandles(meta, {sid, signal: state.abort?.signal, reason:'live retry'});
          }

          // reflect data source
          if (used) el.statusTxt.textContent = (document.visibilityState === 'hidden') ? 'Live (paused)' : 'Live';

          startAgeTicker();
        } else {
          if (el.tradesBody.children.length === 0) setTradesEmpty('empty');
        }
      } finally {
        clearInterval(guard);
      }
    }

    function startAgeTicker(){
      if (state.ageTimer) return;
      state.ageTimer = setInterval(updateAgeCells, 1000);
      updateAgeCells();
    }

    function updateAgeCells(){
      const rows = el.tradesBody.querySelectorAll('tr[data-ts]');
      const now = nowSec();
      for (const r of rows){
        const ts = parseInt(r.dataset.ts || '0', 10);
        const cell = r.querySelector('.ageCell');
        if (!cell) continue;
        if (!ts || !isFinite(ts)) { cell.textContent = '‚Äî'; continue; }
        const d = Math.max(0, now - ts);
        cell.textContent = d < 60 ? (d + 's') : (d < 3600 ? (Math.floor(d/60) + 'm') : (d < 172800 ? (Math.floor(d/3600) + 'h') : (Math.floor(d/86400) + 'd')));
      }
    }

    function renderTradesTable(list, chain, newIds){
      // Re-render to enforce strict ordering (newest on top). Fast enough for max 60 rows.
      const frag = document.createDocumentFragment();

      for (const t of list){
        const tr = document.createElement('tr');
      if (t.tsSec) tr.dataset.ts = String(t.tsSec);
        tr.dataset.id = t.id;
        if (t.tsSec) tr.dataset.ts = String(t.tsSec);

        if (newIds && newIds.has(t.id)) tr.classList.add('tradeNew');

        const sideCls = t.side === 'BUY' ? 'buy' : 'sell';
        tr.classList.add(t.side === 'BUY' ? 'tradeBuy' : 'tradeSell');
        const txUrl = t.tx ? explorerLink(chain, t.tx, 'tx') : '#';

        tr.innerHTML = `
          <td class="center"><span class="side ${sideCls}">${t.side}</span></td>
          <td class="mono">${t.amount !== null ? fmtAmt(t.amount) : '‚Äî'}</td>
          <td class="right mono">${t.priceUsd !== null ? fmtUSD(t.priceUsd) : '‚Äî'}</td>
          <td class="right mono">${t.usd !== null ? fmtUsd2(t.usd) : '‚Äî'}</td>
          <td class="right mono muted ageCell">${t.tsSec ? timeAgo(t.tsSec) : '‚Äî'}</td>
          <td class="mono muted ellipsis" style="max-width:140px">${t.wallet ? escapeHtml(shortAddr(t.wallet)) : '‚Äî'}</td>
          <td class="center">${t.tx ? `<a class="linkPill" style="padding:6px 10px; display:inline-flex" href="${escapeHtml(txUrl)}" target="_blank" rel="noreferrer noopener">‚Üó</a>` : '‚Äî'}</td>
        `;
        frag.appendChild(tr);
      }

      // Swap body content in one go (no jank)
      el.tradesBody.innerHTML = '';
      el.tradesBody.appendChild(frag);
    }

    function normalizeGTTrades(data){
      const arr = data?.data || [];
      const out = [];
      for (const row of arr){
        const a = row?.attributes || {};

        const kindRaw = (a?.kind || a?.side || a?.trade_type || a?.tradeType || '').toString().toLowerCase();
        const isBuy = kindRaw.includes('buy');

        // Amount: Gecko can expose different keys depending on chain/pool.
        const amountCandidates = [
          a?.base_token_amount, a?.baseTokenAmount,
          a?.volume_in_base_token, a?.volumeInBaseToken,
          a?.from_token_amount, a?.fromTokenAmount,
          a?.to_token_amount, a?.toTokenAmount,
          a?.token_amount, a?.tokenAmount,
          a?.amount,
        ].map(toNum).filter(v => v !== null);

        // Use the first sensible amount; if the first is tiny/zero and there is a larger alternative, prefer it.
        let amount = amountCandidates.length ? amountCandidates[0] : null;
        if (amountCandidates.length > 1){
          const best = amountCandidates.reduce((p,c)=> (p===null || (c>p && c>0)) ? c : p, amount);
          if (best !== null) amount = best;
        }

        // USD value / price
        const usd = toNum(a?.volume_in_usd ?? a?.value_in_usd ?? a?.volumeUsd ?? a?.valueUsd ?? a?.amount_usd ?? a?.usd_value ?? a?.usdValue);
        let priceUsd = toNum(a?.price_in_usd ?? a?.price_usd ?? a?.priceUsd ?? a?.execution_price_usd ?? a?.executionPriceUsd);

        if (priceUsd === null && usd !== null && amount !== null && amount > 0){
          priceUsd = usd / amount;
        }

        // Timestamp can be unix, ms, or ISO8601 string
        let ts = a?.block_timestamp ?? a?.timestamp ?? a?.time ?? a?.created_at ?? a?.createdAt ?? null;
        let tsSec = null;
        if (typeof ts === 'string'){
          const parsed = Date.parse(ts);
          if (isFinite(parsed)) tsSec = Math.floor(parsed/1000);
        } else if (isFinite(ts)){
          tsSec = ts > 1e12 ? Math.floor(ts/1000) : Math.floor(ts);
        }

        const tx = (a?.tx_hash || a?.txHash || a?.transaction_hash || a?.transactionHash || a?.hash || a?.signature || '').toString();
        const wallet = (a?.tx_from_address || a?.from_address || a?.maker || a?.maker_address || a?.trader || a?.trader_address || a?.owner || '').toString();

        const id = row?.id || tx || `${tsSec||0}_${priceUsd||0}_${usd||0}_${amount||0}_${kindRaw||''}`;

        out.push({
          id,
          side: isBuy ? 'BUY' : 'SELL',
          amount,
          priceUsd,
          usd,
          tsSec,
          wallet: wallet || null,
          tx: tx || null
        });
      }
      return out;
    }

    function normalizeDSTrades(data){
      // DexScreener trades v1 (io.dexscreener.com) usually returns an array of trade objects.
      const arr = Array.isArray(data) ? data : (data?.trades || data?.data || []);
      const out = [];
      for (const r of (arr || [])){
        if (!r) continue;
        const sideRaw = (r.type || r.side || r.kind || r.tradeType || '').toString().toLowerCase();
        const isBuy = sideRaw.includes('buy');

        const amount = toNum(r.amount ?? r.baseAmount ?? r.volume ?? r.baseVolume ?? r.tokenAmount ?? r.qty);
        const priceUsd = toNum(r.priceUsd ?? r.price_usd ?? r.price ?? r.executionPriceUsd ?? r.execution_price_usd);
        const usd = toNum(r.usd ?? r.volumeUsd ?? r.volume_usd ?? r.valueUsd ?? r.value_usd);

        // timestamp could be ms or sec
        let ts = r.timestamp ?? r.time ?? r.date ?? r.createdAt ?? r.created_at ?? null;
        let tsSec = null;
        if (typeof ts === 'string'){
          const parsed = Date.parse(ts);
          if (isFinite(parsed)) tsSec = Math.floor(parsed/1000);
        } else if (isFinite(ts)){
          tsSec = ts > 1e12 ? Math.floor(ts/1000) : Math.floor(ts);
        }

        const tx = (r.txHash || r.tx_hash || r.transactionHash || r.transaction_hash || r.hash || r.signature || '').toString();
        const wallet = (r.maker || r.owner || r.trader || r.from || r.fromAddress || r.from_address || '').toString();

        const id = (r.id || r.tradeId || r.trade_id || '') || tx || `${tsSec||0}_${priceUsd||0}_${usd||0}_${amount||0}_${sideRaw}`;

        out.push({
          id,
          side: isBuy ? 'BUY' : 'SELL',
          amount: amount !== null ? amount : null,
          priceUsd: priceUsd !== null ? priceUsd : null,
          usd: usd !== null ? usd : (priceUsd !== null && amount !== null ? priceUsd * amount : null),
          tsSec,
          wallet: wallet || null,
          tx: tx || null
        });
      }
      return out;
    }


    function addTradeRow(t, chain){
      const tr = document.createElement('tr');
      if (t.tsSec) tr.dataset.ts = String(t.tsSec);
      const sideCls = t.side === 'BUY' ? 'buy' : 'sell';
      const txUrl = t.tx ? explorerLink(chain, t.tx, 'tx') : '#';
      tr.innerHTML = `
        <td class="center"><span class="side ${sideCls}">${t.side}</span></td>
        <td class="mono">${t.amount !== null ? fmtNum(t.amount, 6) : '‚Äî'}</td>
        <td class="right mono">${t.priceUsd !== null ? fmtUSD(t.priceUsd) : '‚Äî'}</td>
        <td class="right mono">${t.usd !== null ? fmtUSD(t.usd) : '‚Äî'}</td>
        <td class="right mono muted ageCell">${t.tsSec ? timeAgo(t.tsSec) : '‚Äî'}</td>
        <td class="mono muted ellipsis" style="max-width:140px">${t.wallet ? escapeHtml(shortAddr(t.wallet)) : '‚Äî'}</td>
        <td class="center">${t.tx ? `<a class="linkPill" style="padding:6px 10px; display:inline-flex" href="${escapeHtml(txUrl)}" target="_blank" rel="noreferrer noopener">‚Üó</a>` : '‚Äî'}</td>
      `;
      el.tradesBody.prepend(tr);
    }

    function trimTrades(maxRows){
      while (el.tradesBody.children.length > maxRows){
        el.tradesBody.removeChild(el.tradesBody.lastElementChild);
      }
    }

    function growLastCandle(price, tradeTsSec){
      if (!state.series) return;
      if (isFinite(price)) applySeriesPrecision(price);
      const {sec} = tfToGT(state.tf);
      const t = isFinite(tradeTsSec) ? Math.floor(tradeTsSec) : nowSec();
      const bucket = Math.floor(t / sec) * sec;

      const last = state.lastCandle;
      if (!last){
        const c = {time: bucket, open: price, high: price, low: price, close: price};
        state.lastCandle = c;
        try{ state.series.update(c); }catch(e){}
        return;
      }

      if (bucket < last.time) return;

      if (bucket === last.time){
        const c = { time: last.time, open: last.open, high: Math.max(last.high, price), low: Math.min(last.low, price), close: price };
        state.lastCandle = c;
        try{ state.series.update(c); }catch(e){}
      } else {
        const prevClose = last.close;
        const c = { time: bucket, open: prevClose, high: Math.max(prevClose, price), low: Math.min(prevClose, price), close: price };
        state.lastCandle = c;
        try{ state.series.update(c); }catch(e){}
      }
    }

    // ========= Timeframe switching =========
    async function setTimeframe(tf){
      if (tf === state.tf) return;
      state.tf = tf;
      el.tfs.forEach(b => b.classList.toggle('active', b.dataset.tf === tf));

      if (!state.current){ el.chartMeta.textContent = '‚Äî'; return; }

      const sid = ++state.sessionId;
      if (state.abort) state.abort.abort();
      state.abort = new AbortController();
      const signal = state.abort.signal;

      stopLive();
      state.lastCandle = null;
      state.candles = [];
      setStatus('', 'Switching timeframe‚Ä¶');

      await loadCandles(state.current, tf, {sid, signal});
      if (sid !== state.sessionId) return;
      startLive(state.current, {sid});
    }

    // ========= Clear / Reset =========
    function clearAll(){
      stopLive();
      if (state.abort) state.abort.abort();
      state.abort = null;
      state.current = null;
      state.candles = [];
      state.lastCandle = null;
      state.lastTradeId = null;
      el.tradesBody.innerHTML = '';
      el.tradeCount.textContent = '0';
      el.btnDS.href = '#';
      showTokenView(false);
      setStatus('', 'Idle');
    }

    // ========= Settings Modal =========
    function openModal(){
      el.proxyUrl.value = settings.proxyUrl || '';
      el.birdeyeKey.value = settings.birdeyeKey || '';
      el.pollLive.textContent = (settings.pollLiveMs/1000).toFixed(1) + 's';
      el.pollHidden.textContent = Math.round(settings.pollHiddenMs/1000) + 's';
      el.modalBack.classList.add('show');
    }
    function closeModal(){ el.modalBack.classList.remove('show'); }
    function saveSettings(){
      settings.proxyUrl = (el.proxyUrl.value || '').trim();
      settings.birdeyeKey = (el.birdeyeKey.value || '').trim();
      try{ localStorage.setItem(LS.proxy, settings.proxyUrl); }catch(e){}
      try{ localStorage.setItem(LS.birdeye, settings.birdeyeKey); }catch(e){}
      closeModal();
      toast('Settings saved');
      loadTrending();
      if (state.current){ setTimeframe(state.tf); }
    }

    // ========= Events =========
    function setChain(chain, {silent=false}={}){
      if (chain === state.chain) return;
      state.chain = chain;
      el.tabs.forEach(t => {
        const on = t.dataset.chain === chain;
        t.classList.toggle('active', on);
        t.setAttribute('aria-selected', on ? 'true' : 'false');
      });
      clearResults();
      clearAll();
      if (!silent) loadTrending();
      else loadTrending();
    }

    el.tabs.forEach(btn => btn.addEventListener('click', () => setChain(btn.dataset.chain), {passive:true}));
    el.btnSearch.addEventListener('click', () => doSearch(true));
    el.q.addEventListener('input', debounceSearch);
    el.q.addEventListener('keydown', (e)=>{ if (e.key === 'Enter'){ e.preventDefault(); doSearch(true); }});
    el.tfs.forEach(b => b.addEventListener('click', ()=> setTimeframe(b.dataset.tf), {passive:true}));
    el.btnClear.addEventListener('click', ()=> { clearResults(); clearAll(); });
    el.btnSettings.addEventListener('click', openModal);
    el.btnCloseModal.addEventListener('click', closeModal);
    el.modalBack.addEventListener('click', (e)=> { if (e.target === el.modalBack) closeModal(); });
    el.btnSaveSettings.addEventListener('click', saveSettings);

    el.btnClearCache.addEventListener('click', ()=>{
      cacheClear();
      candleCache.clear();
      toast('Local cache cleared');
      loadTrending();
    });

    el.btnResetPolling.addEventListener('click', ()=>{
      settings.pollLiveMs = 2500;
      settings.pollHiddenMs = 12000;
      el.pollLive.textContent = (settings.pollLiveMs/1000).toFixed(1) + 's';
      el.pollHidden.textContent = Math.round(settings.pollHiddenMs/1000) + 's';
      toast('Polling reset');
      if (state.current){
        const sid = ++state.sessionId;
        startLive(state.current, {sid});
      }
    });

    // Global suppression for benign ResizeObserver warnings
    window.addEventListener('error', (e)=>{
      const msg = String(e?.message || '');
      if (msg.includes('ResizeObserver loop limit exceeded') || msg.includes('ResizeObserver loop completed with undelivered notifications')){
        e.preventDefault?.();
        return false;
      }
    }, true);

    // ========= Boot =========
    function boot(){
      setStatus('', 'Booting‚Ä¶');
      clearResults();
      showTokenView(false);
      loadTrending(); // auto-load trending
      setStatus('live', 'Ready');
    }
    boot();
  })();
</script>
</body>
</html>
