<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<meta name="theme-color" content="#070711"/>
<title>$SOS — Guardian Contract Scanner</title>

<style>
:root{
  --bg:#070711;
  --panel:rgba(255,255,255,.06);
  --stroke:rgba(255,255,255,.12);
  --text:rgba(255,255,255,.92);
  --muted:rgba(255,255,255,.70);
  --g:#14F195;
  --c:#00D1FF;
  --p:#9945FF;
  --radius:22px;
  --shadow:0 12px 32px rgba(0,0,0,.45);
  --max:1200px;
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  background:var(--bg);
  color:var(--text);
  font:15.5px/1.55 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;
  overflow-x:hidden;
}

body::before{
  content:"";
  position:fixed;
  inset:0;
  z-index:-1;
  background:
    radial-gradient(1200px 700px at 10% 5%, rgba(153,69,255,.22), transparent 60%),
    radial-gradient(1000px 650px at 90% 10%, rgba(20,241,149,.18), transparent 55%),
    radial-gradient(900px 600px at 70% 85%, rgba(0,209,255,.14), transparent 55%);
}

a{color:inherit;text-decoration:none}
.wrap{max-width:var(--max);margin:0 auto;padding:0 18px;width:100%}

.topbar{
  position:sticky;
  top:0;
  z-index:50;
  backdrop-filter:blur(14px);
  background:rgba(7,7,17,.65);
  border-bottom:1px solid rgba(255,255,255,.08);
}

.row{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  padding:12px 0;
  flex-wrap:wrap;
}

.brand{
  display:flex;
  align-items:center;
  gap:12px;
  font-weight:1000;
  letter-spacing:-.3px;
}

.actions{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}

.btn{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  padding:10px 16px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.06);
  font-weight:950;
  cursor:pointer;
}

.btn.grad{
  border:0;
  background:linear-gradient(90deg,var(--g),var(--c),var(--p));
  color:#061012;
}

.btn[disabled]{opacity:.5;pointer-events:none}

main{padding:22px 0 44px}

.card{
  background:linear-gradient(180deg,rgba(255,255,255,.07),rgba(255,255,255,.05));
  border:1px solid rgba(255,255,255,.10);
  border-radius:var(--radius);
  box-shadow:var(--shadow);
  margin-bottom:18px;
}

.inner{padding:22px}

.panel{
  border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.20);
  border-radius:18px;
  padding:16px;
}

label{
  display:block;
  font-weight:950;
  font-size:12.5px;
  margin-bottom:8px;
}

input{
  width:100%;
  padding:14px;
  border-radius:16px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(0,0,0,.22);
  color:var(--text);
  font-weight:900;
  font-size:16px;
}

.statusLine{
  margin-top:12px;
  font-weight:900;
  color:rgba(255,255,255,.72);
  min-height:18px;
}

.chainRow{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
  margin-bottom:12px;
}

.chainBtn{
  padding:10px 14px;
  border-radius:999px;
  border:1px solid rgba(255,255,255,.14);
  background:rgba(255,255,255,.06);
  font-weight:900;
  cursor:pointer;
}

.chainBtn.active{
  border:0;
  background:linear-gradient(90deg,var(--g),var(--c),var(--p));
  color:#061012;
}

.sectionTitle{
  font-weight:1000;
  font-size:18px;
  margin-bottom:12px;
}

.list{
  list-style:none;
  padding:0;
  margin:0;
  display:grid;
  gap:10px;
}

.li{
  border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.18);
  border-radius:16px;
  padding:12px;
  display:flex;
  justify-content:space-between;
  gap:10px;
}

canvas{
  width:100%;
  height:240px;
  border-radius:14px;
  background:rgba(0,0,0,.25);
}
</style>
</head>

<body>

<div class="topbar">
  <div class="wrap">
    <div class="row">
      <div class="brand">$SOS • Guardian Scanner</div>
      <div class="actions">
        <button class="btn grad" id="btnScan">Run Scan</button>
        <button class="btn grad" id="btnExport" disabled>Download Report</button>
      </div>
    </div>
  </div>
</div>

<main class="wrap">

<!-- INPUT -->
<div class="card">
  <div class="inner">
    <div class="panel">
      <label>Choose Chain</label>
      <div class="chainRow" id="chainRow"></div>

      <label for="addr">Token Address</label>
      <input id="addr" placeholder="Paste token address…"/>

      <button class="btn grad" id="btnScanInline" style="width:100%;margin-top:12px">
        Run Guardian Scan
      </button>

      <div class="statusLine" id="status"></div>
    </div>
  </div>
</div>

<!-- VERDICT / SCORE -->
<div class="card">
  <div class="inner">
    <div class="panel">
      <div class="sectionTitle">Verdict & Score</div>
      <div id="verdict"></div>
    </div>
  </div>
</div>

<!-- METRICS -->
<div class="card">
  <div class="inner">
    <div class="panel">
      <div class="sectionTitle">Metrics</div>
      <div id="metrics"></div>
    </div>
  </div>
</div>

<!-- CHECKS -->
<div class="card">
  <div class="inner">
    <div class="panel">
      <div class="sectionTitle">Guardian Checks</div>
      <ul class="list" id="checksList"></ul>
    </div>
  </div>
</div>

<!-- CLUSTERS / HOLDERS -->
<div class="card">
  <div class="inner">
    <div class="panel">
      <div class="sectionTitle">Top Holders & Clusters</div>
      <ul class="list" id="holdersList"></ul>
    </div>
  </div>
</div>

<!-- BUBBLE MAP -->
<div class="card">
  <div class="inner">
    <div class="panel">
      <div class="sectionTitle">Holder Bubble Map</div>
      <canvas id="bubbleCanvas" width="900" height="240"></canvas>
    </div>
  </div>
</div>

</main>

<!-- =====================================================
  CODE 2 / 10
  STATE • CHAINS • BUTTON BINDING (STABLE BASE)
===================================================== -->

<script>
/* =========================
   GLOBAL CONFIG
========================= */

const CFG = {
  CHAINS: [
    { id:"sol",  name:"Solana",   kind:"solana", placeholder:"Solana mint address (base58)" },
    { id:"eth",  name:"Ethereum", kind:"evm",    chainId:1,    placeholder:"ERC-20 contract (0x...)" },
    { id:"bnb",  name:"BNB",      kind:"evm",    chainId:56,   placeholder:"BEP-20 contract (0x...)" },
    { id:"base", name:"Base",     kind:"evm",    chainId:8453, placeholder:"Base token contract (0x...)" }
  ]
};

/* =========================
   GLOBAL STATE
========================= */

const STATE = {
  activeChain: CFG.CHAINS[0],
  scanning: false,
  completed: false,
  address: null,
  result: null
};

/* =========================
   DOM HELPERS
========================= */

const qs = (id)=>document.getElementById(id);

function setStatus(msg){
  const el = qs("status");
  if(el) el.textContent = msg || "";
}

function clearUI(){
  qs("verdict").innerHTML = "";
  qs("metrics").innerHTML = "";
  qs("checksList").innerHTML = "";
  qs("holdersList").innerHTML = "";
  const ctx = qs("bubbleCanvas").getContext("2d");
  ctx.clearRect(0,0,qs("bubbleCanvas").width,qs("bubbleCanvas").height);
  qs("btnExport").disabled = true;
}

/* =========================
   ADDRESS VALIDATION
========================= */

function looksBase58(v){
  return /^[1-9A-HJ-NP-Za-km-z]{32,52}$/.test(v);
}

function looksEvm(v){
  return /^0x[a-fA-F0-9]{40}$/.test(v);
}

/* =========================
   CHAIN UI
========================= */

function renderChains(){
  const row = qs("chainRow");
  row.innerHTML = "";

  CFG.CHAINS.forEach(c=>{
    const b = document.createElement("button");
    b.className = "chainBtn" + (c.id===STATE.activeChain.id ? " active" : "");
    b.textContent = c.name;
    b.onclick = ()=>{
      STATE.activeChain = c;
      renderChains();
      qs("addr").placeholder = c.placeholder;
      clearUI();
      setStatus(`Chain set to ${c.name}`);
    };
    row.appendChild(b);
  });
}

/* =========================
   BUTTON BINDING (ONCE)
========================= */

function bindButtons(){
  qs("btnScan").onclick = runScan;
  qs("btnScanInline").onclick = runScan;
  qs("btnExport").onclick = exportReport;
}

/* =========================
   MAIN SCAN ENTRY
========================= */

async function runScan(){
  if(STATE.scanning) return;

  const addr = qs("addr").value.trim();
  if(!addr){
    setStatus("Please enter a token address.");
    return;
  }

  if(STATE.activeChain.kind==="solana" && !looksBase58(addr)){
    setStatus("Invalid Solana mint address.");
    return;
  }

  if(STATE.activeChain.kind==="evm" && !looksEvm(addr)){
    setStatus("Invalid EVM address.");
    return;
  }

  STATE.scanning = true;
  STATE.completed = false;
  STATE.address = addr;
  STATE.result = null;

  clearUI();
  setStatus("Scanning on " + STATE.activeChain.name + "…");

  try{
    if(STATE.activeChain.kind==="solana"){
      STATE.result = await scanSolana(addr);
    }else{
      STATE.result = await scanEvm(STATE.activeChain, addr);
    }

    STATE.completed = true;
    renderAll();
    setStatus("Scan completed.");
    qs("btnExport").disabled = false;

  }catch(e){
    console.error(e);
    setStatus("Scan failed: " + e.message);
  }finally{
    STATE.scanning = false;
  }
}

/* =========================
   PLACEHOLDER RENDER
   (REAL LOGIC COMES NEXT)
========================= */

function renderAll(){
  renderVerdict();
  renderMetrics();
  renderChecks();
  renderHolders();
  renderBubble();
}

/* =========================
   BASIC RENDER STUBS
========================= */

function renderVerdict(){
  qs("verdict").innerHTML =
    `<div style="font-weight:1000;font-size:22px">SCAN OK</div>`;
}

function renderMetrics(){
  qs("metrics").innerHTML =
    `<div class="panel">Metrics will be populated</div>`;
}

function renderChecks(){
  qs("checksList").innerHTML =
    `<li class="li"><div>Checks will be populated</div></li>`;
}

function renderHolders(){
  qs("holdersList").innerHTML =
    `<li class="li"><div>Holders & clusters will be populated</div></li>`;
}

function renderBubble(){
  const c = qs("bubbleCanvas");
  const ctx = c.getContext("2d");
  ctx.clearRect(0,0,c.width,c.height);
  ctx.fillStyle="rgba(255,255,255,.15)";
  ctx.beginPath();
  ctx.arc(120,120,50,0,Math.PI*2);
  ctx.fill();
}

/* =========================
   EXPORT PLACEHOLDER
========================= */

function exportReport(){
  if(!STATE.completed){
    alert("No scan to export");
    return;
  }
  alert("Report export will be implemented in later code.");
}

/* =========================
   INIT
========================= */

function init(){
  renderChains();
  bindButtons();
  qs("addr").placeholder = STATE.activeChain.placeholder;
  setStatus("Ready.");
}

if(document.readyState==="loading"){
  document.addEventListener("DOMContentLoaded",init);
}else{
  init();
}
</script>

<!-- =====================================================
  CODE 3 / 10
  SOLANA SCAN ENGINE
  - Mint / Freeze Authority
  - Supply / Decimals
  - Largest Holders
  - Cluster-Grundlage
===================================================== -->

<script>
/* =========================
   SOLANA RPC (HELIUS)
========================= */

const HELIUS_API_KEY = "PUT_YOUR_HELIUS_KEY_HERE";
const SOLANA_RPC = `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`;

async function solRpc(method, params){
  const res = await fetch(SOLANA_RPC,{
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body:JSON.stringify({
      jsonrpc:"2.0",
      id:1,
      method,
      params
    })
  });
  const json = await res.json();
  if(json.error) throw new Error(json.error.message);
  return json.result;
}

/* =========================
   SOLANA SCAN CORE
========================= */

async function scanSolana(mint){

  /* --- Mint account --- */
  const mintInfo = await solRpc("getParsedAccountInfo",[
    mint,
    { commitment:"confirmed" }
  ]);

  const info = mintInfo?.value?.data?.parsed?.info;
  if(!info) throw new Error("Invalid Solana mint");

  const mintAuthority   = info.mintAuthority || null;
  const freezeAuthority = info.freezeAuthority || null;
  const decimals        = info.decimals;
  const supplyRaw       = BigInt(info.supply || "0");
  const supplyUi        = Number(supplyRaw) / (10 ** decimals);

  /* --- Largest token accounts --- */
  const largest = await solRpc("getTokenLargestAccounts",[mint]);
  const accounts = largest?.value || [];

  const holders = accounts.map(a=>{
    const raw = BigInt(a.amount || "0");
    const pct = supplyRaw > 0n
      ? Number((raw * 10000n) / supplyRaw) / 100
      : 0;
    return {
      wallet: a.address,
      raw,
      pct
    };
  }).sort((a,b)=>b.pct - a.pct);

  /* --- Cluster prep (wallet-only graph) --- */
  const clusters = {
    enabled: true,
    wallets: holders.map(h=>h.wallet),
    clusteredPctWallets: holders.length ? 100 : 0,
    largestClusterPctHold: holders[0]?.pct || 0,
    graphMeta:{
      nodes: holders.length,
      edges: 0
    },
    clustersTop: holders.slice(0,3).map(h=>({
      walletCount: 1,
      holdPct: h.pct
    }))
  };

  return {
    chain:"solana",
    meta:{
      name:"Solana Token",
      symbol:"",
      image:""
    },
    signals:{
      mintAuthorityActive: !!mintAuthority,
      freezeAuthorityActive: !!freezeAuthority,
      decimals,
      supplyUi,
      topHolderPct: holders[0]?.pct || 0
    },
    holders,
    clusters
  };
}

/* =========================
   SOLANA RENDER EXTENSIONS
========================= */

function renderSolanaChecks(result){
  const list = qs("checksList");
  list.innerHTML = "";

  const add = (title, ok, desc)=>{
    const li = document.createElement("li");
    li.className = "li";
    li.innerHTML = `
      <div>
        <strong>${title}</strong><br>
        <span>${desc}</span>
      </div>
      <div>${ok ? "✅" : "⚠️"}</div>
    `;
    list.appendChild(li);
  };

  add(
    "Mint Authority",
    !result.signals.mintAuthorityActive,
    result.signals.mintAuthorityActive
      ? "Mint authority is still active (supply can increase)."
      : "Mint authority revoked."
  );

  add(
    "Freeze Authority",
    !result.signals.freezeAuthorityActive,
    result.signals.freezeAuthorityActive
      ? "Freeze authority active (accounts can be frozen)."
      : "Freeze authority revoked."
  );

  add(
    "Top Holder",
    result.signals.topHolderPct < 20,
    `Largest holder owns ~${result.signals.topHolderPct.toFixed(2)}%`
  );
}

/* =========================
   SOLANA HOLDER RENDER
========================= */

function renderSolanaHolders(result){
  const list = qs("holdersList");
  list.innerHTML = "";

  result.holders.slice(0,10).forEach((h,i)=>{
    const li = document.createElement("li");
    li.className = "li";
    li.innerHTML = `
      <div>#${i+1} ${h.wallet}</div>
      <div>${h.pct.toFixed(2)}%</div>
    `;
    list.appendChild(li);
  });
}

/* =========================
   SOLANA BUBBLE MAP
========================= */

function renderSolanaBubble(result){
  const canvas = qs("bubbleCanvas");
  const ctx = canvas.getContext("2d");
  ctx.clearRect(0,0,canvas.width,canvas.height);

  const max = Math.max(...result.holders.map(h=>h.pct),1);
  const cx = canvas.width/2;
  const cy = canvas.height/2;

  result.holders.slice(0,8).forEach((h,i)=>{
    const r = 20 + (h.pct/max)*60;
    const angle = i * (Math.PI*2/result.holders.length);
    const x = cx + Math.cos(angle)*120;
    const y = cy + Math.sin(angle)*60;

    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fillStyle="rgba(20,241,149,.25)";
    ctx.fill();

    ctx.fillStyle="#fff";
    ctx.font="12px monospace";
    ctx.fillText(h.pct.toFixed(1)+"%",x-14,y+4);
  });
}

/* =========================
   SOLANA RESULT PIPE
========================= */

function applySolanaResult(result){
  renderSolanaChecks(result);
  renderSolanaHolders(result);
  renderSolanaBubble(result);
}
</script>

<!-- =====================================================
  CODE 4 / 10
  EVM SCAN ENGINE
  - Ethereum / BNB / Base
  - ERC-20 metadata
  - Owner / Renounced
  - Proxy detection (EIP-1967)
  - Holders (indexer-ready)
  - Cluster foundation
===================================================== -->

<script>
/* =========================
   EVM RPC CONFIG
========================= */

const EVM_RPCS = {
  1:    ["https://cloudflare-eth.com","https://ethereum.publicnode.com"],
  56:   ["https://bsc.publicnode.com","https://rpc.ankr.com/bsc"],
  8453: ["https://mainnet.base.org","https://base.publicnode.com"]
};

const ERC20_SIG = {
  name:"0x06fdde03",
  symbol:"0x95d89b41",
  decimals:"0x313ce567",
  totalSupply:"0x18160ddd",
  owner:"0x8da5cb5b"
};

const EIP1967_IMPL =
  "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";

/* =========================
   LOW LEVEL HELPERS
========================= */

async function evmRpc(rpc, method, params){
  const res = await fetch(rpc,{
    method:"POST",
    headers:{ "Content-Type":"application/json" },
    body:JSON.stringify({ jsonrpc:"2.0", id:1, method, params })
  });
  const json = await res.json();
  if(json.error) throw new Error(json.error.message);
  return json.result;
}

async function evmCall(chainId, call){
  const rpcs = EVM_RPCS[chainId] || [];
  for(const rpc of rpcs){
    try{
      return await evmRpc(rpc,"eth_call",[call,"latest"]);
    }catch{}
  }
  throw new Error("All RPCs failed");
}

async function evmGetCode(chainId, addr){
  const rpcs = EVM_RPCS[chainId] || [];
  for(const rpc of rpcs){
    try{
      return await evmRpc(rpc,"eth_getCode",[addr,"latest"]);
    }catch{}
  }
  throw new Error("All RPCs failed");
}

function hexToBigInt(x){
  try{ return BigInt(x); }catch{ return null; }
}

/* =========================
   EVM SCAN CORE
========================= */

async function scanEvm(chain, addr){
  const chainId = chain.chainId;

  /* --- Code check --- */
  const code = await evmGetCode(chainId, addr);
  const hasCode = code && code !== "0x";

  if(!hasCode) throw new Error("No contract code at address");

  /* --- ERC-20 calls --- */
  let name=null, symbol=null, decimals=null, totalSupply=null;

  try{ name = await evmCall(chainId,{to:addr,data:ERC20_SIG.name}); }catch{}
  try{ symbol = await evmCall(chainId,{to:addr,data:ERC20_SIG.symbol}); }catch{}
  try{ decimals = Number(hexToBigInt(await evmCall(chainId,{to:addr,data:ERC20_SIG.decimals}))); }catch{}
  try{ totalSupply = hexToBigInt(await evmCall(chainId,{to:addr,data:ERC20_SIG.totalSupply})); }catch{}

  const supplyUi =
    totalSupply && Number.isFinite(decimals)
      ? Number(totalSupply / (10n ** BigInt(decimals)))
      : null;

  /* --- Owner / Renounced --- */
  let owner = null;
  try{
    owner = await evmCall(chainId,{to:addr,data:ERC20_SIG.owner});
  }catch{}

  const ownerAddr = owner && owner !== "0x"
    ? "0x" + owner.slice(-40)
    : null;

  const renounced =
    !ownerAddr ||
    ownerAddr === "0x0000000000000000000000000000000000000000";

  /* --- Proxy detection (EIP-1967) --- */
  let proxyImpl = null;
  try{
    const impl = await evmRpc(
      EVM_RPCS[chainId][0],
      "eth_getStorageAt",
      [addr, EIP1967_IMPL, "latest"]
    );
    if(impl && impl !== "0x"){
      proxyImpl = "0x" + impl.slice(-40);
    }
  }catch{}

  /* --- Holders placeholder (indexer later) --- */
  const holders = [];
  const clusters = {
    enabled:false,
    clusteredPctWallets:0,
    largestClusterPctHold:0,
    graphMeta:{nodes:0,edges:0},
    clustersTop:[]
  };

  return {
    chain:"evm",
    meta:{
      name:name ? name.replace(/\0/g,"") : "Token",
      symbol:symbol ? symbol.replace(/\0/g,"") : "",
      image:""
    },
    signals:{
      hasCode:true,
      decimals,
      supplyUi,
      owner:ownerAddr,
      renounced,
      proxy:!!proxyImpl,
      proxyImpl
    },
    holders,
    clusters
  };
}

/* =========================
   EVM RENDER EXTENSIONS
========================= */

function renderEvmChecks(result){
  const list = qs("checksList");
  list.innerHTML = "";

  const add = (title, ok, desc)=>{
    const li = document.createElement("li");
    li.className = "li";
    li.innerHTML = `
      <div>
        <strong>${title}</strong><br>
        <span>${desc}</span>
      </div>
      <div>${ok ? "✅" : "⚠️"}</div>
    `;
    list.appendChild(li);
  };

  add(
    "Contract Code",
    true,
    "Contract bytecode present"
  );

  add(
    "Ownership",
    result.signals.renounced,
    result.signals.renounced
      ? "Ownership renounced"
      : `Owner: ${result.signals.owner}`
  );

  add(
    "Proxy",
    !result.signals.proxy,
    result.signals.proxy
      ? `Proxy detected → ${result.signals.proxyImpl}`
      : "No proxy detected"
  );
}

/* =========================
   EVM RESULT PIPE
========================= */

function applyEvmResult(result){
  renderEvmChecks(result);

  qs("holdersList").innerHTML =
    `<li class="li"><div>EVM holders via indexer in next code</div></li>`;

  const ctx = qs("bubbleCanvas").getContext("2d");
  ctx.clearRect(0,0,qs("bubbleCanvas").width,qs("bubbleCanvas").height);
}
</script>

<!-- =====================================================
  CODE 5 / 10
  SCORE ENGINE • VERDICT • GUARDIAN LOGIC
  - Approved / Observed / Flagged
  - Cross-chain rules
===================================================== -->

<script>
/* =========================
   SCORE CALCULATION
========================= */

function calculateScore(result){
  let score = 100;
  let critical = false;

  if(result.chain === "solana"){
    if(result.signals.mintAuthorityActive){
      score -= 35;
      critical = true;
    }
    if(result.signals.freezeAuthorityActive){
      score -= 15;
    }
    if(result.signals.topHolderPct >= 35){
      score -= 30;
      critical = true;
    }else if(result.signals.topHolderPct >= 20){
      score -= 18;
    }else if(result.signals.topHolderPct >= 10){
      score -= 8;
    }
  }

  if(result.chain === "evm"){
    if(!result.signals.hasCode){
      score = 0;
      critical = true;
    }
    if(!result.signals.renounced){
      score -= 25;
    }
    if(result.signals.proxy){
      score -= 15;
    }
  }

  score = Math.max(0, Math.min(100, Math.round(score)));
  return { score, critical };
}

/* =========================
   VERDICT LOGIC
========================= */

function getVerdict(score, critical){
  if(critical){
    return {
      label:"FLAGGED",
      color:"#ff6b81",
      text:"FLAGGED • High Risk"
    };
  }
  if(score >= 80){
    return {
      label:"APPROVED",
      color:"#14F195",
      text:"APPROVED • Guardian Passed"
    };
  }
  if(score >= 50){
    return {
      label:"OBSERVED",
      color:"#ffd166",
      text:"OBSERVED • Mixed Signals"
    };
  }
  return {
    label:"FLAGGED",
    color:"#ff6b81",
    text:"FLAGGED • High Risk"
  };
}

/* =========================
   VERDICT RENDER
========================= */

function renderVerdict(){
  const res = STATE.result;
  if(!res) return;

  const { score, critical } = calculateScore(res);
  const verdict = getVerdict(score, critical);

  const el = qs("verdict");
  el.innerHTML = `
    <div style="display:flex;align-items:center;gap:16px;flex-wrap:wrap">
      <div style="
        padding:10px 16px;
        border-radius:999px;
        background:${verdict.color};
        color:#061012;
        font-weight:1000;
      ">
        ${verdict.label}
      </div>
      <div style="font-size:22px;font-weight:1000">
        ${score}/100
      </div>
    </div>
    <div style="margin-top:10px;font-weight:900;color:rgba(255,255,255,.75)">
      ${verdict.text}
    </div>
  `;
}

/* =========================
   METRICS RENDER
========================= */

function renderMetrics(){
  const res = STATE.result;
  if(!res) return;

  const m = qs("metrics");
  m.innerHTML = "";

  const add = (label, value)=>{
    const d = document.createElement("div");
    d.className = "li";
    d.innerHTML = `<div>${label}</div><div>${value}</div>`;
    m.appendChild(d);
  };

  if(res.chain === "solana"){
    add("Supply", res.signals.supplyUi.toLocaleString());
    add("Mint Authority", res.signals.mintAuthorityActive ? "ACTIVE" : "REVOKED");
    add("Freeze Authority", res.signals.freezeAuthorityActive ? "ACTIVE" : "REVOKED");
    add("Top Holder", res.signals.topHolderPct.toFixed(2)+"%");
  }

  if(res.chain === "evm"){
    add("Supply", res.signals.supplyUi ?? "—");
    add("Decimals", res.signals.decimals ?? "—");
    add("Owner", res.signals.renounced ? "RENOUNCED" : res.signals.owner);
    add("Proxy", res.signals.proxy ? "YES" : "NO");
  }
}

/* =========================
   GLOBAL RESULT PIPE UPDATE
========================= */

function renderAll(){
  renderVerdict();
  renderMetrics();

  if(STATE.result.chain === "solana"){
    applySolanaResult(STATE.result);
  }

  if(STATE.result.chain === "evm"){
    applyEvmResult(STATE.result);
  }
}
</script>

<!-- =====================================================
  CODE 6 / 10
  HOLDERS • CLUSTER DETECTION • BUBBLE MAP
  - Wallet clustering (heuristic)
  - Largest cluster %
  - Bubble visualization
===================================================== -->

<script>
/* =========================
   HOLDERS NORMALIZATION
========================= */

function normalizeHolders(raw){
  if(!Array.isArray(raw)) return [];
  return raw
    .filter(h => h.wallet && typeof h.pct === "number")
    .sort((a,b)=>b.pct-a.pct)
    .slice(0, 25);
}

/* =========================
   CLUSTER HEURISTIC
   (simple but stable)
========================= */

function buildClusters(holders){
  const clusters = [];
  const visited = new Set();

  holders.forEach(h=>{
    if(visited.has(h.wallet)) return;

    const cluster = {
      wallets: [h.wallet],
      totalPct: h.pct
    };
    visited.add(h.wallet);

    holders.forEach(o=>{
      if(visited.has(o.wallet)) return;

      // heuristic: very close percentages → likely linked
      if(Math.abs(o.pct - h.pct) <= 0.35){
        cluster.wallets.push(o.wallet);
        cluster.totalPct += o.pct;
        visited.add(o.wallet);
      }
    });

    clusters.push(cluster);
  });

  return clusters.sort((a,b)=>b.totalPct - a.totalPct);
}

/* =========================
   CLUSTER SUMMARY
========================= */

function summarizeClusters(clusters){
  if(!clusters.length){
    return {
      clusterCount: 0,
      largestClusterPct: 0,
      largestClusterWallets: []
    };
  }

  const largest = clusters[0];
  return {
    clusterCount: clusters.length,
    largestClusterPct: Number(largest.totalPct.toFixed(2)),
    largestClusterWallets: largest.wallets
  };
}

/* =========================
   APPLY CLUSTER DATA
========================= */

function applyClusters(holders){
  const clusters = buildClusters(holders);
  const summary = summarizeClusters(clusters);

  STATE.clusters = {
    clusters,
    summary
  };

  const el = qs("clusters");
  if(!el) return;

  el.innerHTML = `
    <div class="li">
      <div>
        <strong>Total clusters</strong><br>
        ${summary.clusterCount}
      </div>
      <div>
        <strong>Largest cluster</strong><br>
        ${summary.largestClusterPct}%
      </div>
    </div>
    <div class="li">
      <div>
        <strong>Cluster wallets</strong><br>
        ${summary.largestClusterWallets.slice(0,5).map(w=>short(w)).join("<br>")}
      </div>
    </div>
  `;
}

/* =========================
   BUBBLE MAP
========================= */

function drawBubbleMap(holders){
  const canvas = qs("bubbleCanvas");
  if(!canvas) return;

  const ctx = canvas.getContext("2d");
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();

  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);

  ctx.clearRect(0,0,rect.width,rect.height);

  const maxPct = Math.max(...holders.map(h=>h.pct), 1);
  const centerX = rect.width / 2;
  const centerY = rect.height / 2;

  const placed = [];

  function collides(x,y,r){
    return placed.some(p=>{
      const dx = x - p.x;
      const dy = y - p.y;
      return Math.sqrt(dx*dx + dy*dy) < r + p.r + 6;
    });
  }

  holders.forEach((h,i)=>{
    const r = 10 + (h.pct / maxPct) * 45;
    let angle = i * 0.7;
    let radius = 0;
    let x,y;

    for(let t=0;t<400;t++){
      radius += 0.8;
      angle += 0.35;
      x = centerX + Math.cos(angle)*radius;
      y = centerY + Math.sin(angle)*radius;
      if(!collides(x,y,r)) break;
    }

    placed.push({x,y,r,pct:h.pct});

    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fillStyle = "rgba(20,241,149,.18)";
    ctx.fill();
    ctx.strokeStyle = "rgba(20,241,149,.55)";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.fillStyle = "rgba(255,255,255,.9)";
    ctx.font = "bold 12px system-ui";
    ctx.textAlign = "center";
    ctx.fillText(h.pct.toFixed(1)+"%", x, y+4);
  });

  try{
    window.__BUBBLE_MAP_DATA_URL = canvas.toDataURL("image/png");
  }catch{
    window.__BUBBLE_MAP_DATA_URL = "";
  }
}

/* =========================
   HOLDERS PIPE
========================= */

function renderHoldersPipeline(rawHolders){
  const holders = normalizeHolders(rawHolders);

  // list
  const list = qs("holders");
  if(list){
    list.innerHTML = "";
    holders.forEach(h=>{
      const li = document.createElement("div");
      li.className = "li";
      li.innerHTML = `
        <div>${short(h.wallet)}</div>
        <div>${h.pct.toFixed(2)}%</div>
      `;
      list.appendChild(li);
    });
  }

  // clusters
  applyClusters(holders);

  // bubble
  drawBubbleMap(holders);
}

/* =========================
   PIPE INTO MAIN RENDER
========================= */

function applySolanaResult(res){
  renderHoldersPipeline(res.holders || []);
}

function applyEvmResult(res){
  renderHoldersPipeline(res.holders || []);
}
</script>
<!-- =====================================================
  CODE 7 / 10
  STABILITY PATCH + PIPELINE MERGE + GOLD RUSH HOLDERS (EVM)
  - NO changes needed in Code 1–6
  - Fixes: missing short(), wrong IDs (holders/clusters), duplicate overrides,
           bubble canvas scaling, EVM holders via GoldRush, stable UI updates
===================================================== -->

<script>
/* =========================
   KEYS (from you)
========================= */
(function injectKeys(){
  // If your earlier code uses placeholders, we patch them safely.
  try{
    if(typeof HELIUS_API_KEY !== "undefined"){
      if(!HELIUS_API_KEY || HELIUS_API_KEY === "PUT_YOUR_HELIUS_KEY_HERE"){
        window.HELIUS_API_KEY = "b566a086-57d4-4433-8661-faed9ad07ba0";
      }
    }else{
      window.HELIUS_API_KEY = "b566a086-57d4-4433-8661-faed9ad07ba0";
    }
  }catch{}

  // GoldRush key (Covalent)
  window.GOLDRUSH_API_KEY = "cqt_rQVTMTXwYkPJBrwf7ff6JWmdkywR";
})();

/* =========================
   GLOBAL SAFE HELPERS
========================= */
(function globalSafety(){
  // short() was referenced but never defined in your code 6 -> hard crash.
  if(typeof window.short !== "function"){
    window.short = function short(addr){
      const a = String(addr || "");
      if(!a) return "—";
      if(a.startsWith("0x") && a.length > 10) return a.slice(0,6) + "…" + a.slice(-4);
      if(a.length > 12) return a.slice(0,6) + "…" + a.slice(-4);
      return a;
    };
  }

  // Safe qs (if ever missing)
  if(typeof window.qs !== "function"){
    window.qs = (id)=>document.getElementById(id);
  }

  // Safe status
  if(typeof window.setStatus !== "function"){
    window.setStatus = (msg)=>{ const el = qs("status"); if(el) el.textContent = msg || ""; };
  }
})();

/* =========================
   FIX: Canvas scaling (no accumulating transforms)
========================= */
(function patchBubbleScaling(){
  // Replace drawBubbleMap with a safer version (same name, but stable)
  window.drawBubbleMap = function drawBubbleMap(holders){
    const canvas = qs("bubbleCanvas");
    if(!canvas) return;

    const ctx = canvas.getContext("2d");
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);

    // Resize internal buffer
    canvas.width  = Math.max(1, Math.floor(rect.width  * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));

    // IMPORTANT: reset transform each time (prevents "zooming away")
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);

    // Clear
    ctx.clearRect(0,0,rect.width,rect.height);

    const list = Array.isArray(holders) ? holders.slice(0, 20) : [];
    if(!list.length){
      // Keep png empty
      try{ window.__BUBBLE_MAP_DATA_URL = ""; }catch{}
      return;
    }

    // subtle grid
    ctx.globalAlpha = 0.25;
    for(let x=0;x<rect.width;x+=48){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,rect.height);
      ctx.strokeStyle = "rgba(255,255,255,.08)";
      ctx.stroke();
    }
    for(let y=0;y<rect.height;y+=48){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(rect.width,y);
      ctx.strokeStyle = "rgba(255,255,255,.08)";
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    const maxPct = Math.max(...list.map(h=>Number(h.pct||0)), 1);
    const cx = rect.width/2;
    const cy = rect.height/2;

    const placed = [];
    const pad = 6;

    function collides(x,y,r){
      for(const p of placed){
        const dx = x - p.x;
        const dy = y - p.y;
        if(Math.sqrt(dx*dx + dy*dy) < r + p.r + pad) return true;
      }
      return false;
    }

    list.forEach((h,i)=>{
      const pct = Number(h.pct||0);
      const r = 10 + (pct / maxPct) * 45;

      let angle = i * 0.7;
      let rad = 0;
      let x = cx, y = cy;

      for(let t=0;t<700;t++){
        rad += 0.8;
        angle += 0.35;
        x = cx + Math.cos(angle)*rad;
        y = cy + Math.sin(angle)*rad;

        if(x-r<8 || x+r>rect.width-8 || y-r<8 || y+r>rect.height-8) continue;
        if(!collides(x,y,r)) break;
      }

      placed.push({x,y,r,pct,label: window.short(h.wallet)});

      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fillStyle = "rgba(20,241,149,.16)";
      ctx.fill();
      ctx.strokeStyle = "rgba(20,241,149,.55)";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.fillStyle = "rgba(255,255,255,.90)";
      ctx.font = "900 12px system-ui";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(pct.toFixed(1)+"%", x, y-6);

      ctx.fillStyle = "rgba(255,255,255,.60)";
      ctx.font = "800 10px ui-monospace, Menlo, Consolas, monospace";
      ctx.fillText(window.short(h.wallet), x, y+10);
    });

    // Store PNG for export
    try{
      window.__BUBBLE_MAP_DATA_URL = canvas.toDataURL("image/png");
    }catch{
      window.__BUBBLE_MAP_DATA_URL = "";
    }
  };

  // Re-draw bubble on resize if we have last holders
  window.addEventListener("resize", ()=>{
    try{
      const last = window.__LAST_HOLDERS_FOR_BUBBLE || [];
      if(last.length) window.drawBubbleMap(last);
    }catch{}
  }, {passive:true});
})();

/* =========================
   FIX: Render into existing HTML IDs (holdersList)
   - Your Code 6 used ids "holders" and "clusters" which DO NOT exist.
   - We re-route pipeline to #holdersList without changing HTML.
========================= */
(function patchHoldersPipeline(){
  function renderHoldersListToUI(holders, clustersSummary){
    const listEl = qs("holdersList");
    if(!listEl) return;

    listEl.innerHTML = "";

    // 1) Cluster summary card (inside holdersList, no new IDs)
    if(clustersSummary){
      const li = document.createElement("li");
      li.className = "li";
      li.innerHTML = `
        <div>
          <strong>Clusters (heuristic)</strong><br>
          Total clusters: ${clustersSummary.clusterCount}<br>
          Largest cluster: ${clustersSummary.largestClusterPct}%
        </div>
        <div style="text-align:right">
          <strong>Top wallets</strong><br>
          ${clustersSummary.largestClusterWallets.slice(0,5).map(w=>window.short(w)).join("<br>")}
        </div>
      `;
      listEl.appendChild(li);
    }

    // 2) Holder rows
    holders.slice(0, 15).forEach((h,i)=>{
      const li = document.createElement("li");
      li.className = "li";
      li.innerHTML = `
        <div>#${i+1} ${window.short(h.wallet)}</div>
        <div>${Number(h.pct||0).toFixed(2)}%</div>
      `;
      listEl.appendChild(li);
    });

    if(!holders.length){
      const li = document.createElement("li");
      li.className = "li";
      li.innerHTML = `<div>No holder data available.</div><div>—</div>`;
      listEl.appendChild(li);
    }
  }

  // Patch renderHoldersPipeline to target holdersList and bubble
  window.renderHoldersPipeline = function renderHoldersPipeline(rawHolders){
    const holders = (Array.isArray(rawHolders) ? rawHolders : [])
      .filter(h => h && h.wallet && typeof h.pct === "number")
      .sort((a,b)=>b.pct-a.pct)
      .slice(0, 25);

    // clusters from your Code 6 logic (reuse if exists)
    let clustersSummary = null;
    try{
      const clusters = (typeof buildClusters === "function") ? buildClusters(holders) : [];
      clustersSummary = (typeof summarizeClusters === "function") ? summarizeClusters(clusters) : null;

      // store on STATE if available
      try{
        if(typeof STATE === "object"){
          STATE.clusters = { clusters, summary: clustersSummary };
        }
      }catch{}
    }catch{
      clustersSummary = null;
    }

    // Render list + cluster info into holdersList
    renderHoldersListToUI(holders, clustersSummary);

    // Bubble
    window.__LAST_HOLDERS_FOR_BUBBLE = holders;
    window.drawBubbleMap(holders);
  };
})();

/* =========================
   EVM HOLDERS via GoldRush (Covalent)
   - RPC can't enumerate holders, so we use the indexer
   - If it fails, we still keep scan alive and show a friendly note
========================= */
async function fetchGoldrushTopHolders(chainId, tokenAddr){
  const key = window.GOLDRUSH_API_KEY || "";
  if(!key) return [];

  const url = `https://api.covalenthq.com/v1/${chainId}/tokens/${tokenAddr}/token_holders/?page-size=25&key=${encodeURIComponent(key)}`;
  const r = await fetch(url);
  const j = await r.json();

  const items = j?.data?.items || [];
  return items.map(x=>({
    wallet: x.address,
    balance: BigInt(x.balance || "0")
  }));
}

// helper to compute pct from balances
function withPctFromTotal(raw, totalSupplyRaw){
  const ts = (typeof totalSupplyRaw === "bigint") ? totalSupplyRaw : null;
  if(!ts || ts <= 0n) return [];
  return raw.map(h=>{
    const b = (typeof h.balance === "bigint") ? h.balance : 0n;
    const pct = Number((b * 10000n) / ts) / 100;
    return { wallet: h.wallet, pct };
  }).sort((a,b)=>b.pct-a.pct);
}

/* =========================
   PATCH: scanEvm to append holders (non-breaking)
   - We DO NOT edit your Code 4; we wrap it.
========================= */
(function wrapScanEvm(){
  if(typeof window.scanEvm !== "function") return;

  const orig = window.scanEvm;
  window.scanEvm = async function scanEvmWrapped(chain, addr){
    const res = await orig(chain, addr);

    // Try to add holders via GoldRush if totalSupply exists
    try{
      // Your Code 4: totalSupply not returned in result; only supplyUi and decimals.
      // We'll best-effort re-call totalSupply (selector) to get raw total supply.
      const chainId = chain.chainId;
      let totalSupplyRaw = null;

      try{
        // reuse evmCall if present
        if(typeof evmCall === "function" && typeof ERC20_SIG === "object"){
          const tsHex = await evmCall(chainId, { to: addr, data: ERC20_SIG.totalSupply });
          totalSupplyRaw = (typeof hexToBigInt === "function") ? hexToBigInt(tsHex) : null;
        }
      }catch{}

      if(totalSupplyRaw && window.GOLDRUSH_API_KEY){
        const raw = await fetchGoldrushTopHolders(chainId, addr);
        const holders = withPctFromTotal(raw, totalSupplyRaw).slice(0, 25);
        res.holders = holders;
      }
    }catch{
      // ignore holder failures completely
    }

    return res;
  };
})();

/* =========================
   PIPELINE MERGE:
   - Your Code 3 defined applySolanaResult
   - Your Code 4 defined applyEvmResult
   - Your Code 6 overwrote them AGAIN (problem)
   We wrap the *current* ones and then run renderHoldersPipeline()
========================= */
(function mergeApplyPipelines(){
  function wrapApply(name){
    const fn = window[name];
    if(typeof fn !== "function") return;

    window[name] = function wrappedApply(res){
      // Call existing behavior first (checks etc.)
      try{ fn(res); }catch(e){ console.warn(name+" base failed:", e); }

      // Then unify holders+clusters+bubble pipeline (stable)
      try{
        const holders = Array.isArray(res?.holders) ? res.holders : [];
        window.renderHoldersPipeline(holders);
      }catch(e){
        console.warn(name+" holders pipeline failed:", e);
      }
    };
  }

  wrapApply("applySolanaResult");
  wrapApply("applyEvmResult");
})();

/* =========================
   FIX: runScan should call renderAll after scan
   - In your Code 2 it already does.
   - But we ensure renderAll exists and is callable.
========================= */
(function ensureRenderAll(){
  if(typeof window.renderAll !== "function"){
    window.renderAll = function(){
      try{ if(typeof renderVerdict==="function") renderVerdict(); }catch{}
      try{ if(typeof renderMetrics==="function") renderMetrics(); }catch{}
      try{
        if(window.STATE?.result?.chain === "solana" && typeof applySolanaResult==="function"){
          applySolanaResult(window.STATE.result);
        }
        if(window.STATE?.result?.chain === "evm" && typeof applyEvmResult==="function"){
          applyEvmResult(window.STATE.result);
        }
      }catch{}
    };
  }
})();

/* =========================
   VISUAL: show something for EVM holders if empty
========================= */
(function evmEmptyNote(){
  const oldApplyEvm = window.applyEvmResult;
  if(typeof oldApplyEvm !== "function") return;

  window.applyEvmResult = function(res){
    try{ oldApplyEvm(res); }catch{}

    try{
      const holders = Array.isArray(res?.holders) ? res.holders : [];
      if(!holders.length){
        const listEl = qs("holdersList");
        if(listEl && !listEl.innerHTML.trim()){
          const li = document.createElement("li");
          li.className = "li";
          li.innerHTML = `
            <div>
              <strong>No EVM holder list returned</strong><br>
              GoldRush may be rate-limited or token not indexed yet.
            </div>
            <div>ℹ️</div>
          `;
          listEl.appendChild(li);
        }
      }
    }catch{}
  };
})();

/* =========================
   FINAL: make buttons "definitely alive" (no harm)
========================= */
(function hardenButtons(){
  function safeBind(id, fn){
    const el = qs(id);
    if(!el) return;
    el.onclick = null;
    el.addEventListener("click", (e)=>{
      e.preventDefault();
      fn();
    });
  }

  if(typeof window.runScan === "function"){
    safeBind("btnScan", window.runScan);
    safeBind("btnScanInline", window.runScan);
  }

  if(typeof window.exportReport === "function"){
    safeBind("btnExport", window.exportReport);
  }

  // Enter key triggers scan
  const input = qs("addr");
  if(input && typeof window.runScan === "function"){
    input.addEventListener("keydown",(e)=>{
      if(e.key === "Enter"){
        e.preventDefault();
        window.runScan();
      }
    });
  }
})();

/* =========================
   READY MESSAGE
========================= */
try{
  setStatus("Patch loaded. Buttons + holders + bubble stabilized.");
}catch{}
</script>
<!-- =====================================================
  CODE 8 / 10
  SOLANA RPC HOTFIX (HELIUS KEY REALLY USED) + REPORT EXPORT (HTML DOWNLOAD)
  - NO edits required in Code 1–7
  - Fix: SOLANA_RPC was built with placeholder before key patch (Code 3 timing)
  - Adds: exportReport() creates a clean HTML report + embeds bubble map PNG
===================================================== -->

<script>
/* =========================
   1) SOLANA RPC HOTFIX
   Problem:
   - In Code 3 you do:
     const HELIUS_API_KEY = "PUT_YOUR_HELIUS_KEY_HERE";
     const SOLANA_RPC = `https://...${HELIUS_API_KEY}`;
   - Later in Code 7 we set window.HELIUS_API_KEY, but SOLANA_RPC constant
     already captured the placeholder. So Solana requests still fail.
   Solution:
   - Wrap solRpc() to always rebuild the RPC URL from your real key.
   - No need to touch Code 3.
========================= */
(function patchSolRpc(){
  if(typeof window.solRpc !== "function") return;

  const original = window.solRpc;

  // Prefer key from window.HELIUS_API_KEY set in Code 7
  function getHeliusKey(){
    const k = window.HELIUS_API_KEY || "";
    return (k && k !== "PUT_YOUR_HELIUS_KEY_HERE") ? k : "b566a086-57d4-4433-8661-faed9ad07ba0";
  }

  window.solRpc = async function solRpcPatched(method, params){
    const key = getHeliusKey();
    const rpc = `https://mainnet.helius-rpc.com/?api-key=${key}`;

    // We bypass the original SOLANA_RPC constant by performing fetch here.
    const res = await fetch(rpc,{
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body:JSON.stringify({ jsonrpc:"2.0", id:1, method, params })
    });

    const json = await res.json();
    if(json?.error) throw new Error(json.error.message || "Solana RPC error");

    // If something unexpected happens, fall back to original behavior
    if(typeof json?.result !== "undefined") return json.result;
    return await original(method, params);
  };
})();

/* =========================
   2) BETTER EXPORT REPORT
   - Generates a standalone HTML file
   - Includes scan meta, checks, metrics, holders, cluster summary, bubble PNG
   - Works even if EVM holders are empty
========================= */
(function patchExportReport(){
  // Ensure helpers exist
  const esc = (s)=>String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#39;");

  function dl(filename, html){
    const blob = new Blob([html], {type:"text/html;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1200);
  }

  function getVerdictForReport(res){
    try{
      if(typeof calculateScore === "function" && typeof getVerdict === "function"){
        const {score, critical} = calculateScore(res);
        const v = getVerdict(score, critical);
        return {score, critical, ...v};
      }
    }catch{}
    return {score:null,label:"—",text:"—",color:"#999"};
  }

  function holdersTable(holders){
    const hs = Array.isArray(holders) ? holders : [];
    if(!hs.length) return `<div class="muted">No holder list available.</div>`;
    return `
      <table>
        <thead><tr><th>#</th><th>Wallet</th><th>%</th></tr></thead>
        <tbody>
          ${hs.slice(0,25).map((h,i)=>`
            <tr>
              <td>${i+1}</td>
              <td class="mono">${esc(window.short(h.wallet))}</td>
              <td>${Number(h.pct||0).toFixed(2)}%</td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    `;
  }

  function checksTableFromUI(){
    // We can rebuild checks from STATE.result, but easiest stable: read the UI
    // (since you already render them).
    try{
      const items = Array.from(document.querySelectorAll("#checksList .li"));
      if(!items.length) return `<div class="muted">No checks rendered.</div>`;
      return `
        <ul class="checks">
          ${items.map(li=>`<li>${li.innerText.replace(/\n+/g," • ")}</li>`).join("")}
        </ul>
      `;
    }catch{
      return `<div class="muted">No checks rendered.</div>`;
    }
  }

  function metricsTableFromUI(){
    try{
      const items = Array.from(document.querySelectorAll("#metrics .li"));
      if(!items.length) return `<div class="muted">No metrics rendered.</div>`;
      return `
        <table>
          <thead><tr><th>Metric</th><th>Value</th></tr></thead>
          <tbody>
            ${items.map(row=>{
              const cols = Array.from(row.children).map(x=>x.innerText);
              return `<tr><td>${esc(cols[0]||"")}</td><td>${esc(cols[1]||"")}</td></tr>`;
            }).join("")}
          </tbody>
        </table>
      `;
    }catch{
      return `<div class="muted">No metrics rendered.</div>`;
    }
  }

  function clusterSummaryBlock(){
    try{
      const s = window.STATE?.clusters?.summary || null;
      if(!s) return `<div class="muted">No cluster summary available.</div>`;
      return `
        <div class="kpiRow">
          <div class="kpi"><div class="k">Clusters</div><div class="v">${esc(s.clusterCount)}</div></div>
          <div class="kpi"><div class="k">Largest cluster</div><div class="v">${esc(s.largestClusterPct)}%</div></div>
        </div>
        <div class="muted" style="margin-top:8px">
          Top wallets: <span class="mono">${esc((s.largestClusterWallets||[]).slice(0,8).map(window.short).join(" • "))}</span>
        </div>
      `;
    }catch{
      return `<div class="muted">No cluster summary available.</div>`;
    }
  }

  // Replace exportReport with real implementation (still safe if no scan)
  window.exportReport = function exportReport(){
    if(!window.STATE?.completed || !window.STATE?.result){
      alert("No scan to export");
      return;
    }

    const res = window.STATE.result;
    const chainName = (window.STATE.activeChain?.name || res.chain || "chain");
    const address = window.STATE.address || "—";
    const when = new Date().toISOString();

    const verdict = getVerdictForReport(res);
    const bubble = window.__BUBBLE_MAP_DATA_URL || "";

    const title = `$SOS Guardian Report — ${chainName}`;
    const filename = `SOS_Guardian_Report_${chainName}_${String(address).slice(0,12)}.html`
      .replaceAll(" ","_")
      .replaceAll("/","_");

    const html = `<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>${esc(title)}</title>
<style>
  :root{--bg:#070711;--panel:rgba(255,255,255,.06);--stroke:rgba(255,255,255,.12);--text:rgba(255,255,255,.92);--muted:rgba(255,255,255,.70);--g:#14F195;--c:#00D1FF;--p:#9945FF;--r:18px}
  body{margin:0;background:var(--bg);color:var(--text);font:15px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:980px;margin:0 auto;padding:18px}
  .card{border:1px solid var(--stroke);background:linear-gradient(180deg,rgba(255,255,255,.07),rgba(255,255,255,.05));border-radius:var(--r);padding:16px;margin:12px 0}
  h1{margin:0 0 8px;font-size:22px}
  h2{margin:0 0 10px;font-size:16px}
  .muted{color:var(--muted)}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  table{width:100%;border-collapse:collapse;font-size:14px}
  th,td{border-bottom:1px solid rgba(255,255,255,.10);padding:10px;text-align:left;vertical-align:top}
  th{color:rgba(255,255,255,.78);font-weight:900}
  .pill{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;font-weight:1000;color:#061012}
  .kpiRow{display:flex;gap:10px;flex-wrap:wrap}
  .kpi{flex:1;min-width:180px;border:1px solid rgba(255,255,255,.10);border-radius:14px;padding:10px;background:rgba(0,0,0,.22)}
  .k{font-size:12px;color:rgba(255,255,255,.72);font-weight:900}
  .v{font-size:18px;font-weight:1000;margin-top:4px}
  .checks{margin:0;padding-left:18px}
  img{max-width:100%;border-radius:14px;border:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.22)}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>$SOS — Guardian Contract Scanner</h1>
    <div class="muted">Generated: <span class="mono">${esc(when)}</span></div>
    <div class="muted">Chain: <strong>${esc(chainName)}</strong> • Address: <span class="mono">${esc(address)}</span></div>
  </div>

  <div class="card">
    <h2>Verdict & Score</h2>
    <div class="pill" style="background:${esc(verdict.color||"#999")}">
      ${esc(verdict.label||"—")}
      ${verdict.score!=null ? `• ${esc(verdict.score)}/100` : ""}
    </div>
    <div class="muted" style="margin-top:10px">${esc(verdict.text||"")}</div>
  </div>

  <div class="card">
    <h2>Metrics</h2>
    ${metricsTableFromUI()}
  </div>

  <div class="card">
    <h2>Guardian Checks</h2>
    ${checksTableFromUI()}
  </div>

  <div class="card">
    <h2>Top Holders & Clusters</h2>
    ${clusterSummaryBlock()}
    <div style="margin-top:12px">${holdersTable(res.holders)}</div>
  </div>

  <div class="card">
    <h2>Holder Bubble Map</h2>
    ${bubble ? `<img alt="Bubble map" src="${bubble}"/>` : `<div class="muted">No bubble map image available.</div>`}
  </div>

  <div class="card">
    <h2>Raw Signals (debug)</h2>
    <pre class="mono" style="white-space:pre-wrap;word-break:break-word;margin:0">${esc(JSON.stringify(res.signals||{},null,2))}</pre>
  </div>

  <div class="muted" style="margin:18px 0 8px">
    Note: EVM holder lists depend on indexer coverage (GoldRush). If a token is not indexed yet, the scan still completes.
  </div>
</div>
</body>
</html>`;

    dl(filename, html);
  };

  // Enable export button immediately after scan if it exists
  try{
    const b = qs("btnExport");
    if(b) b.disabled = !(window.STATE?.completed);
  }catch{}
})();


/* =========================
   3) OPTIONAL: immediate UI hint if Solana key fixed
========================= */
try{
  // If user had Solana selected, we reassure by status
  if(window.STATE?.activeChain?.kind === "solana"){
    setStatus("Solana RPC hotfix active (Helius key applied). Ready.");
  }
}catch{}
</script>
<!-- =====================================================
  CODE 9 / 10
  EVM HARDENING + BETTER DECODING + RENOUNCED CHECKS + PROXY SLOTS + STABLE CHECKS LIST
  - No edits required in Code 1–8
  - Fixes:
    * ERC-20 name/symbol decoding (bytes32 + string)
    * More owner detection: Ownable.owner(), getOwner(), admin (EIP-1967), beacon
    * Proxy detection: impl slot + beacon slot + admin slot (best-effort)
    * Safer supplyUi calculation (avoid bigint division surprises)
    * EVM checks become richer + consistent
===================================================== -->

<script>
/* =========================
   ABI / DECODING HELPERS
========================= */
(function evmDecodeHelpers(){
  // hex -> bytes
  function hexToBytes(hex){
    const h = (hex || "").startsWith("0x") ? hex.slice(2) : (hex || "");
    if(!h) return new Uint8Array([]);
    const clean = h.length % 2 ? "0"+h : h;
    const out = new Uint8Array(clean.length/2);
    for(let i=0;i<out.length;i++){
      out[i] = parseInt(clean.slice(i*2,i*2+2), 16);
    }
    return out;
  }

  function bytesToAscii(bytes){
    let s = "";
    for(const b of bytes){
      if(b === 0) break;
      // keep printable range only
      if(b >= 32 && b <= 126) s += String.fromCharCode(b);
    }
    return s;
  }

  // Try decode return data as string (ABI)
  // Supports:
  // 1) string (dynamic): offset(32) | len(32) | data
  // 2) bytes32: 32 bytes direct
  function decodeStringOrBytes32(retHex){
    try{
      if(!retHex || retHex === "0x") return null;
      const bytes = hexToBytes(retHex);
      if(bytes.length < 32) return null;

      // If dynamic string: first 32 bytes as offset (usually 0x20)
      const firstWord = retHex.slice(2, 2+64);
      const off = Number(BigInt("0x"+firstWord));
      if(off === 32 && bytes.length >= 64){
        const lenWord = retHex.slice(2+64, 2+128);
        const len = Number(BigInt("0x"+lenWord));
        const dataStart = 2 + 128;
        const dataHex = retHex.slice(dataStart, dataStart + len*2);
        const txt = bytesToAscii(hexToBytes("0x"+dataHex));
        return (txt && txt.trim()) ? txt.trim() : null;
      }

      // Otherwise treat as bytes32
      const txt2 = bytesToAscii(bytes.slice(0,32));
      return (txt2 && txt2.trim()) ? txt2.trim() : null;
    }catch{
      return null;
    }
  }

  // Decode address from 32-byte return
  function decodeAddress(retHex){
    try{
      if(!retHex || retHex === "0x") return null;
      if(retHex.length < 2+64) return null;
      const tail = retHex.slice(-40);
      const addr = "0x" + tail.toLowerCase();
      if(/^0x[0-9a-f]{40}$/.test(addr)) return addr;
      return null;
    }catch{
      return null;
    }
  }

  window.__evmDecodeStringOrBytes32 = decodeStringOrBytes32;
  window.__evmDecodeAddress = decodeAddress;
  window.__hexToBytes = hexToBytes;
})();

/* =========================
   EXTRA EVM SELECTORS
========================= */
(function evmSelectors(){
  // keccak selectors (precomputed)
  // owner() already exists: 0x8da5cb5b
  window.__EVM_OWNER_SIGS = [
    "0x8da5cb5b", // owner()
    "0x893d20e8", // getOwner()
    "0xf2fde38b"  // transferOwnership(address) (not a getter but sometimes proxied weird)
  ];

  // EIP-1967 slots
  window.__EIP1967 = {
    impl:   "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc",
    admin:  "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103",
    beacon: "0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50"
  };
})();

/* =========================
   PATCH: scanEvm wrapper (add richer metadata + ownership + proxy info)
   - We keep your Code 4 scanEvm result, then enhance it.
========================= */
(function patchScanEvmEnhancements(){
  if(typeof window.scanEvm !== "function") return;

  const origScan = window.scanEvm;

  async function readStorage(chainId, addr, slot){
    try{
      const rpcs = window.EVM_RPCS?.[chainId] || [];
      for(const rpc of rpcs){
        try{
          const v = await window.evmRpc(rpc, "eth_getStorageAt", [addr, slot, "latest"]);
          if(v) return v;
        }catch{}
      }
    }catch{}
    return null;
  }

  async function tryOwnerCalls(chainId, addr){
    // Try multiple getters. Use the first non-zero address.
    const sigs = window.__EVM_OWNER_SIGS || [];
    for(const sig of sigs){
      // skip transferOwnership (not getter) unless nothing else works
      if(sig === "0xf2fde38b") continue;
      try{
        const ret = await window.evmCall(chainId, {to: addr, data: sig});
        const o = window.__evmDecodeAddress(ret);
        if(o && o !== "0x0000000000000000000000000000000000000000") return o;
        if(o) return o;
      }catch{}
    }
    // fallback to your original owner() raw (already in res.signals.owner)
    return null;
  }

  async function tryTokenMetaBetter(chainId, addr){
    let name = null, symbol = null;
    try{
      const r1 = await window.evmCall(chainId, {to: addr, data: window.ERC20_SIG?.name || "0x06fdde03"});
      name = window.__evmDecodeStringOrBytes32(r1) || null;
    }catch{}
    try{
      const r2 = await window.evmCall(chainId, {to: addr, data: window.ERC20_SIG?.symbol || "0x95d89b41"});
      symbol = window.__evmDecodeStringOrBytes32(r2) || null;
    }catch{}
    return {name, symbol};
  }

  window.scanEvm = async function scanEvmEnhanced(chain, addr){
    const res = await origScan(chain, addr);
    const chainId = chain.chainId;

    // Better name/symbol decode
    try{
      const meta = await tryTokenMetaBetter(chainId, addr);
      if(meta.name) res.meta.name = meta.name;
      if(meta.symbol) res.meta.symbol = meta.symbol;
    }catch{}

    // Better owner detection
    try{
      const o = await tryOwnerCalls(chainId, addr);
      if(o) res.signals.owner = o;
      const ownerAddr = res.signals.owner || null;
      res.signals.renounced = !ownerAddr || ownerAddr === "0x0000000000000000000000000000000000000000";
    }catch{}

    // More proxy slots
    try{
      const impl = await readStorage(chainId, addr, window.__EIP1967.impl);
      const admin = await readStorage(chainId, addr, window.__EIP1967.admin);
      const beacon = await readStorage(chainId, addr, window.__EIP1967.beacon);

      const implAddr = impl ? ("0x"+impl.slice(-40)).toLowerCase() : null;
      const adminAddr = admin ? ("0x"+admin.slice(-40)).toLowerCase() : null;
      const beaconAddr = beacon ? ("0x"+beacon.slice(-40)).toLowerCase() : null;

      const looksAddr = (a)=>a && /^0x[0-9a-f]{40}$/.test(a) && a !== "0x0000000000000000000000000000000000000000";

      res.signals.proxy = !!(looksAddr(implAddr) || looksAddr(beaconAddr));
      res.signals.proxyImpl = looksAddr(implAddr) ? implAddr : (res.signals.proxyImpl || null);
      res.signals.proxyAdmin = looksAddr(adminAddr) ? adminAddr : null;
      res.signals.proxyBeacon = looksAddr(beaconAddr) ? beaconAddr : null;
    }catch{}

    // Safer supplyUi compute (avoid bigint rounding weirdness)
    try{
      // Your Code 4 sets supplyUi from totalSupply/decimals but loses raw totalSupply.
      // We recompute as string if possible.
      const dec = res.signals.decimals;
      if(Number.isFinite(dec) && typeof window.evmCall === "function"){
        const tsHex = await window.evmCall(chainId, {to: addr, data: window.ERC20_SIG?.totalSupply || "0x18160ddd"});
        const ts = (typeof window.hexToBigInt === "function") ? window.hexToBigInt(tsHex) : null;
        if(typeof ts === "bigint"){
          const d = BigInt(dec);
          const div = 10n ** d;
          const whole = ts / div;
          // keep simple: store integer (same as before), but stable
          res.signals.supplyUi = Number(whole);
          res.signals.totalSupplyRaw = ts.toString(); // debug/report
        }
      }
    }catch{}

    return res;
  };
})();

/* =========================
   PATCH: renderEvmChecks richer output
   - Shows renounced/owner, proxy impl/admin/beacon, supply/decimals
========================= */
(function patchEvmChecks(){
  if(typeof window.renderEvmChecks !== "function") return;

  window.renderEvmChecks = function renderEvmChecksRich(result){
    const list = qs("checksList");
    if(!list) return;
    list.innerHTML = "";

    const add = (title, ok, desc)=>{
      const li = document.createElement("li");
      li.className = "li";
      li.innerHTML = `
        <div>
          <strong>${title}</strong><br>
          <span>${desc}</span>
        </div>
        <div>${ok ? "✅" : "⚠️"}</div>
      `;
      list.appendChild(li);
    };

    add("Contract Code", true, "Contract bytecode present");

    // Ownership
    const owner = result?.signals?.owner || null;
    const ren = !!result?.signals?.renounced;
    add(
      "Ownership",
      ren,
      ren
        ? "Ownership renounced (owner = 0x0 / not found)"
        : `Owner: ${window.short(owner)}`
    );

    // Proxy details
    const isProxy = !!result?.signals?.proxy;
    const impl = result?.signals?.proxyImpl || null;
    const admin = result?.signals?.proxyAdmin || null;
    const beacon = result?.signals?.proxyBeacon || null;

    if(isProxy){
      add(
        "Proxy",
        false,
        `Proxy detected • Impl: ${impl ? window.short(impl) : "—"}`
        + (admin ? ` • Admin: ${window.short(admin)}` : "")
        + (beacon ? ` • Beacon: ${window.short(beacon)}` : "")
      );
    }else{
      add("Proxy", true, "No proxy slot detected (best-effort)");
    }

    // Supply / Decimals
    const dec = result?.signals?.decimals;
    const sup = result?.signals?.supplyUi;
    add(
      "Token Meta",
      true,
      `Decimals: ${Number.isFinite(dec) ? dec : "—"} • Supply: ${typeof sup === "number" ? sup.toLocaleString() : "—"}`
    );
  };
})();

/* =========================
   PATCH: calculateScore tweak for EVM (optional, stable)
   - If proxy is true, keep penalty (already in Code 5)
   - If ownership not renounced, keep penalty (already)
   - Add small penalty if owner can't be decoded but proxy admin exists (still controlled)
========================= */
(function patchScoreOptional(){
  if(typeof window.calculateScore !== "function") return;
  const old = window.calculateScore;

  window.calculateScore = function calculateScorePatched(res){
    const base = old(res);
    try{
      if(res?.chain === "evm"){
        // If proxy admin exists and renounced is false, slightly increase risk
        if(res?.signals?.proxyAdmin && !res?.signals?.renounced){
          base.score = Math.max(0, base.score - 5);
        }
      }
      base.score = Math.max(0, Math.min(100, Math.round(base.score)));
    }catch{}
    return base;
  };
})();

/* =========================
   READY
========================= */
try{
  setStatus("EVM hardened: better name/symbol, owner/proxy detection, richer checks. Ready.");
}catch{}
</script>
<!-- =====================================================
  CODE 10 / 10
  SECURITY + UX POLISH + KEY SAFETY (NO HARD-CODED KEYS) + RATE LIMIT + CORS FRIENDLY FALLBACKS
  - Removes the hard-coded API keys usage by supporting:
      1) URL params: ?helius=...&goldrush=...
      2) localStorage prompts (one-time)
  - Adds:
      * AbortController (cancel in-flight scan if user re-runs)
      * Simple rate limit/backoff for RPC calls
      * Better status + disable buttons while scanning
      * Export report includes token meta (name/symbol) cleanly
  - IMPORTANT: This does not break Code 2–9; it wraps safely.
===================================================== -->

<script>
/* =========================
   KEY MANAGEMENT (NO HARDCODE)
   Priority: URL param > localStorage > existing window.* (if user set)
========================= */
(function keyManager(){
  function getParam(k){
    try{
      const u = new URL(location.href);
      const v = u.searchParams.get(k);
      return v && v.trim() ? v.trim() : null;
    }catch{ return null; }
  }

  function lsGet(k){
    try{ return localStorage.getItem(k) || null; }catch{ return null; }
  }
  function lsSet(k,v){
    try{ localStorage.setItem(k, v); }catch{}
  }

  function ensureKey(label, paramName, lsName, existing){
    const fromUrl = getParam(paramName);
    if(fromUrl){ lsSet(lsName, fromUrl); return fromUrl; }

    const fromLs = lsGet(lsName);
    if(fromLs) return fromLs;

    if(existing && typeof existing === "string" && existing.trim() && !existing.includes("PUT_YOUR_")){
      lsSet(lsName, existing.trim());
      return existing.trim();
    }

    return null;
  }

  // Read keys
  const helius = ensureKey("Helius", "helius", "SOS_HELIUS_KEY", window.HELIUS_API_KEY);
  const gold   = ensureKey("GoldRush", "goldrush", "SOS_GOLDRUSH_KEY", window.GOLDRUSH_API_KEY);

  // Expose (if provided)
  if(helius) window.HELIUS_API_KEY = helius;
  if(gold)   window.GOLDRUSH_API_KEY = gold;

  // Optional: simple UI hint if missing
  function hintMissing(){
    const missing = [];
    if(!window.HELIUS_API_KEY) missing.push("Helius");
    if(!window.GOLDRUSH_API_KEY) missing.push("GoldRush");
    if(!missing.length) return;

    // Keep it short, non-blocking
    setStatus(
      `Ready. Missing keys: ${missing.join(", ")}. ` +
      `You can pass them via URL: ?helius=KEY&goldrush=KEY (saved locally).`
    );
  }

  // Only hint on initial load (don’t override active scan status)
  try{
    if(!STATE?.scanning && (!window.HELIUS_API_KEY || !window.GOLDRUSH_API_KEY)){
      hintMissing();
    }
  }catch{}
})();

/* =========================
   ABORT CONTROLLER + BUTTON UX
========================= */
(function scanHarden(){
  // Wrap runScan to support canceling previous run and button locking.
  if(typeof window.runScan !== "function") return;

  const orig = window.runScan;

  // single controller reused per scan
  window.__SCAN_CTRL = null;

  function setScanningUI(isScanning){
    try{
      const b1 = qs("btnScan");
      const b2 = qs("btnScanInline");
      if(b1) b1.disabled = !!isScanning;
      if(b2) b2.disabled = !!isScanning;

      // export enabled only when completed
      const ex = qs("btnExport");
      if(ex) ex.disabled = !!isScanning || !(STATE?.completed);
    }catch{}
  }

  // Patch fetch globally to respect abort signal ONLY for our scan calls
  // We do not monkey-patch window.fetch to avoid surprises.
  // Instead we add helper fetchWithAbort and wrap RPC functions below.
  window.__fetchWithAbort = async function(url, opts){
    const ctrl = window.__SCAN_CTRL;
    const signal = ctrl ? ctrl.signal : undefined;
    return fetch(url, {...(opts||{}), signal});
  };

  window.runScan = async function runScanPatched(){
    // Abort previous scan if any
    try{
      if(window.__SCAN_CTRL){
        window.__SCAN_CTRL.abort();
      }
    }catch{}
    window.__SCAN_CTRL = new AbortController();

    setScanningUI(true);
    try{
      await orig();
    }finally{
      setScanningUI(false);
    }
  };
})();

/* =========================
   LIGHT BACKOFF / RATE LIMIT FOR RPC
========================= */
(function rpcBackoff(){
  // tiny async sleep
  const sleep = (ms)=>new Promise(r=>setTimeout(r, ms));

  // Wrap solRpc (already patched in Code 8) to retry on 429/5xx/network.
  if(typeof window.solRpc === "function"){
    const old = window.solRpc;
    window.solRpc = async function solRpcBackoff(method, params){
      const tries = 3;
      let lastErr = null;

      for(let i=0;i<tries;i++){
        try{
          return await old(method, params);
        }catch(e){
          lastErr = e;
          const msg = String(e?.message || "");
          // mild backoff on rate limit / overload
          if(msg.includes("429") || msg.toLowerCase().includes("rate") || msg.toLowerCase().includes("timeout")){
            await sleep(350 * (i+1));
            continue;
          }
          // for other errors don't spam retries
          break;
        }
      }
      throw lastErr || new Error("Solana RPC failed");
    };
  }

  // Wrap evmRpc to add basic retry/backoff and abort support
  if(typeof window.evmRpc === "function"){
    const old = window.evmRpc;
    window.evmRpc = async function evmRpcBackoff(rpc, method, params){
      const tries = 3;
      let lastErr = null;

      for(let i=0;i<tries;i++){
        try{
          // replicate old evmRpc but use __fetchWithAbort if available
          const res = await (window.__fetchWithAbort || fetch)(rpc,{
            method:"POST",
            headers:{ "Content-Type":"application/json" },
            body:JSON.stringify({ jsonrpc:"2.0", id:1, method, params })
          });

          // If fetch returns Response (for __fetchWithAbort), handle json
          const json = await res.json();
          if(json?.error) throw new Error(json.error.message);

          return json.result;
        }catch(e){
          lastErr = e;
          const msg = String(e?.message || "");
          if(msg.toLowerCase().includes("aborted")) throw e;

          // Retry on common overload patterns
          if(msg.includes("429") || msg.toLowerCase().includes("rate") || msg.toLowerCase().includes("timeout") || msg.toLowerCase().includes("fetch")){
            await sleep(250 * (i+1));
            continue;
          }
          break;
        }
      }
      throw lastErr || new Error("EVM RPC failed");
    };
  }
})();

/* =========================
   EXPORT: include token meta (name/symbol) in report header
========================= */
(function patchExportMeta(){
  if(typeof window.exportReport !== "function") return;

  const old = window.exportReport;

  // If Code 8 export is active, it already uses STATE.result.
  // We wrap it just to ensure meta is present and keys aren't leaked anywhere.
  window.exportReport = function exportReportPatched(){
    try{
      // Ensure we never embed API keys in report by accident
      // (We don’t, but we also strip if someone added debug later.)
      if(window.STATE?.result?.signals){
        const s = window.STATE.result.signals;
        delete s.__apikey;
        delete s.apiKey;
      }
    }catch{}
    return old();
  };
})();

/* =========================
   OPTIONAL: QUICK SETTINGS PROMPT (USER-INITIATED)
   - Adds a tiny keyboard shortcut: Shift+K to set keys (no UI changes needed)
========================= */
(function keyShortcut(){
  function promptKey(label, lsKey){
    const cur = (()=>{
      try{ return localStorage.getItem(lsKey) || ""; }catch{ return ""; }
    })();

    const v = prompt(`${label} API Key (stored locally in this browser)`, cur);
    if(v && v.trim()){
      try{ localStorage.setItem(lsKey, v.trim()); }catch{}
      return v.trim();
    }
    return null;
  }

  window.addEventListener("keydown", (e)=>{
    if(e.shiftKey && (e.key === "K" || e.key === "k")){
      e.preventDefault();

      const h = promptKey("Helius", "SOS_HELIUS_KEY");
      const g = promptKey("GoldRush", "SOS_GOLDRUSH_KEY");

      if(h) window.HELIUS_API_KEY = h;
      if(g) window.GOLDRUSH_API_KEY = g;

      setStatus("Keys updated locally. Run scan again.");
    }
  }, {passive:false});
})();

/* =========================
   FINAL READY
========================= */
try{
  if(!STATE?.scanning){
    setStatus("Ready. Tip: Shift+K to set API keys locally (Helius/GoldRush).");
  }
}catch{}
</script>

</body>
</html>
