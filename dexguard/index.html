const ALLOWED_CHAINS = new Set([
  "solana","ethereum","bsc","base","arbitrum","avalanche","optimism","polygon","zksync","sui","monad",
]);

const TF_SECONDS = {
  "1s": 1, "15s": 15, "30s": 30,
  "1m": 60, "3m": 180, "5m": 300, "15m": 900, "30m": 1800,
  "1h": 3600, "2h": 7200, "4h": 14400, "6h": 21600, "12h": 43200,
  "1d": 86400,
};


const GECKO_BASE = "https://api.geckoterminal.com/api/v2";

function geckoNetwork(chain) {
  const c = (chain || "").toLowerCase();
  if (c === "ethereum") return "eth";
  if (c === "sol") return "solana";
  if (c === "bnb") return "bsc";
  return c; // solana, bsc, base, polygon_pos, etc.
}

function geckoTf(tf) {
  const s = (tf || "").toLowerCase().trim();
  const m = s.match(/^(\d+)([mhd])$/);
  if (!m) return null;
  const n = parseInt(m[1], 10);
  const u = m[2];
  if (!Number.isFinite(n) || n <= 0) return null;
  if (u === "m") return { timeframe: "minute", aggregate: n };
  if (u === "h") return { timeframe: "hour", aggregate: n };
  if (u === "d") return { timeframe: "day", aggregate: n };
  return null;
}

async function geckoUpstreamJson(url) {
  const res = await fetch(url, { headers: { "accept": "application/json" } });
  const text = await res.text();
  let j = null;
  try { j = JSON.parse(text); } catch (_) {}
  return { res, text, j };
}

async function geckoPoolOhlcv(chain, pool, tf, limit, fromSec, toSec) {
  const net = geckoNetwork(chain);
  const tfm = geckoTf(tf);
  if (!net || !tfm) return null;

  const baseUrl = `${GECKO_BASE}/networks/${net}/pools/${pool}/ohlcv/${tfm.timeframe}`;
  const mkUrl = (beforeVal) => {
    const u = new URL(baseUrl);
    u.searchParams.set("aggregate", String(tfm.aggregate));
    u.searchParams.set("limit", String(limit));
    u.searchParams.set("currency", "usd");
    if (beforeVal != null) u.searchParams.set("before_timestamp", String(beforeVal));
    return u.toString();
  };

  // GeckoTerminal's before_timestamp has historically been seconds; some stacks use ms.
  const beforeSec = toSec ? Math.floor(Number(toSec)) : null;
  const beforeMs  = toSec ? Math.floor(Number(toSec) * 1000) : null;

  // Try seconds first, then ms if empty or error.
  const tries = [];
  tries.push({ label: "sec", url: mkUrl(beforeSec) });
  if (beforeMs != null) tries.push({ label: "ms", url: mkUrl(beforeMs) });

  let lastFail = null;

  for (const tr of tries) {
    const { res, text, j } = await geckoUpstreamJson(tr.url);
    if (!res.ok) {
      lastFail = { status: res.status, body: (text || "").slice(0, 500), mode: tr.label };
      continue;
    }

    const list = j?.data?.attributes?.ohlcv_list || [];
    const itemsAll = Array.isArray(list) ? list.map((row) => {
      const ts = Number(row?.[0]);
      // Gecko returns ms for timestamps in many cases
      const t = Number.isFinite(ts) ? (ts > 1e12 ? Math.floor(ts / 1000) : Math.floor(ts)) : null;
      const o = safeNum(row?.[1]);
      const c = safeNum(row?.[2]);
      const h = safeNum(row?.[3]);
      const l = safeNum(row?.[4]);
      const v = safeNum(row?.[5]);
      return { t, o, h, l, c, v };
    }).filter(x => x.t && x.o != null && x.h != null && x.l != null && x.c != null) : [];

    const items = (fromSec || toSec)
      ? itemsAll.filter(x => (!fromSec || x.t >= fromSec) && (!toSec || x.t <= toSec))
      : itemsAll;

    if (items && items.length) {
      return {
        ok: true,
        chain,
        pair: pool,
        tf,
        from: fromSec || null,
        to: toSec || null,
        count: items.length,
        items,
        fetchedAt: Date.now(),
        source: "gecko",
        mode: tr.label,
      };
    }

    // If response ok but empty, try next mode if available
    lastFail = { status: 200, body: "empty_ohlcv_list", mode: tr.label };
  }

  return { ok: false, source: "gecko", status: lastFail?.status || 0, body: lastFail?.body || "", mode: lastFail?.mode || null };
}


async function geckoPoolTrades(chain, pool, limit) {
  const net = geckoNetwork(chain);
  if (!net) return null;

  const u = new URL(`${GECKO_BASE}/networks/${net}/pools/${pool}/trades`);
  const { res, text, j } = await geckoUpstreamJson(u.toString());
  if (!res.ok) {
    return { ok: false, source: "gecko", status: res.status, body: (text || "").slice(0, 500) };
  }

  const data = j?.data || [];
  const itemsAll = Array.isArray(data) ? data.map((it) => {
    const a = it?.attributes || {};
    let ts = a.block_timestamp ?? a.timestamp ?? a.time ?? a.datetime ?? a.created_at ?? null;
    if (typeof ts === "string") {
      const d = Date.parse(ts);
      ts = Number.isFinite(d) ? d : ts;
    }
    const n = Number(ts);
    const t = Number.isFinite(n) ? (n > 1e12 ? Math.floor(n / 1000) : Math.floor(n)) : null;

    const kind = String(a.kind ?? a.side ?? a.trade_type ?? "").toLowerCase();
    let side = kind.includes("buy") ? "buy" : (kind.includes("sell") ? "sell" : null);
    if (!side && typeof a.is_buy === "boolean") side = a.is_buy ? "buy" : "sell";

    const usd = safeNum(a.volume_in_usd ?? a.trade_volume_in_usd ?? a.amount_in_usd ?? a.total_value_in_usd);
    const price = safeNum(a.price_in_usd ?? a.trade_price_usd ?? a.price_usd);
    const maker = a.taker_address ?? a.trader_address ?? a.from_address ?? a.wallet_address ?? null;
    const tx = a.tx_hash ?? a.transaction_hash ?? a.tx ?? null;

    return { t, side, usd, price, maker, tx };
  }).filter(x => x.t && x.price != null) : [];

  const items = itemsAll.slice(0, limit);

  return {
    ok: true,
    chain,
    pair: pool,
    count: items.length,
    items,
    fetchedAt: Date.now(),
    source: "gecko",
  };
}

function corsHeaders() {
  return {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type",
    "Access-Control-Max-Age": "86400",
  };
}

function safeStringify(obj) {
  try {
    return JSON.stringify(obj, (_k, v) => (typeof v === "bigint" ? v.toString() : v));
  } catch (e) {
    // last resort
    try { return JSON.stringify({ ok:false, error:"json_stringify_failed", detail: String(e) }); }
    catch { return '{"ok":false,"error":"json_stringify_failed"}'; }
  }
}

function json(data, status = 200, extraHeaders = {}) {
  return new Response(safeStringify(data), {
    status,
    headers: { ...corsHeaders(), "Content-Type": "application/json", ...extraHeaders },
  });
}


function clampInt(n, min, max) {
  n = Number.isFinite(n) ? Math.trunc(n) : min;
  return Math.max(min, Math.min(max, n));
}

function safeNum(x) {
  const n = Number(x);
  return Number.isFinite(n) ? n : null;
}

async function upstreamJson(url, init = {}) {
  const res = await fetch(url, init);
  const text = await res.text();
  let j = null;
  try { j = JSON.parse(text); } catch (_) {}
  return { res, text, j };
}

async function cachedFetch(ctx, cacheKey, ttlSec, fetcher) {
  const cache = caches.default;

  // Try fresh first
  try {
    const r = await fetcher();
    if (r) {
      ctx.waitUntil(cache.put(cacheKey, r.clone()));
      return r;
    }
  } catch (_) {
    // ignore and try cache
  }

  const cached = await cache.match(cacheKey);
  if (cached) {
    const h = new Headers(cached.headers);
    h.set("X-Cache", "stale");
    return new Response(await cached.text(), { status: cached.status, headers: h });
  }

  // If no cache and fetcher failed, let fetcher throw/return null error handling happens above callers
  return null;
}

function hasBirdeyeKey(env) {
  const k = env && env.BIRDEYE_API_KEY;
  return typeof k === "string" && k.trim().length > 10;
}

function birdeyeHeaders(env, chain) {
  return {
    "accept": "application/json",
    ...(hasBirdeyeKey(env) ? { "X-API-KEY": env.BIRDEYE_API_KEY } : {}),
    "x-chain": chain,
  };
}


export default {
  async fetch(request, env, ctx) {
    try {
    const url = new URL(request.url);

    // CORS preflight
    if (request.method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders() });
    }

    // Birdeye is optional: if the API key is missing or invalid, endpoints will fall back where possible.

    // ---------- /api/ds/tokenpairs ----------
    
    // ---------- /api/ds/search ----------
    if (url.pathname === "/api/ds/search") {
      const chain = (url.searchParams.get("chain") || "").toLowerCase();
      const q = (url.searchParams.get("q") || "").trim();
      const limit = clampInt(url.searchParams.get("limit"), 1, 25);

      if (!q || q.length < 2) return json({ ok:false, error:"missing_query" }, 400);

      const cache = caches.default;
      const cacheKeyUrl = new URL(url.origin + url.pathname);
      cacheKeyUrl.searchParams.set("chain", chain || "any");
      cacheKeyUrl.searchParams.set("q", q.toLowerCase());
      cacheKeyUrl.searchParams.set("limit", String(limit));
      const cacheKey = new Request(cacheKeyUrl.toString(), { method:"GET" });

      const cached = await cache.match(cacheKey);
      if (cached) return cached;

      const upstream = new URL("https://api.dexscreener.com/latest/dex/search");
      upstream.searchParams.set("q", q);

      let upstreamRes;
      try {
        upstreamRes = await fetch(upstream.toString(), { headers: { "accept": "application/json" } });
      } catch {
        return json({ ok:false, error:"upstream_fetch_failed" }, 200);
      }

      const text = await upstreamRes.text();
      if (!upstreamRes.ok) {
        return json({ ok:false, error:"dexscreener_error", status: upstreamRes.status, body: text.slice(0,500) }, 200);
      }

      let j;
      try { j = JSON.parse(text); } catch { return json({ ok:false, error:"invalid_upstream_json" }, 200); }

      let pairs = Array.isArray(j?.pairs) ? j.pairs : [];
      if (chain && chain !== "any") pairs = pairs.filter(p => String(p?.chainId || "").toLowerCase() === chain);

      const out = { ok:true, chain: chain || "any", q, count: pairs.length, pairs: pairs.slice(0, limit) };

      const resp = json(out, 200, { "Cache-Control": "public, max-age=10, stale-while-revalidate=60" });
      ctx.waitUntil(cache.put(cacheKey, resp.clone()));
      return resp;
    }

if (url.pathname === "/api/ds/tokenpairs") {
      const chain = (url.searchParams.get("chain") || "solana").toLowerCase();
      const token = (url.searchParams.get("token") || "").trim();
      if (!ALLOWED_CHAINS.has(chain)) return json({ ok:false, error:"unsupported_chain", chain }, 400);
      if (!token || token.length < 20) return json({ ok:false, error:"missing_or_invalid_token" }, 400);

      const cacheKey = new Request(new URL(url.origin + url.pathname + `?chain=${encodeURIComponent(chain)}&token=${encodeURIComponent(token)}`).toString(), { method:"GET" });

      const resp = await cachedFetch(ctx, cacheKey, 10, async () => {
        const upstream = `https://api.dexscreener.com/latest/dex/tokens/${encodeURIComponent(token)}`;
        const { res, j } = await upstreamJson(upstream, { headers: { "accept":"application/json" }});
        if (!res.ok) return json({ ok:false, error:"dexscreener_error", status: res.status }, 200);
        const pairs = Array.isArray(j?.pairs) ? j.pairs.filter(p => String(p?.chainId || "").toLowerCase() === chain) : [];
        return json({ ok:true, chain, token, pairs, fetchedAt: Date.now(), source:"dexscreener" }, 200, {
          "Cache-Control": "public, max-age=10, stale-while-revalidate=60",
        });
      });

      return resp || json({ ok:false, error:"upstream_fetch_failed" }, 200);
    }

    // ---------- /api/price ----------
    if (url.pathname === "/api/price") {
      const chain = (url.searchParams.get("chain") || "solana").toLowerCase();
      const address = (url.searchParams.get("address") || "").trim();
      const pair = (url.searchParams.get("pair") || "").trim();
      if (!ALLOWED_CHAINS.has(chain)) return json({ ok:false, error:"unsupported_chain", chain }, 400);
      if ((!address || address.length < 20) && (!pair || pair.length < 20)) return json({ ok:false, error:"missing_or_invalid_address" }, 400);

      const cacheKey = new Request(new URL(url.origin + url.pathname + `?chain=${encodeURIComponent(chain)}&address=${encodeURIComponent(address)}`).toString(), { method:"GET" });

      const resp = await cachedFetch(ctx, cacheKey, 2, async () => {
        const upstream = new URL("https://public-api.birdeye.so/defi/price");
        upstream.searchParams.set("address", address);
        const { res, text, j } = await upstreamJson(upstream.toString(), { headers: birdeyeHeaders(env, chain) });

        if (url.searchParams.get("raw") === "1") {
          return new Response(text, {
            status: res.status,
            headers: { ...corsHeaders(), "Content-Type":"application/json", "Cache-Control":"no-store" },
          });
        }

        if (!res.ok) {
          return json({ ok:false, error:"birdeye_error", status: res.status, body: (text||"").slice(0,500) }, 200);
        }

        const out = {
          ok: true,
          chain,
          address,
          price: j?.data?.value ?? null,
          fetchedAt: Date.now(),
          source: "birdeye",
        };

        return json(out, 200, {
          "Cache-Control": "public, max-age=2, stale-while-revalidate=10, stale-if-error=60",
        });
      });

      return resp || json({ ok:false, error:"upstream_fetch_failed" }, 200);
    }

    // ---------- /api/candles ----------
    if (url.pathname === "/api/candles") {
      const chain = (url.searchParams.get("chain") || "solana").toLowerCase();
      const address = (url.searchParams.get("address") || "").trim();
      const pair = (url.searchParams.get("pair") || "").trim();
      const tf = (url.searchParams.get("tf") || "15m").toLowerCase();
      if (!ALLOWED_CHAINS.has(chain)) return json({ ok:false, error:"unsupported_chain", chain }, 400);
      if ((!address || address.length < 20) && (!pair || pair.length < 20)) {
        return json({ ok:false, error:"missing_or_invalid_address" }, 400);
      }
      if (!TF_SECONDS[tf]) return json({ ok:false, error:"unsupported_tf", tf }, 400);

      const limit = clampInt(parseInt(url.searchParams.get("limit") || "200", 10), 50, 1000);
      const nowSec = Math.floor(Date.now() / 1000);
      const tfSec = TF_SECONDS[tf];
      const timeTo = clampInt(parseInt(url.searchParams.get("to") || `${nowSec}`, 10), 0, 2147483647);
      const timeFromDefault = timeTo - (limit * tfSec);
      const timeFrom = clampInt(parseInt(url.searchParams.get("from") || `${timeFromDefault}`, 10), 0, 2147483647);

      const cacheKeyUrl = new URL(url.origin + url.pathname);
      cacheKeyUrl.searchParams.set("chain", chain);
      cacheKeyUrl.searchParams.set("tf", tf);
      cacheKeyUrl.searchParams.set("from", String(timeFrom));
      cacheKeyUrl.searchParams.set("to", String(timeTo));
      cacheKeyUrl.searchParams.set("limit", String(limit));
      cacheKeyUrl.searchParams.set("address", address || "");
      cacheKeyUrl.searchParams.set("pair", pair || "");
      const cacheKey = new Request(cacheKeyUrl.toString(), { method:"GET" });

      const doFetch = async () => {
        // Try candidate address list: pair first (if provided), then token address.
        const candidates = [];
        if (pair) candidates.push(pair);
        if (address && address !== pair) candidates.push(address);

        let lastErr = null;

        for (const addr of candidates) {
          // Try v3
          const upstream = new URL("https://public-api.birdeye.so/defi/v3/ohlcv");
          upstream.searchParams.set("address", addr);
          upstream.searchParams.set("type", tf);
          upstream.searchParams.set("time_from", String(timeFrom));
          upstream.searchParams.set("time_to", String(timeTo));
          upstream.searchParams.set("currency", "usd");
          upstream.searchParams.set("ui_amount_mode", "raw");

          const { res, text, j } = await upstreamJson(upstream.toString(), { headers: birdeyeHeaders(env, chain) });

          if (url.searchParams.get("raw") === "1") {
            return new Response(text, {
              status: res.status,
              headers: { ...corsHeaders(), "Content-Type":"application/json", "Cache-Control":"no-store" },
            });
          }

          if (!res.ok) {
            lastErr = { status: res.status, body: (text||"").slice(0,500) };
            // Try legacy endpoint as fallback
            const legacy = new URL("https://public-api.birdeye.so/defi/ohlcv");
            legacy.searchParams.set("address", addr);
            legacy.searchParams.set("type", tf);
            legacy.searchParams.set("time_from", String(timeFrom));
            legacy.searchParams.set("time_to", String(timeTo));
            legacy.searchParams.set("currency", "usd");
            legacy.searchParams.set("ui_amount_mode", "raw");
            const leg = await upstreamJson(legacy.toString(), { headers: birdeyeHeaders(env, chain) });
            if (!leg.res.ok) {
              lastErr = { status: leg.res.status, body: (leg.text||"").slice(0,500) };
              continue;
            }
            // Parse legacy ok
            const rawItems = leg.j?.data?.items || leg.j?.data?.ohlcv || leg.j?.data || [];
            const items = Array.isArray(rawItems) ? rawItems.map((x) => ({
              t: x?.unixTime ?? x?.unix_time ?? x?.time ?? x?.t ?? null,
              o: safeNum(x?.o ?? x?.open),
              h: safeNum(x?.h ?? x?.high),
              l: safeNum(x?.l ?? x?.low),
              c: safeNum(x?.c ?? x?.close),
              v: safeNum(x?.v ?? x?.volume),
            })).filter(c => c.t && c.o != null && c.h != null && c.l != null && c.c != null) : [];

            return json({
              ok:true, chain, address: address || null, pair: pair || null, tf,
              from: timeFrom, to: timeTo, count: items.length, items,
              fetchedAt: Date.now(), source:"birdeye"
            }, 200, { "Cache-Control":"public, max-age=10, stale-while-revalidate=60, stale-if-error=300" });
          }

          // v3 ok parse
          const rawItems = j?.data?.items || j?.data?.ohlcv || j?.data || [];
          const items = Array.isArray(rawItems) ? rawItems.map((x) => ({
            t: x?.unixTime ?? x?.unix_time ?? x?.time ?? x?.t ?? null,
            o: safeNum(x?.o ?? x?.open),
            h: safeNum(x?.h ?? x?.high),
            l: safeNum(x?.l ?? x?.low),
            c: safeNum(x?.c ?? x?.close),
            v: safeNum(x?.v ?? x?.volume),
          })).filter(c => c.t && c.o != null && c.h != null && c.l != null && c.c != null) : [];

          return json({
            ok:true, chain, address: address || null, pair: pair || null, tf,
            from: timeFrom, to: timeTo, count: items.length, items,
            fetchedAt: Date.now(), source:"birdeye"
          }, 200, { "Cache-Control":"public, max-age=10, stale-while-revalidate=60, stale-if-error=300" });
        }

          // If Birdeye failed, try GeckoTerminal (pool OHLCV) when pair is provided
  try {
    if (pair) {
      const g = await geckoPoolOhlcv(chain, pair, tf, limit, timeFrom, timeTo);
      if (g && g.ok && Array.isArray(g.items) && g.items.length) {
        return json(g, 200, { "Cache-Control":"public, max-age=10, stale-while-revalidate=60, stale-if-error=300" });
      }
    }
  } catch (_) {}

  return json({
    ok:false,
    error:"upstream_failed",
    birdeye: lastErr ? { status: lastErr.status || 0, body: lastErr.body || "" } : null,
    geckoTried: !!pair,
  }, 200);
};

      const resp = await cachedFetch(ctx, cacheKey, 10, doFetch);
      return resp || json({ ok:false, error:"upstream_fetch_failed" }, 200);
    }

    // ---------- /api/trades ----------
    if (url.pathname === "/api/trades") {
      const chain = (url.searchParams.get("chain") || "solana").toLowerCase();
      const address = (url.searchParams.get("address") || "").trim();
      const pair = (url.searchParams.get("pair") || "").trim();
      const limit = clampInt(parseInt(url.searchParams.get("limit") || "50", 10), 10, 100);
      const offset = clampInt(parseInt(url.searchParams.get("offset") || "0", 10), 0, 5000);

      if (!ALLOWED_CHAINS.has(chain)) return json({ ok:false, error:"unsupported_chain", chain }, 400);
      if ((!address || address.length < 20) && (!pair || pair.length < 20)) return json({ ok:false, error:"missing_or_invalid_address" }, 400);

      const cacheKeyUrl = new URL(url.origin + url.pathname);
      cacheKeyUrl.searchParams.set("chain", chain);
      cacheKeyUrl.searchParams.set("address", address);
      cacheKeyUrl.searchParams.set("pair", pair);
      cacheKeyUrl.searchParams.set("limit", String(limit));
      cacheKeyUrl.searchParams.set("offset", String(offset));
      const cacheKey = new Request(cacheKeyUrl.toString(), { method:"GET" });

      const doFetch = async () => {let birdeyeErr = null;

// 1) Birdeye token txs (works with token mint)
if (address && address.length >= 20) {
  const upstream = new URL("https://public-api.birdeye.so/defi/v3/token/txs");
  upstream.searchParams.set("address", address);
  upstream.searchParams.set("limit", String(limit));
  upstream.searchParams.set("offset", String(offset));
  // Avoid strict filters to reduce 4xx risk
  // upstream.searchParams.set("sort_type", "desc");
  // upstream.searchParams.set("tx_type", "swap");

  const { res, text, j } = await upstreamJson(upstream.toString(), { headers: birdeyeHeaders(env, chain) });

  if (url.searchParams.get("raw") === "1") {
    return new Response(text, {
      status: res.status,
      headers: { ...corsHeaders(), "Content-Type":"application/json", "Cache-Control":"no-store" },
    });
  }

  if (res.ok) {
    const raw = j?.data?.items || [];
    const items = Array.isArray(raw) ? raw.map((x) => {
      const txType = String(x?.tx_type ?? x?.side ?? "").toLowerCase();
      const side = txType.includes("buy") ? "buy" : (txType.includes("sell") ? "sell" : "unknown");

      const from = x?.from || null;
      const to = x?.to || null;
      const fromAddr = (from?.address || "").trim();
      const toAddr = (to?.address || "").trim();

      const tokenIsTo = toAddr === address;
      const tokenIsFrom = fromAddr === address;

      const tokenAmount = tokenIsTo ? safeNum(to?.ui_amount) : (tokenIsFrom ? safeNum(from?.ui_amount) : null);
      const usd = safeNum(x?.volume_usd);
      const priceUsd = (usd != null && tokenAmount != null && tokenAmount !== 0)
        ? Math.abs(usd / tokenAmount)
        : safeNum(x?.price ?? x?.tradePrice);

      return {
        t: x?.block_unix_time ?? null,
        side,
        price: priceUsd,
        usd,
        maker: x?.owner ?? null,
        tx: x?.tx_hash ?? null,
      };
    }).filter(r => r.t && r.price != null) : [];

    return json({
      ok:true, chain, address, pair: pair || null,
      count: items.length,
      items,
      fetchedAt: Date.now(),
      source:"birdeye",
    }, 200, { "Cache-Control":"public, max-age=1, stale-while-revalidate=10, stale-if-error=30" });
  }

  birdeyeErr = { status: res.status, body: (text||"").slice(0,500) };
}

// 2) GeckoTerminal pool trades (works with pool address)
try {
  if (pair && pair.length >= 20) {
    const g = await geckoPoolTrades(chain, pair, limit);
    if (g && g.ok && Array.isArray(g.items)) {
      return json(g, 200, { "Cache-Control":"public, max-age=10, stale-while-revalidate=60, stale-if-error=300" });
    }
  }
} catch (_) {}

return json({
  ok:false,
  error:"upstream_failed",
  birdeye: birdeyeErr,
  geckoTried: !!pair,
}, 200);
      };

      const resp = await cachedFetch(ctx, cacheKey, 1, doFetch);
      return resp || json({ ok:false, error:"upstream_fetch_failed" }, 200);
    }

    return new Response("Not found", { status: 404, headers: corsHeaders() });
    } catch (e) {
      // Never let the Worker throw (prevents opaque 502s)
      return json({ ok:false, error:"worker_exception", detail: String(e), stack: (e && e.stack) ? String(e.stack).slice(0, 1200) : null }, 200, {
        "Cache-Control": "no-store",
      });
    }

  },
};
