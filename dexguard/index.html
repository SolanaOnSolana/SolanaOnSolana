<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DexGuard v0</title>
  <style>
    body{margin:0;font-family:system-ui;background:#0b0f14;color:#e7eef7}
    header{padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.08);display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .pill{padding:6px 10px;border:1px solid rgba(255,255,255,.12);border-radius:999px;font-size:12px;opacity:.95}
    main{padding:14px;display:grid;gap:12px;max-width:900px;margin:0 auto}
    input{width:100%;padding:12px 12px;border-radius:10px;border:1px solid rgba(255,255,255,.12);background:#0f1520;color:#e7eef7}
    .grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px}
    .card{border:1px solid rgba(255,255,255,.10);background:#0f1520;border-radius:12px;padding:12px}
    .muted{opacity:.7;font-size:12px}
    .big{font-size:20px;font-weight:700}
    table{width:100%;border-collapse:collapse;font-size:12px}
    td,th{padding:8px 6px;border-bottom:1px solid rgba(255,255,255,.08);text-align:left}
    .buy{color:#4ade80}
    .sell{color:#fb7185}
    .warn{color:#fbbf24}
    .bad{color:#fb7185}
    a{color:#93c5fd;text-decoration:none}
    a:hover{text-decoration:underline}
    @media (max-width:720px){ .grid{grid-template-columns:1fr} }
    #chart{min-height:260px}
  </style>
</head>
<body>
  <header>
    <div class="pill">DexGuard v0</div>
    <div class="pill" id="chainPill">chain: solana</div>
    <div class="pill" id="statusPill">idle</div>
    <div class="pill muted" id="hintPill">—</div>
  </header>

  <main>
    <div class="card">
      <div class="muted">Token address (paste mint)</div>
      <input id="addr" placeholder="e.g. BONK: DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263" />
      <div class="muted" style="margin-top:8px">
        Worker base:
        <span id="base"></span>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <div class="muted">Price (USD)</div>
        <div class="big" id="price">—</div>
        <div class="muted" id="priceMeta">—</div>
      </div>

      <div class="card">
        <div class="muted">Trades (last fetch)</div>
        <div class="big" id="tradesCount">—</div>
        <div class="muted" id="tradesMeta">—</div>
      </div>

      <div class="card">
        <div class="muted">Candles (15m)</div>
        <div class="big" id="candlesCount">—</div>
        <div class="muted" id="candlesMeta">—</div>
      </div>
    </div>

    <div class="card" id="dsCard">
      <div style="display:flex;gap:12px;align-items:center">
        <img id="dsLogo" alt="" style="width:44px;height:44px;border-radius:10px;display:none;object-fit:cover;border:1px solid rgba(255,255,255,.12)">
        <div style="flex:1">
          <div class="big" id="dsName">—</div>
          <div class="muted" id="dsSub">—</div>
          <div class="muted" id="dsMeta" style="margin-top:6px">—</div>
        </div>
      </div>
      <div class="muted" style="margin-top:10px" id="dsStats">—</div>
      <div class="muted" style="margin-top:8px" id="dsLinks">—</div>
    </div>


    <div class="card">
      <div class="muted" style="margin-bottom:8px">Chart</div>
      <div id="chart" style="height:360px;width:100%"></div>
      <div class="muted" id="chartMeta" style="margin-top:8px">—</div>
    </div>
    <div class="card">
      <div class="muted" style="margin-bottom:8px">Live trades</div>
      <table>
        <thead>
          <tr><th>Time</th><th>Side</th><th>USD</th><th>Price</th><th>Maker</th></tr>
        </thead>
        <tbody id="trades"></tbody>
      </table>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.2.0/dist/lightweight-charts.standalone.production.js"></script>
  <script>
    const WORKER_BASE = "https://flat-grass-9c26solanaonsolana.simon-kaggwa-why.workers.dev";
    const CHAIN = "solana";
    document.getElementById("base").textContent = WORKER_BASE;

    const el = (id) => document.getElementById(id);
    const fmt = (n, d=6) => (Number.isFinite(n) ? n.toFixed(d) : "—");
    const short = (s) => s ? (s.slice(0,4)+"…"+s.slice(-4)) : "—";

    // Display helper used for first render
    const timeAgo = (tSec) => {
      const diff = (Date.now()/1000 - tSec);
      if (!Number.isFinite(diff)) return "—";
      if (diff < 60) return Math.floor(diff) + "s";
      if (diff < 3600) return Math.floor(diff/60) + "m";
      if (diff < 86400) return Math.floor(diff/3600) + "h";
      if (diff < 86400*7) return Math.floor(diff/86400) + "d";
      if (diff < 86400*30) return Math.floor(diff/(86400*7)) + "w";
      if (diff < 86400*365) return Math.floor(diff/(86400*30)) + "mo";
      return Math.floor(diff/(86400*365)) + "y";
    };

    // Live updater: refreshes all "time ago" cells every second (Dexscreener-style)
    function tickAges() {
      const nodes = document.querySelectorAll(".ago[data-ts]");
      const now = Date.now() / 1000;
      for (const n of nodes) {
        const ts = Number(n.getAttribute("data-ts"));
        if (!Number.isFinite(ts)) continue;
        const diff = now - ts;

        let txt = "—";
        if (diff < 60) txt = Math.floor(diff) + "s";
        else if (diff < 3600) txt = Math.floor(diff/60) + "m";
        else if (diff < 86400) txt = Math.floor(diff/3600) + "h";
        else if (diff < 86400*7) txt = Math.floor(diff/86400) + "d";
        else if (diff < 86400*30) txt = Math.floor(diff/(86400*7)) + "w";
        else if (diff < 86400*365) txt = Math.floor(diff/(86400*30)) + "mo";
        else txt = Math.floor(diff/(86400*365)) + "y";

        n.textContent = txt;
      }
    }

    
function refreshAges() {
  const nodes = document.querySelectorAll(".ago[data-ts]");
  for (const n of nodes) {
    const ts = Number(n.getAttribute("data-ts"));
    n.textContent = timeAgo(ts);
  }
}


    // --- Lightweight chart (candles) ---
    let chart = null;
    let candleSeries = null;
    let ro = null;

    // Keep last rendered candles so we can "move" the chart using newest trades between candle refreshes.
    let lastCandleData = [];
    let lastTfSec = 900; // default 15m
    const tfToSec = (tf) => {
      const s = String(tf || "15m").toLowerCase().trim();
      const n = parseInt(s, 10);
      if (Number.isFinite(n)) {
        if (s.endsWith("s")) return n;
        if (s.endsWith("m")) return n * 60;
        if (s.endsWith("h")) return n * 3600;
        if (s.endsWith("d")) return n * 86400;
      }
      return 900;
    };

    function ensureChart() {
      if (chart && candleSeries) return;
      const container = el("chart");
      if (!container || typeof LightweightCharts === "undefined") return;

      container.innerHTML = "";
      const w = Math.max(1, container.clientWidth || 1);
      const h = Math.max(260, container.clientHeight || 360);

      chart = LightweightCharts.createChart(container, {
        width: w,
        height: h,
        layout: { background: { type: "solid", color: "#0f1520" }, textColor: "#e7eef7" },
        grid: { vertLines: { color: "rgba(255,255,255,.06)" }, horzLines: { color: "rgba(255,255,255,.06)" } },
        rightPriceScale: { borderColor: "rgba(255,255,255,.10)" },
        timeScale: { borderColor: "rgba(255,255,255,.10)", timeVisible: true, secondsVisible: false },
        crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
      });

      candleSeries = chart.addCandlestickSeries({
        upColor: "#22c55e",
        downColor: "#ef4444",
        borderUpColor: "#22c55e",
        borderDownColor: "#ef4444",
        wickUpColor: "#22c55e",
        wickDownColor: "#ef4444",
      });

      if (ro) { try { ro.disconnect(); } catch (e) {} }
      ro = new ResizeObserver(() => {
        if (!chart) return;
        const ww = container.clientWidth || 1;
        const hh = container.clientHeight || 360;
        if (ww > 0 && hh > 0) chart.applyOptions({ width: ww, height: hh });
      });
      ro.observe(container);
    }

    function normalizeSec(t) {
      const n = Number(t);
      if (!Number.isFinite(n)) return null;
      if (n > 1e12) return Math.floor(n / 1000);
      return Math.floor(n);
    }

    function renderCandles(items, tfLabel) {
      try {
        ensureChart();
        if (!candleSeries) return;

        const arr = Array.isArray(items) ? items : [];
        const data = [];
        for (const x of arr) {
          const ts = normalizeSec(x.t);
          const o = Number(x.o), h = Number(x.h), l = Number(x.l), c = Number(x.c);
          if (!ts || !Number.isFinite(o) || !Number.isFinite(h) || !Number.isFinite(l) || !Number.isFinite(c)) continue;
          data.push({ time: ts, open: o, high: h, low: l, close: c });
        }
        data.sort((a,b)=>a.time-b.time);
        candleSeries.setData(data);
        lastCandleData = data;
        lastTfSec = tfToSec(tfLabel || \"15m\");
        if (chart) chart.timeScale().fitContent();

        const meta = document.getElementById("chartMeta");
        if (meta) meta.textContent = data.length ? `ok • ${data.length} candles (${tfLabel || "15m"})` : "no candles";
      } catch (e) {
        console.warn("[chart render fail]", e);
        const meta = document.getElementById("chartMeta");
        if (meta) meta.textContent = "chart error";
      }
    }


    function applyTradeToChart(tradePrice, tradeTs) {
      try {
        const px = Number(tradePrice);
        const ts0 = normalizeSec(tradeTs);
        if (!Number.isFinite(px) || !ts0) return;
        if (!candleSeries || !lastCandleData || !lastCandleData.length) return;

        const bucket = Math.floor(ts0 / lastTfSec) * lastTfSec;
        const last = lastCandleData[lastCandleData.length - 1];
        if (!last || !last.time) return;

        if (bucket === last.time) {
          const close = px;
          const upd = {
            time: last.time,
            open: last.open,
            high: Math.max(last.high, close),
            low: Math.min(last.low, close),
            close,
          };
          lastCandleData[lastCandleData.length - 1] = upd;
          candleSeries.update(upd);
        } else if (bucket > last.time) {
          const open = last.close;
          const close = px;
          const upd = {
            time: bucket,
            open,
            high: Math.max(open, close),
            low: Math.min(open, close),
            close,
          };
          lastCandleData.push(upd);
          candleSeries.update(upd);
        }
      } catch (e) {
        // silent
      }
    }

let timer = null;
    let lastAddr = "";
    let inFlight = false;
    let ageTimer = null;

    function ensureAgeTicker() {
      if (ageTimer) return;
      ageTimer = setInterval(tickAges, 1000);
    }

    async function api(path) {
      const full = WORKER_BASE + path;
      let r, text;
      try {
        r = await fetch(full, { cache: "no-store" });
        text = await r.text();
      } catch (e) {
        return { ok:false, http:0, error:"network_error", detail:String(e), url: full };
      }

      let j = null;
      try { j = JSON.parse(text); } catch { /* keep null */ }

      if (!r.ok) {
        return { ok:false, http:r.status, error:"http_error", body:(text||"").slice(0,250), url: full };
      }

      if (j && typeof j === "object") return j;
      return { ok:false, http:r.status, error:"bad_json", body:(text||"").slice(0,250), url: full };
    }

    function setStatus(kind, msg) {
      const s = el("statusPill");
      s.textContent = msg;
      s.className = "pill" + (kind === "bad" ? " bad" : kind === "warn" ? " warn" : "");
    }

    async function tick(addr) {
      if (inFlight) return;
      inFlight = true;

      setStatus("warn", "loading…");
      el("hintPill").textContent = "—";

      // 1) DexScreener first (gives us best pair + fallback price)
const ds = await api(`/api/ds/tokenpairs?chain=${CHAIN}&token=${encodeURIComponent(addr)}`);

// 2) Price + trades in parallel
const [p, t] = await Promise.all([
  api(`/api/price?chain=${CHAIN}&address=${encodeURIComponent(addr)}`),
  api(`/api/trades?chain=${CHAIN}&address=${encodeURIComponent(addr)}&limit=20`)
]);

// 3) Candles: prefer BEST pair from DexScreener (much more reliable), fallback to token mint
let bestPair = null;
if (ds && ds.ok && Array.isArray(ds.pairs) && ds.pairs.length) {
  bestPair = ds.pairs.slice().sort((a,b)=> (b?.liquidity?.usd||0) - (a?.liquidity?.usd||0))[0] || null;
}
const pairAddr = bestPair?.pairAddress || "";
let c = null;
if (pairAddr) {
  c = await api(`/api/candles?chain=${CHAIN}&pair=${encodeURIComponent(pairAddr)}&tf=15m&limit=200`);
  if (!(c && c.ok)) {
    c = await api(`/api/candles?chain=${CHAIN}&address=${encodeURIComponent(addr)}&tf=15m&limit=200`);
  }
} else {
  c = await api(`/api/candles?chain=${CHAIN}&address=${encodeURIComponent(addr)}&tf=15m&limit=200`);
}

      // PRICE (prefer Birdeye; fallback to DexScreener pair priceUsd)
const dsPrice = (bestPair && bestPair.priceUsd != null) ? Number(bestPair.priceUsd) : null;

if (p && p.ok && p.price != null) {
  el("price").textContent = fmt(Number(p.price), 8);
  el("priceMeta").textContent = "ok";
} else if (dsPrice != null && Number.isFinite(dsPrice)) {
  el("price").textContent = fmt(dsPrice, 8);
  el("priceMeta").textContent = "fallback: dexscreener";
} else {
  el("price").textContent = "—";
  el("priceMeta").textContent = p ? (`fail (${p.http||"?"})`) : "fail";
  console.warn("[price fail]", p);
}


      // TRADES
      if (t && t.ok) {
        el("tradesCount").textContent = String(t.count ?? (t.items?.length ?? 0));
        el("tradesMeta").textContent = "ok";
        const rows = (t.items || []).map(x => `
          <tr>
            <td class="muted ago" data-ts="${Number(x.t)}">${timeAgo(Number(x.t))}</td>
            <td class="${x.side === "buy" ? "buy" : (x.side === "sell" ? "sell" : "")}">${x.side || "—"}</td>
            <td>$${fmt(Number(x.usd), 4)}</td>
            <td>${fmt(Number(x.price), 10)}</td>
            <td class="muted">${short(x.maker)}</td>
          </tr>
        `).join("");
        el("trades").innerHTML = rows;
        tickAges(); // immediate refresh so it feels live right away
              // Move the chart using newest trade price (between candle refreshes)
        try {
          const it = Array.isArray(t.items) ? t.items : [];
          if (it.length) {
            const latest = it.reduce((a,b)=> (Number(b?.t||0) > Number(a?.t||0) ? b : a), it[0]);
            if (latest) applyTradeToChart(latest.price, latest.t);
          }
        } catch (e) {}
      } else {
        el("tradesCount").textContent = "—";
        el("tradesMeta").textContent = t ? (`fail (${t.http||"?"})`) : "fail";
        el("trades").innerHTML = "";
        console.warn("[trades fail]", t);
      }

      // CANDLES
      if (c && c.ok) {
        el("candlesCount").textContent = String(c.count ?? (c.items?.length ?? 0));
        el("candlesMeta").textContent = "ok";
        renderCandles(c.items || [], c.tf || "15m");
      } else {
        // If we already have candle data rendered, keep the chart and mark it as stale instead of "fail"
        if (Array.isArray(lastCandleData) && lastCandleData.length) {
          el("candlesCount").textContent = String(lastCandleData.length);
          el("candlesMeta").textContent = "stale";
          const cm = document.getElementById("chartMeta"); if (cm) cm.textContent = "stale";
        } else {
          el("candlesCount").textContent = "—";
          el("candlesMeta").textContent = c ? (`fail (${c.http||"?"})`) : "fail";
          const cm = document.getElementById("chartMeta"); if (cm) cm.textContent = c ? (`fail (${c.http||"?"})`) : "fail";
          console.warn("[candles fail]", c);
        }

      }

      // DEXSCREENER
      if (ds && ds.ok && Array.isArray(ds.pairs) && ds.pairs.length) {
        // pick best pair: highest liquidity.usd
        const best = ds.pairs.slice().sort((a,b)=> (b?.liquidity?.usd||0) - (a?.liquidity?.usd||0))[0];

        const name = best?.baseToken?.name || "—";
        const sym = best?.baseToken?.symbol || "—";
        const dex = best?.dexId || "—";
        const pair = best?.pairAddress || "—";
        const quoteSym = best?.quoteToken?.symbol || "";

        el("dsName").textContent = `${name} (${sym})`;
        el("dsSub").textContent = `${sym}/${quoteSym}`.trim();

        const liq = best?.liquidity?.usd;
        const fdv = best?.fdv;
        const mcap = best?.marketCap;
        const vol24 = best?.volume?.h24;
        const ch24 = best?.priceChange?.h24;

        el("dsMeta").textContent = `dex: ${dex} • pair: ${pair.slice(0,4)}…${pair.slice(-4)}`;

        el("dsStats").textContent =
          `Liquidity: $${Number(liq||0).toLocaleString()} • FDV: $${Number(fdv||0).toLocaleString()} • MCap: $${Number(mcap||0).toLocaleString()} • Vol 24h: $${Number(vol24||0).toLocaleString()} • 24h: ${ch24 ?? "—"}%`;

        // logo (if present)
        const img = best?.info?.imageUrl || best?.imageUrl || null;
        const logoEl = el("dsLogo");
        if (img) {
          logoEl.src = img;
          logoEl.style.display = "";
        } else {
          logoEl.style.display = "none";
          logoEl.removeAttribute("src");
        }

        // links
        const links = [];
        const websites = best?.info?.websites || [];
        const socials = best?.info?.socials || [];
        for (const w of websites) if (w?.url) links.push(`<a href="${w.url}" target="_blank" rel="noreferrer">Website</a>`);
        for (const s of socials) if (s?.url) links.push(`<a href="${s.url}" target="_blank" rel="noreferrer">${s.type || "Social"}</a>`);
        el("dsLinks").innerHTML = links.length ? ("Links: " + links.join(" • ")) : "Links: —";

      } else {
        el("dsName").textContent = "—";
        el("dsSub").textContent = "—";
        el("dsMeta").textContent = ds ? (`fail (${ds.http||"?"})`) : "fail";
        el("dsStats").textContent = "—";
        el("dsLinks").textContent = "Links: —";
        el("dsLogo").style.display = "none";
        console.warn("[dexscreener fail]", ds);
      }

      // Overall status (don't scream "error" if core live feed is ok)
const bad = [];
if (!(t && t.ok)) bad.push("trades");
if (!(ds && ds.ok)) bad.push("dexscreener");

const soft = [];
if (!(p && p.ok) && !(dsPrice != null)) soft.push("price");
if (!(c && c.ok)) soft.push("candles");

if (bad.length === 0 && soft.length === 0) {
  setStatus("", "live");
  el("hintPill").textContent = "all ok";
} else if (bad.length === 0 && soft.length > 0) {
  setStatus("warn", "live");
  el("hintPill").textContent = "degraded: " + soft.join(", ");
} else {
  setStatus("bad", "error");
  el("hintPill").textContent = "failed: " + bad.concat(soft).join(", ");
}

inFlight = false;
    }

    function start(addr) {
      if (!addr || addr.length < 20) return;
      lastAddr = addr;
      if (timer) clearInterval(timer);

      ensureAgeTicker();
      tick(addr);
      timer = setInterval(() => tick(lastAddr), 2000);
      // update time-ago labels smoothly
      if (!window.__ageTimer) window.__ageTimer = setInterval(refreshAges, 1000);
    }

    el("addr").addEventListener("change", (e) => start(e.target.value.trim()));
    el("addr").value = "DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263";
    start(el("addr").value.trim());
  </script>
</body>
</html>
