<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#070711" />
  <title>$SOS — Guardian Check (Multi-Chain)</title>
  <meta name="description" content="Guardian Approved — token risk score + launch readiness checklist (on-chain verifiable)." />

  <style>
    :root{
      --bg:#070711;
      --panel: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --g:#14F195;
      --c:#00D1FF;
      --p:#9945FF;
      --radius: 22px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --max: 1180px;

      /* brand-ish extras (for icons + report) */
      --sol-g1:#14F195;
      --sol-g2:#00D1FF;
      --sol-g3:#9945FF;

      --bnb-yellow:#F0B90B;
      --base-blue:#0052FF;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--text);
      font: 15.5px/1.55 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: var(--bg);
      position:relative;
      overflow-x:hidden;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      z-index:-1;
      pointer-events:none;
      background:
        radial-gradient(1200px 700px at 10% 5%, rgba(153,69,255,.22), transparent 60%),
        radial-gradient(1000px 650px at 90% 10%, rgba(20,241,149,.18), transparent 55%),
        radial-gradient(900px 600px at 70% 85%, rgba(0,209,255,.14), transparent 55%),
        var(--bg);
      transform: translateZ(0);
    }
    a{color:inherit; text-decoration:none}
    .wrap{max-width:var(--max); margin:0 auto; padding:0 18px; width:100%;}
    main{padding:22px 0 42px}
    .topbar{
      position:sticky;
      top:0;
      z-index:20;
      backdrop-filter: blur(14px);
      background: rgba(7,7,17,.62);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .row{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:12px 0;
      flex-wrap:wrap;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      min-width: 260px;
      user-select:none;
    }
    .brand img{
      width:40px;
      height:40px;
      object-fit:contain;
      filter: drop-shadow(0 10px 25px rgba(0,0,0,.45));
    }
    .bt{display:flex; flex-direction:column; line-height:1.05}
    .bt .t{font-weight:1000; letter-spacing:-.2px; font-size:16px}
    .bt .s{font-weight:850; color:var(--muted); font-size:12.5px}
    .tokenBadge{display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.05);margin-top:8px}
    .tokenImgWrap{position:relative;width:34px;height:34px;flex:0 0 auto}
    .tokenImg{width:34px;height:34px;border-radius:12px;object-fit:cover;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10);display:block}
    .tokenFallback{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-weight:1000;letter-spacing:.04em;color:rgba(255,255,255,.92);background:rgba(255,255,255,.08)}
    .tokenTxt{display:flex;flex-direction:column;line-height:1.1}
    .tokenSym{font-weight:1000;letter-spacing:.02em;font-size:12.5px}
    .tokenNm{font-size:12px;color:rgba(255,255,255,.70);max-width:220px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
      width:100%;
    }
    @media (min-width: 980px){
      .actions{width:auto}
    }
    .btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:9px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      font-weight:950;
      font-size:13px;
      transition: .15s ease;
      user-select:none;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      white-space:nowrap;
    }
    .btn:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .btn.grad{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .btn[disabled]{opacity:.55; pointer-events:none}
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.05));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .inner{padding:22px}
    .hero{
      position:relative;
      overflow:hidden;
      isolation:isolate;
    }
    .hero::before{
      content:"";
      position:absolute;
      inset:-70px -40px;
      background:
        radial-gradient(900px 520px at 18% 28%, rgba(20,241,149,.16), transparent 60%),
        radial-gradient(900px 520px at 82% 20%, rgba(0,209,255,.12), transparent 60%),
        radial-gradient(900px 520px at 70% 86%, rgba(153,69,255,.14), transparent 60%);
      z-index:0;
      pointer-events:none;
    }
    .hero > *{position:relative; z-index:1}
    .h1{
      margin:0;
      font-weight:1000;
      letter-spacing:-1px;
      line-height:1.05;
      font-size: clamp(36px, 4.6vw, 62px);
    }
    .gradText{
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;
    }
    .sub{
      margin-top:10px;
      color: rgba(255,255,255,.76);
      font-weight:850;
      max-width: 940px;
    }
    .classified{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .stamp{
      font-weight:1000;
      font-size:12px;
      letter-spacing: .45px;
      text-transform:uppercase;
      color: rgba(255,255,255,.76);
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius: 999px;
      padding:7px 10px;
    }
    .layout{
      margin-top:16px;
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 980px){
      .layout{grid-template-columns:1fr}
    }

    @media (max-width: 980px){
      .wrap{ padding: 0 14px; }
      .inner{ padding: 16px; }
      .panel{ padding: 14px; }
      .brand{ min-width: 0; width: 100%; }
      .actions{ width: 100%; justify-content: flex-start; }
      .actions .btn{ width: 100%; justify-content: center; padding: 12px 14px; font-size: 14px; }
      .resultTop{ flex-direction: column; align-items: stretch; }
      .resultTop > div:last-child{ width: 100%; justify-content: flex-start; }
      .resultTop .badge{ width: fit-content; }
      .tokenHead{ flex-wrap: nowrap; }
      .tokenName{ font-size: 18px; }
      .tokenSymbol{ font-size: 13px; }
      .metricV{
      margin-top:8px;
      font-weight:1000;
      font-size:22px;
      line-height:1.15;
      display:block;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
      .metricK{ flex-wrap: wrap; gap: 8px; }
      .metricK .badge{ margin-left: auto; }
      .li{ flex-direction: column; align-items: flex-start; gap: 10px; }
      .pillRow{ width:100%; justify-content:flex-start; flex-wrap:wrap; }
      .copyBox{ flex-direction: column; align-items: flex-start; gap: 10px; }
      .modal{ width:100%; }
      .toast{ left:14px; right:14px; transform:none; width:auto; }
    }

    .panel{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 18px;
      padding:16px;
      overflow:hidden;
    }
    label{
      display:block;
      font-weight:950;
      font-size:12.5px;
      letter-spacing:.35px;
      color: rgba(255,255,255,.82);
      margin-bottom:8px;
    }
    input{
      width:100%;
      padding:14px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.92);
      outline:none;
      font-weight:900;
      letter-spacing:.2px;
      font-size:16px;
      max-width:100%;
    }
    input:focus{
      border-color: rgba(0,209,255,.45);
      box-shadow: 0 0 0 3px rgba(0,209,255,.12);
    }
    .statusLine{
      margin-top:12px;
      color: rgba(255,255,255,.72);
      font-weight:900;
      min-height: 18px;
      font-size:13px;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:7px 11px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
    }
    .badge.good{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}
    .badge.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .badge.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}
    .badge.good::before{content:"✓";margin-right:6px;font-weight:1100}
    .badge.warn::before{content:"✕";margin-right:6px;font-weight:1100}
    .badge.bad::before{content:"✕";margin-right:6px;font-weight:1100}
    .resultTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .resultTitle{
      margin:0;
      font-weight:1000;
      font-size:22px;
      letter-spacing:-.4px;
    }
    .mono{
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-weight:900;
      color: rgba(255,255,255,.86);
      margin-top:6px;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .tokenHead{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:10px;
      min-width:0;
    }
    .tokenLogoWrap{
      width:44px;
      height:44px;
      border-radius:12px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      display:none;
      flex:0 0 auto;
    }
    .tokenLogoWrap img{ width:100%; height:100%; object-fit:cover; display:block; }
    .tokenName{
      font-weight:1000;
      font-size:16px;
      letter-spacing:-.2px;
      line-height:1.15;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .tokenSymbol{
      margin-top:2px;
      color: rgba(255,255,255,.70);
      font-weight:900;
      font-size:12.5px;
    }
    .metricStack{margin-top:12px; display:grid; gap:10px;}
    .metric{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      border-radius: 16px;
      padding:12px 12px;
    }
    .metricK{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      color: rgba(255,255,255,.70);
      font-weight:1000;
      font-size:12px;
      letter-spacing:.45px;
      text-transform:uppercase;
    }
    .metricV{
      margin-top:8px;
      font-weight:1000;
      font-size:20px;
      line-height:1.15;
      display:block;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .metricMini{
      margin-top:6px;
      font-weight:850;
      font-size:12px;
      color: rgba(255,255,255,.62);
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .bar{
      margin-top:10px;
      height:12px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .bar > div{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      border-radius:999px;
      transition: width .25s ease;
    }
    .list{
      margin:10px 0 0;
      padding:0;
      list-style:none;
      display:grid;
      gap:10px;
    }
    .li{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      border-radius: 16px;
      padding:12px 12px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      min-width:0;
    }
    .li .left{min-width:0;}
    .li .t{font-weight:1000; font-size:13px; letter-spacing:.2px;}
    .li .d{
      margin-top:4px;
      color: rgba(255,255,255,.70);
      font-weight:750;
      font-size:12.5px;
      line-height:1.35;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    .pillRow{
      display:flex;
      gap:8px;
      align-items:center;
      flex:0 0 auto;
      justify-content:flex-end;
    }
    .pill{
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor:pointer;
    }
    .pill.ok{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}
    .pill.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .pill.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}
    .pill.ok::before{content:"✓";margin-right:6px;font-weight:1100}
    .pill.warn::before{content:"✕";margin-right:6px;font-weight:1100}
    .pill.bad::before{content:"✕";margin-right:6px;font-weight:1100}
    .infoBtn{
      width:26px;
      height:26px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.86);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      font-weight:1000;
      font-size:13px;
      line-height:1;
      -webkit-tap-highlight-color: transparent;
    }
    .infoBtn:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }
    .infoBtn:active{ transform: translateY(0px); }
    .infoBtn span{ transform: translateY(-0.5px); }

    .explorerBtn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .explorerBtn:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }

    footer{
      padding: 18px 0 34px;
      color: rgba(255,255,255,.45);
      font-weight:650;
      text-align:center;
      font-size:12px;
    }

    .modalWrap{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:100;
    }
    .modal{
      width:min(920px, 100%);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(7,7,17,.92);
      box-shadow: 0 16px 50px rgba(0,0,0,.5);
      overflow:hidden;
    }
    .modalHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .modalTitle{ font-weight:1000; letter-spacing:-.3px; }
    .modalBody{
      padding:14px 16px 16px;
      color: rgba(255,255,255,.84);
      font-weight:850;
      line-height:1.5;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    .chainRow{
      margin-top:10px;
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .chainBtn{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      user-select:none;
      font-weight:1000;
      font-size:13px;
      color: rgba(255,255,255,.88);
      -webkit-tap-highlight-color: transparent;
    }
    .chainBtn:hover{ background: rgba(255,255,255,.10); }
    .chainBtn.active{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .chainIcon{
      width:18px;
      height:18px;
      border-radius:6px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      flex:0 0 auto;
    }
    .chainIcon svg{ width:18px; height:18px; display:block; }
    .chainBtn .chainIcon svg{ color: rgba(255,255,255,.92); }
    .chainBtn.active .chainIcon{ background: rgba(0,0,0,.18); border-color: rgba(255,255,255,.25); }
    .chainBtn.active .chainIcon svg{ color:#fff; }

    .chainMiniHint{
      margin-top:10px;
      font-size:12.5px;
      color: rgba(255,255,255,.62);
      font-weight:850;
      line-height:1.35;
    }

    .toast{
      position:fixed;
      top: max(16px, env(safe-area-inset-top));
      left:50%;
      transform:translateX(-50%);
      width:min(920px, calc(100% - 28px));
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(7,7,17,.90);
      box-shadow: 0 16px 50px rgba(0,0,0,.45);
      padding:14px 14px;
      display:none;
      z-index:120;
      backdrop-filter: blur(12px);
    }
    .toastRow{display:flex; align-items:center; justify-content:space-between; gap:12px;}
    .toastTitle{font-weight:1000; font-size:18px; letter-spacing:-.3px;}
    .toastClose{
      padding:9px 12px;
      border-radius:999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      font-weight:950;
      cursor:pointer;
    }
    .toastClose:hover{background: rgba(255,255,255,.10);}

    @media (prefers-reduced-motion: reduce){
      .btn:hover{transform:none}
      .bar > div{transition:none}
      .infoBtn:hover{transform:none}
      .explorerBtn:hover{transform:none}
    }
  

    /* ===== PRO: Bubble Map / Clusters ===== */
    .split2{display:grid; grid-template-columns: 1.05fr .95fr; gap:16px; align-items:start;}
    @media (max-width: 980px){ .split2{grid-template-columns:1fr;} }
    .bubbleWrap{border:1px solid rgba(255,255,255,.10); background: rgba(0,0,0,.14); border-radius: 18px; padding:12px; overflow:hidden;}
    .bubbleHead{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-bottom:10px;}
    .bubbleLegend{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .legendPill{padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.06); font-weight:950; font-size:12px;}
    canvas#bubbleCanvas{width:100%; height:420px; display:block; border-radius: 14px; background: rgba(0,0,0,.22); border:1px solid rgba(255,255,255,.10);}
    @media (max-width: 980px){ canvas#bubbleCanvas{height:360px;} }
    .miniNote{color: rgba(255,255,255,.62); font-weight:850; font-size:12.5px; line-height:1.35;}



    /* Bubblemap external actions */
    .bubbleActions{display:flex;justify-content:flex-end;gap:10px;margin-top:10px;flex-wrap:wrap}
    .bubbleActions .btn{padding:9px 12px;font-size:13px}
    .bubbleActions .btn.ghost{background:rgba(255,255,255,.06)}
    .bubbleActions .btn.ghost:hover{background:rgba(255,255,255,.10)}

</style>
</head>

<body>
  <!-- Toast -->
  <div class="toast" id="toast">
    <div class="toastRow">
      <div class="toastTitle" id="toastTitle">—</div>
      <button class="toastClose" id="toastClose" type="button">Close</button>
    </div>
  </div>

  <div class="topbar">
    <div class="wrap">
      <div class="row">
        <div class="brand">
          <img src="/assets/logo.png" alt="$SOS" onerror="this.style.display='none'">
          <div class="bt">
            <div class="t">$SOS</div>
            <div class="s">Contract Scanner • Token Risk</div>
          </div>
        </div>

        <div class="actions">
          <a class="btn" href="https://solanax1.com/" rel="noreferrer">← Back to Main</a>
          <button class="btn grad" id="btnScan" type="button" onclick="runScan()">Run Guardian Check</button>
          <button class="btn grad" id="btnExport" type="button" disabled>Download Scan Report</button>
        </div>
      </div>
    </div>
  </div>

  <main class="wrap">
    <section class="card hero">
      <div class="inner">
        <div class="classified">
          <div class="stamp">GUARDIAN SYSTEM • MAINNET • BEST-EFFORT VERIFIED</div>
          <div class="stamp" id="stampTime">—</div>
        </div>

        <h1 class="h1" style="margin-top:12px;">
          <span class="gradText">Guardian Contract</span> Scanner
        </h1>

        <div class="sub">
          Multi-chain scan: Solana + ETH + BNB + Base.
          <br/>
        </div>

        <div class="layout">
          <!-- INPUT -->
          <div class="panel">
            <label>Choose Chain</label>
            <div class="chainRow" id="chainRow"></div>
            <div class="chainMiniHint" id="chainHint">—</div>

            <label for="mint" style="margin-top:14px;" id="addrLabel">Token Address</label>
            <input id="mint" placeholder="Paste token address..." autocomplete="off" spellcheck="false" inputmode="text" />
            <button class="btn grad" id="btnScanInline" type="button" onclick="runScan()" style="width:100%; margin-top:12px;">Run Guardian Check</button>
            <div class="statusLine" id="status"></div>
          </div>

          <!-- RESULTS -->
          <div class="panel" id="resultsPanel">
            <div class="resultTop">
              <div style="min-width:0">
                <div class="tokenHead">
                  <div class="tokenLogoWrap" id="tokenLogoWrap"><img id="tokenLogo" alt=""></div>
                  <div style="min-width:0">
                    <div class="tokenName" id="tokenName">—</div>
                    <div class="tokenSymbol" id="tokenSymbol">—</div>
                  </div>
                </div>

                <h3 class="resultTitle" id="verdictTitle">—</h3>
                <div class="mono" id="mintShort">—</div>
              </div>

              <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                <span class="badge" id="verdictBadge">—</span>
                <span class="badge good" id="scoreBadge">—</span>
              </div>
            </div>

            <div class="metricStack" id="metrics"></div>
            <div class="statusLine" id="summary">—</div>
          </div>
        </div>

        <!-- Checks -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">GUARDIAN CHECKS</div>
            <div class="stamp" id="scanHint">—</div>
          </div>
          <ul class="list" id="checksList" style="margin-top:10px;"></ul>
        </div>

        <!-- Launch readiness -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">MARKET / DEX</div>
            <div class="stamp">LIVE DATA</div>
          </div>
          <ul class="list" id="todoList" style="margin-top:10px;"></ul>
        </div>

        <!-- Token standard details -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">CONTRACT FLAGS</div>
            <div class="stamp">BEST-EFFORT</div>
          </div>
          <ul class="list" id="extList" style="margin-top:10px;"></ul>
        </div>

        <!-- Metadata -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOKEN METADATA</div>
            <div class="stamp">RPC / BEST-EFFORT</div>
          </div>
          <ul class="list" id="metaList" style="margin-top:10px;"></ul>
        </div>

        <!-- Top holders -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOP HOLDERS (PREVIEW)</div>
            <div class="stamp" id="holdersStamp">MAINNET</div>
          </div>
          <ul class="list" id="holdersList" style="margin-top:10px;"></ul>
        </div>

        <!-- Bubble Map + Clusters (Solana best-effort) -->
        <div class="panel" style="margin-top:16px;" id="bubblePanel">
          <div class="classified">
            <div class="stamp">BUBBLE MAP</div>
            <div class="stamp" id="bubbleStamp">SOLANA • TOP HOLDERS + FLOWS</div>
          </div>
          <div class="bubbleWrap" style="margin-top:10px;">
            <div class="bubbleHead">
              <div class="miniNote" id="bubbleHint">—</div>
              <div class="bubbleLegend" id="bubbleLegend"></div>
              <div class="bubbleActions" id="bubbleActions">
                <button class="btn ghost" id="bubbleOpenExternal" type="button" onclick="openBubblemapsModal()">Open BubbleMap (DexScreener style)</button>
              </div>
            </div>
            <canvas id="bubbleCanvas" width="1100" height="420"></canvas>
            <div class="miniNote" id="bubbleNote" style="margin-top:10px;">Drag nodes • Click opens explorer • Size = holder % (or sample share if no holder list). Links = sampled recent transfers.</div>
          </div>
        </div>

        <div class="split2" style="margin-top:16px;">
          <div class="panel">
            <div class="classified">
              <div class="stamp">CLUSTERS</div>
              <div class="stamp">CONNECTED WALLETS</div>
            </div>
            <ul class="list" id="clusterList" style="margin-top:10px;"></ul>
          </div>

          <div class="panel">
            <div class="classified">
              <div class="stamp">BUNDLES</div>
              <div class="stamp">SAME-TX DISTRIBUTIONS</div>
            </div>
            <ul class="list" id="bundleList" style="margin-top:10px;"></ul>
          </div>
        </div>

      </div>
    </section>

    <footer>© <span id="y"></span> $SOS • Guardian Check</footer>
  </main>

  <!-- Modal -->
  <div class="modalWrap" id="modalWrap" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle" id="modalTitle">Guardian Details</div>
        <button class="btn" id="modalClose" type="button">Close</button>
      </div>
      <div class="modalBody" id="modalBody"></div>
    </div>
  </div>

  <script>
  /* =========================================================
     GUARDIAN CHECK v2.4 — CLEAN SINGLE-FILE (UPDATED)
     Fixes included in this update (your requests):
     ✅ Chain logos now "original-looking" (Solana/BNB/Base improved SVG)
     ✅ EVM "No signal" spam will be hidden/cleaned (implemented in later parts)
     ✅ Export report will be a branded HTML report (implemented in later parts)
     ========================================================= */

  /* ===================== CONFIG ===================== */
  const CFG = {
    HELIUS_KEY: "b566a086-57d4-4433-8661-faed9ad07ba0",

    // Optional: Moralis for EVM logos/metadata:
    EVM_METADATA_KEY: "",

    // Optional: Covalent GoldRush (holders for EVM)
    GOLDRUSH_API_KEY: "cqt_rQVTMTXwYkPJBrwf7ff6JWmdkywR",

    TOKEN_PROGRAM: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
    TOKEN_2022_PROGRAM: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",

    CHAINS: [
      { id:"sol",  name:"Solana",   kind:"solana", stamp:"MAINNET",    addrLabel:"Token Mint Address",      placeholder:"Paste token mint (Solana)..." },
      { id:"eth",  name:"Ethereum", kind:"evm",    chainId:1,  stamp:"ETH MAINNET",  addrLabel:"Token Contract Address", placeholder:"Paste ERC-20 contract (0x...)" },
      { id:"bnb",  name:"BNB",      kind:"evm",    chainId:56, stamp:"BNB MAINNET",  addrLabel:"Token Contract Address", placeholder:"Paste BEP-20 contract (0x...)" },
      { id:"base", name:"Base",     kind:"evm",    chainId:8453, stamp:"BASE MAINNET", addrLabel:"Token Contract Address", placeholder:"Paste Base token contract (0x...)" }
    ],



    EVM_RPCS: {
      1:    ["https://ethereum.publicnode.com", "https://rpc.ankr.com/eth",  "https://eth.llamarpc.com", "https://cloudflare-eth.com"],
      56:   ["https://bsc.publicnode.com",      "https://rpc.ankr.com/bsc",  "https://bsc-dataseed.binance.org"],
      8453: ["https://base.publicnode.com",     "https://rpc.ankr.com/base", "https://mainnet.base.org"]
    },

    /* NEW (v2.4): Clean UI toggles (no features removed — just display rules) */
   UI: {
  SHOW_PASS_DETAILS_EVM: false,
  SHOW_NO_SIGNAL_METRICS: false,

  // ✅ Logo für Export-Report (funktioniert auch lokal)
  REPORT_LOGO_URL: "https://solanax1.com/assets/logo.png"
},
    

    /* NEW (v2.4): export options */
    EXPORT: {
      // "html" looks like your website (branded) — requested.
      // "txt" keeps old text export available as fallback (still in code).
      DEFAULT_FORMAT: "html"
    }
  };

  /* ===================== ICONS (UPDATED: more original-looking) ===================== */
  const ICONS = {
    /* Solana: proper 3-bar look with gradient */
    sol: `
      <svg viewBox="0 0 64 64" aria-hidden="true">
        <defs>
          <linearGradient id="solg" x1="0" y1="0" x2="1" y2="1">
            <stop offset="0" stop-color="${getComputedStyle(document.documentElement).getPropertyValue('--sol-g1').trim() || '#14F195'}"/>
            <stop offset="0.5" stop-color="${getComputedStyle(document.documentElement).getPropertyValue('--sol-g2').trim() || '#00D1FF'}"/>
            <stop offset="1" stop-color="${getComputedStyle(document.documentElement).getPropertyValue('--sol-g3').trim() || '#9945FF'}"/>
          </linearGradient>
        </defs>
        <path d="M14 18c1.6-1.8 3.5-2.7 5.7-2.7h33.6c3.3 0 5 4 2.8 6.5l-6.1 6.8c-1.6 1.8-3.5 2.7-5.7 2.7H10.7c-3.3 0-5-4-2.8-6.5L14 18Z" fill="url(#solg)"/>
        <path d="M14 38.9c1.6-1.8 3.5-2.7 5.7-2.7h33.6c3.3 0 5 4 2.8 6.5l-6.1 6.8c-1.6 1.8-3.5 2.7-5.7 2.7H10.7c-3.3 0-5-4-2.8-6.5L14 38.9Z" fill="url(#solg)" opacity=".7"/>
        <path d="M50 28.5c-1.6 1.8-3.5 2.7-5.7 2.7H10.7c-3.3 0-5-4-2.8-6.5L14 17.9c1.6-1.8 3.5-2.7 5.7-2.7h33.6c3.3 0 5 4 2.8 6.5L50 28.5Z" fill="url(#solg)" opacity=".9"/>
      </svg>
    `,

    /* Ethereum: clean diamond */
    eth: `
      <svg viewBox="0 0 64 64" aria-hidden="true">
        <path d="M32 6l16 26-16 9-16-9L32 6Z" fill="#ffffff" opacity=".95"/>
        <path d="M32 58l16-22-16 9-16-9 16 22Z" fill="#ffffff" opacity=".75"/>
      </svg>
    `,

    /* BNB: official-like geometric mark in yellow */
    bnb: `
      <svg viewBox="0 0 64 64" aria-hidden="true">
        <path fill="${getComputedStyle(document.documentElement).getPropertyValue('--bnb-yellow').trim() || '#F0B90B'}"
          d="M32 6l8.6 8.6L32 23.2l-8.6-8.6L32 6Zm15.4 15.4L56 30l-8.6 8.6-8.6-8.6L47.4 21.4ZM16.6 21.4 25.2 30l-8.6 8.6L8 30l8.6-8.6ZM32 32.8l8.6 8.6L32 50l-8.6-8.6L32 32.8Zm0-6.9 5.1 5.1L32 36.2 26.9 31 32 25.9Z"/>
      </svg>
    `,

    /* Base: blue circle with white "b" (clean) */
    base: `
      <svg viewBox="0 0 64 64" aria-hidden="true">
        <circle cx="32" cy="32" r="26" fill="${getComputedStyle(document.documentElement).getPropertyValue('--base-blue').trim() || '#0052FF'}"/>
        <path d="M27.5 22h8.1c6.2 0 11.2 5 11.2 11.1S41.8 44.2 35.6 44.2h-8.1V22Zm5.3 5.1v12h2.4c3.3 0 6-2.7 6-6s-2.7-6-6-6h-2.4Z"
              fill="#fff"/>
      </svg>
    `
  };

  /* ===================== SAFE DOM HELPERS ===================== */
  const qs = (id) => document.getElementById(id);
  const setText = (id, v) => { const el = qs(id); if (el) el.textContent = (v ?? ""); };
  const setHTML = (id, v) => { const el = qs(id); if (el) el.innerHTML = (v ?? ""); };
  const on = (id, ev, fn) => { const el = qs(id); if (el) el.addEventListener(ev, fn); };

  const esc = (x) => String(x ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;");

  /* ===================== GLOBAL STATE ===================== */
  let activeChain = CFG.CHAINS[0];
  let LAST_SCAN = null;
  let SCANNING = false;

  /* ===================== UTIL ===================== */
  function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }
  function shortAddr(a){ return a ? (a.slice(0,4) + "…" + a.slice(-4)) : "—"; }
  function fmtInt(n){
    if (n === null || n === undefined || Number.isNaN(n)) return "—";
    try { return new Intl.NumberFormat("en-US").format(Math.round(Number(n))); }
    catch { return String(n); }
  }
  function fmtPct(n){
    if (n === null || n === undefined || Number.isNaN(n)) return "—";
    return `${Number(n).toFixed(2)}%`;
  }
  
  // ===================== LIVE MARKET DATA (DexScreener) =====================
  function safeNum(x){
    const n = Number(x);
    return Number.isFinite(n) ? n : null;
  }

  async function fetchJsonWithTimeout(url, ms=8500){
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), ms);
    try{
      const r = await fetch(url, {signal: ctrl.signal});
      clearTimeout(t);
      if(!r.ok) throw new Error(`HTTP ${r.status}`);
      return await r.json();
    }finally{
      clearTimeout(t);
    }
  }

  async function fetchDexScreener(tokenAddr){
    // Works for Solana mints and EVM token contracts
    const url = `https://api.dexscreener.com/latest/dex/tokens/${tokenAddr}`;
    const j = await fetchJsonWithTimeout(url, 9000);
    const pairs = Array.isArray(j?.pairs) ? j.pairs : [];
    if(!pairs.length) return null;

    // choose the most liquid pair
    pairs.sort((a,b) => (safeNum(b?.liquidity?.usd) || 0) - (safeNum(a?.liquidity?.usd) || 0));
    const p = pairs[0];

    const out = {
      dexId: p?.dexId || '',
      chainId: p?.chainId || '',
      pairAddress: p?.pairAddress || '',
      url: p?.url || '',
      priceUsd: safeNum(p?.priceUsd),
      fdv: safeNum(p?.fdv),
      marketCap: safeNum(p?.marketCap),
      liquidityUsd: safeNum(p?.liquidity?.usd),
      volume24h: safeNum(p?.volume?.h24),
      txns24h: safeNum(p?.txns?.h24 ? (safeNum(p.txns.h24.buys)||0) + (safeNum(p.txns.h24.sells)||0) : null),
      baseToken: p?.baseToken || null,
      quoteToken: p?.quoteToken || null,
      info: p?.info || null,
      rawPair: p
    };
    out.pairsAll = pairs;
    return out;  }

  function money(n){
    if(n === null || n === undefined || Number.isNaN(n)) return '—';
    try{
      const abs = Math.abs(Number(n));
      if(abs >= 1e9) return '$' + (Number(n)/1e9).toFixed(2) + 'B';
      if(abs >= 1e6) return '$' + (Number(n)/1e6).toFixed(2) + 'M';
      if(abs >= 1e3) return '$' + (Number(n)/1e3).toFixed(2) + 'K';
      return '$' + new Intl.NumberFormat('en-US',{maximumFractionDigits:2}).format(Number(n));
    }catch{
      return String(n);
    }
  }

  function priceUsdFmt(n){
    if(n === null || n === undefined || Number.isNaN(n)) return '—';
    const num = Number(n);
    if(num === 0) return '$0';
    const dec = num < 0.01 ? 8 : (num < 1 ? 6 : 4);
    return '$' + num.toFixed(dec).replace(/0+$/,'').replace(/\.$/,'');
  }

  function normalizeAddr(a){
    return String(a||'').toLowerCase();
  }

  function isBurnAddr(a){
    const x = normalizeAddr(a);
    return x === '0x0000000000000000000000000000000000000000' || x === '0x000000000000000000000000000000000000dead' || x === '0x0000000000000000000000000000000000000001';
  }

  function encodeAddrParam(addr){
    const a = normalizeAddr(addr).replace(/^0x/,'');
    return a.padStart(64,'0');
  }

  function encAbiCall(selectorNo0x, args){
    // selectorNo0x: '70a08231' or '0x70a08231'
    const sel = String(selectorNo0x||'').replace(/^0x/i,'').padStart(8,'0').slice(0,8);
    let data = '0x' + sel;
    const a = Array.isArray(args) ? args : [];
    for(const v of a){
      if(typeof v === 'string' && /^0x[0-9a-fA-F]{40}$/.test(v)){
        data += encodeAddrParam(v);
      }else if(typeof v === 'string' && /^[0-9]+$/.test(v)){
        data += BigInt(v).toString(16).padStart(64,'0');
      }else if(typeof v === 'number' && Number.isFinite(v)){
        data += BigInt(Math.trunc(v)).toString(16).padStart(64,'0');
      }else if(typeof v === 'bigint'){
        data += v.toString(16).padStart(64,'0');
      }else{
        // fallback: treat as 0
        data += '0'.repeat(64)
      }
    }
    return data;
  }

  async function pickV2PairAddress(chainId, pairs){
    // Find a UniswapV2-style pair among DexScreener pairs (best-effort).
    // IMPORTANT: Uniswap V3 pools also have token0/token1, so we additionally require getReserves().
    if(!Array.isArray(pairs) || !pairs.length) return null;
    const token0Sel = "0x0dfe1681";
    const token1Sel = "0xd21220a7";
    const reservesSel = "0x0902f1ac"; // getReserves()

    const maxTry = Math.min(14, pairs.length);
    for(let i=0;i<maxTry;i++){
      const p = pairs[i] || {};
      const addr = String(p.pairAddress || p.address || '').trim();
      if(!addr.toLowerCase().startsWith('0x') || addr.length !== 42) continue;
      try{
        const rsv = await ethCall(chainId, addr, reservesSel).catch(()=>null);
        if(!rsv) continue;
        const t0 = await ethCall(chainId, addr, token0Sel).catch(()=>null);
        const t1 = await ethCall(chainId, addr, token1Sel).catch(()=>null);
        if(t0 && t1) return addr;
      }catch{}
    }
    return null;
  }

  async function lpBurnedPercentV2(chainId, pairAddr){
  // Uniswap V2-style LP burn = LP token balance of burn addresses / totalSupply.
  // If the pair is not V2 (e.g., Uniswap V3 pool), returns { pct:null, note:"Not V2" }.
  try{
    if(!pairAddr || !String(pairAddr).toLowerCase().startsWith("0x")) return {pct:null, note:"No pair"};
    // Quick V2 probe
    const token0Sel = "0x0dfe1681";
    const token1Sel = "0xd21220a7";
    const reservesSel = "0x0902f1ac"; // getReserves()
    const rsv = await ethCall(chainId, pairAddr, reservesSel).catch(()=>null);
    if(!rsv) return {pct:null, note:"Not V2 pool (no reserves)"};
    const t0 = await ethCall(chainId, pairAddr, token0Sel).catch(()=>null);
    const t1 = await ethCall(chainId, pairAddr, token1Sel).catch(()=>null);
    if(!t0 || !t1) return {pct:null, note:"Not V2 pool"};

    const total = await ethCall(chainId, pairAddr, "0x18160ddd"); // totalSupply()
    const totalBI = safeBigIntFromStr(total);
    if(totalBI === null || totalBI === 0n) return {pct:null, note:"No LP supply"};

    const burnAddrs = [
      "0x0000000000000000000000000000000000000000",
      "0x000000000000000000000000000000000000dEaD",
      "0x0000000000000000000000000000000000000001"
    ];

    let burned = 0n;
    for(const a of burnAddrs){
      const bal = await ethCall(chainId, pairAddr, encAbiCall("70a08231", [a])); // balanceOf(address)
      const b = safeBigIntFromStr(bal);
      if(b !== null) burned += b;
    }

    const pct = Number((burned * 10000n) / totalBI) / 100;
    return {pct: Math.max(0, Math.min(100, pct)), burned, total: totalBI, note:"dead+0x0+0x1"};
  }catch{
    return {pct:null, note:"Error"};
  }
}


function setStatus(msg){ setText("status", msg || ""); }
  function setBadge(el, txt, mode){
    if(!el) return;
    el.textContent = txt ?? "";
    el.classList.remove("good","warn","bad");
    if(mode) el.classList.add(mode);
  }
let STAMP_TIMER = null;

function updateStampTime(){
  const el = qs("stampTime");
  if(!el) return;

  const now = new Date();
  const live = new Intl.DateTimeFormat("de-DE", {
    timeZone: "Europe/Berlin",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit"
  }).format(now);

  el.textContent = live;
}

function startLiveStampTime(){
  if(STAMP_TIMER) clearInterval(STAMP_TIMER);
  updateStampTime();
  STAMP_TIMER = setInterval(updateStampTime, 1000);
}

  /* ===================== VALIDATION ===================== */
  function looksBase58(s){
    return typeof s === "string" && s.length >= 32 && s.length <= 52 && /^[1-9A-HJ-NP-Za-km-z]+$/.test(s);
  }
  function looksEvmAddress(s){
    return typeof s === "string" && /^0x[0-9a-fA-F]{40}$/.test(s.trim());
  }

  /* ===================== MODAL + TOAST ===================== */
  function openModal(title, bodyHtml){
    setText("modalTitle", title || "Guardian Details");
    setHTML("modalBody", bodyHtml || "");
    const w = qs("modalWrap");
    if(w){
      w.style.display = "flex";
      w.setAttribute("aria-hidden","false");
    }
  }
  function closeModal(){
    const w = qs("modalWrap");
    if(w){
      w.style.display = "none";
      w.setAttribute("aria-hidden","true");
    }

  }

  function bubblemapsUrl(chain, address){
    const a = String(address||'').trim();
    if(!a) return '';
    const c = String(chain||'solana').toLowerCase();
    const slug = (c==='ethereum'||c==='eth') ? 'eth' : (c==='bnb'||c==='bsc') ? 'bsc' : (c==='base') ? 'base' : (c==='solana'||c==='sol') ? 'sol' : 'eth';
    return `https://app.bubblemaps.io/${slug}/token/${a}`;
  }

  function openBubblemapsModal(){
    const chain = activeChain || 'solana';
    const addr = (LAST_SCAN && LAST_SCAN.address) ? LAST_SCAN.address : el('addr').value.trim();
    if(!addr){ toast('Paste an address first'); return; }
    const url = bubblemapsUrl(chain, addr);
    const title = `Bubblemaps • ${chain.toUpperCase()} • ${short(addr)}`;
    const body = `
      <div style="display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;margin-bottom:10px">
        <div class="muted">Tip: use the toolbar inside Bubblemaps to show labels, magic nodes and address list.</div>
        <a class="btn ghost" href="${url}" target="_blank" rel="noreferrer">Open in new tab</a>
      </div>
      <div style="height:70vh;min-height:520px;border:1px solid rgba(255,255,255,.12);border-radius:16px;overflow:hidden;background:#000">
        <iframe src="${url}" style="width:100%;height:100%;border:0" loading="lazy" referrerpolicy="no-referrer"></iframe>
      </div>`;
    openModal(title, body);
  }

  function showToast(title){
    const t = qs("toast");
    if(!t) return;
    setText("toastTitle", title || "");
    t.style.display = "block";
  }
  function hideToast(){
    const t = qs("toast");
    if(!t) return;
    t.style.display = "none";
  }

  /* ===================== EXPLANATION BUILDER ===================== */
  function explain(title, bullets){
    const body = (bullets||[]).map(b => `<div style="margin:6px 0">${esc(b)}</div>`).join("");
    return `
      <div style="font-weight:1000; font-size:18px; margin-bottom:10px">${esc(title)}</div>
      <div style="color:rgba(255,255,255,.72); font-weight:850; line-height:1.55">
        ${body}
      </div>
    `;
  }

  function explainStatus(sev, why){
    const head = sev==="ok" ? "PASS" : sev==="bad" ? "FAIL" : "WATCH";
    const base = sev==="ok" ? [
      "What this means: No clear red flag detected for this specific item.",
      "Important: This does NOT guarantee safety — it only means this one check looks clean."
    ] : sev==="bad" ? [
      "What this means: A strong risk signal was detected for this item.",
      "Important: This can block selling/transfers, change supply, or enable admin abuse."
    ] : [
      "What this means: Unclear or potentially abusable feature detected.",
      "Important: Understand it before buying — verify with the team/docs."
    ];
    const extra = why ? ["Why it matters here: " + why] : [];
    return explain(head, [...base, ...extra]);
  }

  /* ===================== DATA-HTML BUG FIX ===================== */
  const INFO_MAP = new Map();
  function newInfoId(){ return "i_" + Math.random().toString(36).slice(2) + Date.now().toString(36); }
  function registerInfo(html){
    const id = newInfoId();
    INFO_MAP.set(id, html);
    return id;
  }
  function getInfo(id){ return INFO_MAP.get(id) || ""; }

  /* ===================== UI RENDER ===================== */
  function applyTokenHeader(meta, addr){
    const nameEl = qs("tokenName");
    const symEl  = qs("tokenSymbol");
    const wrap   = qs("tokenLogoWrap");
    const img    = qs("tokenLogo");

    const name = (meta?.name || "Token").trim() || "Token";
    const sym  = (meta?.symbol || "").trim();

    if(nameEl) nameEl.textContent = name;
    if(symEl)  symEl.textContent  = sym ? `$${sym}` : `Addr: ${shortAddr(addr)}`;

    if(wrap && img){
      if(meta?.image){
        img.src = meta.image;
        img.alt = name;
        wrap.style.display = "block";
        img.onerror = () => { wrap.style.display = "none"; };
      }else{
        wrap.style.display = "none";
        img.removeAttribute("src");
        img.alt = "";
      }
    }

    // Topbar token badge removed (token info stays in the scan panel/report)

  }

  function pillIcon(sev){ return sev==="ok" ? '✓' : '✕'; }
function pillLabel(sev){ return (sev==="ok" ? (pillIcon(sev)+' PASS') : (pillIcon(sev)+' ' + (sev==="bad" ? 'FAIL' : 'WATCH'))); }
  function pillClass(sev){ return sev==="ok" ? "pill ok" : sev==="bad" ? "pill bad" : "pill warn"; }

  function renderList(listEl, items, defaultTitle){
    if(!listEl) return;
    listEl.innerHTML = "";
    for(const it of items){
      const sev = it.sev || "warn";
      const title = it.t || defaultTitle || "Details";
      const desc = it.d || "—";
      const infoTitle = it.infoTitle || title;

      const html = (it.infoHtml && String(it.infoHtml).trim())
        ? String(it.infoHtml)
        : explainStatus(sev, it.why || "");

      const infoId = registerInfo(html);

      const li = document.createElement("li");
      li.className = "li";
      li.innerHTML = `
        <div class="left">
          <div class="t">${esc(title)}</div>
          <div class="d">${esc(desc)}</div>
        </div>
        <div class="pillRow">
          <span class="${pillClass(sev)}" role="button" tabindex="0"
                data-open="1" data-title="${esc(infoTitle)}" data-info="${esc(infoId)}">${pillLabel(sev)}</span>
          <button class="infoBtn" type="button" aria-label="Info"
                  data-open="1" data-title="${esc(infoTitle)}" data-info="${esc(infoId)}"><span>i</span></button>
        </div>
      `;
      listEl.appendChild(li);
    }
  }

  function renderMetrics(rows){
    const wrap = qs("metrics");
    if(!wrap) return;
    wrap.innerHTML = "";

    /* NEW (v2.4): optionally hide "no signal" cards to avoid spam */
    const filtered = (rows || []).filter(r => {
      if(CFG.UI.SHOW_NO_SIGNAL_METRICS) return true;
      const v = String(r?.value ?? "").toLowerCase();
      const b = String(r?.badge ?? "").toLowerCase();
      if(v.includes("no signal")) return false;
      if(v.includes("not found")) return false;
      if(v.includes("unknown") && b.includes("pass")) return false;
      return true;
    });

    for(const r of filtered){
      const d = document.createElement("div");
      d.className = "metric";
      const bar = (typeof r.barPct === "number")
        ? `<div class="bar"><div style="width:${clamp(r.barPct,0,100)}%"></div></div>`
        : "";
      d.innerHTML = `
        <div class="metricK">
          <span>${esc(r.label || "—")}</span>
          <span class="badge" style="opacity:.9">${esc(r.badge || r.value || "—")}</span>
        </div>
        <div class="metricV">${esc(r.value || "—")}</div>
        ${r.mini ? `<div class="metricMini">${esc(r.mini)}</div>` : ''}
        ${bar}
      `;
      wrap.appendChild(d);
    }
  }

  function explorerBase(chain){
    if(chain.id === "sol")  return {name:"Solscan",   base:"https://solscan.io/account/"};
    if(chain.id === "eth")  return {name:"Etherscan", base:"https://etherscan.io/address/"};
    if(chain.id === "bnb")  return {name:"BscScan",   base:"https://bscscan.com/address/"};
    if(chain.id === "base") return {name:"BaseScan",  base:"https://basescan.org/address/"};
    return {name:"Explorer", base:"#"};
  }

  function renderHoldersEmpty(){
    const el = qs("holdersList");
    if(!el) return;

    const ex = explorerBase(activeChain);
    const addr = (qs('addrInput')?.value || '').trim();
    const hasAddr = addr && (activeChain.kind==='evm' ? /^0x[0-9a-fA-F]{40}$/.test(addr) : addr.length>10);

    el.innerHTML = '';
    const li = document.createElement('li');
    li.className = 'li';

    const infoId = registerInfo(explain('Top holders', [
      'Meaning: Distribution shows whale risk.',
      'Solana: via RPC largest accounts.',
      'EVM: needs an indexer (e.g., GoldRush) — RPC alone cannot list holders.',
      'Tip: If the list is empty, open the explorer holders tab.'
    ]));

    li.innerHTML = `
      <div class="left">
        <div class="t">No holder data</div>
        <div class="d">${activeChain.kind==='solana' ? 'Top holders appear after scan.' : (CFG.GOLDRUSH_API_KEY ? 'Indexer returned no holder list (rate-limit/coverage). Use explorer as fallback.' : 'EVM holders need an indexer (GoldRush).')}<\/div>
      </div>
      <div class="pillRow">
        ${hasAddr ? `<a class="explorerBtn" href="${esc(ex.base + addr)}" target="_blank" rel="noreferrer">Open ${esc(ex.name)}<\/a>` : ''}
        <span class="${pillClass('warn')}" role="button" tabindex="0" data-open="1" data-title="Top holders" data-info="${esc(infoId)}">${pillLabel('warn')}<\/span>
        <button class="infoBtn" type="button" aria-label="Info" data-open="1" data-title="Top holders" data-info="${esc(infoId)}"><span>i</span><\/button>
      </div>`;

    el.appendChild(li);
  }

  function renderHoldersWithExplorer(items, chain){
    const el = qs("holdersList");
    if(!el) return;
    el.innerHTML = "";
    const ex = explorerBase(chain);

    for(const it of items){
      const title = it.t;
      const desc  = it.d;
      const addr  = it.addr;

      const infoId = registerInfo(it.infoHtml || explain("Top holder", [
        "Meaning: Share of supply.",
        "Why it matters: High % = dump risk.",
        "Tip: Check if LP/Burn/Team/Treasury."
      ]));

      const li = document.createElement("li");
      li.className = "li";
      li.innerHTML = `
        <div class="left">
          <div class="t">${esc(title)}</div>
          <div class="d">${esc(desc)}</div>
        </div>
        <div class="pillRow">
          <a class="explorerBtn" href="${esc(ex.base + addr)}" target="_blank" rel="noreferrer">${esc(ex.name)}</a>
          <button class="infoBtn" type="button" aria-label="Info"
                  data-open="1" data-title="${esc(title)}" data-info="${esc(infoId)}"><span>i</span></button>
        </div>
      `;
      el.appendChild(li);
    }
  }

  function renderHoldersList(items){
    // Backward-compat helper (some paths still call renderHoldersList).
    // Renders a holder list with explorer links.
    try{
      return renderHoldersWithExplorer(Array.isArray(items)?items:[], activeChain);
    }catch(e){
      return renderHoldersEmpty();
    }
  }

  /* ===================== PRO: BUBBLE MAP RENDER ===================== */
  function renderBubbleEmpty(){
    const c = qs('bubbleCanvas');
    const legend = qs('bubbleLegend');
    const hint = qs('bubbleHint');
    const stamp = qs('bubbleStamp');
    if(legend) legend.innerHTML = '';
    if(hint) hint.textContent = 'Run a scan to generate a bubble map (' + (activeChain.kind==='evm' ? 'EVM best-effort via GoldRush.' : 'Solana best-effort.') + ')';
    if(stamp) stamp.textContent = (activeChain.kind==='evm') ? (activeChain.name + ' • TOP HOLDERS + TRANSFERS') : 'SOLANA • TOP HOLDERS + FLOWS';
    if(!c) return;
    const ctx = c.getContext('2d');
    ctx.clearRect(0,0,c.width,c.height);
    ctx.fillStyle = 'rgba(255,255,255,.18)';
    ctx.font = '16px ui-sans-serif, system-ui';
    ctx.fillText('Bubble map will appear after scan.', 20, 40);
  }

  function explorerUrlFor(chain, addr){
    const ex = explorerBase(chain);
    return ex.base + addr;
  }

  function drawBubbleMap(model){
    const c = qs('bubbleCanvas');
    const legend = qs('bubbleLegend');
    const hint = qs('bubbleHint');
    const stamp = qs('bubbleStamp');
    if(!c) return;

    if(stamp) stamp.textContent = (activeChain.kind==='evm') ? (activeChain.name + ' • TOP HOLDERS + TRANSFERS') : 'SOLANA • TOP HOLDERS + FLOWS';

    const ctx = c.getContext('2d');
    const W = c.width, H = c.height;

    // HiDPI fix
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const cssW = c.clientWidth || W;
    const cssH = c.clientHeight || H;
    if(Math.round(cssW*dpr) !== c.width || Math.round(cssH*dpr) !== c.height){
      c.width = Math.round(cssW*dpr);
      c.height = Math.round(cssH*dpr);
    }
    const w = c.width, h = c.height;

    const nodes = (model?.nodes || []).map(n => ({...n}));
    const edges = (model?.edges || []).map(e => ({...e}));

    if(!nodes.length){
      renderBubbleEmpty();
      return;
    }

    if(legend){
      const pills = [
        `<span class='legendPill'>Size = holder %</span>`,
        `<span class='legendPill'>Links = recent transfers</span>`,
        `<span class='legendPill'>Click = explorer</span>`
      ];
      legend.innerHTML = pills.join('');

      // Add a compact top-wallet list (click opens explorer)
      const ex = explorerBase(activeChain);
      const topList = nodes.slice().sort((a,b)=>{
        const ap = (Number.isFinite(a.pct)?a.pct:0);
        const bp = (Number.isFinite(b.pct)?b.pct:0);
        if(bp!==ap) return bp-ap;
        return (b.r||0)-(a.r||0);
      }).slice(0, 8);

      if(topList.length){
        const rows = topList.map(n => {
          const a = n.addr || n.id || '';
          const pct = (Number.isFinite(n.pct) && n.pct>0) ? (n.pct>=10 ? n.pct.toFixed(1) : n.pct.toFixed(2))+'%' : '—';
          const label = (n.label && String(n.label).trim()) ? String(n.label).trim() : (a ? shortAddr(a) : 'Wallet');
          const href = a ? (ex.base + a) : '#';
          return `<a class="explorerBtn" style="width:100%; display:flex; justify-content:space-between; gap:10px;" href="${esc(href)}" target="_blank" rel="noreferrer"><span>${esc(label)}</span><span class="muted">${esc(pct)}</span></a>`;
        }).join('');
        legend.innerHTML += `<div style="margin-top:10px; display:flex; flex-direction:column; gap:8px; width:100%">${rows}</div>`;
      }
    }

    if(hint){
      hint.textContent = model?.hint || 'Top holders + recent flows (limited sample).';
    }

    // init positions
    for(const n of nodes){
      if(typeof n.x !== 'number') n.x = Math.random()*w;
      if(typeof n.y !== 'number') n.y = Math.random()*h;
      if(typeof n.vx !== 'number') n.vx = (Math.random()-.5)*0.5;
      if(typeof n.vy !== 'number') n.vy = (Math.random()-.5)*0.5;
    }

    const byId = new Map(nodes.map(n => [n.id, n]));

    // physics
    let dragging = null;
    let dragOffX = 0, dragOffY = 0;

    // view (pan/zoom) in device pixels
    let view = { ox: 0, oy: 0, s: 1 };
    let panning = false;
    let panStart = {x:0,y:0,ox:0,oy:0};

    function hitTest(mx, my){
      for(let i=nodes.length-1;i>=0;i--){
        const n = nodes[i];
        const dx = mx - n.x, dy = my - n.y;
        if(dx*dx + dy*dy <= (n.r*n.r)) return n;
      }
      return null;
    }

    function getMouse(evt){
      const rect = c.getBoundingClientRect();
      const mx = (evt.clientX - rect.left) * (c.width/rect.width);
      const my = (evt.clientY - rect.top) * (c.height/rect.height);
      const wx = (mx - view.ox) / view.s;
      const wy = (my - view.oy) / view.s;
      return {mx,my,wx,wy};
    }

    c.onpointerdown = (evt)=>{
      const {mx,my,wx,wy} = getMouse(evt);
      const n = hitTest(wx,wy);
      if(n){
        dragging = n;
        dragOffX = wx - n.x;
        dragOffY = wy - n.y;
        c.setPointerCapture(evt.pointerId);
      }else{
        panning = true;
        panStart = {x: mx, y: my, ox: view.ox, oy: view.oy};
        c.setPointerCapture(evt.pointerId);
      }
    };
    c.onpointermove = (evt)=>{
      if(panning){
        const {mx,my} = getMouse(evt);
        view.ox = panStart.ox + (mx - panStart.x);
        view.oy = panStart.oy + (my - panStart.y);
        return;
      }
      if(!dragging) return;
      const {mx,my,wx,wy} = getMouse(evt);
      dragging.x = wx - dragOffX;
      dragging.y = wy - dragOffY;
      dragging.vx = 0;
      dragging.vy = 0;
    };
    c.onpointerup = (evt)=>{
      if(dragging){
        dragging = null;
      }
      if(panning){
        panning = false;
      }
      try{ c.releasePointerCapture(evt.pointerId);}catch{};
    };
    c.onwheel = (evt)=>{
      evt.preventDefault();
      const rect = c.getBoundingClientRect();
      const mx = (evt.clientX - rect.left) * (c.width/rect.width);
      const my = (evt.clientY - rect.top) * (c.height/rect.height);
      const zoom = evt.deltaY < 0 ? 1.08 : 0.92;
      const ns = Math.max(0.55, Math.min(2.2, view.s * zoom));
      // keep cursor position stable
      const wx = (mx - view.ox) / view.s;
      const wy = (my - view.oy) / view.s;
      view.s = ns;
      view.ox = mx - wx * view.s;
      view.oy = my - wy * view.s;
    };

    c.onclick = (evt)=>{
      const {mx,my,wx,wy} = getMouse(evt);
      const n = hitTest(wx,wy);
      if(n && n.addr){
        window.open(explorerUrlFor(activeChain, n.addr), '_blank', 'noreferrer');
      }
    };

    function tick(){
      ctx.clearRect(0,0,c.width,c.height);
      ctx.save();
      ctx.setTransform(view.s, 0, 0, view.s, view.ox, view.oy);

      // visible world bounds (so nodes don't get clamped to the *screen* when panning/zooming)
      const worldW = c.width / view.s;
      const worldH = c.height / view.s;
      const worldX0 = (-view.ox) / view.s;
      const worldY0 = (-view.oy) / view.s;

      // forces: repulsion (stable)
      for(let i=0;i<nodes.length;i++){
        const a = nodes[i];
        for(let j=i+1;j<nodes.length;j++){
          const b = nodes[j];
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          const dist2 = dx*dx + dy*dy + 0.01;
          const f = 650 / dist2;
          const fx = dx * f;
          const fy = dy * f;
          if(a !== dragging){ a.vx += fx; a.vy += fy; }
          if(b !== dragging){ b.vx -= fx; b.vy -= fy; }
        }
      }

      // edges attraction
      for(const e of edges){
        const a = byId.get(e.a);
        const b = byId.get(e.b);
        if(!a || !b) continue;
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.sqrt(dx*dx + dy*dy) || 1;
        const target = 130;
        const k = (dist - target) * 0.0020 * (e.w || 1);
        const fx = dx * k;
        const fy = dy * k;
        if(a !== dragging){ a.vx += fx; a.vy += fy; }
        if(b !== dragging){ b.vx -= fx; b.vy -= fy; }
      }

      // integrate + bounds
      for(const n of nodes){
        if(n !== dragging){
          n.vx *= 0.82;
          n.vy *= 0.82;
          n.x += n.vx;
          n.y += n.vy;
        }
        const pad = n.r + 10;
        n.x = Math.max(worldX0 + pad, Math.min(worldX0 + worldW - pad, n.x));
        n.y = Math.max(worldY0 + pad, Math.min(worldY0 + worldH - pad, n.y));
      }

      // edges draw
      ctx.lineWidth = 1;
      ctx.strokeStyle = 'rgba(255,255,255,.18)';
      for(const e of edges){
        const a = byId.get(e.a);
        const b = byId.get(e.b);
        if(!a || !b) continue;
        ctx.globalAlpha = Math.min(0.55, 0.15 + (e.w || 1)*0.05);
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // nodes draw
      for(const n of nodes){
        // glow
        ctx.beginPath();
        ctx.fillStyle = n.color || 'rgba(90,140,255,.62)';
        ctx.shadowColor = n.color || 'rgba(90,140,255,.85)';
        ctx.shadowBlur = Math.min(28, 10 + n.r*0.8);
        ctx.arc(n.x, n.y, n.r, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
        // rim
        ctx.lineWidth = 1.25;
        ctx.strokeStyle = 'rgba(255,255,255,.18)';
        ctx.stroke();
      }

      // overlay labels (DexScreener-ish): show % inside bubble + wallet under
      const labelNodes = nodes.slice().sort((a,b)=>{
        const ap = (Number.isFinite(a.pct)?a.pct:0);
        const bp = (Number.isFinite(b.pct)?b.pct:0);
        if(bp!==ap) return bp-ap;
        return (b.r||0)-(a.r||0);
      }).slice(0, 18);

      ctx.save();
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.shadowColor = 'rgba(0,0,0,.70)';
      ctx.shadowBlur = 10;
      ctx.strokeStyle = 'rgba(0,0,0,.90)';

      for(const n of labelNodes){
        if(!n) continue;
        const addr = n.addr || n.id || '';
        const name = (n.label && String(n.label).trim()) ? String(n.label).trim() : (addr ? shortAddr(addr) : '');
        if(!name) continue;

        const pct = (Number.isFinite(n.pct) && n.pct > 0) ? n.pct : null;
        const pctTxt = pct === null ? '' : (pct >= 10 ? pct.toFixed(1) : pct.toFixed(2)) + '%';

        // Font sizes scale with bubble radius
        const fsPct  = Math.max(11, Math.min(18, (n.r||12) * 0.62));
        const fsAddr = Math.max(10, Math.min(14, (n.r||12) * 0.46));

        if(pctTxt){
          ctx.font = fsPct + 'px ui-sans-serif, system-ui, -apple-system';
          ctx.lineWidth = 4;
          ctx.fillStyle = 'rgba(255,255,255,.95)';
          ctx.strokeText(pctTxt, n.x, n.y - fsAddr*0.25);
          ctx.fillText(pctTxt, n.x, n.y - fsAddr*0.25);

          ctx.font = fsAddr + 'px ui-monospace, Menlo, Consolas, monospace';
          ctx.fillStyle = 'rgba(255,255,255,.88)';
          ctx.strokeText(name, n.x, n.y + fsPct*0.55);
          ctx.fillText(name, n.x, n.y + fsPct*0.55);
        }else{
          ctx.font = fsAddr + 'px ui-monospace, Menlo, Consolas, monospace';
          ctx.lineWidth = 4;
          ctx.fillStyle = 'rgba(255,255,255,.92)';
          ctx.strokeText(name, n.x, n.y);
          ctx.fillText(name, n.x, n.y);
        }
      }

      ctx.restore();

      ctx.restore();
      requestAnimationFrame(tick);
    }

    requestAnimationFrame(tick);
  }


  function clearUI(){
    setText("mintShort","—");
    setText("verdictTitle","—");
    setBadge(qs("verdictBadge"),"—");
    setText("scoreBadge","—");
    setText("summary","—");
    setText("scanHint","—");
    setText("tokenName","—");
    setText("tokenSymbol","—");

    const lw = qs("tokenLogoWrap");
    if(lw) lw.style.display = "none";

    renderMetrics([]);

    renderList(qs("checksList"), [{
      t:"No scan yet",
      sev:"warn",
      d:"Paste an address and run the Guardian Check.",
      why:"No data available yet."
    }], "Guardian Check Details");

    renderList(qs("todoList"), [{
      t:"Waiting for scan",
      sev:"warn",
      d:"We generate the action list from on-chain signals after a scan.",
      why:"Run a scan to generate the checklist."
    }], "Launch Readiness");

    renderList(qs("extList"), [{
      t:"No scan yet",
      sev:"warn",
      d:"Standard details appear after scan.",
      why:"Run a scan to display standard/extensions."
    }], "Token Standard");

    renderList(qs("metaList"), [{
      t:"No scan yet",
      sev:"warn",
      d:"Name / symbol / logo appear after scan.",
      why:"Run a scan to fetch metadata."
    }], "Token Metadata");

    

    renderList(qs("clusterList"), [{t:"No cluster data", sev:"warn", d:"Clusters appear after scan (Solana best-effort).", why:"Run a scan."}], "Clusters");

    renderList(qs("bundleList"), [{t:"No bundle data", sev:"warn", d:"Bundles appear after scan (Solana best-effort).", why:"Run a scan."}], "Bundles");

    renderBubbleEmpty();
renderHoldersEmpty();

    LAST_SCAN = null;
    const ex = qs("btnExport");
    if(ex){
      ex.disabled = true;
      ex.textContent = "Download Scan Report";
    }
  }

  /* ===================== CHAIN UI ===================== */
  function renderChainButtons(){
    const row = qs("chainRow");
    if(!row) return;

    row.innerHTML = "";
    for(const c of CFG.CHAINS){
      const b = document.createElement("button");
      b.type = "button";
      b.className = "chainBtn" + (c.id === activeChain.id ? " active" : "");
      b.innerHTML = `
        <span class="chainIcon">${ICONS[c.id] || ""}</span>
        <span>${esc(c.name)}</span>
      `;
      b.addEventListener("click", () => setActiveChain(c.id, true));
      row.appendChild(b);
    }
  }

  function setActiveChain(chainId, pushUrl){
    const found = CFG.CHAINS.find(x => x.id === chainId) || CFG.CHAINS[0];
    activeChain = found;

    renderChainButtons();

    setText("holdersStamp", activeChain.stamp || "MAINNET");
    setText("addrLabel", activeChain.addrLabel || "Token Address");

    const mint = qs("mint");
    if(mint) mint.placeholder = activeChain.placeholder || "Paste token address...";

    const hint = "";

    setText("chainHint", hint);
    setStatus("");
    clearUI();
    renderBubbleEmpty();

    if(pushUrl){
      const url = new URL(location.href);
      url.searchParams.set("chain", activeChain.id);
      history.replaceState({}, "", url.toString());
    }
  }

  /* ===================== VERDICT / SCORING ===================== */
  function verdictFrom(score, critical){
    if(critical) return {label:"FLAGGED", mode:"bad",  title:"FLAGGED • High Risk"};
    if(score >= 80) return {label:"APPROVED", mode:"good", title:"APPROVED • Guardian Grade"};
    if(score >= 50) return {label:"OBSERVED", mode:"warn", title:"OBSERVED • Mixed Signals"};
    return {label:"FLAGGED", mode:"bad", title:"FLAGGED • High Risk"};
  }

  /* =========================================================
     PART 2/3
     - Solana RPC logic (unchanged behavior)
     - EVM logic (unchanged behavior)
     - FIX: "Proxy / Upgradeability: No proxy signal found." + "Pause function not found."
            will NOT be shown as standalone spam rows in the EVM "Token standard details"
            when CFG.UI.SHOW_PASS_DETAILS_EVM === false.
       (Nothing removed: checks still run, score still uses results, report still includes.)
     ========================================================= */

  /* ===================== SOLANA RPC (Helius) ===================== */
  function HELIUS_RPC(){
    return `https://mainnet.helius-rpc.com/?api-key=${encodeURIComponent(CFG.HELIUS_KEY)}`;
  }

  async function solRpc(method, params){
    if(!CFG.HELIUS_KEY) throw new Error("Helius key missing.");
    const res = await fetch(HELIUS_RPC(), {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ jsonrpc:"2.0", id:1, method, params })
    });

    if(!res.ok){
      const t = await res.text().catch(()=> "");
      throw new Error(`Solana RPC HTTP ${res.status}: ${t.slice(0,220)}`);
    }
    const j = await res.json();
    if(j?.error) throw new Error(j.error.message || "Solana RPC error");
    return j.result;
  }

  async function getMintParsed(mint){
    const r = await solRpc("getAccountInfo", [mint, { encoding:"jsonParsed", commitment:"confirmed" }]);
    const v = r?.value;
    if(!v) return null;
    const owner = v.owner;
    const parsed = (v.data && typeof v.data === "object") ? v.data.parsed : null;
    const info = parsed?.info || null;
    return { owner, info, rawParsed: parsed };
  }
  async function getTokenSupply(mint){
    const r = await solRpc("getTokenSupply", [mint]);
    return r?.value || null;
  }
  async function getLargest(mint){
    const r = await solRpc("getTokenLargestAccounts", [mint]);
    return r?.value || [];
  }
  async function getAsset(mint){
    try { return await solRpc("getAsset", [mint]); }
    catch { return null; }
  }

  

  /* ===================== PRO: SOLANA FLOWS / CLUSTERS / BUBBLE MAP ===================== */
  async function solGetSignatures(address, limit=25){
    const r = await solRpc("getSignaturesForAddress", [address, {limit}]);
    return Array.isArray(r) ? r : [];
  }

  async function solGetTx(signature){
    const r = await solRpc("getTransaction", [signature, {encoding:"jsonParsed", commitment:"confirmed", maxSupportedTransactionVersion:0}]);
    return r || null;
  }

  function buildUnionFind(){
    const parent = new Map();
    const find = (x)=>{
      if(!parent.has(x)) parent.set(x,x);
      let p = parent.get(x);
      while(p !== parent.get(p)) p = parent.get(p);
      let cur = x;
      while(cur !== p){
        const nxt = parent.get(cur);
        parent.set(cur,p);
        cur = nxt;
      }
      return p;
    };
    const unite = (a,b)=>{
      const ra = find(a), rb = find(b);
      if(ra !== rb) parent.set(ra, rb);
    };
    const add = (x)=>{ if(!parent.has(x)) parent.set(x,x); };
    const groups = ()=>{
      const m = new Map();
      for(const k of parent.keys()){
        const r = find(k);
        if(!m.has(r)) m.set(r, []);
        m.get(r).push(k);
      }
      return Array.from(m.values()).sort((a,b)=>b.length-a.length);
    };
    return {add, unite, groups};
  }

  function parseSolMintDeltas(tx, mint){
    try{
      const pre = Array.isArray(tx?.meta?.preTokenBalances) ? tx.meta.preTokenBalances : [];
      const post = Array.isArray(tx?.meta?.postTokenBalances) ? tx.meta.postTokenBalances : [];
      const byIdx = new Map();
      for(const b of pre){
        if(b?.mint === mint && typeof b?.accountIndex === 'number') byIdx.set(b.accountIndex, {pre:b, post:null});
      }
      for(const b of post){
        if(b?.mint === mint && typeof b?.accountIndex === 'number'){
          const row = byIdx.get(b.accountIndex) || {pre:null, post:null};
          row.post = b;
          byIdx.set(b.accountIndex, row);
        }
      }
      const deltas = new Map();
      for(const row of byIdx.values()){
        const owner = row.post?.owner || row.pre?.owner || null;
        if(!owner) continue;
        const preAmt = Number(row.pre?.uiTokenAmount?.uiAmount ?? row.pre?.uiTokenAmount?.amount ?? 0);
        const postAmt = Number(row.post?.uiTokenAmount?.uiAmount ?? row.post?.uiTokenAmount?.amount ?? 0);
        const d = (postAmt - preAmt);
        if(!Number.isFinite(d) || d == 0) continue;
        deltas.set(owner, (deltas.get(owner) || 0) + d);
      }
      return deltas;
    }catch{ return new Map(); }
  }

  async function solComputeFlowsAndBundles(mint, limit=25){
    const sigs = await solGetSignatures(mint, limit);
    const edges = new Map(); // key: a|b -> weight
    const bundles = [];
    const seenSigs = [];

    for(const s of sigs){
      const sig = s?.signature;
      if(!sig) continue;
      const tx = await solGetTx(sig).catch(()=>null);
      if(!tx) continue;
      seenSigs.push(sig);

      const deltas = parseSolMintDeltas(tx, mint);
      if(!deltas || deltas.size < 2) continue;

      const senders = [];
      const recvs = [];
      for(const [who, d] of deltas.entries()){
        if(d < 0) senders.push([who, -d]);
        else recvs.push([who, d]);
      }
      if(!senders.length || !recvs.length) continue;

      // Build edges (approx): connect each sender to each receiver
      for(const [saddr, sAmt] of senders){
        for(const [raddr, rAmt] of recvs){
          const w = Math.min(sAmt, rAmt);
          const k = saddr + '|' + raddr;
          edges.set(k, (edges.get(k) || 0) + w);
        }
      }

      // Bundle heuristic: one dominant sender distributing to many recipients in same tx
      if(senders.length === 1 && recvs.length >= 3){
        const from = senders[0][0];
        const toList = recvs.slice(0, 8).map(x => x[0]);
        bundles.push({sig: sig, from, toList, count: recvs.length});
      }

    }

    return {edges, bundles, seenSigs};
  }


  async function solGetTokenAccountOwner(tokenAccount){
    try{
      const r = await solRpc("getAccountInfo", [tokenAccount, {encoding:"jsonParsed", commitment:"confirmed"}]);
      const v = r?.value;
      const info = v?.data?.parsed?.info;
      const owner = info?.owner || null;
      return owner;
    }catch{
      return null;
    }
  }

  async function poolMap(items, worker, concurrency=6){
    const out = new Array(items.length);
    let i = 0;
    const runners = new Array(Math.min(concurrency, items.length)).fill(0).map(async () => {
      while(i < items.length){
        const idx = i;
        i += 1;
        try{ out[idx] = await worker(items[idx], idx); }
        catch(e){ out[idx] = null; }
      }
    });
    await Promise.all(runners);
    return out;
  }

  async function solLargestToWalletHolders(largest, uiSupply, top=25){
    const rows = Array.isArray(largest) ? largest.slice(0, top) : [];
    const addrs = rows.map(r => r?.address).filter(Boolean);

    const owners = await poolMap(addrs, async (ta) => await solGetTokenAccountOwner(ta), 6);

    const agg = new Map();
    for(let k=0;k<rows.length;k++){
      const ta = rows[k]?.address;
      const owner = owners[k] || ta || '';
      const amt = Number(rows[k]?.uiAmount || 0);
      if(!owner) continue;
      agg.set(owner, (agg.get(owner) || 0) + amt);
    }

    const list = Array.from(agg.entries()).map(([wallet, amount]) => {
      const pct = (uiSupply && uiSupply > 0) ? (amount / uiSupply) * 100 : 0;
      return { wallet, amount, pct };
    }).sort((a,b) => b.amount - a.amount);

    return list;
  }

  function renderHoldersWallets(holders){
    if(!Array.isArray(holders) || !holders.length){
      renderHoldersEmpty();
      return [];
    }
    const top = holders.slice(0, 10).map((h,i) => ({
      t: `#${i+1} ${shortAddr(h.wallet)}`,
      d: `${fmtInt(h.amount)} tokens • ${h.pct.toFixed(2)}%`,
      addr: h.wallet,
      infoHtml: explain("Top holder", [
        `Wallet holds ~${h.pct.toFixed(2)}% of supply.`,
        "Why it matters: high % = dump risk.",
        "Tip: check if LP/Burn/Team/Treasury."
      ])
    }));
    renderHoldersWithExplorer(top, activeChain);
  }

  function buildBubbleModelSol(holders, flow){
    const nodes = [];
    const edges = [];

    const top = (Array.isArray(holders) ? holders : []).slice(0, 20);
    const nodeSet = new Set(top.map(h => h.wallet));

    // add extra nodes from flows (up to 8)
    const flowNodes = new Map();
    if(flow && flow.edges){
      for(const [k,w] of flow.edges.entries()){
        const [a,b] = k.split('|');
        if(a) flowNodes.set(a, (flowNodes.get(a)||0) + w);
        if(b) flowNodes.set(b, (flowNodes.get(b)||0) + w);
      }
    }
    const extras = Array.from(flowNodes.entries())
      .filter(([addr]) => addr && !nodeSet.has(addr))
      .sort((a,b) => b[1]-a[1])
      .slice(0, 8)
      .map(([addr]) => ({wallet: addr, amount: 0, pct: 0}));

    const all = top.concat(extras);
    for(const h of all){
      const pct = Number.isFinite(h.pct) ? h.pct : 0;
      // radius: 10..44 based on pct
      const r = 10 + Math.sqrt(Math.max(0, pct)) * 7;
      nodes.push({
        id: h.wallet,
        label: shortAddr(h.wallet),
        pct,
        r: Math.max(10, Math.min(44, r)),
        href: explorerUrlFor(activeChain, h.wallet)
      });
    }

    const allow = new Set(nodes.map(n => n.id));
    if(flow && flow.edges){
      for(const [k,w] of flow.edges.entries()){
        const [a,b] = k.split('|');
        if(!allow.has(a) || !allow.has(b)) continue;
        edges.push({a, b, w: w});
      }
    }

    // keep top 80 edges by weight
    edges.sort((a,b)=> (b.w||0)-(a.w||0));
    const cut = edges.slice(0, 80).map(e => ({a:e.a, b:e.b, w:e.w}));

    return {
      kind:'sol',
      nodes: nodes.map(n => ({...n, addr: n.id})),
      edges: cut,
      bundles: (flow && Array.isArray(flow.bundles)) ? flow.bundles : [],
      hint: 'Size = holder % (top wallets). Links = recent on-chain transfers (limited sample).'
    };
  }

  function renderClustersFromModel(model){
    const el = qs('clusterList');
    if(!el){ return; }

    const uf = buildUnionFind();
    const nodes = (model?.nodes || []);
    const edges = (model?.edges || []);
    for(const n of nodes) uf.add(n.id);
    for(const e of edges) uf.unite(e.a, e.b);
    const groups = uf.groups().filter(g => g.length >= 2);

    if(!groups.length){
      renderList(el, [{t:"No clusters detected", sev:"warn", d:"No strong wallet-to-wallet links found in the sampled transactions.", why:"We only analyze a limited recent sample."}], "Clusters");
      return;
    }

    const items = groups.slice(0, 6).map((g,i) => {
      const preview = g.slice(0,5).map(shortAddr).join(', ');
      return {
        t: `Cluster #${i+1} (${g.length} wallets)`,
        sev: g.length >= 5 ? 'bad' : 'warn',
        d: preview + (g.length>5 ? ' …' : ''),
        why: 'Connected via recent token balance changes (best-effort).',
        infoHtml: explain('Cluster', [
          `Wallets in this cluster interacted via recent mint balance changes (sampled).`,
          `Cluster size: ${g.length}.`,
          'This is NOT proof of common ownership — treat as a signal to investigate.'
        ])
      };
    });

    renderList(el, items, 'Clusters');
  }

  function renderBundles(bundles){
    const el = qs('bundleList');
    if(!el) return;

    const list = Array.isArray(bundles) ? bundles : [];
    if(!list.length){
      renderList(el, [{t:"No bundles detected", sev:"ok", d:"No multi-recipient distribution was detected in the sampled transactions.", why:"Limited sample."}], "Bundles");
      return;
    }

    const items = list.slice(0, 8).map((b,i) => ({
      t: `Bundle #${i+1} • ${b.recipients} recipients`,
      sev: b.recipients >= 8 ? 'bad' : (b.recipients >= 5 ? 'warn' : 'warn'),
      d: `Sender: ${shortAddr(b.sender)} • Tx: ${shortAddr(b.signature)} • Est. total: ${fmtInt(b.total)}`,
      why: 'Heuristic: one sender distributing to many recipients in one tx.',
      infoHtml: explain('Bundle heuristic', [
        'We flag transactions where 1 sender distributes the token to many wallets in a single tx.',
        'This can indicate wallet farming / staged distribution.',
        'Always verify on-chain in explorer.'
      ])
    }));

    renderList(el, items, 'Bundles');
  }
function pickTokenMetaFromAsset(asset){
    if(!asset) return null;
    const md = asset?.content?.metadata || {};
    const name = (md?.name || asset?.metadata?.name || "").trim();
    const symbol = (md?.symbol || asset?.metadata?.symbol || "").trim();

    let image = "";
    const linksImg = asset?.content?.links?.image;
    if(typeof linksImg === "string") image = linksImg;
    if(!image && Array.isArray(asset?.content?.files)){
      const f = asset.content.files.find(x => (x?.mime || "").includes("image") && x?.uri);
      if(f?.uri) image = f.uri;
    }

    const uri = (asset?.content?.json_uri || asset?.content?.links?.external_url || "").trim();
    const description = (md?.description || asset?.content?.metadata?.description || "").trim();
    const authorities = Array.isArray(asset?.authorities) ? asset.authorities : [];
    return { name, symbol, image, uri, description, authorities };
  }

  function parseExtensionsFromParsed(rawParsed){
    try{
      const info = rawParsed?.info || null;
      if(!info) return null;
      const ex = info.extensions || info.extensionTypes || info.mintExtensions;
      if(Array.isArray(ex) && ex.length){
        return ex.map(x => ({ name: (typeof x === "string") ? x : (x?.type || x?.name || "Extension") }));
      }
      if(ex && typeof ex === "object"){
        return Object.keys(ex).map(k => ({ name:k }));
      }
      return null;
    }catch{
      return null;
    }
  }

  function humanizeExtensionName(n){
    const s = String(n||"").toLowerCase();
    if(s.includes("transferfee") || s.includes("transfer_fee")) return "Transfer Fee (fees on transfers)";
    if(s.includes("permanentdelegate") || s.includes("permanent_delegate")) return "Permanent Delegate (delegate control)";
    if(s.includes("nontransferable") || s.includes("non_transferable")) return "Non-Transferable (cannot be transferred)";
    if(s.includes("interestbearing") || s.includes("interest_bearing")) return "Interest-Bearing (yield mechanics)";
    if(s.includes("confidential")) return "Confidential Transfers (privacy mode)";
    if(s.includes("metadata")) return "Metadata Extension";
    return n;
  }

  function scoreSol(sig){
    let score = 100;
    const checks = [];

    if(sig.freezeActive){
      score -= 35;
      checks.push({
        t:"Freeze Authority",
        sev:"bad",
        d:"Freeze authority is active — wallets can be frozen.",
        why:"Freeze authority is set (not removed).",
        infoHtml: explain("Freeze Authority", [
          "Meaning: Admin can freeze token accounts.",
          "Why it matters: Buyers may be unable to sell/transfer.",
          "PASS would be: Freeze authority = null (removed/renounced)."
        ])
      });
    }else{
      checks.push({
        t:"Freeze Authority",
        sev:"ok",
        d:"Freeze authority removed (good).",
        why:"Freeze authority is not set.",
        infoHtml: explain("Freeze Authority", [
          "Meaning: Admin cannot freeze accounts.",
          "Why PASS: Freeze authority is null / not present."
        ])
      });
    }

    if(sig.mintAuthActive){
      score -= 30;
      checks.push({
        t:"Mint Authority",
        sev:"bad",
        d:"Mint authority is active — supply can be increased.",
        why:"Mint authority is set (not renounced).",
        infoHtml: explain("Mint Authority", [
          "Meaning: Admin can mint new tokens.",
          "Why it matters: Supply inflation can destroy price.",
          "PASS would be: Mint authority = null (renounced)."
        ])
      });
    }else{
      checks.push({
        t:"Mint Authority",
        sev:"ok",
        d:"Mint authority renounced (good).",
        why:"Mint authority is not set.",
        infoHtml: explain("Mint Authority", [
          "Meaning: Supply cannot be increased by admin minting.",
          "Why PASS: Mint authority is null / not present."
        ])
      });
    }

    const t20 = Number(sig.top20 || 0);
    if(t20 >= 75){
      score -= 28;
      checks.push({
        t:"Holder concentration (Top20)",
        sev:"bad",
        d:`Top20 hold ~${t20.toFixed(2)}% (very high).`,
        why:"Extreme concentration.",
        infoHtml: explain("Top20 Distribution", [
          `Top20 share: ~${t20.toFixed(2)}%`,
          "Why it matters: Few wallets can dump.",
          "FAIL here: extremely high whale concentration."
        ])
      });
    }else if(t20 >= 55){
      score -= 18;
      checks.push({
        t:"Holder concentration (Top20)",
        sev:"warn",
        d:`Top20 hold ~${t20.toFixed(2)}% (high).`,
        why:"High concentration.",
        infoHtml: explain("Top20 Distribution", [
          `Top20 share: ~${t20.toFixed(2)}%`,
          "Why it matters: Elevated dump risk.",
          "WATCH: inspect wallets (LP/Burn/Team)."
        ])
      });
    }else if(t20 >= 35){
      score -= 8;
      checks.push({
        t:"Holder concentration (Top20)",
        sev:"warn",
        d:`Top20 hold ~${t20.toFixed(2)}% (moderate).`,
        why:"Moderate concentration.",
        infoHtml: explain("Top20 Distribution", [
          `Top20 share: ~${t20.toFixed(2)}%`,
          "WATCH: whale risk is still possible."
        ])
      });
    }else{
      checks.push({
        t:"Holder concentration (Top20)",
        sev:"ok",
        d:`Top20 hold ~${t20.toFixed(2)}% (better).`,
        why:"Lower concentration.",
        infoHtml: explain("Top20 Distribution", [
          `Top20 share: ~${t20.toFixed(2)}%`,
          "Why PASS: distribution looks healthier."
        ])
      });
    }

    if(sig.programType === "TOKEN_2022"){
      score -= sig.extReadable ? 6 : 10;
      checks.push({
        t:"Token Standard",
        sev:"warn",
        d: sig.extReadable ? "Token-2022 detected (extensions possible)." : "Token-2022 detected (extensions not visible).",
        why:"Token-2022 can include extra rules.",
        infoHtml: explain("Token-2022", [
          "Meaning: SPL token program with optional extensions.",
          "Why it matters: Extensions can add fees/restrictions.",
          "WATCH: review Token Standard Details (extensions)."
        ])
      });
    }else if(sig.programType === "SPL_TOKEN"){
      checks.push({
        t:"Token Standard",
        sev:"ok",
        d:"Standard SPL Token program.",
        why:"Mint owned by standard Token Program.",
        infoHtml: explain("SPL Token", [
          "Meaning: Standard Solana Token Program.",
          "Why PASS: no Token-2022 extension rules."
        ])
      });
    }else{
      score -= 10;
      checks.push({
        t:"Token Standard",
        sev:"warn",
        d:"Unknown token program (caution).",
        why:"Mint owner is not Tokenkeg / Token-2022.",
        infoHtml: explain("Unknown Token Program", [
          "Meaning: Mint is not under standard programs.",
          "Why it matters: Custom programs can hide rules.",
          "WATCH: verify very carefully."
        ])
      });
    }

    if(sig.meta && (sig.meta.name || sig.meta.symbol)){
      checks.push({
        t:"Metadata",
        sev:"ok",
        d:"Name/symbol found.",
        why:"Metadata was fetched successfully.",
        infoHtml: explain("Metadata", [
          "Meaning: Identity (name/symbol/logo) is easier to verify.",
          "Why PASS: metadata could be loaded."
        ])
      });
    }else{
      score -= 4;
      checks.push({
        t:"Metadata",
        sev:"warn",
        d:"Metadata missing/unreadable.",
        why:"No name/symbol returned via metadata endpoint.",
        infoHtml: explain("Metadata", [
          "Meaning: Without metadata it's easier to fake/impersonate.",
          "WATCH: always cross-check official links."
        ])
      });
    }

    score = clamp(Math.round(score), 0, 100);
    const critical = !!(sig.freezeActive || sig.mintAuthActive);
    return { score, checks, critical };
  }

  function todoSol(sig){
    const t = [];

    t.push(sig.freezeActive
      ? {t:"Remove Freeze Authority", sev:"bad", d:"Freeze can block buyers.", why:"Freeze is active — remove it."}
      : {t:"Freeze Authority", sev:"ok", d:"Already removed.", why:"Freeze is not active."}
    );

    t.push(sig.mintAuthActive
      ? {t:"Renounce Mint Authority", sev:"bad", d:"Mint can inflate supply.", why:"Mint is active — renounce it."}
      : {t:"Mint Authority", sev:"ok", d:"Already renounced.", why:"Mint is not active."}
    );

    const t20 = Number(sig.top20 || 0);
    if(t20 >= 55) t.push({t:"Reduce whale concentration", sev:"warn", d:`Top20 ~${t20.toFixed(2)}%.`, why:"High concentration — inspect wallets."});
    else if(t20 >= 35) t.push({t:"Monitor distribution", sev:"warn", d:`Top20 ~${t20.toFixed(2)}%.`, why:"Moderate concentration — monitor."});
    else t.push({t:"Distribution", sev:"ok", d:`Top20 ~${t20.toFixed(2)}% (better).`, why:"Healthier distribution."});

    if(sig.programType === "TOKEN_2022"){
      t.push({t:"Review Token-2022 extensions", sev:"warn", d:"Extensions can change rules.", why:"Token-2022 detected."});
    }else if(sig.programType === "UNKNOWN"){
      t.push({t:"Verify mint program", sev:"warn", d:"Unknown program = extra caution.", why:"Not standard."});
    }else{
      t.push({t:"Token standard", sev:"ok", d:"Standard SPL Token.", why:"Common standard."});
    }

    if(!(sig.meta && (sig.meta.name || sig.meta.symbol))){
      t.push({t:"Publish/verify metadata", sev:"warn", d:"Without metadata, fakes are easier.", why:"Metadata missing."});
    }else{
      t.push({t:"Metadata", sev:"ok", d:"Name/symbol present.", why:"OK."});
    }

    return t.map(x => ({
      ...x,
      infoHtml: explain(x.t, [
        x.d,
        "Why it matters: reduces scam/abuse risk.",
        "Status: " + pillLabel(x.sev)
      ])
    }));
  }

  
  // ===================== MARKET / DEX PANEL (replaces Launch Readiness) =====================
  function renderMarketDex(dex){
    const items = [];
    if(!dex){
      items.push({t:'No DexScreener pair found', sev:'warn', d:'Could not find a live DEX pair for this token via DexScreener.', why:'No indexed pair / very new / wrong chain.'});
    }else{
      const link = dex.url ? `Open pair on DexScreener: ${dex.url}` : 'Pair link unavailable.';
      items.push({t:'DEX Pair', sev:'ok', d:`${(dex.dexId||'DEX').toUpperCase()} • ${dex.pairAddress ? shortAddr(dex.pairAddress) : '—'}`, why: link});
      if(dex.liquidityUsd != null) items.push({t:'Liquidity', sev: dex.liquidityUsd >= 10000 ? 'ok' : 'warn', d: money(dex.liquidityUsd), why:'Higher liquidity usually reduces slippage/manipulation.'});
      if(dex && (dex.marketCap != null || dex.fdv != null)) items.push({t:'Market Cap / FDV', sev:'ok', d: dex.marketCap!=null ? money(dex.marketCap) : money(dex.fdv), why:''});
      if(dex.priceUsd != null) items.push({t:'Price', sev:'ok', d: priceUsdFmt(dex.priceUsd), why:''});
      if(dex.volume24h != null) items.push({t:'Volume 24h', sev: dex.volume24h >= 5000 ? 'ok' : 'warn', d: money(dex.volume24h), why:'Low volume can mean thin markets.'});
    }
    renderList(qs('todoList'), items, 'Market / DEX');
    return items;
  }

  // ===================== CONTRACT FLAGS PANEL (replaces Token Standard Details) =====================
  function renderContractFlags(flags){
    // flags: array of {t, sev, d, why}
    const items = Array.isArray(flags) ? flags : [];
    if(!items.length){
      items.push({t:'No flags', sev:'ok', d:'No major risk flags detected by the current checks.', why:'Still verify official links and liquidity.'});
    }
    renderList(qs('extList'), items, 'Contract Flags');
  }

function renderExtSol(programType, extReadable, extList){
    const el = qs("extList");
    if(!el) return;

    if(programType !== "TOKEN_2022"){
      renderList(el, [{
        t:"Token standard details",
        sev: programType==="SPL_TOKEN" ? "ok" : "warn",
        d: programType==="SPL_TOKEN" ? "Standard SPL Token. Token-2022 extensions not applicable." : "Unknown program. Treat with caution.",
        infoHtml: explain("Token standard details", [
          "Token-2022 extensions only show when Token-2022 is detected.",
          "If 'Unknown': verify extremely carefully."
        ])
      }], "Token standard details");
      return;
    }

    if(!extReadable){
      renderList(el, [{
        t:"Token-2022 extensions",
        sev:"warn",
        d:"Extensions could not be read.",
        infoHtml: explain("Token-2022 extensions", [
          "Token-2022 may include additional rules.",
          "If extensions are not visible: WATCH until verified externally."
        ])
      }], "Token-2022 extensions");
      return;
    }

    const items = (extList || []).map(x => {
      const nameHuman = humanizeExtensionName(x.name);
      const lname = String(x.name||"").toLowerCase();
      let sev = "warn";
      if(lname.includes("nontransferable")) sev = "bad";
      return {
        t: nameHuman,
        sev,
        d: `Extension detected: ${nameHuman}.`,
        infoHtml: explain(nameHuman, [
          "Meaning: Extra rule in the Token-2022 standard.",
          sev==="bad" ? "Risk: can prevent transfers." : "WATCH: only safe if you fully understand it."
        ])
      };
    });

    renderList(el,
      items.length ? items : [{
        t:"No extensions listed",
        sev:"ok",
        d:"No Token-2022 extensions detected.",
        infoHtml: explain("Extensions", ["No additional rules detected."])
      }],
      "Token-2022 Extension Details"
    );
  }

  function renderMetaSol(meta){
    const el = qs("metaList");
    if(!el) return;

    if(!meta){
      renderList(el, [{
        t:"Metadata not available",
        sev:"warn",
        d:"Could not fetch metadata via getAsset.",
        infoHtml: explain("Token metadata", [
          "Meaning: Name/symbol/logo help spot fake tokens.",
          "Why WATCH: metadata could not be loaded."
        ])
      }], "Token Metadata");
      return;
    }

    const items = [];
    items.push({
      t:"Name / Symbol",
      sev:(meta.name || meta.symbol) ? "ok" : "warn",
      d:`${meta.name || "—"} • ${meta.symbol ? "$"+meta.symbol : "—"}`,
      infoHtml: explain("Name / Symbol", [
        "Meaning: Basic identity of the token.",
        (meta.name || meta.symbol) ? "Why PASS: values present." : "Why WATCH: missing/unreadable."
      ])
    });

    items.push({
      t:"Metadata Link",
      sev: meta.uri ? "ok" : "warn",
      d: meta.uri ? "Metadata link found." : "No metadata link found.",
      infoHtml: explain("Metadata Link", [
        "Meaning: Off-chain JSON (logo/description).",
        meta.uri ? "Why PASS: link exists." : "Why WATCH: no link found."
      ])
    });

    items.push({
      t:"Image / Logo",
      sev: meta.image ? "ok" : "warn",
      d: meta.image ? "Logo found." : "No logo found.",
      infoHtml: explain("Logo", [
        "Meaning: Helps verify the real token.",
        meta.image ? "Why PASS: logo found." : "Why WATCH: no logo found."
      ])
    });

    if(meta.description){
      items.push({
        t:"Description",
        sev:"ok",
        d: meta.description.slice(0,120) + (meta.description.length>120 ? "…" : ""),
        infoHtml: explain("Description", [meta.description])
      });
    }

    if(Array.isArray(meta.authorities) && meta.authorities.length){
      items.push({
        t:"Metadata authorities",
        sev:"warn",
        d:"Metadata authorities exist (review).",
        infoHtml: explain("Metadata authorities", [
          "Meaning: Someone may be able to change name/logo later.",
          "WATCH: only OK if authority is removed or clearly governed."
        ])
      });
    }

    renderList(el, items, "Token Metadata");
  }

  function renderHoldersSol(mint, uiSupply, largest){
    if(!uiSupply || !largest || !largest.length){
      renderHoldersEmpty();
      return;
    }

    const top = largest.slice(0,10);
    const items = top.map((x,i) => {
      const addr = x?.address || "";
      const amt = Number(x?.uiAmount || 0);
      const pct = uiSupply > 0 ? (amt / uiSupply) * 100 : 0;

      return {
        t:`#${i+1} ${shortAddr(addr)}`,
        d:`${fmtInt(amt)} tokens • ${pct.toFixed(2)}%`,
        addr,
        infoHtml: explain("Top holder", [
          `Wallet holds ~${pct.toFixed(2)}% of supply.`,
          "Why it matters: high % = dump risk.",
          "Tip: check if LP/Burn/Team/Treasury."
        ])
      };
    });

    renderHoldersWithExplorer(items, activeChain);
    return holders;
  }
    /* ===================== EVM RPC + ERC-20 ===================== */
async function evmRpc(chainId, method, params){
    const urls = CFG.EVM_RPCS[chainId] || [];
    if(!urls.length) throw new Error("No RPC configured for this chain.");

    const timeoutMs = 6500;
    const call = (url) => new Promise((resolve, reject) => {
      const ctrl = new AbortController();
      const timer = setTimeout(() => ctrl.abort(), timeoutMs);
      fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ jsonrpc: "2.0", id: 1, method, params }),
        signal: ctrl.signal
      }).then(async (res) => {
        clearTimeout(timer);
        if(!res.ok){
          const t = await res.text().catch(() => "");
          reject(new Error(`HTTP ${res.status} ${t.slice(0,140)}`));
          return;
        }
        const j = await res.json().catch(() => null);
        if(!j){ reject(new Error("Bad JSON")); return; }
        if(j.error){ reject(new Error(String(j.error?.message || "RPC error").slice(0,140))); return; }
        resolve(j.result);
      }).catch((e) => {
        clearTimeout(timer);
        reject(e);
      });
    });

    // Promise.any polyfill
    const any = (proms) => new Promise((resolve, reject) => {
      let pending = proms.length;
      const errors = [];
      for(const p of proms){
        Promise.resolve(p).then(resolve).catch((e) => {
          errors.push(e);
          pending -= 1;
          if(pending <= 0) reject(new Error(errors.slice(-3).map(x => String(x?.message||x)).join(" • ")));
        });
      }
    });

    // Try 3 at once, then the rest
    const first = urls.slice(0,3);
    const rest  = urls.slice(3);
    try{
      return await any(first.map(call));
    }catch(e1){
      if(!rest.length) throw new Error(`All RPCs failed. ${String(e1?.message||e1)}`);
      try{
        return await any(rest.map(call));
      }catch(e2){
        throw new Error(`All RPCs failed. ${String(e2?.message||e2)}`);
      }
    }
  }

  async function ethCall(chainId, to, data){
    return await evmRpc(chainId, "eth_call", [{to, data}, "latest"]);
  }
  async function getCode(chainId, addr){
    return await evmRpc(chainId, "eth_getCode", [addr, "latest"]);
  }
  async function getStorageAt(chainId, addr, slot){
    return await evmRpc(chainId, "eth_getStorageAt", [addr, slot, "latest"]);
  }

  const SEL = {
    name: "0x06fdde03",
    symbol: "0x95d89b41",
    decimals: "0x313ce567",
    totalSupply: "0x18160ddd",
    owner: "0x8da5cb5b",
    getOwner: "0x893d20e8",
    paused: "0x5c975abb",
    isPaused: "0xb187bd26",
    pause: "0x8456cb59",
    unpause: "0x3f4ba83a"
  };

  function strip0x(h){ return (h||"").startsWith("0x") ? h.slice(2) : (h||""); }

  function decodeUint256(hex){
    const h = strip0x(hex);
    if(!h) return null;
    const padded = h.padStart(64,"0").slice(-64);
    try { return BigInt("0x"+padded); }
    catch { return null; }
  }

  function decodeAddressFrom32(hex){
    const h = strip0x(hex);
    if(!h) return null;
    const padded = h.padStart(64,"0").slice(-40);
    return "0x" + padded;
  }

  function bytes32ToAscii(hex){
    const h = strip0x(hex);
    if(h.length !== 64) return "";
    try{
      const bytes = new Uint8Array(h.match(/.{1,2}/g).map(b => parseInt(b,16)));
      let s = new TextDecoder().decode(bytes).replace(/\0/g,"").trim();
      if(!s) return "";
      if(/^[\x20-\x7E]+$/.test(s)) return s;
      return "";
    }catch{
      return "";
    }
  }

  function decodeString(hex){
    const data = strip0x(hex);
    if(!data) return "";

    // bytes32 style
    if(data.length === 64){
      const b = bytes32ToAscii("0x"+data);
      if(b) return b;
    }

    // ABI string style
    if(data.length < 128) return "";
    const lenHex = data.slice(64,128);
    let len = 0;
    try { len = Number(BigInt("0x"+lenHex)); }
    catch { return ""; }
    if(!Number.isFinite(len) || len <= 0) return "";

    const strData = data.slice(128, 128 + len*2);
    if(!strData) return "";

    try{
      const bytes = new Uint8Array(strData.match(/.{1,2}/g).map(b => parseInt(b,16)));
      return new TextDecoder().decode(bytes).replace(/\0/g,"").trim();
    }catch{
      return "";
    }
  }

  async function getErc20Meta(chainId, addr){
    const out = { name:"", symbol:"", decimals:null, totalSupply:null };
    try { out.name = decodeString(await ethCall(chainId, addr, SEL.name)); } catch {}
    try { out.symbol = decodeString(await ethCall(chainId, addr, SEL.symbol)); } catch {}
    try {
      const v = decodeUint256(await ethCall(chainId, addr, SEL.decimals));
      out.decimals = (v === null) ? null : Number(v);
      if(!Number.isFinite(out.decimals)) out.decimals = null;
    } catch {}
    try { out.totalSupply = decodeUint256(await ethCall(chainId, addr, SEL.totalSupply)); } catch {}
    return out;
  }

  async function getOwner(chainId, addr){
    // Try common ownership getters
    const sels = [SEL.owner, SEL.getOwner].filter(Boolean);
    for(const sel of sels){
      try{
        const r = await ethCall(chainId, addr, sel);
        const a = decodeAddressFrom32(r || "0x");
        if(a && /^0x[0-9a-fA-F]{40}$/.test(a)) return a;
      }catch{}
    }
    return null;
  }

  // paused() check:
  // - TRUE => currently paused (fail)
  // - FALSE => pause function exists (watch)
  // - null => pause function not found/unreadable (pass for this item)
  async function getPaused(chainId, addr){
    // Try paused() and isPaused() (best-effort)
    const sels = [SEL.paused, SEL.isPaused].filter(Boolean);
    for(const sel of sels){
      try{
        const r = await ethCall(chainId, addr, sel);
        const v = decodeUint256(r || "0x");
        if(v === null) continue;
        return v !== 0n;
      }catch{}
    }
    return null;
  }

  /* Proxy detection (EIP-1967) */
  const SLOT_IMPL  = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
  const SLOT_ADMIN = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103";

  async function detectProxy(chainId, addr){
    try{
      const [implRaw, adminRaw] = await Promise.all([
        getStorageAt(chainId, addr, SLOT_IMPL),
        getStorageAt(chainId, addr, SLOT_ADMIN)
      ]);
      const impl  = decodeAddressFrom32(implRaw  || "0x");
      const admin = decodeAddressFrom32(adminRaw || "0x");
      const zero = "0x0000000000000000000000000000000000000000";
      const implNonZero  = impl  && impl.toLowerCase()  !== zero;
      const adminNonZero = admin && admin.toLowerCase() !== zero;
      return { isProxy: implNonZero || adminNonZero, implementation: implNonZero ? impl : null, admin: adminNonZero ? admin : null };
    }catch{
      return {isProxy:false, implementation:null, admin:null};
    }
  }

  /* Optional Moralis metadata */
  function moralisChainParam(chainId){
    if(chainId === 1) return "eth";
    if(chainId === 56) return "bsc";
    if(chainId === 8453) return "base";
    return "eth";
  }

  async function getEvmMetaViaApi(chainId, addr){
    if(!CFG.EVM_METADATA_KEY) return null;
    const chain = moralisChainParam(chainId);
    const url = `https://deep-index.moralis.io/api/v2.2/erc20/metadata?chain=${encodeURIComponent(chain)}&addresses=${encodeURIComponent(addr)}`;

    try{
      const res = await fetch(url, {
        method:"GET",
        headers:{
          "accept":"application/json",
          "x-api-key": CFG.EVM_METADATA_KEY
        }
      });
      if(!res.ok) return null;

      const data = await res.json();
      const item = Array.isArray(data) ? data[0] : null;
      if(!item) return null;

      return {
        name: (item.name || "").trim(),
        symbol: (item.symbol || "").trim(),
        image: (item.logo || item.thumbnail || "").trim(),
        decimals: Number.isFinite(Number(item.decimals)) ? Number(item.decimals) : null
      };
    }catch{
      return null;
    }
  }

  /* Optional GoldRush holders */
  function goldrushChain(chainId){
    if(chainId === 1) return "eth-mainnet";
    if(chainId === 56) return "bsc-mainnet";
    if(chainId === 8453) return "base-mainnet";
    return "eth-mainnet";
  }

  async function goldrushHolders(chainId, addr, limit=80){
  if(!CFG.GOLDRUSH_API_KEY) return [];
  const chain = goldrushChain(chainId);
  const pageSize = Math.min(100, Math.max(10, Number(limit)||80));
  const page = 0;
  // GoldRush Wallet API (Covalent) — token holders v2
  const url = `https://api.covalenthq.com/v1/${chain}/tokens/${addr}/token_holders_v2/?page-size=${pageSize}&page-number=${page}&key=${encodeURIComponent(CFG.GOLDRUSH_API_KEY)}`;
  try{
    const r = await fetch(url);
    if(!r.ok) return [];
    const j = await r.json();
    return Array.isArray(j?.data?.items) ? j.data.items : [];
  }catch{
    return [];
  }
}


  async function goldrushTransfersV2(chainId, addr, limit=600){
  // Best-effort: try GoldRush token transfers endpoint if key is set,
  // otherwise fall back to RPC log sampling (no key).
  const want = Math.max(200, Math.min(1600, Number(limit)||600));

  // 1) GoldRush (if available)
  if(CFG.GOLDRUSH_API_KEY){
    const chain = goldrushChain(chainId);
    const pageSize = 200;
    const maxPages = 6;
    const out = [];
    for(let page=0; page<maxPages && out.length<want; page++){
      // NOTE: Some GoldRush deployments expose `token_transfers_v2` for tokens.
      // If it returns 404/empty, we fall back to RPC sampling.
      const url = `https://api.covalenthq.com/v1/${chain}/tokens/${addr}/token_transfers_v2/?page-size=${pageSize}&page-number=${page}&key=${encodeURIComponent(CFG.GOLDRUSH_API_KEY)}`;
      try{
        const r = await fetch(url);
        if(!r.ok) break;
        const j = await r.json();
        const items = Array.isArray(j?.data?.items) ? j.data.items : [];
        if(!items.length) break;
        out.push(...items);
      }catch{
        break;
      }
    }
    if(out.length) return out.slice(0, want);
  }

  // 2) RPC fallback: sample recent Transfer logs
  return await evmTokenTransfersSample(chainId, addr, want);
}

function hexToInt(h){ return parseInt(String(h||"0x0"), 16) || 0; }
function intToHex(n){ return "0x" + Math.max(0, Number(n)||0).toString(16); }

// Fetches a *sample* of ERC20 Transfer logs from recent blocks (no indexer needed).
// Returned objects mimic GoldRush items (from_address/to_address/value/tx_hash/block_height/block_signed_at).
async function evmTokenTransfersSample(chainId, tokenAddr, maxEvents=1200){
  // CORS-safe, RPC-only fallback used when no indexer is available.
  // This is a *sample*, not a full history.
  try{
    const latestHex = await evmRpc(chainId, "eth_blockNumber", []);
    const latest = hexToInt(latestHex);

    const minFrom = Math.max(0, latest - (CFG?.EVM?.TRANSFER_SAMPLE_BLOCKS || 60000));
    const topic0 = "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef"; // Transfer(address,address,uint256)

    const out = [];
    let to = latest;
    let window = Math.max(200, (CFG?.EVM?.TRANSFER_SAMPLE_STEP || 2500));
    let guard = 0;

    while(to > minFrom && out.length < maxEvents && guard++ < 120){
      const fb = Math.max(minFrom, to - window + 1);
      const params = [{
        address: tokenAddr,
        fromBlock: intToHex(fb),
        toBlock: intToHex(to),
        topics: [topic0]
      }];

      let logs = [];
      try{
        logs = await evmRpc(chainId, "eth_getLogs", params);
        if(!Array.isArray(logs)) logs = [];

        // If we hit a provider that returns huge batches, reduce window to avoid timeouts.
        if(logs.length > 9000){
          window = Math.max(200, Math.floor(window/2));
          continue;
        }
      }catch(err){
        // Too many results / gateway timeouts -> shrink the window and retry same range.
        window = Math.max(200, Math.floor(window/2));
        continue;
      }

      // Take newest logs first (most recent activity).
      logs.reverse();
      for(const lg of logs){
        if(out.length>=maxEvents) break;
        const topics = lg?.topics || [];
        const data = String(lg?.data || "0x0");
        if(topics.length < 3) continue;
        const fromA = "0x" + String(topics[1]).slice(26).toLowerCase();
        const toA   = "0x" + String(topics[2]).slice(26).toLowerCase();
        const valueHex = data.startsWith("0x") ? data : ("0x"+data);
        const valBI = safeBigIntFromStr(valueHex);
        out.push({
          from_address: fromA,
          to_address: toA,
          value: valBI !== null ? valBI.toString() : "0",
          tx_hash: String(lg?.transactionHash || "").toLowerCase(),
          block_height: hexToInt(lg?.blockNumber),
          block_signed_at: null
        });
      }

      // Move the window backward and slowly increase window again for speed.
      to = fb - 1;
      if(window < (CFG?.EVM?.TRANSFER_SAMPLE_STEP || 2500)) window = Math.min((CFG?.EVM?.TRANSFER_SAMPLE_STEP || 2500), Math.floor(window * 1.25));
      if(out.length < 30 && window > 400){
        // If token is super busy, keep window smaller to avoid RPC limits.
        window = Math.max(400, Math.floor(window * 0.9));
      }
    }
    return out;
  }catch{
    return [];
  }
}


  function buildBubbleModelEvm(holdersRaw, transfersRaw){
    const holders = Array.isArray(holdersRaw) ? holdersRaw : [];
    const transfers = Array.isArray(transfersRaw) ? transfersRaw : [];

    const top = holders.slice(0,80).map(h => ({
      addr: String(h?.address||'').toLowerCase(),
      pct:  Number(h?.percentage ?? h?.pct ?? h?.share ?? NaN)
    })).filter(h => h.addr.startsWith('0x'));

    const nodes = [];
    const nodeMap = new Map();
    const addNode = (addr, pct=null, isHolder=false)=>{
      const a = String(addr||'').toLowerCase();
      if(!a.startsWith('0x')) return null;
      if(nodeMap.has(a)) return nodeMap.get(a);
      const p = (Number.isFinite(pct) ? pct : 0);
      const r = isHolder ? (10 + Math.sqrt(Math.max(0,p))*6.8) : 8;
      const n = { id:a, addr:a, label: shortAddr(a), pct:(Number.isFinite(pct)? pct:null), r: Math.max(8, Math.min(46, r)), kind: isHolder?'holder':'wallet' };
      nodes.push(n);
      nodeMap.set(a,n);
      return n;
    };

    for(const h of top){ addNode(h.addr, h.pct, true); }

    const allow = new Set(nodes.map(n=>n.id));

    // collect degrees + raw edge weights
    const deg = new Map();
    const edgesTmp = new Map();
    for(const t of transfers){
      const fa = String(t?.from_address || '').toLowerCase();
      const ta = String(t?.to_address || '').toLowerCase();
      if(!fa.startsWith('0x') || !ta.startsWith('0x')) continue;
      deg.set(fa, (deg.get(fa)||0)+1);
      deg.set(ta, (deg.get(ta)||0)+1);
      const a = fa < ta ? fa : ta;
      const b = fa < ta ? ta : fa;
      const k = a + '|' + b;
      edgesTmp.set(k, (edgesTmp.get(k)||0) + 1);
    }

    // add a few "connector" wallets (Dex/router/exchange hot wallets etc.)
    const extras = Array.from(deg.entries())
      .filter(([a,c]) => c>=3 && !allow.has(a))
      .sort((x,y)=> (y[1]-x[1]))
      .slice(0, 18)
      .map(([a])=>a);

    for(const a of extras){ addNode(a, null, false); }

    const allow2 = new Set(nodes.map(n=>n.id));
    const edges = [];
    for(const [k,w] of edgesTmp.entries()){
      const parts = k.split('|');
      const a = parts[0];
      const b = parts[1];
      if(!allow2.has(a) || !allow2.has(b)) continue;
      edges.push({a,b,w});
    }
    edges.sort((x,y)=>(y.w||0)-(x.w||0));
    const cut = edges.slice(0, 140);

    // Bundles (same tx: one sender -> many recipients)
    const txMap = new Map();
    for(const t of transfers){
      const tx = String(t?.tx_hash || '').toLowerCase();
      if(!tx) continue;
      const fa = String(t?.from_address || '').toLowerCase();
      const ta = String(t?.to_address || '').toLowerCase();
      if(!fa.startsWith('0x') || !ta.startsWith('0x')) continue;
      let row = txMap.get(tx);
      if(!row){ row = {sender:fa, tos:new Set(), count:0}; txMap.set(tx,row); }
      // only count if same sender
      if(row.sender !== fa) continue;
      row.tos.add(ta);
      row.count += 1;
    }

    const bundles = Array.from(txMap.entries())
      .map(([tx,row]) => ({ signature: tx, sender: row.sender, recipients: row.tos.size, total: row.count }))
      .filter(b => b.recipients >= 4)
      .sort((a,b)=> b.recipients - a.recipients)
      .slice(0, 20);

    return {
      kind:'evm',
      nodes,
      edges: cut,
      bundles,
      hint: (top.length ? 'Size = holder % (indexer). Links = recent token transfers (sampled). Drag to explore.' : 'Size = activity (no holder list). Links = recent token transfers (sampled). For a professional view, click “Open BubbleMap”.')
    };
  }

  function scoreEvm(sig){
    let score = 100;
    const checks = [];

    if(!sig.hasCode){
      checks.push({
        t:"Contract found",
        sev:"bad",
        d:"No bytecode at this address.",
        why:"Address is not a contract (or wrong chain).",
        infoHtml: explain("Contract found", [
          "Meaning: The address must contain contract bytecode.",
          "Why FAIL: Address has no code."
        ])
      });
      return { score:0, checks, critical:true };
    }

    checks.push({
      t:"Contract found",
      sev:"ok",
      d:"Bytecode exists (contract).",
      why:"eth_getCode != 0x",
      infoHtml: explain("Contract found", [
        "Meaning: Address is a smart contract.",
        "Why PASS: Bytecode is present."
      ])
    });

    const hasName = !!sig.metaOnChain?.name;
    const hasSymbol = !!sig.metaOnChain?.symbol;

    if(!hasName || !hasSymbol){
      score -= 10;
      checks.push({
        t:"ERC-20 metadata",
        sev:"warn",
        d:"Name or symbol not cleanly readable.",
        why:"name()/symbol() reverted or non-standard ABI.",
        infoHtml: explain("ERC-20 metadata", [
          "Meaning: name()/symbol() help identify the token.",
          "Why WATCH: calls did not return clean values."
        ])
      });
    }else{
      checks.push({
        t:"ERC-20 metadata",
        sev:"ok",
        d:"Name & symbol readable.",
        why:"name()/symbol() responded.",
        infoHtml: explain("ERC-20 metadata", [
          "Meaning: Standard calls work.",
          "Why PASS: name()/symbol() succeeded."
        ])
      });
    }

    const decOk = Number.isFinite(sig.metaOnChain?.decimals) && sig.metaOnChain.decimals >= 0 && sig.metaOnChain.decimals <= 36;
    if(!decOk){
      score -= 12;
      checks.push({
        t:"Decimals",
        sev:"warn",
        d:"decimals() not readable or unusual.",
        why:"decimals() missing/reverted/out-of-range.",
        infoHtml: explain("Decimals", [
          "Meaning: Needed for UI and supply math.",
          "Why WATCH: decimals() not available or weird."
        ])
      });
    }else{
      checks.push({
        t:"Decimals",
        sev:"ok",
        d:`Decimals: ${sig.metaOnChain.decimals}`,
        why:"decimals() responded.",
        infoHtml: explain("Decimals", [
          "Meaning: Standard ERC-20 property.",
          "Why PASS: decimals() succeeded."
        ])
      });
    }

    const supplyReadable = sig.metaOnChain?.totalSupply !== null && sig.metaOnChain?.totalSupply !== undefined;
    if(!supplyReadable){
      score -= 10;
      checks.push({
        t:"Total supply",
        sev:"warn",
        d:"totalSupply() not readable.",
        why:"totalSupply() reverted/unavailable.",
        infoHtml: explain("Total supply", [
          "Meaning: Supply is needed for holder % and tokenomics.",
          "Why WATCH: totalSupply() not available."
        ])
      });
    }else{
      checks.push({
        t:"Total supply",
        sev:"ok",
        d:"Supply readable on-chain.",
        why:"totalSupply() responded.",
        infoHtml: explain("Total supply", [
          "Meaning: Basis for holder %.",
          "Why PASS: totalSupply() succeeded."
        ])
      });
    }

    // Owner check
    const zero = "0x0000000000000000000000000000000000000000";
    if(sig.owner){
      if(sig.owner.toLowerCase() === zero){
        checks.push({
          t:"Owner / Admin",
          sev:"ok",
          d:"Owner is renounced (0x0).",
          why:"owner() == zero address.",
          infoHtml: explain("Owner / Admin", [
            "Meaning: Owner often has special rights (fees/blacklist/etc).",
            "Why PASS: owner is 0x0 (renounced)."
          ])
        });
      }else{
        score -= 22;
        checks.push({
          t:"Owner / Admin",
          sev:"warn",
          d:`Owner active: ${shortAddr(sig.owner)}`,
          why:"owner() is not 0x0.",
          infoHtml: explain("Owner / Admin", [
            "Meaning: Admin control is possible (depends on contract).",
            "Why WATCH: owner exists and may have privileges.",
            "Tip: check multisig / timelock / renounce status."
          ])
        });
      }
    }else{
      score -= 6;
      checks.push({
        t:"Owner / Admin",
        sev:"warn",
        d:"owner() not found / unreadable.",
        why:"owner() missing or reverted.",
        infoHtml: explain("Owner / Admin", [
          "Meaning: Some tokens do not implement owner() in the standard way.",
          "Why WATCH: admin control may exist via other patterns."
        ])
      });
    }

    // Proxy check
    if(sig.proxy?.isProxy){
      score -= 18;
      checks.push({
        t:"Proxy / Upgradeability",
        sev:"warn",
        d:"Upgradeable proxy detected.",
        why:"EIP-1967 slots are non-zero.",
        infoHtml: explain("Proxy / Upgradeability", [
          "Meaning: Contract logic can be changed after deployment.",
          "Why WATCH: upgrades may be possible.",
          `Implementation: ${sig.proxy.implementation ? sig.proxy.implementation : "unknown"}`,
          `Admin: ${sig.proxy.admin ? sig.proxy.admin : "unknown"}`
        ])
      });
    }else{
      checks.push({
        t:"Proxy / Upgradeability",
        sev:"ok",
        d:"No proxy signal found.",
        why:"EIP-1967 slots empty (best-effort).",
        infoHtml: explain("Proxy / Upgradeability", [
          "Meaning: Proxy = upgradeable logic.",
          "Why PASS: no EIP-1967 signal found.",
          "Note: best-effort — other proxy patterns exist."
        ])
      });
    }

    // Pause control check
    if(sig.paused === true){
      score -= 25;
      checks.push({
        t:"Transfer controls (Pause)",
        sev:"bad",
        d:"paused() = TRUE — transfers may be blocked.",
        why:"paused() returned true.",
        infoHtml: explain("Transfer controls (Pause)", [
          "Meaning: Pausable can stop transfers.",
          "Why FAIL: paused() is TRUE => likely currently blocked.",
          "Tip: caution — buyers may be unable to transfer/sell."
        ])
      });
    }else if(sig.paused === false){
      score -= 6;
      checks.push({
        t:"Transfer controls (Pause)",
        sev:"warn",
        d:"Pause function exists (not active right now).",
        why:"paused() exists and returned false.",
        infoHtml: explain("Transfer controls (Pause)", [
          "Meaning: A pause mechanism exists.",
          "Why WATCH: admin may pause later.",
          "Tip: review admin/owner and docs."
        ])
      });
    }else{
      checks.push({
        t:"Transfer controls (Pause)",
        sev:"ok",
        d:"No pause function found.",
        why:"paused() not present or unreadable.",
        infoHtml: explain("Transfer controls (Pause)", [
          "Meaning: No standard pausable signal detected.",
          "Why PASS: paused() not found (best-effort)."
        ])
      });
    }

    score = clamp(Math.round(score), 0, 100);
    const critical = !!(sig.paused === true || !sig.hasCode);
    return { score, checks, critical };
  }

  function todoEvm(sig){
    const t = [];
    if(!sig.hasCode){
      t.push({ t:"Fix address / chain", sev:"bad", d:"No contract bytecode found.", why:"Wrong address or wrong chain." });
    }else{
      const zero = "0x0000000000000000000000000000000000000000";

      if(sig.owner && sig.owner.toLowerCase() !== zero){
        t.push({ t:"Secure admin", sev:"warn", d:"Owner is active. Review privileges/timelock/multisig.", why:"Admin can often change parameters." });
      }else if(sig.owner && sig.owner.toLowerCase() === zero){
        t.push({ t:"Owner", sev:"ok", d:"Owner appears renounced.", why:"0x0." });
      }else{
        t.push({ t:"Admin review", sev:"warn", d:"Owner not visible — check alternative admin controls.", why:"owner() missing." });
      }

      if(sig.proxy?.isProxy){
        t.push({ t:"Upgradeability review", sev:"warn", d:"Proxy detected — logic can be upgraded.", why:"Upgradeable." });
      }else{
        t.push({ t:"Upgradeability", sev:"ok", d:"No proxy signal.", why:"EIP-1967 empty." });
      }

      if(sig.paused === true){
        t.push({ t:"Unpause transfers", sev:"bad", d:"Token appears paused.", why:"paused()==true." });
      }else if(sig.paused === false){
        t.push({ t:"Disclose pause rules", sev:"warn", d:"Pause function exists.", why:"Admin can pause." });
      }else{
        t.push({ t:"Transfer controls", sev:"ok", d:"No pause function found.", why:"paused() not detectable." });
      }

      t.push({ t:"Holders distribution", sev:"warn", d:"Top holders are a key risk factor.", why:"Review whale risk." });
    }

    return t.map(x => ({
      ...x,
      infoHtml: explain(x.t, [
        x.d,
        "Why it matters: reduces rug/manipulation risk.",
        "Status: " + pillLabel(x.sev)
      ])
    }));
  }

  /* ===================== EVM STANDARD DETAILS (FIXED DISPLAY) ===================== */
  function renderStandardEvm(sig){
    // We still compute everything.
    // But we hide pure PASS "no signal" rows to avoid the spam you showed in screenshots,
    // unless CFG.UI.SHOW_PASS_DETAILS_EVM === true.

    const rows = [
      {
        t:"Token standard",
        sev:"ok",
        d:"ERC-20 (on-chain calls).",
        why:"name/symbol/decimals/totalSupply calls.",
        infoHtml: explain("ERC-20 standard", [
          "Meaning: Standard interface (name/symbol/decimals/totalSupply).",
          "Why it matters: Non-standard tokens can break tooling."
        ])
      },
      {
        t:"Proxy / upgradeability",
        sev: sig.proxy?.isProxy ? "warn" : "ok",
        d: sig.proxy?.isProxy ? "Upgradeable proxy detected." : "No proxy signal found.",
        why: sig.proxy?.isProxy ? "EIP-1967 non-zero." : "EIP-1967 empty.",
        infoHtml: explain("Proxy / upgradeability", [
          sig.proxy?.isProxy
            ? "WATCH: upgrades possible."
            : "PASS: no upgrade signal found (best-effort).",
          "Note: Some proxies are not EIP-1967 — always verify source code."
        ])
      },
      {
        t:"Transfer controls (Pause)",
        sev: sig.paused===true ? "bad" : (sig.paused===false ? "warn" : "ok"),
        d: sig.paused===true ? "Currently paused." : (sig.paused===false ? "Pause function exists." : "No pause function found."),
        why: sig.paused===true ? "paused()==true." : (sig.paused===false ? "paused()==false." : "no paused()."),
        infoHtml: explain("Pause", [
          sig.paused===true
            ? "FAIL: transfers likely blocked."
            : (sig.paused===false ? "WATCH: pausable." : "PASS: no pausable signal.")
        ])
      }
    ];

    let out = rows;

    if(!CFG.UI.SHOW_PASS_DETAILS_EVM){
      // hide the rows that are only "PASS + No signal" (your screenshots 3/4)
      out = rows.filter(r => {
        // Always keep token standard row
        if(r.t === "Token standard") return true;

        const d = String(r.d || "").toLowerCase();
        const passNoSignal = (r.sev === "ok") && (
          d.includes("no proxy signal") ||
          d.includes("no pause function") ||
          d.includes("not found")
        );

        return !passNoSignal;
      });

      // If both were hidden, still keep ONE short combined row so the section isn't empty.
      if(out.length === 1){
        out.push({
          t:"Standard signals",
          sev:"ok",
          d:"No proxy / pause red flags detected (best-effort).",
          why:"PASS signals were condensed to keep UI clean.",
          infoHtml: explain("Standard signals", [
            "To keep the UI clean, PASS-only 'no signal' items are condensed.",
            "All checks still run and affect scoring/report."
          ])
        });
      }
    }

    renderList(qs("extList"), out, "Token Standard Details");
  }

  function renderMetaEvm(metaMerged, metaOnChain){
    const items = [];

    items.push({
      t:"Name / Symbol",
      sev:(metaMerged?.name && metaMerged?.symbol) ? "ok" : "warn",
      d:`${metaMerged?.name || "—"} • ${metaMerged?.symbol ? ("$"+metaMerged.symbol) : "—"}`,
      why: (metaMerged?.name && metaMerged?.symbol) ? "name/symbol readable (or via API)." : "Missing/unreadable.",
      infoHtml: explain("Name / Symbol", [
        "Meaning: Token identity.",
        (metaMerged?.name && metaMerged?.symbol) ? "Why PASS: present." : "Why WATCH: missing/unreadable."
      ])
    });

    items.push({
      t:"Decimals",
      sev:Number.isFinite(metaOnChain?.decimals) ? "ok" : "warn",
      d:Number.isFinite(metaOnChain?.decimals) ? String(metaOnChain.decimals) : "Not readable",
      why: Number.isFinite(metaOnChain?.decimals) ? "decimals() ok." : "decimals() missing.",
      infoHtml: explain("Decimals", [
        "Meaning: UI/supply calculation.",
        Number.isFinite(metaOnChain?.decimals) ? "Why PASS: present." : "Why WATCH: not readable."
      ])
    });

    const supplyReadable = metaOnChain?.totalSupply!==null && metaOnChain?.totalSupply!==undefined;
    items.push({
      t:"Total Supply",
      sev:supplyReadable ? "ok" : "warn",
      d:supplyReadable ? (formatSupplyNice(metaOnChain.totalSupply, metaOnChain.decimals, (metaMerged?.decimals ?? null)).text || "—") : "—",
      why: supplyReadable ? "totalSupply() ok." : "totalSupply() missing.",
      infoHtml: explain("Total Supply", [
        "Meaning: Basis for holder %.",
        supplyReadable ? "Why PASS: readable." : "Why WATCH: not readable."
      ])
    });

    if(metaMerged?.image){
      items.push({
        t:"Logo / Image",
        sev:"ok",
        d:"Available",
        why:"Logo is off-chain (normal for EVM).",
        infoHtml: explain("Token Logo (EVM)", [
          "EVM tokens typically do not store logos on-chain.",
          "UIs use tokenlists/explorers/metadata providers."
        ])
      });
    }else{
      items.push({
        t:"Logo / Image",
        sev:"warn",
        d: "Not available",
        why: "Logo not available.",
        infoHtml: explain("Token Logo (EVM)", [
          CFG.EVM_METADATA_KEY ? "Provider returned no logo." : "Optional: set EVM_METADATA_KEY (Moralis) to fetch logos."
        ])
      });
    }

    renderList(qs("metaList"), items, "Token Metadata");
  }

  /* ===================== EVM HOLDERS (GoldRush -> compute %) ===================== */
  function formatUnits(bigint, decimals){
    if(bigint === null || bigint === undefined) return null;
    const d = Number.isFinite(decimals) ? decimals : 18;
    const neg = bigint < 0n;
    let x = neg ? -bigint : bigint;

    const base = 10n ** BigInt(d);
    const whole = x / base;
    const frac  = x % base;

    const fracStr = frac.toString().padStart(d,"0").slice(0,6).replace(/0+$/,"");
    return (neg ? "-" : "") + whole.toString() + (fracStr ? ("." + fracStr) : "");
  }

  function pow10n(d){
    try{ return 10n ** BigInt(Math.max(0, Math.min(36, Number(d||0)))); }catch{ return 10n ** 18n; }
  }

  function isMultipleOfDecimals(total, decimals){
    if(total === null || total === undefined) return false;
    const d = Number(decimals);
    if(!Number.isFinite(d) || d < 0 || d > 36) return false;
    const base = pow10n(d);
    try{ return (total % base) === 0n; }catch{ return false; }
  }

  function pickBestDecimals(total, metaDec, dexDec){
    // Treat null/undefined as missing (do NOT coerce to 0).
    const metaOk = !(metaDec === null || metaDec === undefined || metaDec === '') && Number.isFinite(Number(metaDec));
    const dexOk  = !(dexDec  === null || dexDec  === undefined || dexDec  === '') && Number.isFinite(Number(dexDec));

    const m = metaOk ? Number(metaDec) : NaN;
    const d = dexOk  ? Number(dexDec)  : NaN;

    const mOk = Number.isFinite(m) && m >= 0 && m <= 36;
    const dOk = Number.isFinite(d) && d >= 0 && d <= 36;

    if(!mOk && dOk) return d;
    if(mOk && !dOk) return m;
    if(!mOk && !dOk) return 18;

    // If meta decimals produce a fractional supply but dex decimals aligns perfectly, prefer dex decimals.
    const metaAlign = isMultipleOfDecimals(total, m);
    const dexAlign  = isMultipleOfDecimals(total, d);
    if(!metaAlign && dexAlign) return d;

    return m;
  }

  function compactNumberFromString(numStr){
    if(!numStr) return '—';
    const s = String(numStr);
    const n = Number(s);
    if(Number.isFinite(n) && Math.abs(n) < 1e15){
      const abs = Math.abs(n);
      if(abs >= 1e12) return (n/1e12).toFixed(2).replace(/0+$/,'').replace(/\.$/,'') + 'T';
      if(abs >= 1e9)  return (n/1e9 ).toFixed(2).replace(/0+$/,'').replace(/\.$/,'') + 'B';
      if(abs >= 1e6)  return (n/1e6 ).toFixed(2).replace(/0+$/,'').replace(/\.$/,'') + 'M';
      if(abs >= 1e3)  return (n/1e3 ).toFixed(2).replace(/0+$/,'').replace(/\.$/,'') + 'K';
      return new Intl.NumberFormat('en-US', { maximumFractionDigits: 6 }).format(n);
    }
    // Fallback: comma-separate integer part
    const neg = s.startsWith('-');
    const parts = s.replace('-','').split('.');
    const intp = parts[0];
    const withCommas = intp.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    const frac = parts[1] ? ('.' + parts[1].slice(0,6).replace(/0+$/,'')) : '';
    return (neg?'-':'') + withCommas + (frac=='.'?'':frac);
  }

  function formatSupplyNice(total, metaDec, dexDec){
    if(total === null || total === undefined) return { text:'—', usedDecimals:null, approx:false };

    let used = pickBestDecimals(total, metaDec, dexDec);
    let approx = false;

    // Heuristic: if decimals resolved to 0 but supply is absurdly large, assume 18.
    try{
      if(used === 0){
        const TH = 10n ** 24n;
        if(total > TH){
          used = 18;
          approx = true;
        }
      }
    }catch{}

    const raw = formatUnits(total, used);
    return { text: compactNumberFromString(raw), usedDecimals: used, approx };
  }

  function hasSelectorInCode(codeHex, selectorNo0x){
    try{
      const c = strip0x(codeHex).toLowerCase();
      const sel = String(selectorNo0x||'').toLowerCase().replace(/^0x/,'');
      if(!sel || sel.length !== 8) return false;
      return c.includes(sel);
    }catch{ return false; }
  }

  function scanEvmBytecodeFeatures(codeHex){
    // Heuristic: looks for 4-byte selectors inside bytecode dispatch tables
    const has = (sel) => hasSelectorInCode(codeHex, sel);
    return {
      mintable: has('40c10f19'),
      blacklist: has('f9f92be4') || has('fe575a87') || has('153b0d1e'),
      botList:   has('bfd79284') || has('3bbac579') || has('13b2a23e'),
      maxTx:     has('8c0b5e22') || has('ec28438a'),
      maxWallet: has('aa4bde28') || has('27a14fc2'),
      tradingSwitch: has('8a8c523c') || has('4ada218b') || has('c2e5ec04'),
      pausable: has('5c975abb') || has('b187bd26') || has('8456cb59') || has('3f4ba83a'),
      removeLimits: has('751039fc')
    };
  }

  function safeBigIntFromStr(s){
    try{
      if(s === null || s === undefined) return null;
      if(typeof s === "string"){
        if(s.trim() === "") return null;
        if(s.includes(".")) return BigInt(s.split(".")[0]);
        return BigInt(s);
      }
      if(typeof s === "number"){
        if(!Number.isFinite(s)) return null;
        return BigInt(Math.trunc(s));
      }
      return BigInt(s);
    }catch{
      return null;
    }
  }

  async function renderHoldersEvm(chainId, tokenAddr, metaOnChain){
  const supplyBI = metaOnChain?.totalSupply ?? null;
  const decimals = metaOnChain?.decimals ?? 18;

  // 1) Prefer GoldRush holders if available (best-effort)
  const raw = await goldrushHolders(chainId, tokenAddr);

  const pickAddr = (h) => (h?.address || h?.wallet_address || h?.holder_address || h?.owner_address || h?.wallet || h?.holder || '').trim();
  const pickBal  = (h) => (h?.balance ?? h?.token_balance ?? h?.token_balance_wei ?? h?.balance_wei ?? h?.balance_raw ?? h?.token_balance_raw ?? h?.value ?? h?.balance_quote ?? null);

  const holders = [];
  if(Array.isArray(raw) && raw.length){
    for(const h of raw){
      const addr = String(pickAddr(h) || '').toLowerCase();
      if(!addr.startsWith('0x') || addr.length !== 42) continue;

      const balRaw = pickBal(h);
      const balBI = safeBigIntFromStr(balRaw);

      let pct = null;
      if(supplyBI !== null && supplyBI !== undefined && supplyBI > 0n && balBI !== null){
        // keep 2 decimals, avoid float overflow
        const p = Number((balBI * 1000000n) / supplyBI) / 10000;
        pct = Number.isFinite(p) ? p : null;
      }else{
        const p2 = Number(h?.percentage ?? h?.pct ?? h?.share ?? h?.holding ?? NaN);
        pct = Number.isFinite(p2) ? p2 : null;
      }

      holders.push({
        address: addr,
        balance: (balBI !== null) ? balBI.toString() : (balRaw !== null && balRaw !== undefined ? String(balRaw) : null),
        percentage: pct
      });
    }

    // Sort by percentage if present (fallback stable)
    holders.sort((a,b) => (Number(b.percentage ?? -1) - Number(a.percentage ?? -1)));

    const items = holders.slice(0,10).map((h,i) => {
      const addr = h.address;
      const balBI2 = safeBigIntFromStr(h.balance);
      const balFmt = (balBI2 !== null) ? formatUnits(balBI2, decimals) : (h.balance ? String(h.balance) : '—');
      const pctStr = (h.percentage === null || h.percentage === undefined) ? '—' : (Number(h.percentage).toFixed(2) + '%');
      return {
        t:`#${i+1} ${shortAddr(addr)}`,
        d:`${balFmt} tokens • ${pctStr}`,
        addr,
        infoHtml: explain('Top holders (EVM)', [
          'Source: GoldRush indexer (best-effort).',
          'Why it matters: whale concentration can impact price.',
          'Tip: verify in explorer holders tab.'
        ])
      };
    });

    renderHoldersWithExplorer(items, activeChain);
    return holders;
  }

  // 2) Fallback: derive "top wallets" from a recent transfer sample (NOT true balances)
  const transfers = await evmTokenTransfersSample(chainId, tokenAddr, 2000);
  if(transfers && transfers.length){
    // net flow approximation: inflow - outflow in the sample window
    const net = new Map();
    for(const t of transfers){
      const fa = String(t?.from_address||"").toLowerCase();
      const ta = String(t?.to_address||"").toLowerCase();
      const vBI = safeBigIntFromStr(t?.value);
      if(vBI === null) continue;
      if(fa.startsWith('0x')) net.set(fa, (net.get(fa)||0n) - vBI);
      if(ta.startsWith('0x')) net.set(ta, (net.get(ta)||0n) + vBI);
    }

    const top = [...net.entries()]
      .filter(([a,v]) => a.startsWith('0x') && v > 0n)
      .sort((a,b) => (b[1] > a[1] ? 1 : (b[1] < a[1] ? -1 : 0)))
      .slice(0,10);

    const items = top.map(([addr, v], i) => ({
      t:`#${i+1} ${shortAddr(addr)}`,
      d:`${formatUnits(v, decimals)} tokens`,
      addr,
      infoHtml: explain('Fallback top wallets (sample)', [
        'This is NOT a holder snapshot.',
        'We approximate using a recent on-chain transfer sample when no indexer holder list is available.'
      ])
    }));

    renderHoldersWithExplorer(items, activeChain);
    return [];
  }

  renderHoldersEmpty();
  return [];
}



  /* ===================== MAIN SCAN FLOW (same, just calls updated display) ===================== */
  async function runScan(){
    if(SCANNING) return;
    SCANNING = true;

    hideToast();
    updateStampTime();

    const addr = (qs("mint")?.value || "").trim();
    setStatus("");
    clearUI();

    setText("mintShort", addr ? shortAddr(addr) : "—");

    try{
      if(activeChain.kind === "solana"){
        if(!looksBase58(addr)) throw new Error("Invalid Solana mint. (Base58, 32–52 chars)");
        setStatus("Connecting to Solana RPC…");

        const mintParsed = await getMintParsed(addr);
        if(!mintParsed || !mintParsed.info) throw new Error("Mint not found or not parsable.");

        const ownerProg = mintParsed.owner || "";
        const programType =
          ownerProg === CFG.TOKEN_2022_PROGRAM ? "TOKEN_2022"
          : ownerProg === CFG.TOKEN_PROGRAM ? "SPL_TOKEN"
          : "UNKNOWN";

        setStatus("Fetching supply…");
        const supply = await getTokenSupply(addr);
        const uiSupply = Number(supply?.uiAmount ?? NaN);

        setStatus("Fetching largest holders…");
        const largest = await getLargest(addr);

        setStatus("Fetching metadata (getAsset)…");
        const asset = await getAsset(addr);
        const meta = pickTokenMetaFromAsset(asset);

        const mintAuth = mintParsed.info?.mintAuthority ?? null;
        const freezeAuth = mintParsed.info?.freezeAuthority ?? null;

        const extListRaw = parseExtensionsFromParsed(mintParsed.rawParsed);
        const extReadable = Array.isArray(extListRaw);

        let top20 = 0;
        if(Number.isFinite(uiSupply) && uiSupply > 0 && Array.isArray(largest)){
          top20 = largest.slice(0,20).reduce((acc, x) => acc + (Number(x?.uiAmount || 0) / uiSupply * 100), 0);
        }

        setStatus("Fetching live market data (DexScreener)…");
        const dex = await fetchDexScreener(addr).catch(()=> null);
        if(dex && !meta?.image){
          const img = (dex?.info?.imageUrl || dex?.info?.image || dex?.baseToken?.logoURI || "");
          if(img) meta.image = String(img);
        }

        const sig = {
          programType,
          dex,
          extReadable,
          extensions: extListRaw || [],
          mintAuthActive: !!mintAuth,
          freezeActive: !!freezeAuth,
          mintAuthority: mintAuth,
          freezeAuthority: freezeAuth,
          uiSupply: Number.isFinite(uiSupply) ? uiSupply : null,
          top20,
          meta
        };

        applyTokenHeader(meta, addr);

        const {score, checks, critical} = scoreSol(sig);
        const verdict = verdictFrom(score, critical);

        setText("verdictTitle", verdict.title);
        setBadge(qs("verdictBadge"), verdict.label, verdict.mode);
        setText("scoreBadge", `${score}/100`);
        setText("scanHint", programType === "TOKEN_2022" ? "Token-2022 • Review extensions" : "Standard checks");
        const mintRevoked = !mintAuth;
        const freezeRevoked = !freezeAuth;

        const metricRows = [
          { label:"Guardian Score", value:`${score}/100`, badge: verdict.label, barPct: score, mini:"" },
          { label:"Mint Authority", value: mintRevoked ? "REVOKED" : "ACTIVE", badge: mintRevoked ? "PASS" : "FAIL", mini:"" },
          { label:"Freeze Authority", value: freezeRevoked ? "REVOKED" : "ACTIVE", badge: freezeRevoked ? "PASS" : "WATCH", mini:""},
          { label:"Liquidity", value: dex?.liquidityUsd ? money(dex.liquidityUsd) : "—", badge: dex?.dexId ? dex.dexId.toUpperCase() : "DEX", mini:""},
          { label:"Market Cap", value: (dex?.marketCap ? money(dex.marketCap) : (dex?.fdv ? money(dex.fdv) : "—")), badge: dex?.marketCap ? "MCAP" : (dex?.fdv ? "FDV" : "—"), mini:"" },
          { label:"Price", value: dex?.priceUsd ? priceUsdFmt(dex.priceUsd) : "—", badge: "USD", mini:"" },
          { label:"Total Supply", value: Number.isFinite(uiSupply) ? fmtInt(uiSupply) : "—", badge:"Supply", mini:"" },
          { label:"Top20 Concentration", value: Number.isFinite(top20) ? fmtPct(top20) : "—", badge:"Holders", mini:"", barPct: Number.isFinite(top20) ? clamp(top20,0,100) : undefined }
        ];
        renderMetrics(metricRows);



        setText(
          "summary",
          critical ? "Critical risk detected (mint/freeze authority)."
                   : (score>=80 ? "Looks strong — still verify liquidity and official links."
                               : "Mixed signals — verify admin controls && holders.")
        );

        renderList(qs("checksList"), checks, "Guardian Checks");
        const todos = renderMarketDex(dex) || [];
        const flags = [];
        flags.push({t:"Mint Authority Revoked", sev: mintRevoked ? "ok" : "bad", d: mintRevoked ? "YES" : "NO", why: mintRevoked ? "Supply cannot be increased." : "Owner can mint more supply."});
        flags.push({t:"Freeze Authority Revoked", sev: freezeRevoked ? "ok" : "warn", d: freezeRevoked ? "YES" : "NO", why: freezeRevoked ? "Cannot freeze accounts." : "Freeze authority exists."});
        flags.push({t:"Token Program", sev: programType === "TOKEN_2022" ? "warn" : "ok", d: programType === "TOKEN_2022" ? "Token-2022" : "SPL Token", why: programType === "TOKEN_2022" ? "Token-2022 can include extra extensions — review." : "Standard SPL token."});
        renderContractFlags(flags);
        renderMetaSol(meta);

        setStatus("Resolving holder wallets…");
        const holderWallets = await solLargestToWalletHolders(largest, uiSupply, 35).catch(() => []);
        renderHoldersWallets(holderWallets);

        setStatus("Analyzing recent flows (clusters/bundles)…");
        const flow = await solComputeFlowsAndBundles(addr, 30).catch(() => ({edges:new Map(), bundles:[], seenSigs:[]}));
        const bubbleModel = buildBubbleModelSol(holderWallets, flow);
        drawBubbleMap(bubbleModel);
        renderClustersFromModel(bubbleModel);
        renderBundles(flow?.bundles || []);


        LAST_SCAN = {
          time: Date.now(),
          chain: activeChain,
          address: addr,
          score,
          verdict,
          checks,
          todos,
          metrics: metricRows,
          token: {
            name: (meta?.name || '').trim(),
            symbol: (meta?.symbol || '').trim(),
            image: (meta?.image || '').trim()
          }
        };

        enableExport(); /* defined in Part 3 (export system) */
        setStatus("Scan complete.");
      }else{
        if(!looksEvmAddress(addr)) throw new Error("Invalid EVM address. Must be 0x + 40 hex chars.");
        const chainId = activeChain.chainId;

        setStatus("Connecting to EVM RPC…");
        const code = await getCode(chainId, addr);
        const hasCode = !!(code && code !== "0x" && code !== "0x0");

        const bytecodeFeatures = hasCode ? scanEvmBytecodeFeatures(code) : {mintable:false, blacklist:false, botList:false, maxTx:false, maxWallet:false, tradingSwitch:false, pausable:false, removeLimits:false};

        setStatus("Reading ERC-20 on-chain metadata…");
        const metaOnChain = await getErc20Meta(chainId, addr);

        setStatus("Fetching optional metadata provider…");
        const metaApi = await getEvmMetaViaApi(chainId, addr);

        const metaMerged = {
          name: (metaOnChain?.name || metaApi?.name || "").trim(),
          symbol: (metaOnChain?.symbol || metaApi?.symbol || "").trim(),
          image: (metaApi?.image || "").trim()
        };

        setStatus("Fetching live market data (DexScreener)…");
        const dex = await fetchDexScreener(addr).catch(()=> null);
        if(dex && !metaMerged.image){
          const img = (dex?.info?.imageUrl || dex?.info?.image || dex?.baseToken?.logoURI || "");
          if(img) metaMerged.image = String(img);
        }
        applyTokenHeader(metaMerged, addr);

        // best-effort LP burn check (V2-style Uniswap pairs)
        let lpBurn = {pct:null, note:"No LP data."};
        if(dex){
          let pairForBurn = dex.pairAddress || null;
          // If best pair is UniswapV3 (no LP token), try to find an alternative V2-style pair among pairs list.
          if(dex.pairsAll && dex.pairsAll.length){
            const v2 = await pickV2PairAddress(chainId, dex.pairsAll).catch(()=>null);
            if(v2) pairForBurn = v2;
          }
          if(pairForBurn){
            lpBurn = await lpBurnedPercentV2(chainId, pairForBurn);
            if(lpBurn && lpBurn.pct === null && typeof lpBurn.note==='string' && lpBurn.note.toLowerCase().includes('not v2')){
              lpBurn.note = 'V3 pool / no LP token (or non-V2 pool)';
            }
          }
        }

        setStatus("Checking owner/proxy/controls…");
        const [owner, proxy, paused] = await Promise.all([
          getOwner(chainId, addr),
          detectProxy(chainId, addr),
          getPaused(chainId, addr)
        ]);

        const ownerEff = owner || (proxy?.admin ? proxy.admin : null);
        const ownerSource = owner ? 'owner()/getOwner()' : (proxy?.admin ? 'proxy admin' : 'unavailable');

        const sig = { hasCode, metaOnChain, metaMerged, owner: ownerEff, proxy, paused, dex, ownerSource, bytecodeFeatures };
        const {score, checks, critical} = scoreEvm(sig);
        const verdict = verdictFrom(score, critical);

        setText("verdictTitle", verdict.title);
        setBadge(qs("verdictBadge"), verdict.label, verdict.mode);
        setText("scoreBadge", `${score}/100`);
        setText("scanHint", `${activeChain.stamp} • ERC-20 checks`);

        const supplyReadable = metaOnChain?.totalSupply !== null && metaOnChain?.totalSupply !== undefined;
        const dexDec = safeNum(dex?.baseToken?.decimals);
        const supplyNice = supplyReadable ? formatSupplyNice(metaOnChain.totalSupply, metaOnChain.decimals, dexDec) : {text:'—', usedDecimals:null};
        const supplyText = supplyNice.text;

        const metricRows = [
          { label:"Guardian Score", value:`${score}/100`, badge: verdict.label, barPct: score, mini:"" },
          { label:"Ownership Renounced", value: (ownerEff ? (isBurnAddr(ownerEff)?"YES":"NO") : "NOT DETECTED"), badge: ownerEff ? (isBurnAddr(ownerEff)?"PASS":"WATCH") : "WATCH", mini:"" },
          { label:"Liquidity", value: dex?.liquidityUsd != null ? money(dex.liquidityUsd) : "—", badge: dex?.dexId ? dex.dexId.toUpperCase() : "DEX", mini:""},
          { label:"Market Cap", value: (dex?.marketCap != null ? money(dex.marketCap) : (dex?.fdv != null ? money(dex.fdv) : "—")), badge: dex?.marketCap != null ? "MCAP" : (dex?.fdv != null ? "FDV" : "—"), mini:"" },
          { label:"Price", value: dex?.priceUsd != null ? priceUsdFmt(dex.priceUsd) : "—", badge: "USD", mini:"" },
          { label:"LP Burned", value: lpBurn?.pct != null ? `${lpBurn.pct.toFixed(2)}%` : "UNKNOWN", badge: lpBurn?.pct != null ? (lpBurn.pct>=90?"PASS":"WATCH") : "UNKNOWN", mini:""},
          { label:"Proxy", value: proxy?.isProxy ? "Upgradeable" : "No signal", badge: proxy?.isProxy ? "WATCH" : "PASS", mini:"" },
          { label:"Total Supply", value: supplyText ? (supplyText + (supplyNice.approx ? " (assumed)" : "")) : "—", badge: supplyReadable ? "On-chain" : "Unknown", mini:"" }
        ];
        renderMetrics(metricRows);

        setText(
          "summary",
          critical ? "Critical risk detected (paused or contract missing)."
                   : (score>=80 ? "Looks strong — still verify liquidity and official links."
                               : "Mixed signals — verify admin/upgradeability/holders.")
        );

        renderList(qs("checksList"), checks, "Guardian Checks");
        const todos = renderMarketDex(dex) || [];
        const flags = [];
        const renounced = ownerEff ? isBurnAddr(ownerEff) : null;

        flags.push({t:"Owner / Admin", sev: ownerEff ? (isBurnAddr(ownerEff)?"ok":"warn") : "warn", d: ownerEff ? (isBurnAddr(ownerEff)?"Renounced":shortAddr(ownerEff)) : "NOT DETECTED", why: `Source: ${ownerSource}.`});
        flags.push({t:"Ownership Renounced", sev: renounced===true ? "ok" : (renounced===false?"warn":"warn"), d: renounced===null?"NOT DETECTED":(renounced?"YES":"NO"), why:`Best-effort via ${ownerSource}.`});

        // Upgradeability / proxy
        flags.push({t:"Proxy / Upgradeable", sev: proxy?.isProxy ? "warn" : "ok", d: proxy?.isProxy ? "YES" : "NO", why:"EIP-1967 slots check."});

        // Pausable state + presence
        flags.push({t:"Paused (state)", sev: paused===true ? "bad" : (paused===false?"warn":"ok"), d: paused===null?"UNKNOWN":(paused?"YES":"NO"), why: paused===true ? "paused()==true / isPaused()==true" : (paused===false ? "pausable detected (not paused)" : "no signal")});
        flags.push({t:"Pausable (bytecode)", sev: bytecodeFeatures.pausable ? "warn" : "ok", d: bytecodeFeatures.pausable ? "DETECTED" : "NOT DETECTED", why:"Heuristic selector scan."});

        // Mint / blacklist / limits heuristics
        flags.push({t:"Mint Function", sev: bytecodeFeatures.mintable ? "warn" : "ok", d: bytecodeFeatures.mintable ? "DETECTED" : "NOT DETECTED", why:"Heuristic selector scan (mint)."});
        flags.push({t:"Blacklist", sev: bytecodeFeatures.blacklist ? "warn" : "ok", d: bytecodeFeatures.blacklist ? "DETECTED" : "NOT DETECTED", why:"Heuristic selector scan (blacklist)."});
        flags.push({t:"Bot List", sev: bytecodeFeatures.botList ? "warn" : "ok", d: bytecodeFeatures.botList ? "DETECTED" : "NOT DETECTED", why:"Heuristic selector scan (bots)."});
        flags.push({t:"Max Tx", sev: bytecodeFeatures.maxTx ? "warn" : "ok", d: bytecodeFeatures.maxTx ? "DETECTED" : "NOT DETECTED", why:"Heuristic selector scan (limits)."});
        flags.push({t:"Max Wallet", sev: bytecodeFeatures.maxWallet ? "warn" : "ok", d: bytecodeFeatures.maxWallet ? "DETECTED" : "NOT DETECTED", why:"Heuristic selector scan (limits)."});
        flags.push({t:"Trading Switch", sev: bytecodeFeatures.tradingSwitch ? "warn" : "ok", d: bytecodeFeatures.tradingSwitch ? "DETECTED" : "NOT DETECTED", why:"Heuristic selector scan (enableTrading/tradingEnabled)."});
        if(bytecodeFeatures.removeLimits){
          flags.push({t:"Remove Limits", sev:"warn", d:"DETECTED", why:"Heuristic selector scan (removeLimits)."});
        }

        if(lpBurn && lpBurn.pct !== null){
          flags.push({t:"LP Burned (best-effort)", sev: lpBurn.pct>=90?"ok":"warn", d:`${lpBurn.pct.toFixed(2)}%`, why: (lpBurn.note || 'Only counts LP tokens in dead/0x0. Lockers/V3 not included.')});
        }

        renderContractFlags(flags);

        renderMetaEvm(metaMerged, metaOnChain);

        

        // PRO: bubble map / clusters / bundles on EVM (best-effort via indexer)
        setStatus("Fetching top holders (indexer)…");
        const holdersRaw = await renderHoldersEvm(chainId, addr, metaOnChain);

        setStatus("Fetching recent transfers (indexer)…");
        const transfers = await goldrushTransfersV2(chainId, addr, 700);

        if(transfers && transfers.length){
          const model = buildBubbleModelEvm(holdersRaw || [], transfers);
          const hasHolders = (holdersRaw && holdersRaw.length);
          setText('bubbleStamp', activeChain.name + (hasHolders ? ' • TOP HOLDERS + FLOWS' : ' • TRANSFER FLOWS'));
          setText('bubbleHint', hasHolders ? (model.hint || 'Bubble map generated.') : 'Size = activity (no holder list). Links = recent transfers (sampled). Drag to explore.');
          drawBubbleMap(model);
          renderClustersFromModel(model);
          renderBundles(model.bundles || []);
        }else{
          setText('bubbleStamp', activeChain.name + ' • LIMITED');
          setText('bubbleHint', CFG.GOLDRUSH_API_KEY ? 'Indexer returned no transfer graph for this token (or rate-limited).' : 'EVM bubble map needs an indexer.' );
          renderBubbleEmpty();
          renderList(qs('clusterList'), [{t:'No cluster data', sev:'warn', d:'No graph could be built from recent transfers.', why:'Try again or a different token.'}], 'Clusters');
          renderList(qs('bundleList'), [{t:'No bundle data', sev:'warn', d:'No same-tx distributions detected in the sample.', why:'Limited sample.'}], 'Bundles');
        }


        LAST_SCAN = {
          time: Date.now(),
          chain: activeChain,
          address: addr,
          score,
          verdict,
          checks,
          todos,
          metrics: metricRows,
          token: {
            name: (metaMerged?.name || '').trim(),
            symbol: (metaMerged?.symbol || '').trim(),
            image: (metaMerged?.image || '').trim()
          }
        };

        enableExport(); /* defined in Part 3 (export system) */
        setStatus("Scan complete.");
      }
    }catch(err){
      const msg = String(err?.message || err);
      setStatus("Error: " + msg);
      showToast("Connection error: " + msg);
      renderHoldersEmpty();
    }finally{
      SCANNING = false;
    }
  }

  /* ===================== BRANDED REPORT EXPORT (HTML, CLEAN) ===================== */
  function fileSafe(s){
    return String(s || "").replace(/[^a-zA-Z0-9_\-]/g, "").slice(0, 40) || "scan";
  }

  function chainNiceName(chain){
    return chain?.stamp ? `${chain.name} • ${chain.stamp}` : `${chain?.name || "Chain"} (${chain?.id || "-"})`;
  }

  function sevLabel(sev){
    return sev === "ok" ? "PASS" : (sev === "bad" ? "FAIL" : "WATCH");
  }

  function sevColor(sev){
    // used only inside exported HTML report
    if(sev === "ok")  return "linear-gradient(90deg, #14F195, #00D1FF, #9945FF)";
    if(sev === "bad") return "rgba(255,120,150,.18)";
    return "rgba(255,220,130,.14)";
  }

  function sevBorder(sev){
    if(sev === "ok")  return "rgba(255,255,255,.10)";
    if(sev === "bad") return "rgba(255,120,150,.35)";
    return "rgba(255,220,130,.35)";
  }

  function escAttr(x){
    return String(x ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;");
  }

  function buildBrandedReportHtml(scan){
    const dt = new Date(scan.time);
    const utc = dt.toISOString().replace("T"," ").replace("Z","");
    const chainLine = chainNiceName(scan.chain);

    // resolve logo (same path as your site; user can adjust)
    // If your logo is hosted elsewhere, set CFG.UI.REPORT_LOGO_URL to an absolute URL in Part 1.
    const logoUrl = (CFG?.UI?.REPORT_LOGO_URL && String(CFG.UI.REPORT_LOGO_URL).trim())
      ? String(CFG.UI.REPORT_LOGO_URL).trim()
      : "/assets/logo.png";

    const tokenName = (scan?.token?.name || '').trim();
    const tokenSymbol = (scan?.token?.symbol || '').trim();
    const tokenImage = (scan?.token?.image || '').trim();
    const tokenInit = (tokenSymbol || tokenName || '??').replace(/[^a-zA-Z0-9]/g,'').slice(0,2).toUpperCase() || '??';

    const metricsHtml = (Array.isArray(scan.metrics) ? scan.metrics : []).map(m => `
      <div class="metric">
        <div class="k">
          <span>${escAttr(m.label || "Metric")}</span>
          <span class="chip">${escAttr(m.badge || m.value || "—")}</span>
        </div>
        <div class="v">${escAttr(m.value || "—")}</div>
        ${(m.mini && String(m.mini).trim()) ? `<div class="mini">${escAttr(m.mini)}</div>` : ''}
      </div>
    `).join("");

    const checksHtml = (Array.isArray(scan.checks) ? scan.checks : []).map(c => `
      <div class="rowCard" style="border-color:${sevBorder(c.sev)}">
        <div class="left">
          <div class="t">${escAttr(c.t || "Check")}</div>
          <div class="d">${escAttr(c.d || "—")}</div>
        </div>
        <div class="right">
          <div class="pill ${c.sev === "ok" ? "ok" : (c.sev === "bad" ? "bad" : "warn")}">
            ${sevLabel(c.sev)}
          </div>
        </div>
      </div>
    `).join("");

    const todosHtml = (Array.isArray(scan.todos) ? scan.todos : []).map(t => `
      <div class="rowCard" style="border-color:${sevBorder(t.sev)}">
        <div class="left">
          <div class="t">${escAttr(t.t || "Action")}</div>
          <div class="d">${escAttr(t.d || "—")}</div>
        </div>
        <div class="right">
          <div class="pill ${t.sev === "ok" ? "ok" : (t.sev === "bad" ? "bad" : "warn")}">
            ${sevLabel(t.sev)}
          </div>
        </div>
      </div>
    `).join("");

    const verdictMode = scan?.verdict?.mode || "good";
    const verdictText = scan?.verdict?.title || "Guardian Report";
    const verdictLabel = scan?.verdict?.label || "APPROVED";

    const summaryLine = (qs("summary")?.textContent || "").trim() || "";

    return `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <meta name="theme-color" content="#070711"/>
  <title>$SOS Guardian Scan Report • ${escAttr(tokenSymbol || "TOKEN")}</title>
  <style>
    :root{
      --bg:#070711;
      --panel: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --g:#14F195;
      --c:#00D1FF;
      --p:#9945FF;
      --radius: 22px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --max: 980px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--text);
      font: 15.5px/1.55 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: var(--bg);
      overflow-x:hidden;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      z-index:-1;
      pointer-events:none;
      background:
        radial-gradient(1200px 700px at 10% 5%, rgba(153,69,255,.22), transparent 60%),
        radial-gradient(1000px 650px at 90% 10%, rgba(20,241,149,.18), transparent 55%),
        radial-gradient(900px 600px at 70% 85%, rgba(0,209,255,.14), transparent 55%),
        var(--bg);
    }
    .wrap{max-width:var(--max); margin:0 auto; padding:22px 16px 40px;}
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.05));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .inner{padding:18px}
    .top{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:14px;
      flex-wrap:wrap;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:12px;
      min-width: 240px;
    }
    .tokenBadge{
      display:flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
    }
    .tokenImg{
      width:32px;
      height:32px;
      border-radius: 10px;
      object-fit: cover;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
    }
    .tokenTxt{display:flex; flex-direction:column; line-height:1.1}
    .tokenSym{font-weight:800; letter-spacing:.02em}
    .tokenNm{font-size:12px; color: rgba(255,255,255,.70)}
    .brand img{width:44px;height:44px;object-fit:contain;filter: drop-shadow(0 10px 25px rgba(0,0,0,.45));}
    .bt{display:flex; flex-direction:column; line-height:1.05}
    .bt .t{font-weight:1000; letter-spacing:-.2px; font-size:16px}
    .bt .s{font-weight:850; color:var(--muted); font-size:12.5px}
    .tokenBadge{display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.05);margin-top:8px}
    .tokenImgWrap{position:relative;width:34px;height:34px;flex:0 0 auto}
    .tokenImg{width:34px;height:34px;border-radius:12px;object-fit:cover;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.10);display:block}
    .tokenFallback{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;font-weight:1000;letter-spacing:.04em;color:rgba(255,255,255,.92);background:rgba(255,255,255,.08)}
    .tokenTxt{display:flex;flex-direction:column;line-height:1.1}
    .tokenSym{font-weight:1000;letter-spacing:.02em;font-size:12.5px}
    .tokenNm{font-size:12px;color:rgba(255,255,255,.70);max-width:220px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .stamp{
      font-weight:1000;
      font-size:12px;
      letter-spacing: .45px;
      text-transform:uppercase;
      color: rgba(255,255,255,.76);
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius: 999px;
      padding:7px 10px;
      white-space:nowrap;
    }
    .h1{
      margin:12px 0 0;
      font-weight:1000;
      letter-spacing:-1px;
      line-height:1.05;
      font-size: 36px;
    }
    .gradText{
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;
    }
    .sub{margin-top:8px; color: rgba(255,255,255,.76); font-weight:850}
    .grid{
      margin-top:14px;
      display:grid;
      grid-template-columns: 1fr;
      gap:12px;
    }
    .panel{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 18px;
      padding:14px;
    }
    .krow{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .mono{font-family: ui-monospace, Menlo, Consolas, monospace; font-weight:900; color: rgba(255,255,255,.86); overflow-wrap:anywhere;}
    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:7px 11px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
    }
    .badge.good{border:0; background: linear-gradient(90deg, var(--g), var(--c), var(--p)); color:#061012}
    .badge.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .badge.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}
    .badge.good::before{content:"✓";margin-right:6px;font-weight:1100}
    .badge.warn::before{content:"✕";margin-right:6px;font-weight:1100}
    .badge.bad::before{content:"✕";margin-right:6px;font-weight:1100}
    .sectionTitle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .sectionTitle .l{font-weight:1000; letter-spacing:.35px; font-size:12px; text-transform:uppercase; color: rgba(255,255,255,.72);}
    .metricGrid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:10px;
    }
    @media (max-width:720px){ .metricGrid{grid-template-columns:1fr;} }
    .metric{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      border-radius: 16px;
      padding:12px 12px;
    }
    .metric .k{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      color: rgba(255,255,255,.70);
      font-weight:1000;
      font-size:12px;
      letter-spacing:.45px;
      text-transform:uppercase;
    }
    .metric .v{margin-top:8px; font-weight:1000; font-size:20px;}
    .metric .mini{margin-top:6px; font-weight:850; font-size:12px; color: rgba(255,255,255,.62);}
    .chip{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
    }
    .rowCard{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      border-radius: 16px;
      padding:12px 12px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
    }
    .rowCard .t{font-weight:1000; font-size:13px; letter-spacing:.2px;}
    .rowCard .d{margin-top:4px; color: rgba(255,255,255,.70); font-weight:750; font-size:12.5px; line-height:1.35;}
    .pill{
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
      user-select:none;
    }
    .pill.ok{border:0; background: linear-gradient(90deg, var(--g), var(--c), var(--p)); color:#061012}
    .pill.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .pill.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}
    .pill.ok::before{content:"✓";margin-right:6px;font-weight:1100}
    .pill.warn::before{content:"✕";margin-right:6px;font-weight:1100}
    .pill.bad::before{content:"✕";margin-right:6px;font-weight:1100}
    .footer{
      margin-top:14px;
      text-align:center;
      color: rgba(255,255,255,.45);
      font-weight:650;
      font-size:12px;
    }
    .printHint{
      margin-top:10px;
      color: rgba(255,255,255,.60);
      font-weight:850;
      font-size:12px;
      text-align:center;
    }
    @media print{
      body::before{display:none}
      .printHint{display:none}
      .wrap{padding:0}
      .card{box-shadow:none}
    }
  

    /* ===== PRO: Bubble Map / Clusters ===== */
    .split2{display:grid; grid-template-columns: 1.05fr .95fr; gap:16px; align-items:start;}
    @media (max-width: 980px){ .split2{grid-template-columns:1fr;} }
    .bubbleWrap{border:1px solid rgba(255,255,255,.10); background: rgba(0,0,0,.14); border-radius: 18px; padding:12px; overflow:hidden;}
    .bubbleHead{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; margin-bottom:10px;}
    .bubbleLegend{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .legendPill{padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.06); font-weight:950; font-size:12px;}
    canvas#bubbleCanvas{width:100%; height:420px; display:block; border-radius: 14px; background: rgba(0,0,0,.22); border:1px solid rgba(255,255,255,.10);}
    @media (max-width: 980px){ canvas#bubbleCanvas{height:360px;} }
    .miniNote{color: rgba(255,255,255,.62); font-weight:850; font-size:12.5px; line-height:1.35;}



    /* Bubblemap external actions */
    .bubbleActions{display:flex;justify-content:flex-end;gap:10px;margin-top:10px;flex-wrap:wrap}
    .bubbleActions .btn{padding:9px 12px;font-size:13px}
    .bubbleActions .btn.ghost{background:rgba(255,255,255,.06)}
    .bubbleActions .btn.ghost:hover{background:rgba(255,255,255,.10)}

</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="inner">
        <div class="top">
          <div class="brand">
            <img src="${escAttr(logoUrl)}" alt="$SOS" onerror="this.style.display='none'">
            <div class="bt">
              <div class="t">$SOS</div>
              <div class="s">Guardian Scan Report</div>
            </div>
          </div>
          <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end;">
            <div class="stamp">${escAttr(chainLine)}</div>
            <div class="stamp">${escAttr(utc)} UTC</div>
          </div>
        </div>

        <div class="h1">
          <span class="gradText">${escAttr(verdictText)}</span>
        </div>

        <div class="sub">
          Address: <span class="mono">${escAttr(scan.address)}</span>
        </div>

        ${(tokenName || tokenSymbol || tokenImage) ? `
        <div class="tokenBadge" style="margin-top:10px; display:flex">
          <div class="tokenImgWrap">
            ${tokenImage ? `<img class="tokenImg" src="${escAttr(tokenImage)}" alt="${escAttr(tokenName || tokenSymbol || 'Token')}" onerror="this.style.display='none'">` : ''}
            ${!tokenImage ? `<div class="tokenImg tokenFallback">${escAttr(tokenInit)}</div>` : ''}
          </div>
          <div class="tokenTxt">
            <div class="tokenSym">${escAttr(tokenSymbol ? ('$'+tokenSymbol) : 'TOKEN')}</div>
            <div class="tokenNm">${escAttr(tokenName || 'Scanned asset')}</div>
          </div>
        </div>
        ` : ''}

        <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap;">
          <span class="badge ${verdictMode === "good" ? "good" : (verdictMode === "bad" ? "bad" : "warn")}">${escAttr(verdictLabel)}</span>
          <span class="badge good">${escAttr(scan.score)}/100</span>
        </div>

        ${summaryLine ? `<div class="sub" style="margin-top:10px;">${escAttr(summaryLine)}</div>` : ""}

        <div class="grid">
          <div class="panel">
            <div class="sectionTitle">
              <div class="l">Key Metrics</div>
              <div class="l">On-Chain / Best-Effort</div>
            </div>
            <div class="metricGrid">
              ${metricsHtml || `<div class="metric"><div class="k"><span>Metrics</span><span class="chip">—</span></div><div class="v">—</div><div class="mini">No metrics available.</div></div>`}
            </div>
          </div>

          <div class="panel">
            <div class="sectionTitle">
              <div class="l">Checks</div>
              <div class="l">PASS / WATCH / FAIL</div>
            </div>
            <div style="display:grid; gap:10px;">
              ${checksHtml || `<div class="rowCard"><div><div class="t">No checks</div><div class="d">No check data available.</div></div><div class="pill warn">WATCH</div></div>`}
            </div>
          </div>

          <div class="panel">
            <div class="sectionTitle">
              <div class="l">Launch Readiness</div>
              <div class="l">Action List</div>
            </div>
            <div style="display:grid; gap:10px;">
              ${todosHtml || `<div class="rowCard"><div><div class="t">No checklist</div><div class="d">No action list available.</div></div><div class="pill warn">WATCH</div></div>`}
            </div>
          </div>

          <div class="panel">
            <div class="sectionTitle">
              <div class="l">Notes</div>
              <div class="l">$SOS Guardian System</div>
            </div>
            <div style="color: rgba(255,255,255,.74); font-weight:850; font-size:12.5px; line-height:1.45;">
              <div style="margin:6px 0;">• This report is heuristic and best-effort. Always verify liquidity, official links, and contract code.</div>
              <div style="margin:6px 0;">• PASS/WATCH/FAIL applies per-check only. It is not a guarantee of safety.</div>
              <div style="margin:6px 0;">• Tip: Use your browser “Print” → “Save as PDF” for a clean PDF export.</div>
            </div>
          </div>
        </div>

        <div class="printHint">Tip: Press Ctrl+P / Cmd+P → Save as PDF (keeps this design).</div>
        <div class="footer">© ${new Date().getFullYear()} $SOS • Guardian Scan</div>
      </div>
    </div>
  </div>
</body>
</html>`;
  }

  function downloadHtml(filename, html){
    const blob = new Blob([html], { type:"text/html;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // Keep TXT export too (not removed) — but now we prefer HTML.
  function buildReportText(scan){
    const L = [];
    const dt = new Date(scan.time);

    L.push("$SOS Guardian Scan Report");
    L.push("========================================");
    L.push(`Time (UTC): ${dt.toISOString().replace("T"," ").replace("Z","")}`);
    L.push(`Chain: ${scan.chain.name} (${scan.chain.id})`);
    L.push(`Address: ${scan.address}`);
    L.push(`Verdict: ${scan.verdict.title}`);
    L.push(`Score: ${scan.score}/100`);
    L.push("");

    if(scan.metrics && Array.isArray(scan.metrics) && scan.metrics.length){
      L.push("Key Metrics");
      L.push("----------------------------------------");
      for(const m of scan.metrics){
        const label = m?.label || "Metric";
        const value = m?.value ?? "—";
        L.push(`- ${label}: ${value}`);
      }
      L.push("");
    }

    L.push("Checks");
    L.push("----------------------------------------");
    for(const c of scan.checks){
      L.push(`- [${pillLabel(c.sev)}] ${c.t}: ${c.d}`);
    }
    L.push("");

    L.push("Launch Readiness");
    L.push("----------------------------------------");
    for(const t of scan.todos){
      L.push(`- [${pillLabel(t.sev)}] ${t.t}: ${t.d}`);
    }

    L.push("");
    L.push("Notes");
    L.push("----------------------------------------");
    L.push("- This report is heuristic and best-effort. Always verify liquidity, official links, and contract code.");
    L.push("- PASS/WATCH/FAIL applies per-check only. It is not a guarantee of safety.");
    return L.join("\n");
  }

  function downloadText(filename, text){
    const blob = new Blob([text], {type:"text/plain;charset=utf-8"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function enableExport(){
    const b = qs("btnExport");
    if(!b) return;
    b.disabled = false;
    b.textContent = "Download Scan Report";
  }

  /* ===================== EVENTS (modal + buttons) ===================== */
  function wireGlobalClick(){
    document.addEventListener("click", (e) => {
      const t = e.target;
      const openEl = t?.closest?.("[data-open='1']");
      if(openEl){
        const title = openEl.getAttribute("data-title") || "Details";
        const infoId = openEl.getAttribute("data-info") || "";
        const html = getInfo(infoId);
        if(html) openModal(title, html);
        return;
      }
    });

    document.addEventListener("keydown", (e) => {
      if(e.key !== "Enter" && e.key !== " ") return;
      const a = document.activeElement;
      if(a && a.matches && a.matches("[data-open='1']")){
        e.preventDefault();
        const title = a.getAttribute("data-title") || "Details";
        const infoId = a.getAttribute("data-info") || "";
        const html = getInfo(infoId);
        if(html) openModal(title, html);
      }
    });
  }

  function init(){
  setText("y", String(new Date().getFullYear()));

  on("modalClose", "click", closeModal);
  on("toastClose", "click", hideToast);

  on("modalWrap", "click", (e) => {
    if(e.target === qs("modalWrap")) closeModal();
  });

  on("btnScan", "click", runScan);
  on("btnScanInline", "click", runScan);

  on("mint", "keydown", (e) => {
    if(e.key === "Enter") runScan();
  });

  on("btnExport", "click", () => {
    if(!LAST_SCAN) return;

    const safeAddr = fileSafe((LAST_SCAN.address || "").replace(/^0x/i,"").slice(0, 16));
    const sym = fileSafe((LAST_SCAN?.token?.symbol || '').toLowerCase()).slice(0,12);
    const htmlName = `guardian_scan_${LAST_SCAN.chain.id}_${sym || 'token'}_${safeAddr}.html`;
    const html = buildBrandedReportHtml(LAST_SCAN);
    downloadHtml(htmlName, html);
  });

  const url = new URL(location.href);
  const chainParam = url.searchParams.get("chain");
  if(chainParam && CFG.CHAINS.some(c => c.id === chainParam)){
    activeChain = CFG.CHAINS.find(c => c.id === chainParam);
  }

  setActiveChain(activeChain.id, false);
  startLiveStampTime();
  wireGlobalClick();
}

  // Safety: expose runScan globally for inline onclick fallback
  window.runScan = runScan;

  // Safety: surface JS errors to the UI once
  (function(){
    let shown = false;
    window.addEventListener('error', (e)=>{
      if(shown) return;
      shown = true;
      try{
        const msg = (e && e.message) ? e.message : 'Unknown script error';
        setStatus('Script error: ' + msg);
        showToast('Script error: ' + msg);
      }catch(_){}
    });
    window.addEventListener('unhandledrejection', (e)=>{
      if(shown) return;
      shown = true;
      try{
        const msg = (e && e.reason && (e.reason.message||e.reason)) ? (e.reason.message||e.reason) : 'Unhandled promise rejection';
        setStatus('Script error: ' + msg);
        showToast('Script error: ' + msg);
      }catch(_){}
    });
  })();



init();


  </script>

</body>
</html>
