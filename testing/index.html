<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#070711" />
  <title>$SOS â€” DEX Terminal (Multi-Chain)</title>
  <meta name="description" content="$SOS DEX Terminal â€” native chart + live trades across Solana, Ethereum, BNB, Base." />

  <style>
    :root{
      --bg:#070711;
      --bg2:#070711;
      --bg3:#070711;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.085);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --muted2: rgba(255,255,255,.55);
      --g:#14F195;
      --r:#FF4D6D;
      --c:#00D1FF;
      --p:#9945FF;
      --radius: 22px;
      --shadow: 0 14px 40px rgba(0,0,0,.55);
      --max: 1280px;
      --glass: blur(14px);
      --t: .18s ease;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
     margin:0;
     color:var(--text);
     font: 16px/1.6 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
     background: var(--bg);
     overflow-x:hidden;
     position: relative;
     }

    body::before{
     content:"";
     position: fixed;
     inset: 0;
     z-index: -1;
     pointer-events: none;
     background:
     radial-gradient(1200px 760px at 10% 5%, rgba(153,69,255,.24), transparent 60%),
     radial-gradient(1000px 720px at 90% 10%, rgba(20,241,149,.18), transparent 58%),
     radial-gradient(900px 640px at 72% 92%, rgba(0,209,255,.14), transparent 58%),
     radial-gradient(900px 640px at 0% 95%, rgba(0,209,255,.06), transparent 60%),
     var(--bg);
     transform: translateZ(0);
     }
a{color:inherit; text-decoration:none}
    button,input,select{font:inherit}

    .wrap{max-width:var(--max); margin:0 auto; padding:18px 16px 28px}

    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:12px 12px;
      border:1px solid var(--stroke);
      background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.04));
      border-radius: 26px;
      box-shadow: var(--shadow);
      backdrop-filter: var(--glass);
      position:sticky; top:10px; z-index:20;
    }

    

    /* Topbar: replace $SOS title with Dexguard button */
    .topbar #topDexguardBtn{ padding: 9px 16px; }
    .topbar #topDexguardBtn .dexguardText{ font-size: 18px; }
    .topbar #topDexguardBtn .dexguardChip{ font-size: 12px; }


    /* Topbar brand area (legacy logo styles kept clean so CSS never breaks) */
    .brand{display:flex; align-items:center; gap:10px; min-width:0}
    .logo{
      width:38px; height:38px; border-radius:14px;
      display:grid; place-items:center;
      background:
        radial-gradient(14px 14px at 35% 30%, rgba(20,241,149,.9), transparent 60%),
        radial-gradient(14px 14px at 70% 35%, rgba(0,209,255,.9), transparent 60%),
        radial-gradient(14px 14px at 50% 80%, rgba(153,69,255,.9), transparent 60%),
        rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
    }
    .logo span{font-weight:900; letter-spacing:-.02em}

    /* Top-left DexGuard button (replaces old SOS title) */
    .topbar .dexguardBtn{ padding:9px 16px; }
    .topbar .dexguardText{ font-size:18px; }
    @media (max-width:520px){
      .topbar .dexguardText{ font-size:16px; }
    }

    .brandTxt{min-width:0}
    .brandTxt .t1{font-weight:900; letter-spacing:-.02em; font-size:15px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .brandTxt .t2{font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}

    .actions{display:flex; align-items:center; gap:10px}

    .pillRow{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
    .pill{
      display:inline-flex; align-items:center; gap:7px;
      padding:9px 12px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.85);
      cursor:pointer;
      user-select:none;
      transition: transform var(--t), background var(--t), border-color var(--t);
    }
    .pill:hover{transform: translateY(-1px); background: rgba(255,255,255,.07)}
    .pill.active{border-color: rgba(153,69,255,.55); background: rgba(153,69,255,.14)}
    .pill .dot{width:10px; height:10px; border-radius:50%; background: rgba(255,255,255,.18); box-shadow: inset 0 0 0 1px rgba(255,255,255,.14)}
    .pill.active .dot{background: var(--p)}

    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px;
      padding:10px 14px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      cursor:pointer;
      transition: transform var(--t), background var(--t), border-color var(--t);
    }
    .btn:hover{transform: translateY(-1px); background: rgba(255,255,255,.085)}
    .btn.primary{background: rgba(20,241,149,.14); border-color: rgba(20,241,149,.32)}
    .btn.ghost{background: rgba(255,255,255,.03)}

    /* Twitter/X button (topbar) */
    .btn.xbtn{
      background: rgba(0,0,0,.55);
      border-color: rgba(255,255,255,.16);
      color: rgba(255,255,255,.92);
    }
    .btn.xbtn:hover{ background: rgba(0,0,0,.70); }

    /* Hide topbar chain pills + buy button (use lower controls instead) */
    #netPills, #btnBuy{ display:none !important; }
    .btn.xbtn svg{ width:14px; height:14px; display:block; }

    /* Remove topbar chain pills + buy button (keep lower buttons) */
    #netPills{ display:none !important; }
    #btnBuy{ display:none !important; }

    .panel{
      margin-top:14px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: var(--glass);
      overflow:hidden;
    }

    
    /* ===== Dex-style Top Trending Bar + Search (MATCH MAIN PAGE) ===== */
    :root{
      --tickerSpeed: 8.2s;
      --tickerDistance: 50%;

      --solColor: #9945FF;
      --ethColor: #627EEA;
      --bnbColor: #F3BA2F;
      --baseColor:#0052FF;

      --netColor: var(--solColor);
      --netGlow: rgba(153,69,255,.22);
    }

    body.net-sol{ --netColor: var(--solColor); --netGlow: rgba(153,69,255,.22); }
    body.net-eth{ --netColor: var(--ethColor); --netGlow: rgba(98,126,234,.22); }
    body.net-bnb{ --netColor: var(--bnbColor); --netGlow: rgba(243,186,47,.22); }
    body.net-base{ --netColor: var(--baseColor); --netGlow: rgba(0,82,255,.22); }

    /* Top trending bar container (inside panel) */
    .topBar{
      z-index: 60;
      position: relative;
      background: rgba(11,16,51,.45);
      border-bottom: 1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }

    .topBarInner{
      padding: 14px 16px 12px;
      display:flex;
      flex-direction: column;
      gap: 10px;
    }

    .topRow{
      display:flex;
      align-items:center;
      justify-content:flex-start;
      gap: 12px;
      flex-wrap:wrap;
    }

    /* keep chain pills close to LIVE TRENDING (not pushed to far right) */
    .chainToggle{ margin-left: 10px; }

    .bottomRow{
      display:flex;
      align-items:center;
      gap: 12px;
      min-width: 0;
    }

    .hotBlock{ display:flex; align-items:center; gap: 12px; flex-wrap:wrap; }
    .hotLabel{
      display:inline-flex;
      align-items:center;
      gap: 10px;
      padding: 9px 14px;
      border-radius: 999px;
      background: rgba(255,65,65,.10);
      border: 1px solid rgba(255,65,65,.20);
      box-shadow: 0 12px 32px rgba(0,0,0,.24);
      font-weight: 1100;
      letter-spacing: .6px;
    }
    .hotFire{ width: 18px; height: 18px; opacity: .95; display:grid; place-items:center; }

    .dexguardBtn{
      display:inline-flex;
      align-items:center;
      gap:12px;
      padding: 9px 16px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background:
        radial-gradient(140% 120% at 0% 0%, rgba(0,209,255,.18), rgba(0,209,255,0) 55%),
        radial-gradient(140% 120% at 100% 100%, rgba(153,69,255,.18), rgba(153,69,255,0) 55%),
        rgba(8,18,40,.50);
      box-shadow: 0 12px 34px rgba(0,0,0,.28);
      color: rgba(255,255,255,.92);
      font-weight: 1050;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease, box-shadow .15s ease;
      position:relative;
      overflow:hidden;
    }
    .dexguardBtn:hover{
      transform: translateY(-1px);
      border-color: rgba(255,255,255,.18);
      background:
        radial-gradient(140% 120% at 0% 0%, rgba(0,209,255,.22), rgba(0,209,255,0) 60%),
        radial-gradient(140% 120% at 100% 100%, rgba(153,69,255,.22), rgba(153,69,255,0) 60%),
        rgba(8,18,40,.62);
      box-shadow: 0 16px 46px rgba(0,0,0,.36);
    }
    .dexguardBtn:active{ transform: translateY(0px) scale(.995); }
    .dexguardBtn::after{
      content:"";
      position:absolute;
      inset:-60% -40%;
      background: linear-gradient(120deg,
        transparent 0%,
        rgba(255,255,255,.00) 35%,
        rgba(255,255,255,.22) 50%,
        rgba(255,255,255,.06) 60%,
        transparent 75%
      );
      transform: translateX(-170%) rotate(10deg);
      opacity:0;
      pointer-events:none;
      mix-blend-mode: screen;
      animation: dexguardShine 6.8s ease-in-out infinite;
    }
    @keyframes dexguardShine{
      0%, 72%{ opacity:0; transform: translateX(-170%) rotate(10deg); }
      78%{ opacity:.70; }
      92%{ opacity:0; transform: translateX(170%) rotate(10deg); }
      100%{ opacity:0; transform: translateX(170%) rotate(10deg); }
    }

    .dexguardChip{
      position: relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 7px 14px;
      border-radius: 999px;
      background: rgba(3,12,24,.65);
      border: 1px solid rgba(255,255,255,.10);
      font-weight: 1100;
      letter-spacing: .28em;
      font-size: 13px;
      color: rgba(255,255,255,.96);
    }
    .dexguardChip::before{
      content:"";
      position:absolute;
      inset:-2px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(20,241,149,.88), rgba(0,209,255,.88), rgba(153,69,255,.88));
      z-index:-1;
      opacity:.9;
    }
    .dexguardText{
      font-weight: 1050;
      letter-spacing: -.2px;
      font-size: 20px;
      line-height: 1;
    }

    @media (max-width: 520px){
      .dexguardText{ font-size: 18px; }
      .dexguardBtn{ padding: 9px 14px; gap: 10px; }
      .dexguardChip{ padding: 7px 12px; }
    }

    .chainToggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }

    .chainBtn{
      appearance:none;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.92);
      font-weight: 1000;
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 999px;
      cursor:pointer;
      letter-spacing: .35px;
      transition: transform .15s ease, background .15s ease, border-color .15s ease, box-shadow .15s ease;
    }
    .chainBtn:hover{ background: rgba(255,255,255,.09); transform: translateY(-1px); }
    .chainBtn:active{ transform: translateY(0px) scale(.99); }

    .chainBtn[data-net="solana"]{ border-color: rgba(153,69,255,.50); background: rgba(153,69,255,.10); box-shadow: 0 0 0 1px rgba(153,69,255,.12) inset, 0 10px 22px rgba(153,69,255,.10); }
    .chainBtn[data-net="eth"]{ border-color: rgba(98,126,234,.50); background: rgba(98,126,234,.10); box-shadow: 0 0 0 1px rgba(98,126,234,.12) inset, 0 10px 22px rgba(98,126,234,.10); }
    .chainBtn[data-net="bsc"]{ border-color: rgba(243,186,47,.52); background: rgba(243,186,47,.10); box-shadow: 0 0 0 1px rgba(243,186,47,.12) inset, 0 10px 22px rgba(243,186,47,.10); }
    .chainBtn[data-net="base"]{ border-color: rgba(0,82,255,.52); background: rgba(0,82,255,.10); box-shadow: 0 0 0 1px rgba(0,82,255,.12) inset, 0 10px 22px rgba(0,82,255,.10); }

    .chainBtn.active{
      color: rgba(255,255,255,.96);
      text-shadow: 0 1px 0 rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.96);
      box-shadow: 0 10px 26px rgba(0,0,0,.28);
    }
    body.net-sol .chainBtn.active{ background: linear-gradient(90deg, rgba(153,69,255,.96), rgba(153,69,255,.52)); }
    body.net-eth .chainBtn.active{ background: linear-gradient(90deg, rgba(98,126,234,.96), rgba(98,126,234,.52)); }
    body.net-bnb .chainBtn.active{ background: linear-gradient(90deg, rgba(243,186,47,.96), rgba(243,186,47,.50)); }
    body.net-base .chainBtn.active{ background: linear-gradient(90deg, rgba(0,82,255,.96), rgba(0,82,255,.50)); }

    .tickerWrap{
      flex: 1;
      min-width: 0;
      position: relative;
      overflow: hidden;
      border-radius: 999px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 30px rgba(0,0,0,.22);
      padding: 10px 12px;
    }

    .tickerWrap:before,
    .tickerWrap:after{
      content:"";
      position:absolute;
      top:0; bottom:0;
      width: 44px;
      pointer-events:none;
      z-index: 2;
    }
    .tickerWrap:before{ left:0; background: linear-gradient(90deg, rgba(11,16,51,.92), rgba(11,16,51,0)); }
    .tickerWrap:after{ right:0; background: linear-gradient(270deg, rgba(11,16,51,.92), rgba(11,16,51,0)); }

    .tickerTrack{
      display:flex;
      gap: 10px;
      align-items:center;
      white-space: nowrap;
      will-change: transform;
      animation: tickerMarquee var(--tickerSpeed) linear infinite;
    }

    .tickerWrap:hover .tickerTrack{ animation-play-state: paused; }

    @keyframes tickerMarquee{
      0%{ transform: translateX(0); }
      100%{ transform: translateX(calc(-1 * var(--tickerDistance))); }
    }

    .tickerItem{
      display:inline-flex;
      align-items:center;
      gap: 10px;
      padding: 7px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 0 0 1px var(--netGlow) inset;
      color: rgba(255,255,255,.92);
      font-weight: 900;
      font-size: 13px;
      letter-spacing: .1px;
      cursor:pointer;
    }

    .tickerLogoWrap{
      width:28px;
      height:28px;
      flex:0 0 28px;
      border-radius: 6px;
      overflow:hidden;
      display:grid;
      place-items:center;
      background: rgba(255,255,255,.07);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 8px 18px rgba(0,0,0,.22);
    }
    .tickerLogo{ width:100%; height:100%; object-fit: cover; display:block; }
    .tickerLogoFallback{ font-size: 12px; font-weight: 1100; color: rgba(255,255,255,.90); line-height: 1; }
    .tickerItem.top1 .tickerLogoWrap{ border-color: rgba(255,215,0,.35); box-shadow: 0 0 0 1px rgba(255,215,0,.15) inset, 0 10px 22px rgba(0,0,0,.22); }

    .tickerItem .rank{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width: 28px;
      height: 22px;
      padding: 0 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      font-size: 12px;
      font-weight: 1000;
      color: var(--netColor);
    }
    .tickerItem .sym{ font-weight: 950; }

    .tickerPct{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      height: 22px;
      padding: 0 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      font-size: 12px;
      font-weight: 950;
      color: rgba(255,255,255,.90);
    }
    .tickerPct.up{ color: rgba(20,241,149,.98); background: rgba(20,241,149,.10); border-color: rgba(20,241,149,.22); }
    .tickerPct.down{ color: rgba(255,90,90,.96); background: rgba(255,90,90,.10); border-color: rgba(255,90,90,.22); }

    .tickerItem.top1{
      background: rgba(255,215,0,.10);
      border-color: rgba(255,215,0,.32);
      box-shadow: 0 0 0 1px rgba(255,215,0,.18) inset, 0 12px 30px rgba(0,0,0,.26);
    }
    .tickerItem.top1 .rank{
      background: linear-gradient(90deg, #F3BA2F, #FFD700, #FFF2B0);
      color: rgba(10,10,22,.92);
      border: 0;
      font-weight: 1100;
    }

    /* Search (styled like main page) */
    .dexSearch{position: relative; width: 360px; max-width: 44vw; z-index: 99999; isolation:isolate; }
    .dexSearchInner{
      display:flex;
      gap: 8px;
      align-items:center;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 30px rgba(0,0,0,.22);
    }
    .dexInput{
      flex: 1;
      min-width: 0;
      background: transparent;
      border: 0;
      outline: none;
      color: rgba(255,255,255,.92);
      font-weight: 850;
      font-size: 13px;
    }
    .dexInput::placeholder{ color: rgba(255,255,255,.55); font-weight: 800; }

    /* Re-skin existing results dropdown to match main page style */
    .results{
      z-index: 1000001;
display:none;
      position:absolute;
      top: calc(100% + 10px);
      right: 0;
      left: auto;
      width: min(560px, calc(100vw - 28px));
      max-height: 60vh;
      overflow:auto;
      padding: 10px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      /* IMPORTANT: fully readable dropdown (no chart bleed-through) */
      background: rgba(12,16,40,.98);
      box-shadow: 0 26px 90px rgba(0,0,0,.78);
      isolation: isolate;
      z-index: 999999;
    }

    /* Search modal scrim: blocks chart/trades from showing through while searching */
    .searchScrim{
      display:none;
      position:fixed;
      inset:0;
      background: rgba(7,7,17,.72);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 999990;
    }
    .dexSearch.open .searchScrim{ display:block; }


    /* Keep DexGuard search row markup, but make it feel like the main dropdown */
    .resItem{
      border-radius: 16px;
      margin-bottom: 10px;
      border: 1px solid rgba(255,255,255,.10);
      background: #141c44;
      padding: 10px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      cursor:pointer;
      transition: background .15s ease, border-color .15s ease, transform .15s ease;
    }
    .resItem:hover{ background: #18214f; border-color: rgba(255,255,255,.18); transform: translateY(-1px); }
    .resItem:last-child{ margin-bottom: 0; }

    .resL{ display:flex; align-items:center; gap: 10px; min-width:0; }
    .resLogo{
      width: 36px;
      height: 36px;
      border-radius: 12px;
      overflow:hidden;
      display:grid;
      place-items:center;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      flex: 0 0 36px;
    }
    .resLogo img{ width:100%; height:100%; object-fit:cover; display:block; }
    .resLogo .fb{ font-weight:1100; color: rgba(255,255,255,.92); }

    .resTxt{ min-width:0; }
    .resName{ font-weight: 1000; letter-spacing:-.01em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .resMeta{ font-size: 12px; color: rgba(255,255,255,.64); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; margin-top: 2px; }
    .resR{ display:flex; gap: 8px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }

    /* Hide legacy UI bits so the bar looks identical */
    #btnGo{ display:none !important; }
    #modeHint{ display:none !important; }

    @media (max-width: 860px){
      .dexSearch{ width: 100%; max-width: 100%; }
      .bottomRow{ flex-direction: column; align-items: stretch; }
    }
    /* Layout: chart on top, trades underneath (desktop + mobile) */
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
      padding:14px;
    }

    .card{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.045);
      border-radius: 20px;
      overflow:hidden;
    }

    .cardHd{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:14px 14px;
      border-bottom:1px solid rgba(255,255,255,.07);
    }
    .pair{display:flex; align-items:center; gap:10px; min-width:0}
    .tlogo{width:38px; height:38px; border-radius:14px; overflow:hidden; display:grid; place-items:center; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10)}
    .tlogo img{width:100%; height:100%; object-fit:cover}
    .tlogo .fb{font-weight:900; opacity:.9}
    .pairTxt{min-width:0}
    .pairName{font-weight:950; letter-spacing:-.02em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .pairNameSub{font-size:12px; font-weight:800; opacity:.72; margin-left:8px; letter-spacing:0;}
    .pairMeta{font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}

    .stats{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}
    .statPill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.10);
      font-size:12px;
      color: rgba(255,255,255,.86);
      white-space:nowrap;
    }
    .statPill.up{border-color: rgba(20,241,149,.30); background: rgba(20,241,149,.10); color: rgba(20,241,149,.92)}
    .statPill.down{border-color: rgba(255,77,109,.28); background: rgba(255,77,109,.10); color: rgba(255,77,109,.92)}

    #chartWrap{height: 520px; position:relative; z-index:0}
    #chart{position:absolute; inset:0; z-index:1}
    /* Ensure dropdowns/menus always sit above the chart canvas */
    #chart canvas{position:relative; z-index:1}

    .controls{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:12px 12px;
      border-top:1px solid rgba(255,255,255,.07);
      background: rgba(0,0,0,.10);
      flex-wrap:wrap;
    }

    .tfRow{display:flex; gap:6px; flex-wrap:wrap}
    .tf{padding:8px 10px; border-radius: 999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); cursor:pointer; font-weight:850; font-size:12px}
    .tf.active{border-color: rgba(0,209,255,.42); background: rgba(0,209,255,.14)}

    .rightCtl{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .sel{padding:9px 10px; border-radius: 999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); color: var(--text)}

    .tableHd{
      display:flex; align-items:flex-end; justify-content:space-between;
      padding:14px 14px;
      border-bottom:1px solid rgba(255,255,255,.07);
    }
    .ttl{font-weight:950; letter-spacing:-.02em}
    .sub{font-size:12px; color:var(--muted)}

    .trades{
      height: 600px;
      overflow:auto;
    }

    .tradeHead, .tradeRow{
      display:grid;
      grid-template-columns: 90px 70px 90px 1fr 110px 1fr 34px;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      font-size:13px;
    }
    .tradeHead{
      position:sticky; top:0; z-index:5;
      background: rgba(12,12,20,.92);
      backdrop-filter: blur(12px);
      font-size:12px;
      color: rgba(255,255,255,.72);
      font-weight:900;
    }
    .tradeRow:hover{background: rgba(255,255,255,.05)}
    .typeBadge{
      display:inline-flex; align-items:center; justify-content:center;
      padding:6px 10px;
      border-radius:999px;
      font-weight:950;
      font-size:12px;
      letter-spacing:-.01em;
      border:1px solid rgba(255,255,255,.10);
      width:fit-content;
    }
    .typeBadge.buy{background: rgba(20,241,149,.10); border-color: rgba(20,241,149,.30); color: rgba(20,241,149,.95)}
    .typeBadge.sell{background: rgba(255,77,109,.10); border-color: rgba(255,77,109,.28); color: rgba(255,77,109,.95)}

    .mono{font-variant-numeric: tabular-nums; font-feature-settings: "tnum" 1}
    .maker{display:flex; align-items:center; gap:8px; min-width:0}
    .maker .addr{white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color: rgba(255,255,255,.85)}
    .maker .new{font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid rgba(153,69,255,.30); background: rgba(153,69,255,.12); color: rgba(153,69,255,.95); font-weight:900}

    .iconBtn{width:30px; height:30px; border-radius: 999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); display:grid; place-items:center; cursor:pointer}
    .iconBtn:hover{background: rgba(255,255,255,.08)}

    .toast{
      position:fixed;
      left:50%; transform: translateX(-50%);
      bottom:18px;
      background: rgba(10,10,18,.92);
      border:1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.92);
      padding:12px 14px;
      border-radius: 14px;
      box-shadow: 0 14px 60px rgba(0,0,0,.65);
      backdrop-filter: blur(14px);
      display:none;
      z-index:60;
      max-width: calc(100% - 24px);
    }

    /* Mobile-first: keep it clean */
    .mobileTabs{display:none}
    .tabBar{
      display:flex; gap:8px;
      padding:12px 12px;
      border-top:1px solid rgba(255,255,255,.06);
      background: rgba(0,0,0,.12);
    }
    .tab{
      flex:1;
      padding:10px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      font-weight:950;
      cursor:pointer;
      text-align:center;
    }
    .tab.active{border-color: rgba(153,69,255,.55); background: rgba(153,69,255,.14)}

    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr}
      .trades{height: 420px}
      #chartWrap{height: 420px}
      .topbar{position:sticky; top:10px}
    }

    @media (max-width: 640px){
      /* Remove the harsh green mid-page wash on small screens */
      body{
        background:
          radial-gradient(900px 520px at 25% 0%, rgba(153,69,255,.22), transparent 60%),
          radial-gradient(900px 520px at 85% 18%, rgba(0,209,255,.14), transparent 60%),
          var(--bg);
      }

      .wrap{padding:12px 10px 18px}

      /* Cleaner, less "thick" top header */
      .topbar{
        padding:10px 10px;
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }
      .actions{justify-content:space-between; width:100%; gap:8px; flex-wrap:wrap}
      .btn{padding:10px 12px; font-size:13px}
      .pill{padding:8px 10px}

      /* Make the trending/search header feel compact & aligned */
      .topBarInner{padding:12px 12px 12px}
      .hotLabel{padding:10px 12px; font-size:13px}
      .chainBtn{padding:8px 10px; font-size:12px}
      .dexSearchInner{padding:10px 12px}
      .results{left:0; right:0; width: calc(100vw - 24px)}

      .tickerTrack{animation-duration: 22s}
      .grid{padding:12px}
      .stats{justify-content:flex-start}

      /* Always show chart then trades (no tabs) */
      .mobileTabs{display:none !important}
      #mobileTradesWrap{display:none !important}
      .desktopOnly{display:block}

      #chartWrap{height: 460px}
      .trades{height: 520px}

      /* Trades table: keep it readable */
      .tradeHead, .tradeRow{grid-template-columns: 62px 64px 78px 1fr 0 0 34px}
      .tradeHead .hideM, .tradeRow .hideM{display:none}
      .maker .new{display:none}
    }
  
    /* Chart loading overlay (only affects chart area) */
    #chartSkel{
      position:absolute; inset:0;
      display:none;
      place-items:center;
      background: linear-gradient(180deg, rgba(9,12,33,.72), rgba(9,12,33,.38));
      border-radius:16px;
      z-index:10;
      pointer-events:none;
    }
    #chartSkel .skelBox{
      width:min(520px, 86%);
      padding:18px 16px;
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      background: rgba(255,255,255,.04);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #chartSkel .skelLine{
      height:10px;
      margin:10px 0;
      border-radius:999px;
      background: linear-gradient(90deg, rgba(255,255,255,.06), rgba(255,255,255,.14), rgba(255,255,255,.06));
      background-size: 240% 100%;
      animation: chartSkel 1.1s linear infinite;
    }
    #chartSkel .skelHint{
      margin-top:12px;
      font-size:13px;
      color: rgba(255,255,255,.78);
      font-weight:800;
      text-align:center;
    }
    @keyframes chartSkel{
      0%{ background-position: 0% 0%; }
      100%{ background-position: 240% 0%; }
    }

    /* Smooth trade row insertion */
    .tradeRow.newRow{
      animation: tradeIn .22s ease-out both;
    }
    @keyframes tradeIn{
      from{ opacity:0; transform: translateY(-6px); }
      to{ opacity:1; transform: translateY(0); }
    }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <button class="dexguardBtn" id="topDexguardBtn" type="button" aria-label="DexGuard">
          <span class="dexguardChip" aria-hidden="true">DEX</span>
          <span class="dexguardText">DexGuard</span>
        </button>
      </div>

      <div class="actions">
        <div class="pillRow" id="netPills"></div>
        <a class="btn ghost" id="btnBack" href="/">Back to Main</a>
        <a class="btn xbtn" id="btnX" href="https://www.x.com/solana_x1" target="_blank" rel="noreferrer" aria-label="Twitter/X">
          <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true" focusable="false" style="display:block">
            <path fill="currentColor" d="M18.9 2H22l-6.8 7.8L23 22h-6.2l-4.8-7.1L5.8 22H2l7.4-8.5L1 2h6.3l4.3 6.4L18.9 2Zm-1.1 18h1.7L6.2 3.9H4.4L17.8 20Z"/>
          </svg>
          <span>Twitter/X</span>
        </a>
        <a class="btn primary" id="btnBuy" href="#" target="_blank" rel="noreferrer">Buy</a>
      </div>
    </div>
    <div class="panel">
      <!-- TOP TRENDING BAR + SEARCH (MATCH MAIN PAGE) -->
      <div class="topBar" id="topBar">
        <div class="topBarInner">
          <div class="topRow">
            <div class="hotBlock" aria-label="Hot trending live">
              <div class="hotLabel" title="Live trending"><span class="hotFire">ðŸ”¥</span><span>LIVE TRENDING</span></div>
              <div id="status" style="display:none">Bootingâ€¦</div>
              <div id="clock" style="display:none"></div>
            </div>

            <div class="chainToggle" id="trendToggle" aria-label="Trending chain">
              <button class="chainBtn active" data-net="solana" type="button">SOL</button>
              <button class="chainBtn" data-net="eth" type="button">ETH</button>
              <button class="chainBtn" data-net="bsc" type="button">BNB</button>
              <button class="chainBtn" data-net="base" type="button">BASE</button>
            </div>
          </div>

          <div class="bottomRow">
            <div class="tickerWrap" aria-label="Trending tokens">
              <div class="tickerTrack" id="tickerTrack">
                <span class="tickerItem" style="opacity:.75"><span class="rank">â€¦</span><span class="tickerLogoWrap"><span class="tickerLogoFallback">â€¢</span></span><span class="sym">Trending</span></span>
                <span class="tickerItem" style="opacity:.75"><span class="rank">â€¦</span><span class="tickerLogoWrap"><span class="tickerLogoFallback">â€¢</span></span><span class="sym">Trending</span></span>
                <span class="tickerItem" style="opacity:.75"><span class="rank">â€¦</span><span class="tickerLogoWrap"><span class="tickerLogoFallback">â€¢</span></span><span class="sym">Trending</span></span>
                <span class="tickerItem" style="opacity:.75"><span class="rank">â€¦</span><span class="tickerLogoWrap"><span class="tickerLogoFallback">â€¢</span></span><span class="sym">Trending</span></span>
              </div>
            </div>

            <div class="dexSearch" role="search" aria-label="Search token by name or contract">
              <div class="dexSearchInner">
                <input class="dexInput" id="q" placeholder="Search token / paste contractâ€¦" autocomplete="off" spellcheck="false" />
                <div class="hint" id="modeHint">auto</div>
                <button class="btn" id="btnGo" type="button">Open</button>
              </div>
              <div class="results" id="results"></div>
              <div id="searchScrim" class="searchScrim" aria-hidden="true"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="grid">
        <div class="card" id="chartCard">
          <div class="cardHd">
            <div class="pair">
              <div class="tlogo" id="tokenLogo"><span class="fb" id="tokenLogoFb">$</span></div>
              <div class="pairTxt">
                <div class="pairName" id="pairName">â€”</div>
                <div class="pairMeta" id="pairMeta">Paste a token / choose a trending token</div>
              </div>
            </div>
            <div class="stats" id="stats"></div>
          </div>

          <div id="chartWrap"><div id="chart"></div></div>

          <div class="controls">
            <div class="tfRow" id="tfRow"></div>
            <div class="rightCtl">
              <button class="btn" id="btnFit" type="button">Fit</button>
              <button class="btn" id="btnRefresh" type="button">Refresh</button>
              <select class="sel" id="poolSel" title="Pool"></select>
            </div>
          </div>

          <div class="mobileTabs">
            <div class="tabBar">
              <button class="tab active" id="tabChart" type="button">Chart</button>
              <button class="tab" id="tabTrades" type="button">Trades</button>
            </div>
          </div>
        </div>

        <div class="card desktopOnly" id="tradesCard">
          <div class="tableHd">
            <div>
              <div class="ttl">Live Trades</div>
              <div class="sub" id="tradesSub">Buys / Sells (live)</div>
            </div>
            <div class="sub" id="tradesStat">â€”</div>
          </div>

          <div class="trades" id="trades">
            <div class="tradeHead">
              <div class="col age">Age</div>
              <div class="col type">Type</div>
              <div class="col usd">USD</div>
              <div class="col amt">Amount</div>
              <div class="col price hideM">Price</div>
              <div class="col maker hideM">Maker</div>
              <div class="col links"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="grid mobileTabs" id="mobileTradesWrap" style="display:none; padding-top:0">
        <div class="card" style="grid-column:1/-1">
          <div class="tableHd">
            <div>
              <div class="ttl">Live Trades</div>
              <div class="sub" id="tradesSubM">Buys / Sells (live)</div>
            </div>
            <div class="sub" id="tradesStatM">â€”</div>
          </div>
          <div class="trades" id="tradesM">
            <div class="tradeHead">
              <div class="col age">Age</div>
              <div class="col type">Type</div>
              <div class="col usd">USD</div>
              <div class="col amt">Amount</div>
              <div class="col price hideM">Price</div>
              <div class="col maker hideM">Maker</div>
              <div class="col links"></div>
            </div>
          </div>
        </div>
      </div>

    </div>

    <div class="toast" id="toast"></div>
  </div>

  <script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js"></script>
  <script>
  (function(){
    // =========================================================
    //  $SOS DEX Terminal â€” from scratch
    //  Data sources:
    //   - Token discovery: DexScreener public API (search + token pairs)
    //   - OHLCV + trades: GeckoTerminal API (pools)
    //  No embeds. No third-party iframes.
    // =========================================================

    // -------------------- Constants
    const GECKO = 'https://api.geckoterminal.com/api/v2';
    const DS = 'https://api.dexscreener.com/latest/dex';

    const NET_LABEL = { solana:'SOL', eth:'ETH', bsc:'BNB', base:'BASE' };
    const NET_DS = { solana:'solana', eth:'ethereum', bsc:'bsc', base:'base' };
    const NET_GECKO = { solana:'solana', eth:'eth', bsc:'bsc', base:'base' };

    const DEFAULT_TOKEN = {
      solana: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC
      eth:    '0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',  // USDC
      bsc:    '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d',  // USDC
      base:   '0x833589fCD6eDb6E08f4c7C32D4f71b54bda02913'   // USDC
    };

    // Prefer stable quote pools for chart correctness
    const STABLE_QUOTES = {
      solana: ['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'],
      eth: ['0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48','0xdAC17F958D2ee523a2206206994597C13D831ec7'],
      bsc: ['0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d','0x55d398326f99059fF775485246999027B3197955'],
      base:['0x833589fCD6eDb6E08f4c7C32D4f71b54bda02913']
    };

    // Chart timeframes -> Gecko candle granularity
    const TF = [
      {k:'1m',  gecko:'minute',   agg:60,    live:true},
      {k:'5m',  gecko:'minute',   agg:300},
      {k:'15m', gecko:'minute',   agg:900},
      {k:'1h',  gecko:'hour',     agg:3600},
      {k:'4h',  gecko:'hour',     agg:14400},
      {k:'1d',  gecko:'day',      agg:86400},
      {k:'ALL', gecko:'day',      agg:86400}
    ];

    // -------------------- DOM
    const $ = (id)=>document.getElementById(id);
    const netPills = $('netPills');
    const statusEl = $('status');
    const clockEl = $('clock');
    const tickerTrack = $('tickerTrack');
    const q = $('q');
    const dexSearch = q?.closest?.('.dexSearch');
    const results = $('results');
    const searchScrim = $('searchScrim');
    const btnGo = $('btnGo');
    const modeHint = $('modeHint');

    const pairNameEl = $('pairName');
    const pairMetaEl = $('pairMeta');
    const statsEl = $('stats');
    const tokenLogo = $('tokenLogo');
    const tokenLogoFb = $('tokenLogoFb');

    const poolSel = $('poolSel');
    const tfRow = $('tfRow');
    const btnFit = $('btnFit');
    const btnRefresh = $('btnRefresh');

    const tradesDesk = $('trades');
    const tradesMob = $('tradesM');
    const tradesStat = $('tradesStat');
    const tradesStatM = $('tradesStatM');

    const btnBack = $('btnBack');
    const btnBuy = $('btnBuy');

    const topDexguardBtn = $('topDexguardBtn');

    const tabChart = $('tabChart');
    const tabTrades = $('tabTrades');
    const mobileTradesWrap = $('mobileTradesWrap');
    const chartCard = $('chartCard');
    const tradesCard = $('tradesCard');

    const toastEl = $('toast');

    // -------------------- Helpers
    const sleep = (ms)=>new Promise(r=>setTimeout(r, ms));
    const lc = (v)=>String(v||'').toLowerCase();

    function toast(msg, ms=2200){
      toastEl.textContent = msg;
      toastEl.style.display='block';
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=>toastEl.style.display='none', ms);
    }

    function esc(s){
      return String(s??'').replace(/[&<>"]/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[m]));
    }

    function shortAddr(a){
      a = String(a||'');
      if(a.length<=14) return a;
      return a.slice(0,6)+'â€¦'+a.slice(-4);
    }

    function num(v){
      const n = Number(v);
      return Number.isFinite(n) ? n : NaN;
    }

    function formatCompact(n){
      n = Number(n);
      if(!Number.isFinite(n)) return 'â€”';
      const abs = Math.abs(n);
      const s = (x)=> (Math.round(x*100)/100).toString();
      if(abs>=1e12) return s(n/1e12)+'T';
      if(abs>=1e9)  return s(n/1e9)+'B';
      if(abs>=1e6)  return s(n/1e6)+'M';
      if(abs>=1e3)  return s(n/1e3)+'K';
      if(abs>=1)    return (Math.round(n*10000)/10000).toString();
      return n.toPrecision(3);
    }

    function formatPrice(v){
      v = Number(v);
      if(!Number.isFinite(v)) return 'â€”';
      if(v===0) return '0';
      if(v>=1) return v.toFixed(6).replace(/0+$/,'').replace(/\.$/,'');
      // small price
      const s = v.toPrecision(6);
      return s;
    }

    function nowClock(){
      const d = new Date();
      clockEl.textContent = d.toLocaleString(undefined, {hour:'2-digit', minute:'2-digit', second:'2-digit'});
    }

    // fetch with timeout + retry + CORS fallback via allorigins
    async function fetchJson(url, {timeout=12000, retries=1, signal=null}={}){
      const proxy = (u)=>'https://api.allorigins.win/raw?url=' + encodeURIComponent(u);
      let lastErr=null;

      const makeSignal = ()=>{
        const ctl = new AbortController();
        let extAbort = null;
        if(signal){
          if(signal.aborted){ try{ ctl.abort(); }catch(_e){} }
          extAbort = ()=>{ try{ ctl.abort(); }catch(_e){} };
          try{ signal.addEventListener('abort', extAbort, {once:true}); }catch(_e){}
        }
        const t = setTimeout(()=>{ try{ ctl.abort(); }catch(_e){} }, timeout);
        return {ctl, t, extAbort};
      };

      for(let i=0;i<=retries;i++){
        const {ctl, t, extAbort} = makeSignal();
        try{
          const r = await fetch(url, {
            headers:{'accept':'application/json'},
            signal: ctl.signal,
          });
          clearTimeout(t);
          if(extAbort && signal) try{ signal.removeEventListener('abort', extAbort); }catch(_e){}
          if(!r.ok) throw new Error('HTTP '+r.status);
          return await r.json();
        }catch(e){
          clearTimeout(t);
          if(extAbort && signal) try{ signal.removeEventListener('abort', extAbort); }catch(_e){}
          lastErr = e;
          try{
            const {ctl:ctl2, t:t2, extAbort:ext2} = makeSignal();
            const r2 = await fetch(proxy(url), {headers:{'accept':'application/json'}, signal: ctl2.signal});
            clearTimeout(t2);
            if(ext2 && signal) try{ signal.removeEventListener('abort', ext2); }catch(_e){}
            if(!r2.ok) throw new Error('HTTP '+r2.status);
            return await r2.json();
          }catch(e2){
            lastErr = e2;
          }
          if(i<retries) await new Promise(r=>setTimeout(r, 250 + i*250));
        }
      }
      throw lastErr || new Error('fetchJson failed');
    }

    function normalizeChain(x){
      x = lc(x);
      if(x==='sol' || x==='solana') return 'solana';
      if(x==='eth' || x==='ethereum') return 'eth';
      if(x==='bnb' || x==='bsc') return 'bsc';
      if(x==='base') return 'base';
      return 'solana';
    }

    function isEvmAddr(s){
      return /^0x[a-fA-F0-9]{40}$/.test(String(s||'').trim());
    }

    function isSolAddr(s){
      // best-effort base58 length
      s = String(s||'').trim();
      return s.length>=32 && s.length<=50 && /^[1-9A-HJ-NP-Za-km-z]+$/.test(s);
    }

    // robust pool address extraction from gecko pool object
    function poolAddressFromPool(p){
      const a = p?.attributes || {};
      if(a.address) return String(a.address);
      const id = String(p?.id||'');
      // examples:
      //  - "solana_..._POOL"
      //  - "ethereum:0xPOOL"
      //  - "bsc/0xPOOL"
      const last = id.split('_').pop();
      const last2 = last.split(':').pop();
      const last3 = last2.split('/').pop();
      return last3;
    }

    function tokenIdToAddr(id){
      id = String(id||'').trim();
      if(!id) return '';
      // Gecko often uses ids like 'solana_<addr>' or 'ethereum_<addr>'
      if(id.includes('_')) return id.split('_').pop();
      if(id.includes(':')) return id.split(':').pop();
      if(id.includes('/')) return id.split('/').pop();
      return id;
    }

    function tokenAddrFromPool(p, which){
      const a = p?.attributes || {};
      let v = a[`${which}_token_address`] || a[`${which}_token_id`] || '';
      if(!v){
        const rel = p?.relationships?.[`${which}_token`]?.data?.id || '';
        v = rel;
      }
      return tokenIdToAddr(v);
    }

    function tokenSymFromPool(p, which){
      const a = p?.attributes || {};
      const k = `${which}_token_symbol`;
      const sym = a[k] || a[`${which}_symbol`] || '';
      return String(sym||'').replace(/\s+/g,'').slice(0,12);
    }

    function tokenImgFromPool(p, which){
      const a = p?.attributes || {};
      // Some responses include image urls per token
      const direct = a[`${which}_token_image_url`] || a[`${which}_token_logo`] || '';
      if(direct) return String(direct);
      // Best-effort fallback: sometimes nested token object is present (not always)
      const nested = a?.[`${which}_token`]?.data?.attributes?.image_url || a?.[`${which}_token`]?.data?.attributes?.imageUrl || '';
      return String(nested||'');
    }

    function tokenPriceFromPool(p, which){
      const a = p?.attributes || {};
      const v = (which==='base') ? (a.base_token_price_usd || a.token_price_usd || a.price_usd) : (a.quote_token_price_usd || a.quote_price_usd);
      const n = Number(v);
      return Number.isFinite(n) ? n : NaN;
    }

    function poolLiqUsd(p){
      const a = p?.attributes || {};
      const v = num(a.reserve_in_usd || a.liquidity_in_usd || a.liquidity_usd || a.reserveUsd);
      return Number.isFinite(v) ? v : 0;
    }

    function poolCreatedMs(p){
      const a = p?.attributes || {};
      const t = Date.parse(a.pool_created_at || a.created_at || a.createdAt || a.creation_time || '');
      return Number.isFinite(t) ? t : NaN;
    }

    function fmtAge(ms){
      if(!Number.isFinite(ms)) return 'â€”';
      const d = Math.max(0, Date.now()-ms);
      const s = Math.floor(d/1000);
      if(s<60) return s+'s';
      const m = Math.floor(s/60);
      if(m<60) return m+'m';
      const h = Math.floor(m/60);
      if(h<24) return h+'h';
      const days = Math.floor(h/24);
      return days+'d';
    }

    function explorerTx(net, sig){
      net = normalizeChain(net);
      if(net==='solana') return 'https://solscan.io/tx/'+sig;
      if(net==='eth') return 'https://etherscan.io/tx/'+sig;
      if(net==='bsc') return 'https://bscscan.com/tx/'+sig;
      if(net==='base') return 'https://basescan.org/tx/'+sig;
      return '#';
    }

    function explorerAddr(net, a){
      net = normalizeChain(net);
      if(net==='solana') return 'https://solscan.io/account/'+a;
      if(net==='eth') return 'https://etherscan.io/address/'+a;
      if(net==='bsc') return 'https://bscscan.com/address/'+a;
      if(net==='base') return 'https://basescan.org/address/'+a;
      return '#';
    }

    // Buy link (best-effort) â€” can be replaced later per your preference
    function buildBuyUrl(net, tokenAddr){
      net = normalizeChain(net);
      if(net==='solana') return 'https://jup.ag/swap/SOL-' + encodeURIComponent(tokenAddr);
      if(net==='eth') return 'https://app.uniswap.org/#/swap?outputCurrency=' + encodeURIComponent(tokenAddr);
      if(net==='bsc') return 'https://pancakeswap.finance/swap?outputCurrency=' + encodeURIComponent(tokenAddr);
      if(net==='base') return 'https://app.uniswap.org/#/swap?chain=base&outputCurrency=' + encodeURIComponent(tokenAddr);
      return '#';
    }

    // -------------------- State
    const qs = new URLSearchParams(location.search);
    let activeNet = normalizeChain(qs.get('chain') || 'solana');
    let addr = String(qs.get('addr')||'').trim();

    let activeTF = TF.find(x=>x.k==='5m') || TF[1] || TF[0];
    let poolChoices = [];
    let poolId = '';
    let poolAddr = '';
    let tokenSide = 'base';
        let curTokenSymbol = 'TOKEN';
    let curQuoteSymbol = '';
    let curTokenName = '';
    let curTokenImage = '';
    let curTokenAddr = '';
let seenMakers = new Set();
    let tradesSeen = new Set();

    let pollTradesTimer = null;
    let pollMetaTimer = null;
    let pollCandleTimer = null;
    let trendingTimer = null;
    let ageTimer = null;

    // -------------------- Chart
    const chartEl = $('chart');
    const chart = LightweightCharts.createChart(chartEl, {
      width: chartEl.clientWidth || 800,
      height: chartEl.clientHeight || 520,
      layout: { background: { type:'solid', color:'rgba(0,0,0,0)' }, textColor:'rgba(255,255,255,.86)' },
      grid: { vertLines:{color:'rgba(255,255,255,.06)'}, horzLines:{color:'rgba(255,255,255,.06)'} },
      rightPriceScale: { borderColor:'rgba(255,255,255,.12)' },
      timeScale: { borderColor:'rgba(255,255,255,.12)', timeVisible:true, secondsVisible:false },
      crosshair: { mode: 1 },
      handleScroll: { mouseWheel:true, pressedMouseMove:true, horzTouchDrag:true, vertTouchDrag:true },
      handleScale: { axisPressedMouseMove:true, mouseWheel:true, pinch:true },
    });

    const candleSeries = chart.addCandlestickSeries({
      upColor: 'rgba(20,241,149,.95)',
      downColor:'rgba(255,77,109,.95)',
      wickUpColor:'rgba(20,241,149,.95)',
      wickDownColor:'rgba(255,77,109,.95)',
      borderVisible:false,
      priceFormat:{ type:'price', precision: 10, minMove: 1e-10 }
    });

    const volumeSeries = chart.addHistogramSeries({
      priceFormat: { type:'volume' },
      priceScaleId: '',
      lastValueVisible:false,
      base:0,
    });
    chart.priceScale('').applyOptions({ scaleMargins:{ top:0.84, bottom:0 } });

    const ro = new ResizeObserver(()=>{
      chart.applyOptions({ width: chartEl.clientWidth, height: chartEl.clientHeight });
    });
    ro.observe(chartEl);

    btnFit.onclick = ()=>chart.timeScale().fitContent();

    // -------------------- UI boot
    function renderNetPills(){
      netPills.innerHTML='';
      const nets=[{k:'solana',label:'SOL'},{k:'eth',label:'ETH'},{k:'bsc',label:'BNB'},{k:'base',label:'BASE'}];
      nets.forEach(n=>{
        const b=document.createElement('div');
        b.className='pill'+(activeNet===n.k?' active':'');
        b.innerHTML = `<span class="dot"></span>${esc(n.label)}`;
        b.onclick=()=>{
          activeNet=n.k;
          renderNetPills();
          toast('Chain: '+n.label);
          // keep current addr if it matches chain type; otherwise default
          if(!addr){ addr = DEFAULT_TOKEN[activeNet]; }
          navigate(activeNet, addr);
        };
        netPills.appendChild(b);
      });
    }

    function renderTimeframes(){
      tfRow.innerHTML='';
      TF.forEach(t=>{
        const b=document.createElement('button');
        b.className='tf'+(t.k===activeTF.k?' active':'');
        b.textContent=t.k;
        b.onclick=()=>{
          activeTF=t;
          [...tfRow.children].forEach(x=>x.classList.toggle('active', x.textContent===t.k));
          if(poolAddr){
            loadCandles(true);
          }
        };
        tfRow.appendChild(b);
      });
    }

    function setMobileTab(which){
      if(!tabChart || !tabTrades) return;
      const isTrades = which==='trades';
      tabChart.classList.toggle('active', !isTrades);
      tabTrades.classList.toggle('active', isTrades);
      mobileTradesWrap.style.display = isTrades ? 'block' : 'none';
      chartCard.style.display = isTrades ? 'none' : 'block';
    }

    if(tabChart && tabTrades){
      tabChart.onclick=()=>setMobileTab('chart');
      tabTrades.onclick=()=>setMobileTab('trades');
    }



    // Top-left Dexguard button -> jump to trending bar
    if(topDexguardBtn){
      topDexguardBtn.onclick = ()=>{
        const tb = document.getElementById('topBar');
        if(tb) tb.scrollIntoView({behavior:'smooth', block:'start'});
      };
    }

    btnRefresh.onclick=()=>{
      if(!poolAddr){ toast('Pick a token first'); return; }
      loadCandles(true);
      loadTrades(true);
      loadMeta(true);
    };

    // -------------------- Search
    let searchTimer=null;
    let searchReq=0;

    function showResults(html){
      results.innerHTML = html;
      const open = !!html;
      results.style.display = open ? 'block' : 'none';
      if(searchScrim) searchScrim.style.display = open ? 'block' : 'none';
      if(dexSearch) dexSearch.classList.toggle('open', open);
    }

    function hideResults(){
      results.style.display = 'none';
      if(searchScrim) searchScrim.style.display = 'none';
      if(dexSearch) dexSearch.classList.remove('open');
    }

    if(searchScrim){
      searchScrim.addEventListener('click', hideResults);
    }

    async function dsSearch(query){
      // DexScreener search is used ONLY for discovery. We do not embed anything.
      const url = DS + '/search/?q=' + encodeURIComponent(query);
      const j = await fetchJson(url, {timeout:12000, retries:1});
      return Array.isArray(j?.pairs) ? j.pairs : [];
    }

    async function dsTokenPairsV1(net, tokenAddr){
      const chain = NET_DS[normalizeChain(net)] || 'solana';
      const url = `https://api.dexscreener.com/token-pairs/v1/${chain}/${encodeURIComponent(tokenAddr)}`;
      try{
        const j = await fetchJson(url, {timeout:14000, retries:1});
        return Array.isArray(j) ? j : [];
      }catch(_){
        return [];
      }
    }

    function bestPairAnyNet(pairs){
      const list = (pairs||[]).slice();
      if(!list.length) return null;
      list.sort((a,b)=>{
        const la = Number(a?.liquidity?.usd||0);
        const lb = Number(b?.liquidity?.usd||0);
        if(lb!==la) return lb-la;
        const va = Number(a?.volume?.h24||0);
        const vb = Number(b?.volume?.h24||0);
        return vb-va;
      });
      return list[0];
    }

    function bestPairForNet(pairs, net){
      const want = NET_DS[normalizeChain(net)];
      const list = (pairs||[]).filter(p=>lc(p?.chainId)===want);
      if(!list.length) return null;
      list.sort((a,b)=>{
        const la = Number(a?.liquidity?.usd||0);
        const lb = Number(b?.liquidity?.usd||0);
        if(lb!==la) return lb-la;
        const va = Number(a?.volume?.h24||0);
        const vb = Number(b?.volume?.h24||0);
        return vb-va;
      });
      return list[0];
    }


    function dsExtractTokenMeta(pair, tokenAddr){
      const tAddr = lc(tokenAddr||'');
      const base = pair?.baseToken || {};
      const quote = pair?.quoteToken || {};
      const baseAddr = lc(base?.address||'');
      const quoteAddr = lc(quote?.address||'');
      const isQuote = !!tAddr && !!quoteAddr && tAddr===quoteAddr;
      const tok = isQuote ? quote : base;
      const oth = isQuote ? base : quote;

      const sym = String(tok?.symbol||'TOKEN').replace(/\s+/g,'').slice(0,12) || 'TOKEN';
      const name = String(tok?.name||'').trim();
      const quoteSym = String(oth?.symbol||'').replace(/\s+/g,'').slice(0,12);

      const img = String(
        pair?.info?.imageUrl || pair?.info?.image_url ||
        pair?.imageUrl || pair?.image_url ||
        tok?.logoURI || tok?.logoUrl || tok?.logo_url || tok?.icon || tok?.image ||
        ''
      ).trim();

      return { symbol: sym, name, quoteSymbol: quoteSym, image: img };
    }


    function netFromDsChainId(chainId){
      const c = lc(chainId);
      if(c==='solana') return 'solana';
      if(c==='ethereum') return 'eth';
      if(c==='bsc') return 'bsc';
      if(c==='base') return 'base';
      return null;
    }

    function bestPairAnyNet(pairs){
      const list = (pairs||[]).filter(p=>netFromDsChainId(p?.chainId));
      if(!list.length) return null;
      list.sort((a,b)=>{
        const la = Number(a?.liquidity?.usd||0);
        const lb = Number(b?.liquidity?.usd||0);
        if(lb!==la) return lb-la;
        const va = Number(a?.volume?.h24||0);
        const vb = Number(b?.volume?.h24||0);
        return vb-va;
      });
      return list[0];
    }

    function renderSearchResults(pairs){
      const best = bestPairForNet(pairs, activeNet);
      // show top 12 for chain
      const want = NET_DS[activeNet];
      const list = (pairs||[]).filter(p=>lc(p?.chainId)===want).slice(0, 12);
      if(!list.length){
        showResults(`<div style="padding:12px; color:rgba(255,255,255,.75)">No results on ${esc(NET_LABEL[activeNet])}. Try another chain.</div>`);
        return;
      }
      const html = list.map(p=>{
        const base = p?.baseToken || {};
        const sym = String(base.symbol || base.name || 'TOKEN');
        const name = String(base.name || sym);
        const addr = String(base.address || '');
        const img = p?.info?.imageUrl || p?.info?.image_url || '';
        const pct = num(p?.priceChange?.h24);
        const mc = num(p?.marketCap || p?.fdv);
        const pctTxt = Number.isFinite(pct) ? (pct>0?'+':'')+pct.toFixed(2)+'%' : 'â€”';
        const pctClass = Number.isFinite(pct) ? (pct>0?'up':(pct<0?'down':'')) : '';
        const logo = img ? `<img src="${esc(img)}" referrerpolicy="no-referrer" onerror="this.remove();"/>` : `<span class="fb">${esc(sym.slice(0,1).toUpperCase())}</span>`;
        return `
          <div class="resItem" data-addr="${esc(addr)}" data-name="${esc(sym)}">
            <div class="resL">
              <div class="resLogo">${logo}</div>
              <div class="resTxt">
                <div class="resName">$${esc(sym)} <span style="opacity:.65">(${esc(name)})</span></div>
                <div class="resMeta">${esc(NET_LABEL[activeNet])} â€¢ ${esc(shortAddr(addr))} â€¢ Liq $${esc(formatCompact(p?.liquidity?.usd))}</div>
              </div>
            </div>
            <div class="resR">
              <span class="statPill ${pctClass}">24h ${esc(pctTxt)}</span>
              <span class="statPill">MCap ${esc(formatCompact(mc))}</span>
            </div>
          </div>
        `;
      }).join('');
      showResults(html);

      // click bind
      [...results.querySelectorAll('.resItem')].forEach(el=>{
        el.onclick=()=>{
          const a = el.getAttribute('data-addr')||'';
          hideResults();
          q.value = a;
          openToken(a);
        };
      });
    }

    q.addEventListener('input', ()=>{
      clearTimeout(searchTimer);
      const v = q.value.trim();

      // mode hint
      if(isEvmAddr(v)) modeHint.textContent = 'EVM';
      else if(isSolAddr(v)) modeHint.textContent = 'SOL';
      else modeHint.textContent = 'auto';

      if(v.length<2){ hideResults(); return; }
      searchTimer = setTimeout(async ()=>{
        const id = ++searchReq;
        try{
          const pairs = await dsSearch(v);
          if(id!==searchReq) return;
          renderSearchResults(pairs);
        }catch(e){
          if(id!==searchReq) return;
          showResults(`<div style="padding:12px; color:rgba(255,255,255,.75)">Search error. Try again.</div>`);
        }
      }, 220);
    });

    q.addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){
        e.preventDefault();
        hideResults();
        openToken(q.value.trim());
      }
    });

    document.addEventListener('click', (e)=>{
      if(!results.contains(e.target) && e.target!==q) hideResults();
    });

    btnGo.onclick=()=>openToken(q.value.trim());

    // -------------------- Gecko: pool selection
    function geckoNet(){ return NET_GECKO[activeNet]; }

    async function resolvePoolsFromGecko(tokenAddr){
      // /networks/{network}/tokens/{token}/pools?include=base_token,quote_token&page=1
      const url = `${GECKO}/networks/${encodeURIComponent(geckoNet())}/tokens/${encodeURIComponent(tokenAddr)}/pools?include=base_token,quote_token,dex&page=1`;
      const j = await fetchJson(url, {timeout:14000, retries:1});
      return Array.isArray(j?.data) ? j.data : [];
    }

    function chooseBestPool(pools, tokenAddr){
      const tok = lc(tokenAddr);
      const preferSet = new Set((STABLE_QUOTES[activeNet]||[]).map(lc));

      // rank pools
      const ranked = (pools||[]).map(p=>{
        const a = p?.attributes || {};
        const base = lc(tokenAddrFromPool(p,'base'));
        const quote = lc(tokenAddrFromPool(p,'quote'));
        const liq = poolLiqUsd(p);
        const created = poolCreatedMs(p);
        const isBase = base===tok;
        const isQuote = quote===tok;
        const stableQuote = isBase && preferSet.has(quote);
        const score =
          (stableQuote? 9e15 : 0) +
          (isBase? 7e15 : 0) +
          (isQuote? 4e15 : 0) +
          (Number.isFinite(liq)? liq*1e6 : 0) +
          (Number.isFinite(created)? created : 0);
        return {p, score, isBase, isQuote, liq};
      }).sort((a,b)=>b.score-a.score);

      return ranked[0]?.p || null;
    }

    function renderPoolSelect(pools){
      poolSel.innerHTML='';
      const opts = pools.slice(0, 25).map((p,i)=>{
        const a = p?.attributes || {};
        const dex = String(a.dex_name || a.dex || 'DEX');
        const name = String(a.name || a.pool_name || '').trim();
        const liq = poolLiqUsd(p);
        const age = fmtAge(poolCreatedMs(p));
        const label = `${dex} â€¢ ${name?name:shortAddr(poolAddressFromPool(p))} â€¢ Liq $${formatCompact(liq)} â€¢ ${age}`;
        const id = String(p?.id||'');
        return `<option value="${esc(id)}">${esc(label)}</option>`;
      }).join('');
      poolSel.innerHTML = opts;
      poolSel.style.display = opts ? 'inline-flex' : 'none';
      poolSel.disabled = !opts;

      poolSel.onchange = ()=>{
        const id = poolSel.value;
        const picked = pools.find(x=>String(x?.id||'')===id);
        if(picked){
          applyPool(picked);
          loadCandles(true);
          loadTrades(true);
          loadMeta(true);
        }
      };
    }

    function applyTokenHeader(meta){
      const symIn = String(meta?.symbol||'').trim();
      const nameIn = String(meta?.name||'').trim();
      const quoteIn = String(meta?.quoteSymbol||'').trim();
      const imgIn = String(meta?.image||'').trim();

      const sym = (symIn && symIn.toUpperCase()!=='TOKEN')
        ? symIn
        : ((curTokenSymbol && curTokenSymbol.toUpperCase()!=='TOKEN') ? curTokenSymbol : (symIn||'TOKEN'));

      const quote = quoteIn || curQuoteSymbol || '';
      const name = nameIn || curTokenName || '';
      const img  = imgIn  || curTokenImage || '';

      curTokenSymbol = sym || 'TOKEN';
      curQuoteSymbol = quote || '';
      if(name) curTokenName = name;
      if(imgIn) curTokenImage = imgIn;

      const title = quote ? `$${sym}/${quote}` : `$${sym}`;
      pairNameEl.textContent = title;
      pairMetaEl.textContent = `${NET_LABEL[activeNet]} â€¢ ${shortAddr(addr)}`;

      if(img){
        tokenLogo.innerHTML = `<img src="${esc(img)}" alt="" referrerpolicy="no-referrer" onerror="this.onerror=null; this.remove(); var p=this.parentNode; if(p){p.innerHTML='<span class=\\"fb\\">${esc(sym.slice(0,1).toUpperCase())}</span>';}" />`;
      }else{
        tokenLogo.innerHTML = `<span class="fb">${esc(sym.slice(0,1).toUpperCase())}</span>`;
      }
    }

    function applyStats(st){
      const pills=[];
      if(Number.isFinite(st.price)) pills.push(`<span class="statPill">Price $${esc(formatPrice(st.price))}</span>`);
      if(Number.isFinite(st.liq)) pills.push(`<span class="statPill">Liq $${esc(formatCompact(st.liq))}</span>`);
      if(Number.isFinite(st.mcap)) pills.push(`<span class="statPill">MCap $${esc(formatCompact(st.mcap))}</span>`);
      if(Number.isFinite(st.h24)) pills.push(`<span class="statPill ${st.h24>0?'up':(st.h24<0?'down':'')}">24h ${esc((st.h24>0?'+':'')+st.h24.toFixed(2)+'%')}</span>`);
      statsEl.innerHTML = pills.join('') || `<span class="statPill">â€”</span>`;
    }

    function applyPool(p){
      const a = p?.attributes || {};
      poolId = String(p?.id||'');
      poolAddr = poolAddressFromPool(p);

      // Determine side: if token matches base -> buys are quote->base? We use Gecko trade_type.
      const base = lc(tokenAddrFromPool(p,'base'));
      const quote = lc(tokenAddrFromPool(p,'quote'));
      tokenSide = (base===lc(addr)) ? 'base' : ((quote===lc(addr)) ? 'quote' : 'base');

      // Meta (pick correct token side)
      const baseSym = tokenSymFromPool(p,'base') || 'TOKEN';
      const quoteSym = tokenSymFromPool(p,'quote') || '';
      const sym = tokenSide==='base' ? baseSym : (quoteSym || baseSym || 'TOKEN');
      const quoteShown = tokenSide==='base' ? quoteSym : baseSym;
      const img = tokenSide==='base' ? tokenImgFromPool(p,'base') : tokenImgFromPool(p,'quote');
      const symFinal = (sym && sym.toUpperCase()!=='TOKEN') ? sym : (curTokenSymbol||'TOKEN');
      const imgFinal = img || curTokenImage || '';
      const nameFinal = curTokenName || '';
      const quoteFinal = quoteShown || curQuoteSymbol || '';
      applyTokenHeader({symbol: symFinal, name: nameFinal, quoteSymbol: quoteFinal, image: imgFinal});

      // initial stats best-effort (pick correct side price)
      const price = tokenSide==='base' ? tokenPriceFromPool(p,'base') : tokenPriceFromPool(p,'quote');
      const liq = num(a.reserve_in_usd || a.liquidity_in_usd || a.liquidity_usd);
      const mcap = num(a.market_cap_usd || a.fdv_usd);
      const h24 = num(a.price_change_percentage?.h24 || a.price_change_percentage_24h || a.price_change_24h);
      applyStats({price, liq, mcap, h24});

      btnBuy.href = buildBuyUrl(activeNet, addr);
    }

    // -------------------- Candles
    let rawCandles=[];

    function geckoCandlesUrl(gran, before){
      // /networks/{network}/pools/{pool}/ohlcv/{timeframe}?aggregate=...&before_timestamp=...&limit=1000&currency=usd
      const agg = (activeTF.k==='ALL' ? 1 : Math.max(1, Math.floor(activeTF.agg / (gran==='minute'?60:(gran==='hour'?3600:86400)) )));
      const params = new URLSearchParams();
      params.set('aggregate', String(agg));
      params.set('limit', '1000');
      params.set('currency','usd');
      if(before) params.set('before_timestamp', String(before));
      return `${GECKO}/networks/${encodeURIComponent(geckoNet())}/pools/${encodeURIComponent(poolAddr)}/ohlcv/${encodeURIComponent(gran)}?`+params.toString();
    }

    function mapGeckoOhlcv(j){
      const list = j?.data?.attributes?.ohlcv_list;
      if(!Array.isArray(list)) return [];
      // each row: [timestamp, open, high, low, close, volume]
      // Gecko timestamps should be unix seconds, but some proxies may return ms.
      return list.map(r=>{
        const ts = Number(r[0]) || 0;
        const time = ts>1e12 ? Math.floor(ts/1000) : Math.floor(ts);
        const open = Number(r[1]);
        const high = Number(r[2]);
        const low  = Number(r[3]);
        const close= Number(r[4]);
        const volume = Number(r[5]);
        return {time, open, high, low, close, volume};
      }).filter(x=>x.time>0 && Number.isFinite(x.open) && Number.isFinite(x.high) && Number.isFinite(x.low) && Number.isFinite(x.close));
    }

    
    // -------------------- Chart + Trades (stable realtime)
    const _candleCache = new Map(); // key -> {at:number, candles:Array}
    const CANDLE_CACHE_TTL = 25000;

    let _candleCtl = null;
    let _tradesCtl = null;

    let _tradesInFlight = false;
    let _candlesInFlight = false;

    // bounded dedupe
    let tradesSeen = new Map();   // id -> tsSeen
    let _tradesSeenQ = [];        // FIFO ids
    const MAX_SEEN_TRADES = 5000;

    function _markTradeSeen(id){
      if(!id) return;
      if(tradesSeen.has(id)) return;
      tradesSeen.set(id, Date.now());
      _tradesSeenQ.push(id);
      if(_tradesSeenQ.length > MAX_SEEN_TRADES){
        const drop = _tradesSeenQ.splice(0, _tradesSeenQ.length - MAX_SEEN_TRADES);
        drop.forEach(k=>tradesSeen.delete(k));
      }
    }

    function stopLiveLoops(){
      if(pollTradesTimer){ clearInterval(pollTradesTimer); pollTradesTimer=null; }
      if(pollCandleTimer){ clearInterval(pollCandleTimer); pollCandleTimer=null; }
      if(ageTimer){ clearInterval(ageTimer); ageTimer=null; }
      _tradesInFlight = false;
      _candlesInFlight = false;
      try{ if(_tradesCtl) _tradesCtl.abort(); }catch(_e){}
      try{ if(_candleCtl) _candleCtl.abort(); }catch(_e){}
      _tradesCtl = null;
      _candleCtl = null;
    }

    // lightweight overlay for chart loading / errors
    const _chartOverlay = (()=>{
      const wrap = $('chartWrap') || document.getElementById('chartWrap');
      if(!wrap) return null;
      let el = document.getElementById('chartSkel');
      if(!el){
        el = document.createElement('div');
        el.id = 'chartSkel';
        el.innerHTML = `<div class="skelBox">
          <div class="skelLine"></div>
          <div class="skelLine"></div>
          <div class="skelLine"></div>
          <div class="skelHint" id="chartSkelHint">Loading chartâ€¦</div>
        </div>`;
        wrap.appendChild(el);
      }
      return el;
    })();

    function _showChartOverlay(msg){
      if(!_chartOverlay) return;
      const hint = document.getElementById('chartSkelHint');
      if(hint) hint.textContent = msg || 'Loading chartâ€¦';
      _chartOverlay.style.display = 'grid';
    }
    function _hideChartOverlay(){
      if(!_chartOverlay) return;
      _chartOverlay.style.display = 'none';
    }

    function applyCandlesToChart(fit){
      const src = rawCandles || [];
      if(!src.length){
        candleSeries.setData([]);
        volumeSeries.setData([]);
        return;
      }
      candleSeries.setData(src.map(c=>({time:c.time, open:c.open, high:c.high, low:c.low, close:c.close})));
      volumeSeries.setData(src.map(c=>({time:c.time, value:c.volume, color:(c.close>=c.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'})));
      if(fit) chart.timeScale().fitContent();
    }

    function applyTradeToCandles(tr){
      if(!rawCandles || !rawCandles.length) return;
      if(!Number.isFinite(tr?.price)) return;
      if(!Number.isFinite(tr?.tsMs)) return;

      const tfSec = (activeTF?.k==='ALL') ? 86400 : (activeTF?.agg || 300);
      const ts = Math.floor(tr.tsMs/1000);
      const bucket = Math.floor(ts / tfSec) * tfSec;

      // find candle (usually last)
      let c = rawCandles[rawCandles.length-1];
      if(!c || bucket > c.time){
        const prevClose = c?.close ?? tr.price;
        c = { time: bucket, open: prevClose, high: tr.price, low: tr.price, close: tr.price, volume: 0 };
        rawCandles.push(c);
      }else if(bucket < c.time){
        // late trade: try update matching candle if exists
        let found = null;
        for(let i=rawCandles.length-1;i>=0 && rawCandles[i].time>=bucket;i--){ if(rawCandles[i].time===bucket){ found=rawCandles[i]; break; } }
        if(!found) return;
        c = found;
      }

      c.high = Math.max(c.high, tr.price);
      c.low  = Math.min(c.low,  tr.price);
      c.close = tr.price;

      const addVol = Number.isFinite(tr.usd) ? tr.usd : 0;
      if(addVol>0) c.volume = (Number(c.volume)||0) + addVol;

      candleSeries.update({time:c.time, open:c.open, high:c.high, low:c.low, close:c.close});
      volumeSeries.update({time:c.time, value:c.volume, color:(c.close>=c.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
    }

    async function refreshLatestCandles(){
      if(!poolAddr) return;
      if(_candlesInFlight) return;
      _candlesInFlight = true;
      try{
        if(_candleCtl) _candleCtl.abort();
        _candleCtl = new AbortController();
        const gran = activeTF.gecko;
        const url = geckoCandlesUrl(gran, null);
        const j = await fetchJson(url, {timeout:16000, retries:1, signal:_candleCtl.signal});
        const part = mapGeckoOhlcv(j);
        if(!part.length) return;

        // merge by timestamp
        const map = new Map((rawCandles||[]).map(c=>[c.time,c]));
        part.forEach(c=>map.set(c.time,c));
        rawCandles = Array.from(map.values()).sort((a,b)=>a.time-b.time);

        const key = `${activeNet}|${poolAddr}|${activeTF.k}`;
        _candleCache.set(key, {at: Date.now(), candles: rawCandles.slice()});

        // update the tail
        const tail = part.slice(-40).sort((a,b)=>a.time-b.time);
        tail.forEach(c=>{
          candleSeries.update({time:c.time, open:c.open, high:c.high, low:c.low, close:c.close});
          volumeSeries.update({time:c.time, value:c.volume, color:(c.close>=c.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
        });
      }catch(_e){}finally{
        _candlesInFlight = false;
      }
    }

    async function loadCandles(fit){
      if(!poolAddr) return;
      _showChartOverlay('Loading chartâ€¦');
      statusEl.textContent = 'Loading chartâ€¦';

      const cacheKey = `${activeNet}|${poolAddr}|${activeTF.k}`;
      const cached = _candleCache.get(cacheKey);
      if(cached && (Date.now()-cached.at) < CANDLE_CACHE_TTL && Array.isArray(cached.candles) && cached.candles.length){
        rawCandles = cached.candles.slice();
        applyCandlesToChart(!!fit);
        _hideChartOverlay();
        statusEl.textContent = 'Live.';
        return;
      }

      rawCandles = [];
      candleSeries.setData([]);
      volumeSeries.setData([]);

      try{
        if(_candleCtl) _candleCtl.abort();
        _candleCtl = new AbortController();

        const gran = activeTF.gecko;
        let before = null;
        let all = [];
        let guard = 0;
        const maxPages = (activeTF.k==='ALL' ? 10 : 5);

        while(guard++ < maxPages){
          const url = geckoCandlesUrl(gran, before);
          const j = await fetchJson(url, {timeout:17000, retries:1, signal:_candleCtl.signal});
          const part = mapGeckoOhlcv(j);
          if(!part.length) break;

          all = part.concat(all);

          const oldest = part[0]?.time;
          if(!Number.isFinite(oldest)) break;
          before = String(Math.max(0, oldest - 1));

          if(part.length < 900) break;
          await new Promise(r=>setTimeout(r, 0));
        }

        const map = new Map();
        all.forEach(c=>{ if(Number.isFinite(c?.time)) map.set(c.time, c); });
        rawCandles = Array.from(map.values()).sort((a,b)=>a.time-b.time);

        if(!rawCandles.length){
          statusEl.textContent = 'Chart not available.';
          _showChartOverlay('Chart not available.');
          return;
        }

        _candleCache.set(cacheKey, {at: Date.now(), candles: rawCandles.slice()});
        applyCandlesToChart(!!fit);
        _hideChartOverlay();
        statusEl.textContent = 'Live.';
      }catch(e){
        if(e?.name==='AbortError') return;
        console.error(e);
        statusEl.textContent = 'Chart error.';
        _showChartOverlay('Chart error. Click Refresh.');
      }
    }

    function parseTrade(t){
      const a = t?.attributes || t || {};
      const num = (v)=>{ v = Number(v); return Number.isFinite(v) ? v : NaN; };

      const id = String(t?.id || a.tx_hash || a.transaction_hash || a.signature || a.transaction_id || '') || '';
      const side = String(a.trade_type || a.side || a.taker_side || a.kind || '').toLowerCase();
      const type = side.includes('sell') ? 'sell' : (side.includes('buy') ? 'buy' : (a.is_buy===true?'buy':(a.is_sell===true?'sell':'')));

      const tx = String(a.tx_hash || a.transaction_hash || a.signature || a.transaction_id || id || '').trim();
      const maker = String(a.maker || a.trader || a.wallet_address || a.user || a.from || a.from_address || a.trader_address || a.owner || '').trim();

      const rawTs = (a.block_timestamp ?? a.timestamp ?? a.time ?? a.created_at ?? a.mined_at ?? a.block_time ?? 0);
      const tsMs = Number.isFinite(Number(rawTs)) ? (Number(rawTs)>10_000_000_000?Number(rawTs):Number(rawTs)*1000) : Date.now();

      const usd = num(a.volume_in_usd || a.usd_value || a.volume_usd || a.amount_usd || a.total_usd);
      const price = num(a.price_in_usd || a.price_usd || a.price);

      const baseAmt = num(a.base_token_amount || a.amount_base || a.base_amount || a.base_token_volume || a.base_volume);
      const quoteAmt = num(a.quote_token_amount || a.amount_quote || a.quote_amount || a.quote_token_volume || a.quote_volume);

      const amount = Number.isFinite(baseAmt) ? baseAmt : (Number.isFinite(quoteAmt)? quoteAmt : NaN);

      return { id: (tx||id), tx:(tx||id), maker, type, tsMs, usd, price, baseAmt, quoteAmt, amount };
    }

    async function geckoTrades(limit=200, {signal=null}={}){
      const base = `${GECKO}/networks/${encodeURIComponent(geckoNet())}/pools/${encodeURIComponent(poolAddr)}/trades`;
      try{
        const url1 = base + `?page=1&limit=${encodeURIComponent(limit)}`;
        const j1 = await fetchJson(url1, {timeout:14000, retries:1, signal});
        if(Array.isArray(j1?.data) && j1.data.length) return j1.data;
      }catch(_e){}
      try{
        const url2 = base + `?limit=${encodeURIComponent(limit)}`;
        const j2 = await fetchJson(url2, {timeout:14000, retries:1, signal});
        if(Array.isArray(j2?.data)) return j2.data;
      }catch(_e){}
      return [];
    }

    function _tradeRowHtml(tr){
      const ageHtml = `<span class="ageTxt mono" data-ts="${esc(String(tr.tsMs||0))}">â€”</span>`;
      const typeClass = tr.type==='buy' ? 'buy' : (tr.type==='sell' ? 'sell' : '');
      const typeTxt = tr.type ? tr.type.toUpperCase() : 'â€”';
      const usdTxt = Number.isFinite(tr.usd) ? ('$'+formatCompact(tr.usd)) : 'â€”';

      const amt = Number.isFinite(tr.amount) ? tr.amount : NaN;
      const amtTxt = Number.isFinite(amt) ? (formatCompact(amt) + (curTokenSymbol?(' '+curTokenSymbol):'')) : 'â€”';

      const priceTxt = Number.isFinite(tr.price) ? '$'+formatPrice(tr.price) : 'â€”';

      const isNew = tr.maker ? (!seenMakers.has(tr.maker)) : false;
      if(tr.maker){
        seenMakers.add(tr.maker);
        if(seenMakers.size>2000) seenMakers = new Set(Array.from(seenMakers).slice(-2000));
      }

      const makerHtml = tr.maker
        ? `<div class="maker">
            <a class="addr mono" href="${esc(explorerAddr(activeNet, tr.maker))}" target="_blank" rel="noreferrer" title="${esc(tr.maker)}">${esc(shortAddr(tr.maker))}</a>
            ${isNew?'<span class="new">NEW</span>':''}
          </div>`
        : `<span class="mono" style="opacity:.7">â€”</span>`;

      const txUrl = tr.tx ? explorerTx(activeNet, tr.tx) : '#';

      return `
        <div class="tradeRow newRow" data-id="${esc(tr.id)}" data-ts="${esc(String(tr.tsMs||0))}" data-type="${esc(tr.type||'')}">
          <div class="mono">${ageHtml}</div>
          <div><span class="typeBadge ${esc(typeClass)}">${esc(typeTxt)}</span></div>
          <div class="mono">${esc(usdTxt)}</div>
          <div class="mono">${esc(amtTxt)}</div>
          <div class="mono hideM">${esc(priceTxt)}</div>
          <div class="hideM">${makerHtml}</div>
          <div>
            <a class="iconBtn" href="${esc(txUrl)}" target="_blank" rel="noreferrer" title="Open Tx">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14 3h7v7" stroke="rgba(255,255,255,.80)" stroke-width="2" stroke-linecap="round"/><path d="M21 3 10 14" stroke="rgba(255,255,255,.80)" stroke-width="2" stroke-linecap="round"/><path d="M10 5H7a4 4 0 0 0-4 4v8a4 4 0 0 0 4 4h8a4 4 0 0 0 4-4v-3" stroke="rgba(255,255,255,.55)" stroke-width="2" stroke-linecap="round"/></svg>
            </a>
          </div>
        </div>
      `;
    }

    function renderTrades(trades, {reset=false}={}){
      const parsed = (trades||[]).map(parseTrade).filter(x=>x.id && Number.isFinite(x.tsMs));
      parsed.sort((a,b)=>b.tsMs-a.tsMs);

      if(reset){
        tradesContainer().forEach(el=>{
          const head = el.querySelector('.tradeHead');
          el.innerHTML='';
          if(head) el.appendChild(head);
        });
        tradesSeen = new Map();
        _tradesSeenQ = [];
        seenMakers = new Set();
      }

      const newly = [];
      for(const tr of parsed){
        if(tradesSeen.has(tr.id)) continue;
        _markTradeSeen(tr.id);
        newly.push(tr);
      }
      if(!newly.length) return [];

      const add = newly.slice().sort((a,b)=>a.tsMs-b.tsMs);

      tradesContainer().forEach(el=>{
        const head = el.querySelector('.tradeHead');
        for(const tr of add){
          const wrapper = document.createElement('div');
          wrapper.innerHTML = _tradeRowHtml(tr).trim();
          const row = wrapper.firstElementChild;
          if(!row) continue;
          el.insertBefore(row, head ? head.nextSibling : el.firstChild);
          requestAnimationFrame(()=>row.classList.remove('newRow'));
        }
        const rows = [...el.querySelectorAll('.tradeRow')];
        const maxRows = 220;
        if(rows.length > maxRows) rows.slice(maxRows).forEach(r=>r.remove());
      });

      const total = tradesDesk.querySelectorAll('.tradeRow').length;
      if(tradesStat) tradesStat.textContent = total ? `${total} shown` : 'â€”';
      if(tradesStatM) tradesStatM.textContent = total ? `${total} shown` : 'â€”';

      return newly;
    }

    function updateAges(){
      const now = Date.now();
      tradesContainer().forEach(el=>{
        el.querySelectorAll('.ageTxt').forEach(span=>{
          const ts = Number(span.getAttribute('data-ts') || 0);
          if(!Number.isFinite(ts) || !ts){ span.textContent = 'â€”'; return; }
          const s = Math.max(0, Math.floor((now - ts)/1000));
          if(s < 60) span.textContent = `${s}s ago`;
          else if(s < 3600) span.textContent = `${Math.floor(s/60)}m ago`;
          else span.textContent = `${Math.floor(s/3600)}h ago`;
        });
      });
    }

    async function loadTrades(reset=false){
      if(!poolAddr) return;
      try{
        if(_tradesCtl) _tradesCtl.abort();
        _tradesCtl = new AbortController();

        const data = await geckoTrades(220, {signal:_tradesCtl.signal});
        const newly = renderTrades(data, {reset}) || [];
        if(newly.length){
          newly.slice().sort((a,b)=>a.tsMs-b.tsMs).forEach(applyTradeToCandles);
        }
        statusEl.textContent = 'Live.';
      }catch(e){
        if(e?.name==='AbortError') return;
        console.error(e);
        statusEl.textContent = 'Trades error.';
      }
    }

    function startLiveLoops(){
      stopLiveLoops();
      updateAges();
      ageTimer = setInterval(updateAges, 1000);

      pollTradesTimer = setInterval(async ()=>{
        if(_tradesInFlight) return;
        _tradesInFlight = true;
        try{ await loadTrades(false); }catch(_e){}finally{ _tradesInFlight=false; }
      }, 1500);

      pollCandleTimer = setInterval(async ()=>{
        if(_candlesInFlight) return;
        _candlesInFlight = true;
        try{ await refreshLatestCandles(); }catch(_e){}finally{ _candlesInFlight=false; }
      }, 15000);
    }
function loadMeta(){
      if(!poolAddr) return;
      try{
        const p = await geckoPool();
        if(!p) return;
        applyPool(p);
      }catch(e){
        // ignore
      }
    }

    
    // -------------------- Trending (match main site)
    const TREND_CACHE = new Map();

    function applyNetTheme(){
      document.body.classList.remove('net-sol','net-eth','net-bnb','net-base');
      if(activeNet==='solana') document.body.classList.add('net-sol');
      else if(activeNet==='eth') document.body.classList.add('net-eth');
      else if(activeNet==='bsc') document.body.classList.add('net-bnb');
      else if(activeNet==='base') document.body.classList.add('net-base');
    }

    function syncTrendToggle(){
      const wrap = $('trendToggle');
      if(!wrap) return;
      [...wrap.querySelectorAll('.chainBtn')].forEach(b=>{
        b.classList.toggle('active', normalizeChain(b.dataset.net)===(activeNet));
      });
    }

    async function fetchTrendingPools(net){
      const key = String(net||'');
      const cached = TREND_CACHE.get(key);
      const now = Date.now();
      if(cached && (now - cached.ts) < 45000) return cached.data;

      const url = `${GECKO}/networks/${encodeURIComponent(net)}/trending_pools?include=base_token,quote_token,dex`;
      const j = await fetchJson(url, {timeout:14000, retries:1});
      const data = Array.isArray(j?.data) ? j.data : [];
      const inc  = Array.isArray(j?.included) ? j.included : [];
      const incMap = new Map();
      for(const it of inc){ if(it?.id) incMap.set(it.id, it); }
      const out = { data, incMap };
      TREND_CACHE.set(key, {ts: now, data: out});
      return out;
    }

    
    // Render ticker items EXACT like main page
    function poolToTickerItem(p, n, incMap){
      const a = p?.attributes || {};
      const rel = p?.relationships || {};
      const baseRef = rel?.base_token?.data || null;
      const quoteRef = rel?.quote_token?.data || null;

      const baseId = baseRef?.id ? String(baseRef.id) : '';
      const baseType = baseRef?.type ? String(baseRef.type) : '';
      const quoteId = quoteRef?.id ? String(quoteRef.id) : '';
      const quoteType = quoteRef?.type ? String(quoteRef.type) : '';

      const baseT = baseId ? ((incMap.get(baseType+':' + baseId) || incMap.get(baseId))?.attributes || {}) : {};
      const quoteT = quoteId ? ((incMap.get(quoteType+':' + quoteId) || incMap.get(quoteId))?.attributes || {}) : {};

      const sym = String((baseT?.symbol || baseT?.name || '')).trim() || (a?.name ? String(a.name).split('/')[0].trim() : '') || 'TOKEN';
      const symClean = String(sym||'TOKEN').replace(/[^a-zA-Z0-9_$\.\-]/g,'').slice(0,24) || 'TOKEN';
      const symDisp = symClean.startsWith('$') ? symClean : ('$' + symClean.replace(/^\$/,''));

      const pctRaw = ((a?.price_change_percentage && (a.price_change_percentage.h24 ?? a.price_change_percentage['h24'] ?? a.price_change_percentage['24h'])) ?? a?.price_change_percentage_24h ?? a?.price_change_percentage_h24 ?? null);
      const pctNum = (pctRaw===null || pctRaw===undefined || pctRaw==='') ? NaN : Number(pctRaw);
      const pctTxt = Number.isFinite(pctNum) ? `${pctNum>0?'+':''}${pctNum.toFixed(2)}%` : '';
      const pctCls = Number.isFinite(pctNum) ? (pctNum>0?'up':(pctNum<0?'down':'')) : '';

      const logoUrlRaw = String(
        baseT?.image_url || baseT?.imageUrl || baseT?.image || baseT?.logo_url || baseT?.logoUrl ||
        quoteT?.image_url || quoteT?.imageUrl || quoteT?.image || quoteT?.logo_url || quoteT?.logoUrl ||
        a?.image_url || a?.imageUrl || a?.base_token_image_url || a?.base_token_imageUrl || a?.token_image_url || a?.token_imageUrl ||
        ''
      ).trim();
      let logoUrl = logoUrlRaw;
      if(logoUrl && logoUrl.startsWith('/')) logoUrl = 'https://www.geckoterminal.com' + logoUrl;
      const first = (symClean || 'T').slice(0,1).toUpperCase();

      // Prefer token CA (GeckoTerminal base_token id is usually the token CA)
      const tokenAddr = String((baseT?.address || baseId || '')).trim();

      const top1 = (n===0);
      const cls = `tickerItem${top1?' top1':''}`;
      const rankTxt = top1 ? `ðŸ”¥ #1` : `#${n+1}`;

      const logo = logoUrl
        ? `<span class="tickerLogoWrap"><img class="tickerLogo" src="${esc(logoUrl)}" alt="" loading="lazy" referrerpolicy="no-referrer" onerror="this.remove(); var w=this.closest('.tickerLogoWrap'); if(w){w.innerHTML='<span class=tickerLogoFallback>${esc(first)}</span>';}\"></span>`
        : `<span class="tickerLogoWrap"><span class="tickerLogoFallback">${esc(first)}</span></span>`;

      return `<a class="${cls}" href="#" data-addr="${esc(tokenAddr)}" title="Open ${esc(symDisp)}">
        <span class="rank">${esc(rankTxt)}</span>
        ${logo}
        <span class="sym">${esc(symDisp)}</span>
        ${pctTxt ? `<span class="tickerPct ${esc(pctCls)}">${esc(pctTxt)}</span>` : ''}
      </a>`;
    }

    // Make the marquee a true endless loop: distance + duration scale with content width.
    function syncTickerMarquee(){
      try{
        if(!tickerTrack) return;
        const isMobile = window.matchMedia('(max-width: 860px)').matches;
        const pxPerSec = isMobile ? 120 : 95;
        requestAnimationFrame(()=>{
          const total = tickerTrack.scrollWidth || 0;
          if(total < 20) return;
          const one = Math.max(1, Math.round(total / 2));
          document.documentElement.style.setProperty('--tickerDistance', one + 'px');
          const dur = Math.min(22, Math.max(6.5, one / pxPerSec));
          document.documentElement.style.setProperty('--tickerSpeed', dur.toFixed(2) + 's');
        });
      }catch(_e){}
    }

    let _tickerResizeT = null;
    window.addEventListener('resize', ()=>{
      clearTimeout(_tickerResizeT);
      _tickerResizeT = setTimeout(syncTickerMarquee, 120);
    }, {passive:true});

    function renderTrendingTicker(pools, incMap){
      const top = (pools||[]).slice(0, 10);
      if(!top.length){
        tickerTrack.innerHTML = `<span class="tickerItem" style="opacity:.75"><span class="rank">!</span><span class="sym">Trending unavailable</span></span>`;
        syncTickerMarquee();
        return;
      }

      const items = top.map((p,i)=>poolToTickerItem(p,i,incMap)).join('');
      tickerTrack.innerHTML = items + items;
      syncTickerMarquee();
    }

    async function startTrending(){
      applyNetTheme();
      syncTrendToggle();

      const load = async ()=>{
        try{
          const net = geckoNet();
          const res = await fetchTrendingPools(net);
          renderTrendingTicker(res.data, res.incMap);
        }catch(e){
          console.error('trending failed', e);
          tickerTrack.innerHTML = `<div class="tickerEmpty">Trending unavailable.</div>`;
        }
      };

      await load();
      statusEl.textContent = 'Live.';
      if(trendingTimer) clearInterval(trendingTimer);
      trendingTimer = setInterval(load, 25000);

      tickerTrack.onclick = (e)=>{
        const a = e.target.closest('.tickerItem');
        if(!a) return;
        e.preventDefault();
        const tAddr = a.getAttribute('data-addr') || '';
        if(tAddr) openToken(tAddr, {skipInput:true});
      };

      const toggle = $('trendToggle');
      if(toggle){
        toggle.onclick = (e)=>{
          const b = e.target.closest('.chainBtn');
          if(!b) return;
          const net = normalizeChain(b.dataset.net || 'solana');
          if(net===activeNet) return;
          activeNet = net;
          applyNetTheme();
          syncTrendToggle();
          renderNetPills();
          if(!addr) addr = DEFAULT_TOKEN[activeNet];
          navigate(activeNet, addr);
        };
      }
    }


    // -------------------- Navigation + Boot
    function updateUrl(){
      const u = new URL(location.href);
      u.searchParams.set('chain', activeNet);
      if(addr) u.searchParams.set('addr', addr);
      history.replaceState({}, '', u.toString());
    }

    function navigate(chain, address){
      activeNet = normalizeChain(chain);
      addr = String(address||'').trim();
      updateUrl();
      renderNetPills();
      applyNetTheme();
      startTrending();
      // if address exists, load it
      if(addr){
        openToken(addr, {skipInput:true, silent:true, boot:true});
      }
    }

    async function openToken(input, {
      try{ stopLiveLoops(); }catch(_e){}
skipInput=false}={}){
      let v = String(input||'').trim();
      if(!v){ toast('Paste a token name or address'); return; }
      if(!skipInput) q.value = v;

      // reset view
      statusEl.textContent = 'Loadingâ€¦';
      pairNameEl.textContent = 'Loadingâ€¦';
      pairMetaEl.textContent = 'Resolving best poolâ€¦';
      results.innerHTML = '';

      

      // default timeframe: always open on 5m
      activeTF = TF.find(x=>x.k==='5m') || TF[1] || TF[0];
      renderTimeframes();

      let dsPair = null;

      // If user typed a name/symbol (not an address), resolve via DexScreener search (auto across chains)
      if(!isEvmAddr(v) && !isSolAddr(v)){
        statusEl.textContent = 'Searchingâ€¦';
        pairNameEl.textContent = 'Searchingâ€¦';
        pairMetaEl.textContent = 'Finding best matchâ€¦';
        try{
          const pairs = await dsSearch(v);
          if(!pairs.length){
            statusEl.textContent = 'Not found.';
            pairNameEl.textContent = 'Not found';
            pairMetaEl.textContent = 'Try a contract address.';
            toast('No results. Try contract address.');
            return;
          }
          const best = bestPairAnyNet(pairs);
          if(!best){
            toast('No usable pair found.');
            return;
          }
          // switch net to best match chain
          const chainId = lc(best?.chainId||'');
          const newNet = (chainId==='solana') ? 'solana' : (chainId==='ethereum' ? 'eth' : (chainId==='bsc' ? 'bsc' : (chainId==='base' ? 'base' : activeNet)));
          if(newNet !== activeNet){
            activeNet = newNet;
            renderNetPills();
            startTrending();
          }

          dsPair = best;
          v = String(best?.baseToken?.address || '').trim() || v;
          if(!skipInput) q.value = v;
        }catch(e){
          statusEl.textContent = 'Search error.';
          toast('Search failed. Try again.');
          return;
        }
      }

      // If it's an EVM address and no dsPair yet, try all EVM nets and pick best liquidity
      if(isEvmAddr(v) && !dsPair){
        const nets = ['eth','bsc','base'];
        let best = null;
        for(const n of nets){
          const arr = await dsTokenPairsV1(n, v);
          const cand = bestPairAnyNet(arr);
          if(cand && (!best || Number(cand?.liquidity?.usd||0) > Number(best?.liquidity?.usd||0))) best = cand;
        }
        if(best){
          const chainId = lc(best?.chainId||'');
          const newNet = (chainId==='ethereum') ? 'eth' : (chainId==='bsc' ? 'bsc' : (chainId==='base' ? 'base' : activeNet));
          if(newNet !== activeNet){
            activeNet = newNet;
            renderNetPills();
            startTrending();
          }
          dsPair = best;
        }
      }

      // If it's Solana address and no dsPair yet, fetch DS token-pairs on Solana
      if(isSolAddr(v) && !dsPair){
        const arr = await dsTokenPairsV1('solana', v);
        const best = bestPairAnyNet(arr);
        if(best) dsPair = best;
      }

      // preferred pool address (pairAddress is usually the AMM pool address)
      let preferredPool = dsPair?.pairAddress || dsPair?.pair_address || '';

      // Fill header from DexScreener meta (fast symbols/logos/stats)
      if(dsPair){
        const meta = dsExtractTokenMeta(dsPair, v);
        curTokenAddr = v;
        if(meta?.image) curTokenImage = meta.image;
        if(meta?.name) curTokenName = meta.name;
        applyTokenHeader(meta);

        applyStats({
          price: num(dsPair?.priceUsd),
          liq: num(dsPair?.liquidity?.usd),
          mcap: num(dsPair?.fdv),
          h24: num(dsPair?.priceChange?.h24),
        });
      }else{
        curTokenAddr = v;
        curTokenName = '';
        curTokenImage = '';
        applyTokenHeader({symbol:'TOKEN', name:'', quoteSymbol:'', image:''});
        applyStats({});
      }

      // reset caches/timers
      tradesSeen = new Set();
      seenMakers = new Set();

      try{
        // 1) preferred pool first (when available via DexScreener)
        if(preferredPool){
          poolAddr = preferredPool;
          const p = await geckoPool();
          if(p){
            applyPool(p);
            statusEl.textContent = 'Loading chartâ€¦';
            await loadCandles(true);
            statusEl.textContent = 'Loading tradesâ€¦';
            await loadTrades(true);
            statusEl.textContent = 'Live.';
            startLiveLoops();
            return;
          }
        }

        // 2) fallback: Gecko token pools -> choose best
        const pools = await resolvePoolsFromGecko(v);
        if(!pools.length){
          statusEl.textContent = 'Not found.';
          pairNameEl.textContent = 'Not found';
          pairMetaEl.textContent = 'Try a different token or chain.';
          toast('Token not found on this chain.');
          return;
        }

        const best = chooseBestPool(pools, v);
        poolChoices = pools;
        poolAddr = poolAddressFromPool(best);

        const p = await geckoPool();
        if(!p) throw new Error('Pool fetch failed');
        applyPool(p);

        statusEl.textContent = 'Loading chartâ€¦';
        await loadCandles(true);
        statusEl.textContent = 'Loading tradesâ€¦';
        await loadTrades(true);
        statusEl.textContent = 'Live.';
        startLiveLoops();
      }catch(e){
        console.error(e);
        statusEl.textContent = 'Load error.';
        // Avoid noisy toast on first load / auto-open. Show toast only after user actions.
        if(!opts || (!opts.silent && !opts.boot)){
          toast('Failed to load chart/trades. API blocked or pool unsupported.');
        }
        // One gentle auto-retry on boot (sometimes APIs are rate-limited on initial load)
        if(opts && opts.boot && !openToken._bootRetried){
          openToken._bootRetried = true;
          setTimeout(()=>openToken(addr, {skipInput:true, silent:true}), 1200);
        }
}
    }

    // Boot trending
    startTrending();

    // Open initial token if present
    if(!addr) addr = DEFAULT_TOKEN[activeNet];
    // auto-open default
    openToken(addr, {skipInput:true, silent:true, boot:true});

  })();
  </script>
</body>
</html>
