<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#070711" />
  <title>$SOS â€” DEX Terminal (Multi-Chain)</title>
  <meta name="description" content="$SOS DEX Terminal â€” native chart + live trades across Solana, Ethereum, BNB, Base." />

  <style>
    :root{
      --bg:#070711;
      --bg2:#070711;
      --bg3:#070711;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.085);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --muted2: rgba(255,255,255,.55);
      --g:#14F195;
      --r:#FF4D6D;
      --c:#00D1FF;
      --p:#9945FF;
      --radius: 22px;
      --shadow: 0 14px 40px rgba(0,0,0,.55);
      --max: 1280px;
      --glass: blur(14px);
      --t: .18s ease;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
     margin:0;
     color:var(--text);
     font: 16px/1.6 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
     background: var(--bg);
     overflow-x:hidden;
     position: relative;
     }

    body::before{
     content:"";
     position: fixed;
     inset: 0;
     z-index: -1;
     pointer-events: none;
     background:
     radial-gradient(1200px 760px at 10% 5%, rgba(153,69,255,.24), transparent 60%),
     radial-gradient(1000px 720px at 90% 10%, rgba(20,241,149,.18), transparent 58%),
     radial-gradient(900px 640px at 72% 92%, rgba(0,209,255,.14), transparent 58%),
     radial-gradient(900px 640px at 0% 95%, rgba(0,209,255,.06), transparent 60%),
     var(--bg);
     transform: translateZ(0);
     }
a{color:inherit; text-decoration:none}
    button,input,select{font:inherit}

    .wrap{max-width:var(--max); margin:0 auto; padding: calc(var(--topbar-space, 84px) + 18px) 16px 28px}

    .topbar{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:12px 12px;
      border:1px solid var(--stroke);
      background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.04));
      border-radius: 26px;
      box-shadow: var(--shadow);
      backdrop-filter: var(--glass);
      position:fixed; top: calc(env(safe-area-inset-top) + 10px); left:50%; transform: translateX(-50%); width: min(var(--max), calc(100vw - 24px)); z-index:1000;
    }

    

    /* Topbar: replace $SOS title with Dexguard button */
    .topbar #topDexguardBtn{ padding: 9px 16px; }
    .topbar #topDexguardBtn .dexguardText{ font-size: 18px; }
    .topbar #topDexguardBtn .dexguardChip{ font-size: 12px; }


    /* Topbar brand area (legacy logo styles kept clean so CSS never breaks) */
    .brand{display:flex; align-items:center; gap:10px; min-width:0}
    .logo{
      width:38px; height:38px; border-radius:14px;
      display:grid; place-items:center;
      background:
        radial-gradient(14px 14px at 35% 30%, rgba(20,241,149,.9), transparent 60%),
        radial-gradient(14px 14px at 70% 35%, rgba(0,209,255,.9), transparent 60%),
        radial-gradient(14px 14px at 50% 80%, rgba(153,69,255,.9), transparent 60%),
        rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
    }
    .logo span{font-weight:900; letter-spacing:-.02em}

    /* Top-left DexGuard button (replaces old SOS title) */
    .topbar .dexguardBtn{ padding:9px 16px; }
    .topbar .dexguardText{ font-size:18px; }
    @media (max-width:520px){
      .topbar .dexguardText{ font-size:16px; }
    }

    .brandTxt{min-width:0}
    .brandTxt .t1{font-weight:900; letter-spacing:-.02em; font-size:15px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .brandTxt .t2{font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}

    .actions{display:flex; align-items:center; gap:10px}

    .pillRow{display:flex; align-items:center; gap:8px; flex-wrap:wrap}
    .pill{
      display:inline-flex; align-items:center; gap:7px;
      padding:9px 12px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.85);
      cursor:pointer;
      user-select:none;
      transition: transform var(--t), background var(--t), border-color var(--t);
    }
    .pill:hover{transform: translateY(-1px); background: rgba(255,255,255,.07)}
    .pill.active{border-color: rgba(153,69,255,.55); background: rgba(153,69,255,.14)}
    .pill .dot{width:10px; height:10px; border-radius:50%; background: rgba(255,255,255,.18); box-shadow: inset 0 0 0 1px rgba(255,255,255,.14)}
    .pill.active .dot{background: var(--p)}

    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      gap:8px;
      padding:10px 14px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      cursor:pointer;
      transition: transform var(--t), background var(--t), border-color var(--t);
    }
    .btn:hover{transform: translateY(-1px); background: rgba(255,255,255,.085)}
    .btn.primary{background: rgba(20,241,149,.14); border-color: rgba(20,241,149,.32)}
    .btn.ghost{background: rgba(255,255,255,.03)}

    /* Twitter/X button (topbar) */
    .btn.xbtn{
      background: rgba(0,0,0,.55);
      border-color: rgba(255,255,255,.16);
      color: rgba(255,255,255,.92);
    }
    .btn.xbtn:hover{ background: rgba(0,0,0,.70); }

    /* Hide topbar chain pills + buy button (use lower controls instead) */
    #netPills, #btnBuy{ display:none !important; }
    .btn.xbtn svg{ width:14px; height:14px; display:block; }

    /* Remove topbar chain pills + buy button (keep lower buttons) */
    #netPills{ display:none !important; }
    #btnBuy{ display:none !important; }

    .panel{
      margin-top:14px;
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: var(--glass);
      overflow:hidden;
    }

    
    /* ===== Dex-style Top Trending Bar + Search (MATCH MAIN PAGE) ===== */
    :root{
      --tickerSpeed: 8.2s;
      --tickerDistance: 50%;

      --solColor: #9945FF;
      --ethColor: #627EEA;
      --bnbColor: #F3BA2F;
      --baseColor:#0052FF;

      --netColor: var(--solColor);
      --netGlow: rgba(153,69,255,.22);
    }

    body.net-sol{ --netColor: var(--solColor); --netGlow: rgba(153,69,255,.22); }
    body.net-eth{ --netColor: var(--ethColor); --netGlow: rgba(98,126,234,.22); }
    body.net-bnb{ --netColor: var(--bnbColor); --netGlow: rgba(243,186,47,.22); }
    body.net-base{ --netColor: var(--baseColor); --netGlow: rgba(0,82,255,.22); }

    /* Top trending bar container (inside panel) */
    .topBar{
      z-index: 60;
      position: relative;
      background: rgba(11,16,51,.45);
      border-bottom: 1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
    }

    .topBarInner{
      padding: 14px 16px 12px;
      display:flex;
      flex-direction: column;
      gap: 10px;
    }

    .topRow{
      display:flex;
      align-items:center;
      justify-content:flex-start;
      gap: 12px;
      flex-wrap:wrap;
    }

    /* keep chain pills close to LIVE TRENDING (not pushed to far right) */
    .chainToggle{ margin-left: 10px; }

    .bottomRow{
      display:flex;
      align-items:center;
      gap: 12px;
      min-width: 0;
    }

    .hotBlock{ display:flex; align-items:center; gap: 12px; flex-wrap:wrap; }
    .hotLabel{
      display:inline-flex;
      align-items:center;
      gap: 10px;
      padding: 9px 14px;
      border-radius: 999px;
      background: rgba(255,65,65,.10);
      border: 1px solid rgba(255,65,65,.20);
      box-shadow: 0 12px 32px rgba(0,0,0,.24);
      font-weight: 1100;
      letter-spacing: .6px;
    }
    .hotFire{ width: 18px; height: 18px; opacity: .95; display:grid; place-items:center; }

    .dexguardBtn{
      display:inline-flex;
      align-items:center;
      gap:12px;
      padding: 9px 16px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background:
        radial-gradient(140% 120% at 0% 0%, rgba(0,209,255,.18), rgba(0,209,255,0) 55%),
        radial-gradient(140% 120% at 100% 100%, rgba(153,69,255,.18), rgba(153,69,255,0) 55%),
        rgba(8,18,40,.50);
      box-shadow: 0 12px 34px rgba(0,0,0,.28);
      color: rgba(255,255,255,.92);
      font-weight: 1050;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .15s ease, background .15s ease, border-color .15s ease, box-shadow .15s ease;
      position:relative;
      overflow:hidden;
    }
    .dexguardBtn:hover{
      transform: translateY(-1px);
      border-color: rgba(255,255,255,.18);
      background:
        radial-gradient(140% 120% at 0% 0%, rgba(0,209,255,.22), rgba(0,209,255,0) 60%),
        radial-gradient(140% 120% at 100% 100%, rgba(153,69,255,.22), rgba(153,69,255,0) 60%),
        rgba(8,18,40,.62);
      box-shadow: 0 16px 46px rgba(0,0,0,.36);
    }
    .dexguardBtn:active{ transform: translateY(0px) scale(.995); }
    .dexguardBtn::after{
      content:"";
      position:absolute;
      inset:-60% -40%;
      background: linear-gradient(120deg,
        transparent 0%,
        rgba(255,255,255,.00) 35%,
        rgba(255,255,255,.22) 50%,
        rgba(255,255,255,.06) 60%,
        transparent 75%
      );
      transform: translateX(-170%) rotate(10deg);
      opacity:0;
      pointer-events:none;
      mix-blend-mode: screen;
      animation: dexguardShine 6.8s ease-in-out infinite;
    }
    @keyframes dexguardShine{
      0%, 72%{ opacity:0; transform: translateX(-170%) rotate(10deg); }
      78%{ opacity:.70; }
      92%{ opacity:0; transform: translateX(170%) rotate(10deg); }
      100%{ opacity:0; transform: translateX(170%) rotate(10deg); }
    }

    .dexguardChip{
      position: relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding: 7px 14px;
      border-radius: 999px;
      background: rgba(3,12,24,.65);
      border: 1px solid rgba(255,255,255,.10);
      font-weight: 1100;
      letter-spacing: .28em;
      font-size: 13px;
      color: rgba(255,255,255,.96);
    }
    .dexguardChip::before{
      content:"";
      position:absolute;
      inset:-2px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(20,241,149,.88), rgba(0,209,255,.88), rgba(153,69,255,.88));
      z-index:-1;
      opacity:.9;
    }
    .dexguardText{
      font-weight: 1050;
      letter-spacing: -.2px;
      font-size: 20px;
      line-height: 1;
    }

    @media (max-width: 520px){
      .dexguardText{ font-size: 18px; }
      .dexguardBtn{ padding: 9px 14px; gap: 10px; }
      .dexguardChip{ padding: 7px 12px; }
    }

    .chainToggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 6px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }

    .chainBtn{
      appearance:none;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.92);
      font-weight: 1000;
      font-size: 12px;
      padding: 8px 10px;
      border-radius: 999px;
      cursor:pointer;
      letter-spacing: .35px;
      transition: transform .15s ease, background .15s ease, border-color .15s ease, box-shadow .15s ease;
    }
    .chainBtn:hover{ background: rgba(255,255,255,.09); transform: translateY(-1px); }
    .chainBtn:active{ transform: translateY(0px) scale(.99); }

    .chainBtn[data-net="solana"]{ border-color: rgba(153,69,255,.50); background: rgba(153,69,255,.10); box-shadow: 0 0 0 1px rgba(153,69,255,.12) inset, 0 10px 22px rgba(153,69,255,.10); }
    .chainBtn[data-net="eth"]{ border-color: rgba(98,126,234,.50); background: rgba(98,126,234,.10); box-shadow: 0 0 0 1px rgba(98,126,234,.12) inset, 0 10px 22px rgba(98,126,234,.10); }
    .chainBtn[data-net="bsc"]{ border-color: rgba(243,186,47,.52); background: rgba(243,186,47,.10); box-shadow: 0 0 0 1px rgba(243,186,47,.12) inset, 0 10px 22px rgba(243,186,47,.10); }
    .chainBtn[data-net="base"]{ border-color: rgba(0,82,255,.52); background: rgba(0,82,255,.10); box-shadow: 0 0 0 1px rgba(0,82,255,.12) inset, 0 10px 22px rgba(0,82,255,.10); }

    .chainBtn.active{
      color: rgba(255,255,255,.96);
      text-shadow: 0 1px 0 rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.96);
      box-shadow: 0 10px 26px rgba(0,0,0,.28);
    }
    body.net-sol .chainBtn.active{ background: linear-gradient(90deg, rgba(153,69,255,.96), rgba(153,69,255,.52)); }
    body.net-eth .chainBtn.active{ background: linear-gradient(90deg, rgba(98,126,234,.96), rgba(98,126,234,.52)); }
    body.net-bnb .chainBtn.active{ background: linear-gradient(90deg, rgba(243,186,47,.96), rgba(243,186,47,.50)); }
    body.net-base .chainBtn.active{ background: linear-gradient(90deg, rgba(0,82,255,.96), rgba(0,82,255,.50)); }

    .tickerWrap{
      flex: 1;
      min-width: 0;
      position: relative;
      overflow: hidden;
      border-radius: 999px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 30px rgba(0,0,0,.22);
      padding: 10px 12px;
    }

    .tickerWrap:before,
    .tickerWrap:after{
      content:"";
      position:absolute;
      top:0; bottom:0;
      width: 44px;
      pointer-events:none;
      z-index: 2;
    }
    .tickerWrap:before{ left:0; background: linear-gradient(90deg, rgba(11,16,51,.92), rgba(11,16,51,0)); }
    .tickerWrap:after{ right:0; background: linear-gradient(270deg, rgba(11,16,51,.92), rgba(11,16,51,0)); }

    .tickerTrack{
      display:flex;
      gap: 10px;
      align-items:center;
      white-space: nowrap;
      will-change: transform;
      animation: tickerMarquee var(--tickerSpeed) linear infinite;
    }

    .tickerWrap:hover .tickerTrack{ animation-play-state: paused; }

    @keyframes tickerMarquee{
      0%{ transform: translateX(0); }
      100%{ transform: translateX(calc(-1 * var(--tickerDistance))); }
    }

    .tickerItem{
      display:inline-flex;
      align-items:center;
      gap: 10px;
      padding: 7px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 0 0 1px var(--netGlow) inset;
      color: rgba(255,255,255,.92);
      font-weight: 900;
      font-size: 13px;
      letter-spacing: .1px;
      cursor:pointer;
    }

    .tickerLogoWrap{
      width:28px;
      height:28px;
      flex:0 0 28px;
      border-radius: 6px;
      overflow:hidden;
      display:grid;
      place-items:center;
      background: rgba(255,255,255,.07);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 8px 18px rgba(0,0,0,.22);
    }
    .tickerLogo{ width:100%; height:100%; object-fit: cover; display:block; }
    .tickerLogoFallback{ font-size: 12px; font-weight: 1100; color: rgba(255,255,255,.90); line-height: 1; }
    .tickerItem.top1 .tickerLogoWrap{ border-color: rgba(255,215,0,.35); box-shadow: 0 0 0 1px rgba(255,215,0,.15) inset, 0 10px 22px rgba(0,0,0,.22); }

    .tickerItem .rank{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width: 28px;
      height: 22px;
      padding: 0 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      font-size: 12px;
      font-weight: 1000;
      color: var(--netColor);
    }
    .tickerItem .sym{ font-weight: 950; }

    .tickerPct{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      height: 22px;
      padding: 0 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      font-size: 12px;
      font-weight: 950;
      color: rgba(255,255,255,.90);
    }
    .tickerPct.up{ color: rgba(20,241,149,.98); background: rgba(20,241,149,.10); border-color: rgba(20,241,149,.22); }
    .tickerPct.down{ color: rgba(255,90,90,.96); background: rgba(255,90,90,.10); border-color: rgba(255,90,90,.22); }

    .tickerItem.top1{
      background: rgba(255,215,0,.10);
      border-color: rgba(255,215,0,.32);
      box-shadow: 0 0 0 1px rgba(255,215,0,.18) inset, 0 12px 30px rgba(0,0,0,.26);
    }
    .tickerItem.top1 .rank{
      background: linear-gradient(90deg, #F3BA2F, #FFD700, #FFF2B0);
      color: rgba(10,10,22,.92);
      border: 0;
      font-weight: 1100;
    }

    /* Search (styled like main page) */
    .dexSearch{position: relative; width: 360px; max-width: 44vw; z-index: 99999; isolation:isolate; }
    .dexSearchInner{
      display:flex;
      gap: 8px;
      align-items:center;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 10px 30px rgba(0,0,0,.22);
    }
    .dexInput{
      flex: 1;
      min-width: 0;
      background: transparent;
      border: 0;
      outline: none;
      color: rgba(255,255,255,.92);
      font-weight: 850;
      font-size: 13px;
    }
    .dexInput::placeholder{ color: rgba(255,255,255,.55); font-weight: 800; }

    /* Re-skin existing results dropdown to match main page style */
    .results{
      z-index: 1000001;
display:none;
      position:absolute;
      top: calc(100% + 10px);
      right: 0;
      left: auto;
      width: min(560px, calc(100vw - 28px));
      max-height: 60vh;
      overflow:auto;
      padding: 10px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.14);
      /* IMPORTANT: fully readable dropdown (no chart bleed-through) */
      background: rgba(12,16,40,.98);
      box-shadow: 0 26px 90px rgba(0,0,0,.78);
      isolation: isolate;
      z-index: 999999;
    }

    /* Search modal scrim: blocks chart/trades from showing through while searching */
    .searchScrim{
      display:none;
      position:fixed;
      inset:0;
      background: rgba(7,7,17,.72);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: 999990;
    }
    .dexSearch.open .searchScrim{ display:block; }


    /* Keep DexGuard search row markup, but make it feel like the main dropdown */
    .resItem{
      border-radius: 16px;
      margin-bottom: 10px;
      border: 1px solid rgba(255,255,255,.10);
      background: #141c44;
      padding: 10px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      cursor:pointer;
      transition: background .15s ease, border-color .15s ease, transform .15s ease;
    }
    .resItem:hover{ background: #18214f; border-color: rgba(255,255,255,.18); transform: translateY(-1px); }
    .resItem:last-child{ margin-bottom: 0; }

    .resL{ display:flex; align-items:center; gap: 10px; min-width:0; }
    .resLogo{
      width: 36px;
      height: 36px;
      border-radius: 12px;
      overflow:hidden;
      display:grid;
      place-items:center;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      flex: 0 0 36px;
    }
    .resLogo img{ width:100%; height:100%; object-fit:cover; display:block; }
    .resLogo .fb{ font-weight:1100; color: rgba(255,255,255,.92); }

    .resTxt{ min-width:0; }
    .resName{ font-weight: 1000; letter-spacing:-.01em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .resMeta{ font-size: 12px; color: rgba(255,255,255,.64); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; margin-top: 2px; }
    .resR{ display:flex; gap: 8px; align-items:center; flex-wrap:wrap; justify-content:flex-end; }

    /* Hide legacy UI bits so the bar looks identical */
    #btnGo{ display:none !important; }
    #modeHint{ display:none !important; }

    @media (max-width: 860px){
      .dexSearch{ width: 100%; max-width: 100%; }
      .bottomRow{ flex-direction: column; align-items: stretch; }
    }
    /* Layout: chart on top, trades underneath (desktop + mobile) */
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:14px;
      padding:14px;
    }

    .card{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.045);
      border-radius: 20px;
      overflow:hidden;
    }

    .cardHd{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:14px 14px;
      border-bottom:1px solid rgba(255,255,255,.07);
    }
    .pair{display:flex; align-items:center; gap:10px; min-width:0}
    .tlogo{width:38px; height:38px; border-radius:14px; overflow:hidden; display:grid; place-items:center; background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.10)}
    .tlogo img{width:100%; height:100%; object-fit:cover}
    .tlogo .fb{font-weight:900; opacity:.9}
    .pairTxt{min-width:0}
    .pairName{font-weight:950; letter-spacing:-.02em; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .pairNameSub{font-size:12px; font-weight:800; opacity:.72; margin-left:8px; letter-spacing:0;}
    .pairMeta{font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}

    .stats{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}
    .statPill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.10);
      font-size:12px;
      color: rgba(255,255,255,.86);
      white-space:nowrap;
    }
    .statPill.up{border-color: rgba(20,241,149,.30); background: rgba(20,241,149,.10); color: rgba(20,241,149,.92)}
    .statPill.down{border-color: rgba(255,77,109,.28); background: rgba(255,77,109,.10); color: rgba(255,77,109,.92)}

    #chartWrap{height: clamp(380px, 52vh, 600px); position:relative; z-index:0}
    #chart{position:absolute; inset:0; z-index:1}
    /* Ensure dropdowns/menus always sit above the chart canvas */
    #chart canvas{position:relative; z-index:1}

    .controls{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      padding:12px 12px;
      border-top:1px solid rgba(255,255,255,.07);
      background: rgba(0,0,0,.10);
      flex-wrap:wrap;
    }

    .tfRow{display:flex; gap:6px; flex-wrap:wrap}
    .tf{padding:8px 10px; border-radius: 999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); cursor:pointer; font-weight:850; font-size:12px}
    .tf.active{border-color: rgba(0,209,255,.42); background: rgba(0,209,255,.14)}

    .rightCtl{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .sel{padding:9px 10px; border-radius: 999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); color: var(--text)}

    .tableHd{
      display:flex; align-items:flex-end; justify-content:space-between;
      padding:14px 14px;
      border-bottom:1px solid rgba(255,255,255,.07);
    }
    .ttl{font-weight:950; letter-spacing:-.02em}
    .sub{font-size:12px; color:var(--muted)}

    .trades{
      height: 600px;
      overflow:auto;
    }

    .tradeHead, .tradeRow{
      display:grid;
      grid-template-columns: 90px 70px 90px 1fr 110px 1fr 34px;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      font-size:13px;
    }
    .tradeHead{
      position:sticky; top:0; z-index:5;
      background: rgba(12,12,20,.92);
      backdrop-filter: blur(12px);
      font-size:12px;
      color: rgba(255,255,255,.72);
      font-weight:900;
    }
    .tradeRow:hover{background: rgba(255,255,255,.05)}
    .typeBadge{
      display:inline-flex; align-items:center; justify-content:center;
      padding:6px 10px;
      border-radius:999px;
      font-weight:950;
      font-size:12px;
      letter-spacing:-.01em;
      border:1px solid rgba(255,255,255,.10);
      width:fit-content;
    }
    .typeBadge.buy{background: rgba(20,241,149,.10); border-color: rgba(20,241,149,.30); color: rgba(20,241,149,.95)}
    .typeBadge.sell{background: rgba(255,77,109,.10); border-color: rgba(255,77,109,.28); color: rgba(255,77,109,.95)}

    .mono{font-variant-numeric: tabular-nums; font-feature-settings: "tnum" 1}
    .maker{display:flex; align-items:center; gap:8px; min-width:0}
    .maker .addr{white-space:nowrap; overflow:hidden; text-overflow:ellipsis; color: rgba(255,255,255,.85)}
    .maker .new{font-size:11px; padding:4px 8px; border-radius:999px; border:1px solid rgba(153,69,255,.30); background: rgba(153,69,255,.12); color: rgba(153,69,255,.95); font-weight:900}

    .iconBtn{width:30px; height:30px; border-radius: 999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.05); display:grid; place-items:center; cursor:pointer}
    .iconBtn:hover{background: rgba(255,255,255,.08)}

    .toast{
      position:fixed;
      left:50%; transform: translateX(-50%);
      bottom:18px;
      background: rgba(10,10,18,.92);
      border:1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.92);
      padding:12px 14px;
      border-radius: 14px;
      box-shadow: 0 14px 60px rgba(0,0,0,.65);
      backdrop-filter: blur(14px);
      display:none;
      z-index:60;
      max-width: calc(100% - 24px);
    }

    /* Mobile-first: keep it clean */
    .mobileTabs{display:none}
    .tabBar{
      display:flex; gap:8px;
      padding:12px 12px;
      border-top:1px solid rgba(255,255,255,.06);
      background: rgba(0,0,0,.12);
    }
    .tab{
      flex:1;
      padding:10px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      font-weight:950;
      cursor:pointer;
      text-align:center;
    }
    .tab.active{border-color: rgba(153,69,255,.55); background: rgba(153,69,255,.14)}

    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr}
      .trades{height: 420px}
      #chartWrap{height: clamp(340px, 48vh, 520px)}
      .topbar{position:fixed; top: calc(env(safe-area-inset-top) + 10px); left:50%; transform: translateX(-50%); width: min(var(--max), calc(100vw - 20px));}
    }

    @media (max-width: 640px){
      /* Remove the harsh green mid-page wash on small screens */
      body{
        background:
          radial-gradient(900px 520px at 25% 0%, rgba(153,69,255,.22), transparent 60%),
          radial-gradient(900px 520px at 85% 18%, rgba(0,209,255,.14), transparent 60%),
          var(--bg);
      }

      .wrap{padding: calc(var(--topbar-space, 84px) + 12px) 10px 18px}

      /* Cleaner, less "thick" top header */
      .topbar{
        padding:10px 10px;
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }
      .actions{justify-content:space-between; width:100%; gap:8px; flex-wrap:wrap}
      .btn{padding:10px 12px; font-size:13px}
      .pill{padding:8px 10px}

      /* Make the trending/search header feel compact & aligned */
      .topBarInner{padding:12px 12px 12px}
      .hotLabel{padding:10px 12px; font-size:13px}
      .chainBtn{padding:8px 10px; font-size:12px}
      .dexSearchInner{padding:10px 12px}
      .results{left:0; right:0; width: calc(100vw - 24px)}

      .tickerTrack{animation-duration: 22s}
      .grid{padding:12px}
      .stats{justify-content:flex-start}

      /* Always show chart then trades (no tabs) */
      .mobileTabs{display:none !important}
      #mobileTradesWrap{display:none !important}
      .desktopOnly{display:block}

      #chartWrap{height: clamp(360px, 52vh, 560px)}
      .trades{height: 520px}

      /* Trades table: keep it readable */
      .tradeHead, .tradeRow{grid-template-columns: 62px 64px 78px 1fr 0 0 34px}
      .tradeHead .hideM, .tradeRow .hideM{display:none}
      .maker .new{display:none}
    }
  

/* ================================
   DexGuard UI/UX Premium Patch (Design-only)
   ================================ */

/* Design tokens */
:root{
  --s-1:8px;
  --s-2:12px;
  --s-3:16px;
  --s-4:20px;
  --s-5:24px;
  --r-1:14px;
  --r-2:18px;
  --r-3:22px;
  --e-1: 0 10px 28px rgba(0,0,0,.36);
  --e-2: 0 18px 54px rgba(0,0,0,.55);
  --glassSm: blur(10px);
  --glassNone: blur(0px);
  --hit:44px;
}

/* Global polish + accessibility */
.btn, .pill, .chainBtn, .tf, .iconBtn, .tab{
  min-height: var(--hit);
}
.btn, .pill, .chainBtn, .tf, .sel{
  -webkit-tap-highlight-color: transparent;
}
.btn:focus-visible, .pill:focus-visible, .chainBtn:focus-visible, .tf:focus-visible, .dexInput:focus-visible, .iconBtn:focus-visible{
  outline: 2px solid rgba(0,209,255,.55);
  outline-offset: 2px;
}
.panel{
  /* Avoid expensive blur on large surfaces */
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
  box-shadow: var(--e-2);
}
.topBar{
  /* Keep glass subtle (no heavy blur on wide area) */
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
}

/* Make typography feel more terminal-grade */
.pairName{
  font-size: 15px;
  line-height: 1.25;
}
.pairMeta{
  line-height: 1.35;
}

/* Search dropdown: no full-page dim/blur; keep dropdown crisp */
.searchScrim{
  display:none !important;
  background: transparent !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
}
.dexSearch.open .searchScrim{ display:none !important; }
.results{
  left: 0 !important;
  right: 0 !important;
  width: min(560px, calc(100vw - 28px)) !important;
  transform: translateZ(0);
}
.resItem{
  min-height: 56px;
  padding: 12px 12px;
}
.resR .btn, .resR .iconBtn{
  min-height: 40px;
  height: 40px;
}

/* Token header + controls: tighter + consistent */
.cardHd{ padding: 14px 14px; }
.controls{
  padding: 10px 12px;
}
.tf{
  min-height: 40px;
  padding: 10px 12px;
  font-size: 12px;
}
.sel{ min-height: 40px; }

/* Table rows: smoother hover/tap */
.tradeRow{ transition: background var(--t); }
.tradeRow:active{ background: rgba(255,255,255,.07); }

/* ===== Mobile-first: compact sticky top bar + proper hierarchy ===== */
@media (max-width: 740px){
  .wrap{
    padding: calc(var(--topbar-space, 84px) + 10px) 10px 110px; /* reserve space for bottom sheet */
  }

  .topbar{
    position: fixed;
    top: calc(env(safe-area-inset-top) + 8px);
    left: 50%;
    transform: translateX(-50%);
    width: min(var(--max), calc(100vw - 20px));
    z-index: 1000;
    padding: 10px 10px;
    border-radius: var(--r-2);
    backdrop-filter: var(--glassSm);
    -webkit-backdrop-filter: var(--glassSm);
  }
  .brand{ gap: 10px; }
  #topDexguardBtn{
    min-height: var(--hit);
    padding: 8px 14px;
  }
  .actions{
    gap: 8px;
    flex-wrap: nowrap;
    justify-content: flex-end;
    width: auto;
  }
  #btnBack{
    min-height: var(--hit);
    padding: 10px 12px;
    font-size: 12px;
    white-space: nowrap;
  }
  #btnX{
    width: var(--hit);
    height: var(--hit);
    padding: 0;
    justify-content: center;
  }
  #btnX span{ display:none; }

  /* Trending/search header: compact, app-like */
  .topBarInner{
    padding: 10px 10px 10px;
    gap: 10px;
  }
  .topRow{
    gap: 10px;
    flex-wrap: wrap;
    justify-content: space-between;
  }
  .hotLabel{
    display:none; /* keep accessible via ticker; don't dominate */
  }
  .chainToggle{
    margin-left: 0;
    width: 100%;
    justify-content: space-between;
  }
  .chainBtn{
    flex: 1;
    text-align: center;
    min-height: 40px;
    padding: 10px 10px;
    font-size: 12px;
  }

  .bottomRow{
    flex-direction: column;
    align-items: stretch;
    gap: 10px;
  }
  .tickerWrap{
    padding: 8px 10px;
    border-radius: 18px;
  }
  .tickerTrack{ animation-duration: 22s; }
  .tickerItem{ font-size: 12px; padding: 8px 10px; }

  /* Search: prominent + thumb friendly */
  .dexSearch{ width: 100%; max-width: 100%; }
  .dexSearchInner{
    min-height: var(--hit);
    padding: 10px 12px;
    border-radius: 18px;
  }
  .dexInput{
    font-size: 14px;
    font-weight: 900;
  }
  .results{
    max-height: 58vh;
    border-radius: 18px;
  }

  /* Main content hierarchy */
  #chartWrap{ height: clamp(360px, 52vh, 560px); }
  .card{
    border-radius: var(--r-3);
  }
  .cardHd{
    padding: 12px 12px;
    gap: 10px;
  }
  .tlogo{
    width: 40px;
    height: 40px;
    border-radius: 14px;
  }
  .pairName{
    font-size: 15px;
  }
  .stats{
    justify-content: flex-start;
    gap: 8px;
  }

  /* Hide legacy mobile tabs wrapper entirely */
  .mobileTabs{ display:none !important; }
  #mobileTradesWrap{ display:none !important; }

  /* ===== Live Trades bottom sheet ===== */
  #tradesCard{
    --sheetPeek: 58px;
    --sheetH: clamp(240px, 42vh, 420px);
    position: fixed !important;
    left: 10px;
    right: 10px;
    bottom: calc(env(safe-area-inset-bottom) + 10px);
    margin: 0 !important;
    height: var(--sheetH);
    max-height: 45vh;
    max-width: none !important;
    z-index: 95;
    box-shadow: var(--e-2);
    transform: translateY(calc(100% - var(--sheetPeek)));
    transition: transform .20s cubic-bezier(.2,.9,.2,1);
    will-change: transform;
    background: rgba(10,12,22,.72);
    backdrop-filter: var(--glassSm);
    -webkit-backdrop-filter: var(--glassSm);
    border-radius: 20px;
    overflow: hidden;
  }
  #tradesCard.sheetOpen{
    transform: translateY(0);
  }
  #tradesCard .tableHd{
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255,255,255,.08);
    background: rgba(10,12,22,.74);
    backdrop-filter: var(--glassSm);
    -webkit-backdrop-filter: var(--glassSm);
    cursor: pointer;
    user-select: none;
  }
  #tradesCard .tableHd::before{
    content:"";
    display:block;
    width: 46px;
    height: 4px;
    border-radius: 999px;
    background: rgba(255,255,255,.18);
    margin: 2px auto 8px;
  }
  #tradesCard .tableHd .ttl{
    font-size: 14px;
    letter-spacing: -.01em;
  }
  #tradesCard .tableHd .sub{
    font-size: 12px;
  }
  #tradesCard .tableHd{
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap: 10px;
  }
  #tradesCard .tableHd .sheetRight{
    display:flex;
    align-items:center;
    gap: 8px;
  }
  #tradesCard:not(.sheetOpen) .trades{
    display:none;
  }
  #tradesCard.sheetOpen .trades{
    height: calc(var(--sheetH) - 78px);
    max-height: calc(45vh - 78px);
    overflow:auto;
    -webkit-overflow-scrolling: touch;
  }
  #tradesCard .sheetToggleBtn{
    width: 40px;
    height: 40px;
  }
  #tradesCard.sheetOpen .sheetToggleBtn{
    transform: rotate(180deg);
  }


  /* Trades columns: reduce clutter on mobile */
  .tradeHead, .tradeRow{
    grid-template-columns: 64px 64px 84px 1fr 0 0 34px !important;
  }
  .maker .new{ display:none !important; }
}

/* ===== Desktop premium grid balancing ===== */
@media (min-width: 980px){
  .grid{
    gap: 16px;
    padding: 16px;
  }
  #chartWrap{ height: clamp(460px, 56vh, 720px); }
  .cardHd{ padding: 16px 16px; }
  .controls{ padding: 12px 14px; }
  .trades{ height: 560px; }
}

/* ================================
   DexGuard Targeted UI PATCH (A/B/C)
   ================================ */
/* Header pills stay single-row with horizontal scroll if needed (no wrapping) */
#netPills{
  display:flex;
  flex-wrap: nowrap !important;
  gap: 8px;
  overflow-x: auto;
  overflow-y: hidden;
  scrollbar-width: none;
  max-width: 52vw;
}
#netPills::-webkit-scrollbar{ display:none; }
@media (max-width: 640px){
  #netPills{ max-width: 44vw; }
  .pill{ min-height: 40px; padding: 8px 10px; }
}


/* TASK A â€” Fixed top header single-row + logo */
.topbar{ flex-wrap: nowrap !important; }
.topbar .brand{ flex: 0 0 auto; min-width: 0; }
.topLogo{
  height: 34px;
  width: auto;
  max-width: 180px;
  display: block;
  object-fit: contain;
}
.actions{ flex-wrap: nowrap !important; white-space: nowrap; min-width: 0; }
.actions > *{ flex: 0 0 auto; }
#btnBack{ white-space: nowrap; }
#btnX{ white-space: nowrap; }
@media (max-width: 740px){
  /* remove bottom-sheet reserved space */
  .wrap{ padding: calc(var(--topbar-space, 84px) + 10px) 10px 18px !important; }
}
@media (max-width: 640px){
  /* force single-row header (no stacking) */
  .topbar{ flex-direction: row !important; align-items: center !important; gap: 10px !important; }
  .actions{ width: auto !important; justify-content: flex-end !important; gap: 8px !important; }
  .topLogo{ height: 30px; max-width: 150px; }
  #btnBack{ font-size: 12px; padding: 9px 10px; }
  #btnX{ width: 42px; height: 42px; }
}
@media (max-width: 360px){
  .topLogo{ height: 28px; max-width: 130px; }
  #btnBack{ font-size: 11px; padding: 8px 9px; }
}

/* TASK C â€” Search dropdown never clipped */
.panel{ overflow: visible !important; }
.topBar{ z-index: 5000 !important; }
.dexSearch{ z-index: 6000 !important; }
.results{ z-index: 7000 !important; }
.grid{ position: relative; z-index: 1; }

/* TASK B â€” Live Trades stays under chart, expands downward only */
#tradesCard{
  position: relative !important;
  left: auto !important; right: auto !important; bottom: auto !important;
  transform: none !important;
  height: auto !important;
  max-height: none !important;
  margin: 0 !important;
}
#tradesCard .tableHd{
  cursor: pointer;
  user-select: none;
}
#tradesCard .tableHd .sheetRight{ display:flex; align-items:center; gap:10px; }
#tradesCard .accToggleBtn{
  width: 40px;
  height: 40px;
  display: grid;
  place-items: center;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.05);
}
#tradesCard .accToggleBtn:hover{ background: rgba(255,255,255,.08); }
#tradesCard .accToggleBtn svg{ transition: transform var(--t); }
#tradesCard.open .accToggleBtn svg{ transform: rotate(180deg); }

/* collapsed: header only */
#tradesCard:not(.open) .trades{ display:none !important; }

/* expanded: internal scrolling region, still in page flow */
#tradesCard.open .trades{
  display:block !important;
  height: auto !important;
  max-height: clamp(240px, 45vh, 600px);
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
@media (max-width: 980px){
  #tradesCard.open .trades{ max-height: clamp(220px, 42vh, 520px); }
}


/* ===== DexGuard Live Terminal Patch: Split Panel + Live Txns ===== */
#btnRefresh,#btnFit{display:none !important;}
.splitRoot{display:flex; flex-direction:column; height:clamp(520px,70vh,780px); min-height:480px; max-height:820px; margin-top:10px;}
.splitChart{flex:1 1 auto; min-height:220px; position:relative; display:flex; flex-direction:column;}
.splitChart #chartWrap{flex:1 1 auto; height:100% !important; min-height:220px;}
.splitHandle{flex:0 0 14px; height:14px; cursor:ns-resize; touch-action:none; user-select:none; display:flex; align-items:center; justify-content:center;
  background:rgba(255,255,255,.03); border-top:1px solid rgba(255,255,255,.06); border-bottom:1px solid rgba(255,255,255,.06);}
.splitHandle::before{content:""; width:52px; height:4px; border-radius:999px; background:rgba(255,255,255,.18);}
.splitPanel{flex:0 0 var(--split-bottom,260px); min-height:160px; max-height:calc(100% - 220px); overflow:hidden; display:flex; flex-direction:column;
  background:rgba(0,0,0,.12); border-radius:16px;}
.splitTabs{display:flex; gap:8px; padding:10px 10px 8px; align-items:center; border-bottom:1px solid rgba(255,255,255,.07); background:rgba(0,0,0,.16);}
.splitTab{appearance:none; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.03); color:rgba(255,255,255,.88); padding:8px 10px; border-radius:12px;
  font-weight:650; font-size:12px; letter-spacing:.2px; cursor:pointer;}
.splitTab.active{background:rgba(255,184,0,.14); border-color:rgba(255,184,0,.22); color:#ffd37a;}
.splitBody{flex:1; overflow:auto; -webkit-overflow-scrolling:touch;}
.tradeRow.enter{animation:tradeEnter .26s ease-out both;}
@keyframes tradeEnter{from{opacity:0; transform:translateY(-10px);}to{opacity:1; transform:translateY(0);}}
/* Hide legacy mobile chart/trades tabs (split panel replaces them) */
.mobileTabs{display:none !important;}
#mobileTradesWrap{display:none !important;}



/* ================================
   TOP HEADER BAR FLOW PATCH (normal flow, not fixed/sticky)
   ================================ */
.wrap{
  padding: 18px 16px 28px !important;
}
@media (max-width: 640px){
  .wrap{ padding: 12px 10px 18px !important; }
}
.topbar{
  position: static !important;
  top: auto !important;
  left: auto !important;
  right: auto !important;
  transform: none !important;
  width: 100% !important;
  z-index: auto !important;
  margin: 12px 0 14px !important;
}
@media (max-width: 980px){
  .topbar{
    position: static !important;
    top: auto !important;
    left: auto !important;
    transform: none !important;
    width: 100% !important;
  }
}
@media (max-width: 740px){
  .topbar{
    position: static !important;
    top: auto !important;
    left: auto !important;
    transform: none !important;
    width: 100% !important;
  }
}
@media (max-width: 640px){
  .topbar{
    position: static !important;
    top: auto !important;
    left: auto !important;
    transform: none !important;
    width: 100% !important;
    margin: 10px 0 12px !important;
  }
}


</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="brand">
        <img class="topLogo" id="topLogo" src="dexguard.png" alt="DexGuard" loading="eager" decoding="async" />
      </div>

      <div class="actions">
        <div class="pillRow" id="netPills"></div>
        <a class="btn ghost" id="btnBack" href="/">Back to Main</a>
        <a class="btn xbtn" id="btnX" href="https://www.x.com/solana_x1" target="_blank" rel="noreferrer" aria-label="Twitter/X">
          <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true" focusable="false" style="display:block">
            <path fill="currentColor" d="M18.9 2H22l-6.8 7.8L23 22h-6.2l-4.8-7.1L5.8 22H2l7.4-8.5L1 2h6.3l4.3 6.4L18.9 2Zm-1.1 18h1.7L6.2 3.9H4.4L17.8 20Z"/>
          </svg>
          <span>Twitter/X</span>
        </a>
        <a class="btn primary" id="btnBuy" href="#" target="_blank" rel="noreferrer">Buy</a>
      </div>
    </div>
    <div class="panel">
      <!-- TOP TRENDING BAR + SEARCH (MATCH MAIN PAGE) -->
      <div class="topBar" id="topBar">
        <div class="topBarInner">
          <div class="topRow">
            <div class="hotBlock" aria-label="Hot trending live">
              <div class="hotLabel" title="Live trending"><span class="hotFire">ðŸ”¥</span><span>LIVE TRENDING</span></div>
              <div id="status" style="display:none">Bootingâ€¦</div>
              <div id="clock" style="display:none"></div>
            </div>

            <div class="chainToggle" id="trendToggle" aria-label="Trending chain">
              <button class="chainBtn active" data-net="solana" type="button">SOL</button>
              <button class="chainBtn" data-net="eth" type="button">ETH</button>
              <button class="chainBtn" data-net="bsc" type="button">BNB</button>
              <button class="chainBtn" data-net="base" type="button">BASE</button>
            </div>
          </div>

          <div class="bottomRow">
            <div class="tickerWrap" aria-label="Trending tokens">
              <div class="tickerTrack" id="tickerTrack">
                <span class="tickerItem" style="opacity:.75"><span class="rank">â€¦</span><span class="tickerLogoWrap"><span class="tickerLogoFallback">â€¢</span></span><span class="sym">Trending</span></span>
                <span class="tickerItem" style="opacity:.75"><span class="rank">â€¦</span><span class="tickerLogoWrap"><span class="tickerLogoFallback">â€¢</span></span><span class="sym">Trending</span></span>
                <span class="tickerItem" style="opacity:.75"><span class="rank">â€¦</span><span class="tickerLogoWrap"><span class="tickerLogoFallback">â€¢</span></span><span class="sym">Trending</span></span>
                <span class="tickerItem" style="opacity:.75"><span class="rank">â€¦</span><span class="tickerLogoWrap"><span class="tickerLogoFallback">â€¢</span></span><span class="sym">Trending</span></span>
              </div>
            </div>

            <div class="dexSearch" role="search" aria-label="Search token by name or contract">
              <div class="dexSearchInner">
                <input class="dexInput" id="q" placeholder="Search token / paste contractâ€¦" autocomplete="off" spellcheck="false" />
                <div class="hint" id="modeHint">auto</div>
                <button class="btn" id="btnGo" type="button">Open</button>
              </div>
              <div class="results" id="results"></div>
              <div id="searchScrim" class="searchScrim" aria-hidden="true"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="grid">
        <div class="card" id="chartCard">
          <div class="cardHd">
            <div class="pair">
              <div class="tlogo" id="tokenLogo"><span class="fb" id="tokenLogoFb">$</span></div>
              <div class="pairTxt">
                <div class="pairName" id="pairName">â€”</div>
                <div class="pairMeta" id="pairMeta">Paste a token / choose a trending token</div>
              </div>
            </div>
            <div class="stats" id="stats"></div>
          </div>

          <div id="chartWrap"><div id="chart"></div></div>

          <div class="controls">
            <div class="tfRow" id="tfRow"></div>
            <div class="rightCtl">
              <button class="btn" id="btnFit" type="button">Fit</button>
              <button class="btn" id="btnRefresh" type="button">Refresh</button>
              <select class="sel" id="poolSel" title="Pool"></select>
            </div>
          </div>

          <div class="mobileTabs">
            <div class="tabBar">
              <button class="tab active" id="tabChart" type="button">Chart</button>
              <button class="tab" id="tabTrades" type="button">Trades</button>
            </div>
          </div>
        </div>

        <div class="card desktopOnly" id="tradesCard">
          <div class="tableHd" role="button" aria-label="Toggle Live Trades" aria-expanded="false">
            <div>
              <div class="ttl">Live Trades</div>
              <div class="sub" id="tradesSub">Buys / Sells (live)</div>
            </div>
            <div class="sheetRight">
              <div class="sub" id="tradesStat">â€”</div>
            </div>
          </div>

          <div class="trades" id="trades">
            <div class="tradeHead">
              <div class="col age">Age</div>
              <div class="col type">Type</div>
              <div class="col usd">USD</div>
              <div class="col amt">Amount</div>
              <div class="col price hideM">Price</div>
              <div class="col maker hideM">Maker</div>
              <div class="col links"></div>
            </div>
          </div>
        </div>
      </div>

      <div class="grid mobileTabs" id="mobileTradesWrap" style="display:none; padding-top:0">
        <div class="card" style="grid-column:1/-1">
          <div class="tableHd">
            <div>
              <div class="ttl">Live Trades</div>
              <div class="sub" id="tradesSubM">Buys / Sells (live)</div>
            </div>
            <div class="sub" id="tradesStatM">â€”</div>
          </div>
          <div class="trades" id="tradesM">
            <div class="tradeHead">
              <div class="col age">Age</div>
              <div class="col type">Type</div>
              <div class="col usd">USD</div>
              <div class="col amt">Amount</div>
              <div class="col price hideM">Price</div>
              <div class="col maker hideM">Maker</div>
              <div class="col links"></div>
            </div>
          </div>
        </div>
      </div>

    </div>

    <div class="toast" id="toast"></div>
  </div>

  <script src="https://unpkg.com/lightweight-charts@4.2.1/dist/lightweight-charts.standalone.production.js"></script>
  <script>
  (function(){
    // =========================================================
    //  $SOS DEX Terminal â€” from scratch
    //  Data sources:
    //   - Token discovery: DexScreener public API (search + token pairs)
    //   - OHLCV + trades: GeckoTerminal API (pools)
    //  No embeds. No third-party iframes.
    // =========================================================

    // -------------------- Constants
    const GECKO = 'https://api.geckoterminal.com/api/v2';
    const DS = 'https://api.dexscreener.com/latest/dex';

    const NET_LABEL = { solana:'SOL', eth:'ETH', bsc:'BNB', base:'BASE' };
    const NET_DS = { solana:'solana', eth:'ethereum', bsc:'bsc', base:'base' };
    const NET_GECKO = { solana:'solana', eth:'eth', bsc:'bsc', base:'base' };
    // Native gas/settlement unit for each chain (display only)
    const NATIVE_UNIT = { solana:'SOL', eth:'ETH', bsc:'BNB', base:'ETH' };
    function nativeUnit(net){
      const n = String(net||'').toLowerCase();
      return NATIVE_UNIT[n] || (NET_LABEL[n] || 'ETH');
    }


    const DEFAULT_TOKEN = {
      solana: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', // USDC
      eth:    '0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48',  // USDC
      bsc:    '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d',  // USDC
      base:   '0x833589fCD6eDb6E08f4c7C32D4f71b54bda02913'   // USDC
    };

    const DEFAULT_MARKET_TOKEN = {
      solana: 'So11111111111111111111111111111111111111112', // wSOL
      eth:    '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2',   // WETH
      bsc:    '0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c',   // WBNB
      base:   '0x4200000000000000000000000000000000000006'    // WETH on Base
    };

    // Prefer stable quote pools for chart correctness
    const STABLE_QUOTES = {
      solana: ['EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'],
      eth: ['0xA0b86991c6218b36c1d19d4a2e9eb0ce3606eb48','0xdAC17F958D2ee523a2206206994597C13D831ec7'],
      bsc: ['0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d','0x55d398326f99059fF775485246999027B3197955'],
      base:['0x833589fCD6eDb6E08f4c7C32D4f71b54bda02913']
    };

    // Chart timeframes -> Gecko candle granularity
    const TF = [
      {k:'1m',  gecko:'minute',   agg:60,    live:true},
      {k:'5m',  gecko:'minute',   agg:300},
      {k:'15m', gecko:'minute',   agg:900},
      {k:'1h',  gecko:'hour',     agg:3600},
      {k:'4h',  gecko:'hour',     agg:14400},
      {k:'1w',  gecko:'day',      agg:604800},
      {k:'1d',  gecko:'day',      agg:86400},
      {k:'ALL', gecko:'day',      agg:86400}
    ];

    // -------------------- DOM
    const $ = (id)=>document.getElementById(id);
    const netPills = $('netPills');
    const statusEl = $('status');
    const clockEl = $('clock');
    const tickerTrack = $('tickerTrack');
    const q = $('q');
    const dexSearch = q?.closest?.('.dexSearch');
    const results = $('results');
    const searchScrim = $('searchScrim');
    const btnGo = $('btnGo');
    const modeHint = $('modeHint');

    const pairNameEl = $('pairName');
    const pairMetaEl = $('pairMeta');
    const statsEl = $('stats');
    const tokenLogo = $('tokenLogo');
    const tokenLogoFb = $('tokenLogoFb');

    const poolSel = $('poolSel');
    const tfRow = $('tfRow');
    const btnFit = $('btnFit');
    const btnRefresh = $('btnRefresh');

    const tradesDesk = $('trades');
    const tradesMob = $('tradesM');
    const tradesStat = $('tradesStat');
    const tradesStatM = $('tradesStatM');

    const btnBack = $('btnBack');
    const btnBuy = $('btnBuy');

    const topDexguardBtn = $('topDexguardBtn');

    const tabChart = $('tabChart');
    const tabTrades = $('tabTrades');
    const mobileTradesWrap = $('mobileTradesWrap');
    const chartCard = $('chartCard');
    const tradesCard = $('tradesCard');

    const toastEl = $('toast');

    // -------------------- Helpers
    const sleep = (ms)=>new Promise(r=>setTimeout(r, ms));
    const lc = (v)=>String(v||'').toLowerCase();

    function toast(msg, ms=2200){
      toastEl.textContent = msg;
      toastEl.style.display='block';
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=>toastEl.style.display='none', ms);
    }

    function esc(s){
      return String(s??'').replace(/[&<>"]/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[m]));
    }

    function shortAddr(a){
      a = String(a||'');
      if(a.length<=14) return a;
      return a.slice(0,6)+'â€¦'+a.slice(-4);
    }

    function num(v){
      const n = Number(v);
      return Number.isFinite(n) ? n : NaN;
    }

    function formatCompact(n){
      n = Number(n);
      if(!Number.isFinite(n)) return 'â€”';
      const abs = Math.abs(n);
      const s = (x)=> (Math.round(x*100)/100).toString();
      if(abs>=1e12) return s(n/1e12)+'T';
      if(abs>=1e9)  return s(n/1e9)+'B';
      if(abs>=1e6)  return s(n/1e6)+'M';
      if(abs>=1e3)  return s(n/1e3)+'K';
      if(abs>=1)    return (Math.round(n*10000)/10000).toString();
      return n.toPrecision(3);
    }

    function formatPrice(v){
      v = Number(v);
      if(!Number.isFinite(v)) return 'â€”';
      if(v===0) return '0';
      if(v>=1) return v.toFixed(6).replace(/0+$/,'').replace(/\.$/,'');
      // small price
      const s = v.toPrecision(6);
      return s;
    }

    function nowClock(){
      const d = new Date();
      clockEl.textContent = d.toLocaleString(undefined, {hour:'2-digit', minute:'2-digit', second:'2-digit'});
    }

    // fetch with timeout + retry + CORS fallback via allorigins
    async function fetchJson(url, {timeout=12000, retries=1}={}){
      const proxy = (u)=>'https://api.allorigins.win/raw?url=' + encodeURIComponent(u);
      let lastErr=null;
      for(let i=0;i<=retries;i++){
        const ctl = new AbortController();
        const t = setTimeout(()=>ctl.abort(), timeout);
        try{
          const r = await fetch(url, {
            headers:{'accept':'application/json'},
            signal: ctl.signal,
            cache: 'no-store'
          });
          clearTimeout(t);
          if(!r.ok) throw new Error('HTTP '+r.status);
          return await r.json();
        }catch(e){
          clearTimeout(t);
          lastErr=e;
          // try proxy for CORS / network error
          try{
            const msg = String(e&&e.message||e||'');
            const isCors = (e instanceof TypeError) || /Failed to fetch|NetworkError|CORS/i.test(msg);
            if(isCors){
              const r2 = await fetch(proxy(url), {cache:'no-store'});
              if(r2.ok){
                const txt = await r2.text();
                return JSON.parse(txt);
              }
            }
          }catch(_){ }
          if(i<retries) await sleep(250*(i+1));
        }
      }
      throw lastErr || new Error('Network');
    }

    function normalizeChain(x){
      x = lc(x);
      if(x==='sol' || x==='solana') return 'solana';
      if(x==='eth' || x==='ethereum') return 'eth';
      if(x==='bnb' || x==='bsc') return 'bsc';
      if(x==='base') return 'base';
      return 'solana';
    }

    function isEvmAddr(s){
      return /^0x[a-fA-F0-9]{40}$/.test(String(s||'').trim());
    }

    function isSolAddr(s){
      // best-effort base58 length
      s = String(s||'').trim();
      return s.length>=32 && s.length<=50 && /^[1-9A-HJ-NP-Za-km-z]+$/.test(s);
    }

    // robust pool address extraction from gecko pool object
    function poolAddressFromPool(p){
      const a = p?.attributes || {};
      if(a.address) return String(a.address);
      const id = String(p?.id||'');
      // examples:
      //  - "solana_..._POOL"
      //  - "ethereum:0xPOOL"
      //  - "bsc/0xPOOL"
      const last = id.split('_').pop();
      const last2 = last.split(':').pop();
      const last3 = last2.split('/').pop();
      return last3;
    }

    function tokenIdToAddr(id){
      id = String(id||'').trim();
      if(!id) return '';
      // Gecko often uses ids like 'solana_<addr>' or 'ethereum_<addr>'
      if(id.includes('_')) return id.split('_').pop();
      if(id.includes(':')) return id.split(':').pop();
      if(id.includes('/')) return id.split('/').pop();
      return id;
    }

    function tokenAddrFromPool(p, which){
      const a = p?.attributes || {};
      let v = a[`${which}_token_address`] || a[`${which}_token_id`] || '';
      if(!v){
        const rel = p?.relationships?.[`${which}_token`]?.data?.id || '';
        v = rel;
      }
      return tokenIdToAddr(v);
    }

    function tokenSymFromPool(p, which){
      const a = p?.attributes || {};
      const k = `${which}_token_symbol`;
      const sym = a[k] || a[`${which}_symbol`] || '';
      return String(sym||'').replace(/\s+/g,'').slice(0,12);
    }

    function tokenImgFromPool(p, which){
      const a = p?.attributes || {};
      // Some responses include image urls per token
      const direct = a[`${which}_token_image_url`] || a[`${which}_token_logo`] || '';
      if(direct) return String(direct);
      // Best-effort fallback: sometimes nested token object is present (not always)
      const nested = a?.[`${which}_token`]?.data?.attributes?.image_url || a?.[`${which}_token`]?.data?.attributes?.imageUrl || '';
      return String(nested||'');
    }

    function tokenPriceFromPool(p, which){
      const a = p?.attributes || {};
      const v = (which==='base') ? (a.base_token_price_usd || a.token_price_usd || a.price_usd) : (a.quote_token_price_usd || a.quote_price_usd);
      const n = Number(v);
      return Number.isFinite(n) ? n : NaN;
    }

    function poolLiqUsd(p){
      const a = p?.attributes || {};
      const v = num(a.reserve_in_usd || a.liquidity_in_usd || a.liquidity_usd || a.reserveUsd);
      return Number.isFinite(v) ? v : 0;
    }

    function poolCreatedMs(p){
      const a = p?.attributes || {};
      const t = Date.parse(a.pool_created_at || a.created_at || a.createdAt || a.creation_time || '');
      return Number.isFinite(t) ? t : NaN;
    }

    function fmtAge(ms){
      if(!Number.isFinite(ms)) return 'â€”';
      const d = Math.max(0, Date.now()-ms);
      const s = Math.floor(d/1000);
      if(s<60) return s+'s';
      const m = Math.floor(s/60);
      if(m<60) return m+'m';
      const h = Math.floor(m/60);
      if(h<24) return h+'h';
      const days = Math.floor(h/24);
      return days+'d';
    }

    function explorerTx(net, sig){
      net = normalizeChain(net);
      if(net==='solana') return 'https://solscan.io/tx/'+sig;
      if(net==='eth') return 'https://etherscan.io/tx/'+sig;
      if(net==='bsc') return 'https://bscscan.com/tx/'+sig;
      if(net==='base') return 'https://basescan.org/tx/'+sig;
      return '#';
    }

    function explorerAddr(net, a){
      net = normalizeChain(net);
      if(net==='solana') return 'https://solscan.io/account/'+a;
      if(net==='eth') return 'https://etherscan.io/address/'+a;
      if(net==='bsc') return 'https://bscscan.com/address/'+a;
      if(net==='base') return 'https://basescan.org/address/'+a;
      return '#';
    }

    // Buy link (best-effort) â€” can be replaced later per your preference
    function buildBuyUrl(net, tokenAddr){
      net = normalizeChain(net);
      if(net==='solana') return 'https://jup.ag/swap/SOL-' + encodeURIComponent(tokenAddr);
      if(net==='eth') return 'https://app.uniswap.org/#/swap?outputCurrency=' + encodeURIComponent(tokenAddr);
      if(net==='bsc') return 'https://pancakeswap.finance/swap?outputCurrency=' + encodeURIComponent(tokenAddr);
      if(net==='base') return 'https://app.uniswap.org/#/swap?chain=base&outputCurrency=' + encodeURIComponent(tokenAddr);
      return '#';
    }

    // -------------------- State
    const qs = new URLSearchParams(location.search);
    let activeNet = normalizeChain(qs.get('chain') || 'solana');
    let addr = String(qs.get('addr')||'').trim();

    let activeTF = TF.find(x=>x.k==='15m') || TF[0];
    let poolChoices = [];
    let poolId = '';
    let poolAddr = '';
    let tokenSide = 'base';
        let curTokenSymbol = 'TOKEN';
    let curQuoteSymbol = '';
    let curTokenName = '';
    let curTokenImage = '';
    let curTokenAddr = '';
let seenMakers = new Set();
    let tradesSeen = new Set();

    let pollTradesTimer = null;
    let pollMetaTimer = null;
    let pollCandleTimer = null;
    let trendingTimer = null;
    let ageTimer = null;

    // -------------------- Chart
    const chartEl = $('chart');
    const chart = LightweightCharts.createChart(chartEl, {
      width: chartEl.clientWidth || 800,
      height: chartEl.clientHeight || 520,
      layout: { background: { type:'solid', color:'rgba(0,0,0,0)' }, textColor:'rgba(255,255,255,.86)' },
      grid: { vertLines:{color:'rgba(255,255,255,.06)'}, horzLines:{color:'rgba(255,255,255,.06)'} },
      rightPriceScale: { borderColor:'rgba(255,255,255,.12)' },
      timeScale: { borderColor:'rgba(255,255,255,.12)', timeVisible:true, secondsVisible:false },
      crosshair: { mode: 1 },
      handleScroll: { mouseWheel:true, pressedMouseMove:true, horzTouchDrag:true, vertTouchDrag:true },
      handleScale: { axisPressedMouseMove:true, mouseWheel:true, pinch:true },
    });

    const candleSeries = chart.addCandlestickSeries({
      upColor: 'rgba(20,241,149,.95)',
      downColor:'rgba(255,77,109,.95)',
      wickUpColor:'rgba(20,241,149,.95)',
      wickDownColor:'rgba(255,77,109,.95)',
      borderVisible:false,
      autoscaleInfoProvider: (original) => {
        const res = original();
        try{
          const pr = res && res.priceRange;
          if(pr && Number.isFinite(pr.minValue) && Number.isFinite(pr.maxValue)){
            const min = pr.minValue;
            const max = pr.maxValue;
            const span = (max - min) || Math.max(Math.abs(max), Math.abs(min), 1);
            const pad = span * 0.04;
            return { ...res, priceRange: { minValue: min - pad, maxValue: max + pad } };
          }
        }catch(_){ }
        return res;
      },
      priceFormat:{ type:'price', precision: 10, minMove: 1e-10 }
    });

    const volumeSeries = chart.addHistogramSeries({
      priceFormat: { type:'volume' },
      priceScaleId: '',
      lastValueVisible:false,
      base:0,
    });
    chart.priceScale('').applyOptions({ scaleMargins:{ top:0.84, bottom:0 } });

    const ro = new ResizeObserver(()=>{
      chart.applyOptions({ width: chartEl.clientWidth, height: chartEl.clientHeight });
    });
    ro.observe(chartEl);

    /* Fit button removed (auto-fit handled) */

    // -------------------- UI boot
    function renderNetPills(){
      netPills.innerHTML='';
      const nets=[{k:'solana',label:'SOL'},{k:'eth',label:'ETH'},{k:'bsc',label:'BNB'},{k:'base',label:'BASE'}];
      nets.forEach(n=>{
        const b=document.createElement('div');
        b.className='pill'+(activeNet===n.k?' active':'');
        b.innerHTML = `<span class="dot"></span>${esc(n.label)}`;
        b.onclick=()=>{
          activeNet=n.k;
          renderNetPills();
          toast('Chain: '+n.label);
          // keep current addr if it matches chain type; otherwise default
          if(!addr || (activeNet==='solana' ? !isSolAddr(addr) : !isEvmAddr(addr))){ addr = DEFAULT_MARKET_TOKEN[activeNet]; }
          navigate(activeNet, addr);
        };
        netPills.appendChild(b);
      });
    }

    function renderTimeframes(){
      tfRow.innerHTML='';
      TF.forEach(t=>{
        const b=document.createElement('button');
        b.className='tf'+(t.k===activeTF.k?' active':'');
        b.textContent=t.k;
        b.onclick=()=>{
          activeTF=t;
          [...tfRow.children].forEach(x=>x.classList.toggle('active', x.textContent===t.k));
          if(poolAddr){
            try{ if(typeof stopLiveLoops==='function') stopLiveLoops(); }catch(_){ }
            loadCandles(true);
            loadTrades(true);
            startLiveLoops();
          }
        };
        tfRow.appendChild(b);
      });
    }

    
    function setActiveTFKey(key){
      const t = TF.find(x=>x.k===key) || TF.find(x=>x.k==='15m') || TF[0];
      activeTF = t;
      if(tfRow && tfRow.children && tfRow.children.length){
        [...tfRow.children].forEach(x=>x.classList.toggle('active', x.textContent===t.k));
      }
      return t;
    }
function setMobileTab(which){
      if(!tabChart || !tabTrades) return;
      const isTrades = which==='trades';
      tabChart.classList.toggle('active', !isTrades);
      tabTrades.classList.toggle('active', isTrades);
      mobileTradesWrap.style.display = isTrades ? 'block' : 'none';
      chartCard.style.display = isTrades ? 'none' : 'block';
    }

    if(tabChart && tabTrades){
      tabChart.onclick=()=>setMobileTab('chart');
      tabTrades.onclick=()=>setMobileTab('trades');
    }



    // Top-left Dexguard button -> jump to trending bar
    if(topDexguardBtn){
      topDexguardBtn.onclick = ()=>{
        const tb = document.getElementById('topBar');
        if(tb) tb.scrollIntoView({behavior:'smooth', block:'start'});
      };
    }
    /* Refresh button removed (auto updates) */
// -------------------- Search
    let searchTimer=null;
    let searchReq=0;

    function showResults(html){
      results.innerHTML = html;
      const open = !!html;
      results.style.display = open ? 'block' : 'none';
      if(searchScrim) searchScrim.style.display = open ? 'block' : 'none';
      if(dexSearch) dexSearch.classList.toggle('open', open);
    }

    function hideResults(){
      results.style.display = 'none';
      if(searchScrim) searchScrim.style.display = 'none';
      if(dexSearch) dexSearch.classList.remove('open');
    }

    if(searchScrim){
      searchScrim.addEventListener('click', hideResults);
    }

    async function dsSearch(query){
      // DexScreener search is used ONLY for discovery. We do not embed anything.
      const url = DS + '/search/?q=' + encodeURIComponent(query);
      const j = await fetchJson(url, {timeout:12000, retries:1});
      return Array.isArray(j?.pairs) ? j.pairs : [];
    }

    async function dsTokenPairsV1(net, tokenAddr){
      const chain = NET_DS[normalizeChain(net)] || 'solana';
      const url = `https://api.dexscreener.com/token-pairs/v1/${chain}/${encodeURIComponent(tokenAddr)}`;
      try{
        const j = await fetchJson(url, {timeout:14000, retries:1});
        return Array.isArray(j) ? j : [];
      }catch(_){
        return [];
      }
    }

    function bestPairAnyNet(pairs){
      const list = (pairs||[]).slice();
      if(!list.length) return null;
      list.sort((a,b)=>{
        const la = Number(a?.liquidity?.usd||0);
        const lb = Number(b?.liquidity?.usd||0);
        if(lb!==la) return lb-la;
        const va = Number(a?.volume?.h24||0);
        const vb = Number(b?.volume?.h24||0);
        return vb-va;
      });
      return list[0];
    }

    function bestPairForNet(pairs, net){
      const want = NET_DS[normalizeChain(net)];
      const list = (pairs||[]).filter(p=>lc(p?.chainId)===want);
      if(!list.length) return null;
      list.sort((a,b)=>{
        const la = Number(a?.liquidity?.usd||0);
        const lb = Number(b?.liquidity?.usd||0);
        if(lb!==la) return lb-la;
        const va = Number(a?.volume?.h24||0);
        const vb = Number(b?.volume?.h24||0);
        return vb-va;
      });
      return list[0];
    }


    function dsExtractTokenMeta(pair, tokenAddr){
      const tAddr = lc(tokenAddr||'');
      const base = pair?.baseToken || {};
      const quote = pair?.quoteToken || {};
      const baseAddr = lc(base?.address||'');
      const quoteAddr = lc(quote?.address||'');
      const isQuote = !!tAddr && !!quoteAddr && tAddr===quoteAddr;
      const tok = isQuote ? quote : base;
      const oth = isQuote ? base : quote;

      const sym = String(tok?.symbol||'TOKEN').replace(/\s+/g,'').slice(0,12) || 'TOKEN';
      const name = String(tok?.name||'').trim();
      const quoteSym = String(oth?.symbol||'').replace(/\s+/g,'').slice(0,12);

      const img = String(
        pair?.info?.imageUrl || pair?.info?.image_url ||
        pair?.imageUrl || pair?.image_url ||
        tok?.logoURI || tok?.logoUrl || tok?.logo_url || tok?.icon || tok?.image ||
        ''
      ).trim();

      return { symbol: sym, name, quoteSymbol: quoteSym, image: img };
    }


    function netFromDsChainId(chainId){
      const c = lc(chainId);
      if(c==='solana') return 'solana';
      if(c==='ethereum') return 'eth';
      if(c==='bsc') return 'bsc';
      if(c==='base') return 'base';
      return null;
    }

    function bestPairAnyNet(pairs){
      const list = (pairs||[]).filter(p=>netFromDsChainId(p?.chainId));
      if(!list.length) return null;
      list.sort((a,b)=>{
        const la = Number(a?.liquidity?.usd||0);
        const lb = Number(b?.liquidity?.usd||0);
        if(lb!==la) return lb-la;
        const va = Number(a?.volume?.h24||0);
        const vb = Number(b?.volume?.h24||0);
        return vb-va;
      });
      return list[0];
    }

    function renderSearchResults(pairs){
      const best = bestPairForNet(pairs, activeNet);
      // show top 12 for chain
      const want = NET_DS[activeNet];
      const list = (pairs||[]).filter(p=>lc(p?.chainId)===want).slice(0, 12);
      if(!list.length){
        showResults(`<div style="padding:12px; color:rgba(255,255,255,.75)">No results on ${esc(NET_LABEL[activeNet])}. Try another chain.</div>`);
        return;
      }
      const html = list.map(p=>{
        const base = p?.baseToken || {};
        const sym = String(base.symbol || base.name || 'TOKEN');
        const name = String(base.name || sym);
        const addr = String(base.address || '');
        const img = p?.info?.imageUrl || p?.info?.image_url || '';
        const pct = num(p?.priceChange?.h24);
        const mc = num(p?.marketCap || p?.fdv);
        const pctTxt = Number.isFinite(pct) ? (pct>0?'+':'')+pct.toFixed(2)+'%' : 'â€”';
        const pctClass = Number.isFinite(pct) ? (pct>0?'up':(pct<0?'down':'')) : '';
        const logo = img ? `<img src="${esc(img)}" referrerpolicy="no-referrer" onerror="this.remove();"/>` : `<span class="fb">${esc(sym.slice(0,1).toUpperCase())}</span>`;
        return `
          <div class="resItem" data-addr="${esc(addr)}" data-name="${esc(sym)}">
            <div class="resL">
              <div class="resLogo">${logo}</div>
              <div class="resTxt">
                <div class="resName">$${esc(sym)} <span style="opacity:.65">(${esc(name)})</span></div>
                <div class="resMeta">${esc(NET_LABEL[activeNet])} â€¢ ${esc(shortAddr(addr))} â€¢ Liq $${esc(formatCompact(p?.liquidity?.usd))}</div>
              </div>
            </div>
            <div class="resR">
              <span class="statPill ${pctClass}">24h ${esc(pctTxt)}</span>
              <span class="statPill">MCap ${esc(formatCompact(mc))}</span>
            </div>
          </div>
        `;
      }).join('');
      showResults(html);

      // click bind
      [...results.querySelectorAll('.resItem')].forEach(el=>{
        el.onclick=()=>{
          const a = el.getAttribute('data-addr')||'';
          hideResults();
          q.value = a;
          openToken(a);
        };
      });
    }

    q.addEventListener('input', ()=>{
      clearTimeout(searchTimer);
      const v = q.value.trim();

      // mode hint
      if(isEvmAddr(v)) modeHint.textContent = 'EVM';
      else if(isSolAddr(v)) modeHint.textContent = 'SOL';
      else modeHint.textContent = 'auto';

      if(v.length<2){ hideResults(); return; }
      searchTimer = setTimeout(async ()=>{
        const id = ++searchReq;
        try{
          const pairs = await dsSearch(v);
          if(id!==searchReq) return;
          renderSearchResults(pairs);
        }catch(e){
          if(id!==searchReq) return;
          showResults(`<div style="padding:12px; color:rgba(255,255,255,.75)">Search error. Try again.</div>`);
        }
      }, 220);
    });

    q.addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){
        e.preventDefault();
        hideResults();
        openToken(q.value.trim());
      }
    });

    document.addEventListener('click', (e)=>{
      if(!results.contains(e.target) && e.target!==q) hideResults();
    });

    btnGo.onclick=()=>openToken(q.value.trim());

    // -------------------- Gecko: pool selection
    function geckoNet(){ return NET_GECKO[activeNet]; }

    async function resolvePoolsFromGecko(tokenAddr){
      // /networks/{network}/tokens/{token}/pools?include=base_token,quote_token&page=1
      const url = `${GECKO}/networks/${encodeURIComponent(geckoNet())}/tokens/${encodeURIComponent(tokenAddr)}/pools?include=base_token,quote_token,dex&page=1`;
      const j = await fetchJson(url, {timeout:14000, retries:1});
      return Array.isArray(j?.data) ? j.data : [];
    }

    function chooseBestPool(pools, tokenAddr){
      const tok = lc(tokenAddr);
      const preferSet = new Set((STABLE_QUOTES[activeNet]||[]).map(lc));

      // rank pools
      const ranked = (pools||[]).map(p=>{
        const a = p?.attributes || {};
        const base = lc(tokenAddrFromPool(p,'base'));
        const quote = lc(tokenAddrFromPool(p,'quote'));
        const liq = poolLiqUsd(p);
        const created = poolCreatedMs(p);
        const isBase = base===tok;
        const isQuote = quote===tok;
        const stableQuote = isBase && preferSet.has(quote);
        const score =
          (stableQuote? 9e15 : 0) +
          (isBase? 7e15 : 0) +
          (isQuote? 4e15 : 0) +
          (Number.isFinite(liq)? liq*1e6 : 0) +
          (Number.isFinite(created)? created : 0);
        return {p, score, isBase, isQuote, liq};
      }).sort((a,b)=>b.score-a.score);

      return ranked[0]?.p || null;
    }

    function renderPoolSelect(pools){
      poolSel.innerHTML='';
      const opts = pools.slice(0, 25).map((p,i)=>{
        const a = p?.attributes || {};
        const dex = String(a.dex_name || a.dex || 'DEX');
        const name = String(a.name || a.pool_name || '').trim();
        const liq = poolLiqUsd(p);
        const age = fmtAge(poolCreatedMs(p));
        const label = `${dex} â€¢ ${name?name:shortAddr(poolAddressFromPool(p))} â€¢ Liq $${formatCompact(liq)} â€¢ ${age}`;
        const id = String(p?.id||'');
        return `<option value="${esc(id)}">${esc(label)}</option>`;
      }).join('');
      poolSel.innerHTML = opts;
      poolSel.style.display = opts ? 'inline-flex' : 'none';
      poolSel.disabled = !opts;

      poolSel.onchange = ()=>{
        const id = poolSel.value;
        const picked = pools.find(x=>String(x?.id||'')===id);
        if(picked){
          applyPool(picked);
          loadCandles(true);
          loadTrades(true);
          loadMeta(true);
        }
      };
    }

    function applyTokenHeader(meta){
      const symIn = String(meta?.symbol||'').trim();
      const nameIn = String(meta?.name||'').trim();
      const quoteIn = String(meta?.quoteSymbol||'').trim();
      const imgIn = String(meta?.image||'').trim();

      const sym = (symIn && symIn.toUpperCase()!=='TOKEN')
        ? symIn
        : ((curTokenSymbol && curTokenSymbol.toUpperCase()!=='TOKEN') ? curTokenSymbol : (symIn||'TOKEN'));

      const quote = quoteIn || curQuoteSymbol || '';
      const name = nameIn || curTokenName || '';
      const img  = imgIn  || curTokenImage || '';

      curTokenSymbol = sym || 'TOKEN';
      curQuoteSymbol = quote || '';
      if(name) curTokenName = name;
      if(imgIn) curTokenImage = imgIn;

      const title = `$${sym}/${nativeUnit(activeNet)}`;
      const nameHtml = (name && name.toLowerCase()!==sym.toLowerCase())
        ? `<span class="pairNameSub">${esc(name)}</span>` : '';
      pairNameEl.innerHTML = `${esc(title)}${nameHtml ? ' ' + nameHtml : ''}`;
      pairMetaEl.textContent = `${NET_LABEL[activeNet]} â€¢ ${shortAddr(addr)} â€¢ Native chart + live trades`;

      if(img){
        tokenLogo.innerHTML = `<img src="${esc(img)}" alt="" referrerpolicy="no-referrer" onerror="this.onerror=null; this.remove(); var p=this.parentNode; if(p){p.innerHTML='<span class=\\"fb\\">${esc(sym.slice(0,1).toUpperCase())}</span>';}" />`;
      }else{
        tokenLogo.innerHTML = `<span class="fb">${esc(sym.slice(0,1).toUpperCase())}</span>`;
      }
    }

    function applyStats(st){
      const pills=[];
      if(Number.isFinite(st.price)) pills.push(`<span class="statPill">Price $${esc(formatPrice(st.price))}</span>`);
      if(Number.isFinite(st.liq)) pills.push(`<span class="statPill">Liq $${esc(formatCompact(st.liq))}</span>`);
      if(Number.isFinite(st.mcap)) pills.push(`<span class="statPill">MCap $${esc(formatCompact(st.mcap))}</span>`);
      if(Number.isFinite(st.h24)) pills.push(`<span class="statPill ${st.h24>0?'up':(st.h24<0?'down':'')}">24h ${esc((st.h24>0?'+':'')+st.h24.toFixed(2)+'%')}</span>`);
      statsEl.innerHTML = pills.join('') || `<span class="statPill">â€”</span>`;
    }

    function applyPool(p){
      const a = p?.attributes || {};
      poolId = String(p?.id||'');
      poolAddr = poolAddressFromPool(p);

      // Determine side: if token matches base -> buys are quote->base? We use Gecko trade_type.
      const base = lc(tokenAddrFromPool(p,'base'));
      const quote = lc(tokenAddrFromPool(p,'quote'));
      tokenSide = (base===lc(addr)) ? 'base' : ((quote===lc(addr)) ? 'quote' : 'base');

      // Meta (pick correct token side)
      const baseSym = tokenSymFromPool(p,'base') || 'TOKEN';
      const quoteSym = tokenSymFromPool(p,'quote') || '';
      const sym = tokenSide==='base' ? baseSym : (quoteSym || baseSym || 'TOKEN');
      const quoteShown = tokenSide==='base' ? quoteSym : baseSym;
      const img = tokenSide==='base' ? tokenImgFromPool(p,'base') : tokenImgFromPool(p,'quote');
      const symFinal = (sym && sym.toUpperCase()!=='TOKEN') ? sym : (curTokenSymbol||'TOKEN');
      const imgFinal = img || curTokenImage || '';
      const nameFinal = curTokenName || '';
      const quoteFinal = quoteShown || curQuoteSymbol || '';
      applyTokenHeader({symbol: symFinal, name: nameFinal, quoteSymbol: quoteFinal, image: imgFinal});

      // initial stats best-effort (pick correct side price)
      const price = tokenSide==='base' ? tokenPriceFromPool(p,'base') : tokenPriceFromPool(p,'quote');
      const liq = num(a.reserve_in_usd || a.liquidity_in_usd || a.liquidity_usd);
      const mcap = num(a.market_cap_usd || a.fdv_usd);
      const h24 = num(a.price_change_percentage?.h24 || a.price_change_percentage_24h || a.price_change_24h);
      applyStats({price, liq, mcap, h24});

      btnBuy.href = buildBuyUrl(activeNet, addr);
    }

    // -------------------- Candles
    let rawCandles=[];

    // Candles paging + viewport normalization
    const CANDLE_LIMIT = 1000;
    const candlePager = { loading:false, hasMore:true, before:null, key:'' };
    let _pagingAttached = false;

    function desiredViewportBars(){
      const k = activeTF?.k || '15m';
      if(k==='1m') return 320;
      if(k==='5m') return 300;
      if(k==='15m') return 260;
      if(k==='1h') return 240;
      if(k==='4h') return 220;
      if(k==='1d') return 200;
      if(k==='1w') return 180;
      if(k==='ALL') return 260;
      return 260;
    }

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function syncBarSpacing(){
      try{
        const r = chart.timeScale().getVisibleLogicalRange();
        const bars = r ? Math.max(10, Math.round(r.to - r.from)) : desiredViewportBars();
        const w = Math.max(320, chartEl.clientWidth || 800);
        const spacing = clamp(w / (bars * 1.15), 3.5, 18);
        chart.timeScale().applyOptions({ barSpacing: spacing });
      }catch(_){}
    }

    function applyDefaultViewport(){
      try{
        const total = (rawCandles||[]).length;
        if(!total){ return; }
        const bars = desiredViewportBars();
        const from = Math.max(0, total - bars);
        const to = Math.max(0, total - 1);
        chart.timeScale().setVisibleLogicalRange({from, to});
        chart.timeScale().applyOptions({ rightOffset: 6 });
        syncBarSpacing();
      }catch(_){}
    }

    function attachPaging(){
      if(_pagingAttached) return;
      _pagingAttached = true;

      chart.timeScale().subscribeVisibleLogicalRangeChange((range)=>{
        if(!range) return;
        if(!poolAddr) return;
        if(candlePager.loading || !candlePager.hasMore) return;
        if(range.from < 30){
          loadOlderCandles();
        }
      });

      // keep candle spacing stable on resize
      const _ro2 = new ResizeObserver(()=>{ try{ syncBarSpacing(); }catch(_){} });
      _ro2.observe(chartEl);
    }


    function geckoCandlesUrl(gran, before){
      // /networks/{network}/pools/{pool}/ohlcv/{timeframe}?aggregate=...&before_timestamp=...&limit=1000&currency=usd
      const agg = (activeTF.k==='ALL' ? 1 : Math.max(1, Math.floor(activeTF.agg / (gran==='minute'?60:(gran==='hour'?3600:86400)) )));
      const params = new URLSearchParams();
      params.set('aggregate', String(agg));
      params.set('limit', '1000');
      params.set('currency','usd');
      if(before) params.set('before_timestamp', String(before));
      return `${GECKO}/networks/${encodeURIComponent(geckoNet())}/pools/${encodeURIComponent(poolAddr)}/ohlcv/${encodeURIComponent(gran)}?`+params.toString();
    }

    function mapGeckoOhlcv(j){
      const list = j?.data?.attributes?.ohlcv_list;
      if(!Array.isArray(list)) return [];
      const cleanNum = (v)=>{
        if(v==null) return NaN;
        if(typeof v==='string') v = v.replace(/,/g,'').trim();
        const n = Number(v);
        return Number.isFinite(n) ? n : NaN;
      };
      const out = [];
      for(const r of list){
        if(!r || r.length<5) continue;
        const ts = cleanNum(r[0]) || 0;
        const time = ts>1e12 ? Math.floor(ts/1000) : Math.floor(ts);
        const open = cleanNum(r[1]);
        const high0 = cleanNum(r[2]);
        const low0  = cleanNum(r[3]);
        const close= cleanNum(r[4]);
        const volume = cleanNum(r[5]);
        if(!(time>0) || !Number.isFinite(open) || !Number.isFinite(close) || !Number.isFinite(high0) || !Number.isFinite(low0)) continue;
        const high = Math.max(high0, open, close);
        const low  = Math.min(low0, open, close);
        out.push({time, open, high, low, close, volume: Number.isFinite(volume)?volume:0});
      }
      return out;
    }

    function applyCandlesToChart(fit){
      // Ensure strictly ascending + unique by time
      const map = new Map();
      for(const c of (rawCandles||[])){
        if(!c || !(c.time>0)) continue;
        map.set(c.time, c);
      }
      rawCandles = Array.from(map.values()).sort((a,b)=>a.time-b.time);
      const src = rawCandles;

      candleSeries.setData(src.map(c=>({time:c.time, open:c.open, high:c.high, low:c.low, close:c.close})));
      volumeSeries.setData(src.map(c=>({time:c.time, value:c.volume||0, color:(c.close>=c.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'})));

      if(fit){
        applyDefaultViewport();
      }else{
        // keep bar spacing reasonable even during live updates
        syncBarSpacing();
      }
    }

    function applyTradeToCandles(tr){
      if(!rawCandles || !rawCandles.length) return;
      if(!Number.isFinite(tr?.price)) return;
      if(!Number.isFinite(tr?.tsMs)) return;

      const tsSec = Math.floor(tr.tsMs/1000);
      const bucket = Math.floor(tsSec / activeTF.agg) * activeTF.agg;

      const last = rawCandles[rawCandles.length-1];
      const usdVol = Number.isFinite(tr.usd) ? tr.usd : 0;

      if(bucket < last.time - activeTF.agg*3){
        // too old for current visible timeframe; ignore
        return;
      }

      if(bucket === last.time){
        last.close = tr.price;
        if(tr.price > last.high) last.high = tr.price;
        if(tr.price < last.low) last.low = tr.price;
        if(usdVol) last.volume = (Number.isFinite(last.volume)?last.volume:0) + usdVol;
        candleSeries.update({time:last.time, open:last.open, high:last.high, low:last.low, close:last.close});
        volumeSeries.update({time:last.time, value:last.volume, color:(last.close>=last.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
        return;
      }

      if(bucket > last.time){
        const open = Number.isFinite(last.close) ? last.close : tr.price;
        const c = {
          time: bucket,
          open,
          high: Math.max(open, tr.price),
          low: Math.min(open, tr.price),
          close: tr.price,
          volume: usdVol
        };
        rawCandles.push(c);
        candleSeries.update({time:c.time, open:c.open, high:c.high, low:c.low, close:c.close});
        volumeSeries.update({time:c.time, value:c.volume, color:(c.close>=c.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
      }
    }

    async function refreshLatestCandles(){
      if(!poolAddr) return;
      const _key0 = `${activeNet}|${poolAddr}|${activeTF?.k||''}`;
      const _reqId = (refreshLatestCandles._reqId = (refreshLatestCandles._reqId||0) + 1);
      const _my = _reqId;
      try{
        const gran = activeTF.gecko;
        const url = geckoCandlesUrl(gran, null);
        const j = await fetchJson(url, {timeout:16000, retries:1});
        if(_my !== refreshLatestCandles._reqId) return;
        if(_key0 !== `${activeNet}|${poolAddr}|${activeTF?.k||''}`) return;
        const part = mapGeckoOhlcv(j);
        if(!part.length) return;
        part.sort((a,b)=>a.time-b.time);

        // Merge by time, keeping history
        const earliest = part[0].time;
        const keep = rawCandles.filter(c=>c.time < earliest);
        const map = new Map();
        for(const c of part) map.set(c.time, c);
        rawCandles = keep.concat(Array.from(map.values()).sort((a,b)=>a.time-b.time));

        applyCandlesToChart(false);
      }catch(e){
        // ignore
      }
    }


    async function loadCandles(fit){
      if(!poolAddr) return;
      attachPaging();

      statusEl.textContent = 'Loading chartâ€¦';
      candlePager.loading = true;
      candlePager.hasMore = true;
      candlePager.before = null;
      candlePager.key = `${activeNet}|${poolAddr}|${activeTF?.k||''}`;

      rawCandles=[];
      candleSeries.setData([]);
      volumeSeries.setData([]);

      try{
        const gran = activeTF.gecko;
        const needBars = desiredViewportBars();
        let pages = 0;
        let before = null;
        let all = [];

        while(pages++ < (activeTF.k==='ALL' ? 10 : 6)){
          const url = geckoCandlesUrl(gran, before);
          const j = await fetchJson(url, {timeout:18000, retries:1});
          let part = mapGeckoOhlcv(j);
          if(!part.length){
            candlePager.hasMore = false;
            break;
          }
          part.sort((a,b)=>a.time-b.time);

          // prepend
          all = part.concat(all);

          // continue paging older
          const oldest = part[0].time;
          before = oldest - 1;
          if(part.length < (CANDLE_LIMIT - 10)) { candlePager.hasMore = false; break; }

          // stop once we have enough data for a good-looking viewport + buffer
          if(all.length >= (needBars * 2)) break;
        }

        // dedupe + sort
        const map = new Map();
        for(const c of all){ map.set(c.time, c); }
        rawCandles = Array.from(map.values()).sort((a,b)=>a.time-b.time);

        if(!rawCandles.length){
          statusEl.textContent = 'Chart not available for this pool.';
          candlePager.hasMore = false;
          candlePager.before = null;
          candlePager.loading = false;
          return;
        }

        candlePager.before = rawCandles[0].time - 1;
        applyCandlesToChart(true);
        statusEl.textContent = 'Live.';
      }catch(e){
        statusEl.textContent = 'Chart error.';
        console.error(e);
      }finally{
        candlePager.loading = false;
      }
    }

    async function loadOlderCandles(){
      if(!poolAddr) return;
      if(candlePager.loading || !candlePager.hasMore) return;

      const key = `${activeNet}|${poolAddr}|${activeTF?.k||''}`;
      if(candlePager.key && candlePager.key !== key) return; // stale
      const before = candlePager.before;
      if(!before) { candlePager.hasMore = false; return; }

      candlePager.loading = true;
      const prevRange = (()=>{ try{ return chart.timeScale().getVisibleLogicalRange(); }catch(_){ return null; } })();
      const prevTimes = new Set(rawCandles.map(c=>c.time));

      try{
        const url = geckoCandlesUrl(activeTF.gecko, before);
        const j = await fetchJson(url, {timeout:18000, retries:1});
        let part = mapGeckoOhlcv(j);
        if(!part.length){
          candlePager.hasMore = false;
          return;
        }
        part.sort((a,b)=>a.time-b.time);

        let added = 0;
        for(const c of part){
          if(!prevTimes.has(c.time)) added++;
        }

        // merge + dedupe
        const map = new Map();
        for(const c of rawCandles) map.set(c.time, c);
        for(const c of part) map.set(c.time, c);
        rawCandles = Array.from(map.values()).sort((a,b)=>a.time-b.time);

        // update pager
        candlePager.before = rawCandles[0].time - 1;
        if(part.length < (CANDLE_LIMIT - 10)) candlePager.hasMore = false;

        applyCandlesToChart(false);

        // keep viewport anchored after prepend
        if(prevRange && added>0){
          chart.timeScale().setVisibleLogicalRange({
            from: prevRange.from + added,
            to: prevRange.to + added
          });
        }
        syncBarSpacing();
      }catch(e){
        // keep hasMore true; transient errors
      }finally{
        candlePager.loading = false;
      }
    }

    // -------------------- Trades
    function tradesContainer(){
      // write to both desktop + mobile
      return [tradesDesk, tradesMob];
    }

    function ensureTradeHead(){
      // head exists in markup
    }

    function timeAgo(tsMs){
      const d = Math.max(0, Date.now() - tsMs);
      const s = Math.floor(d/1000);
      if(s<60) return s+'s';
      const m = Math.floor(s/60);
      if(m<60) return m+'m';
      const h = Math.floor(m/60);
      if(h<24) return h+'h';
      const days = Math.floor(h/24);
      return days+'d';
    }

    function parseTrade(t){
      const a = t?.attributes || {};
      const id = String(t?.id || a.tx_hash || a.transaction_hash || a.signature || a.transaction_id || '') || '';
      const side = String(a.trade_type || a.side || a.taker_side || a.kind || '').toLowerCase();
      const type = side.includes('sell') ? 'sell' : (side.includes('buy') ? 'buy' : (a.is_buy===true?'buy':(a.is_sell===true?'sell':'')));

      const tx = String(a.tx_hash || a.transaction_hash || a.signature || a.transaction_id || id || '').trim();
      const maker = String(
        a.taker || a.trader || a.wallet_address || a.from_address || a.maker || a.maker_address || a.tx_from_address || a.user_address || ''
      ).trim();

      const rawTs = (a.block_timestamp ?? a.timestamp ?? a.time ?? a.created_at ?? a.mined_at ?? a.block_time ?? 0);
      let tsMs = NaN;
      if(typeof rawTs==='number'){
        tsMs = rawTs>1e12 ? rawTs : rawTs*1000;
      }else{
        const tsv = String(rawTs||'').trim();
        if(tsv && /^\d+(\.\d+)?$/.test(tsv)){
          const n = Number(tsv);
          tsMs = n>1e12 ? n : n*1000;
        }else{
          const d = Date.parse(tsv);
          if(Number.isFinite(d)) tsMs = d;
        }
      }
      if(!Number.isFinite(tsMs)) tsMs = Date.now();

      const usd = num(a.volume_in_usd || a.usd_value || a.volume_usd || a.amount_usd || a.total_usd);
      const price = num(a.price_in_usd || a.price_usd || a.price);

      const baseAmt = num(a.base_token_amount || a.amount_base || a.base_amount || a.base_token_volume || a.base_volume);
      const quoteAmt = num(a.quote_token_amount || a.amount_quote || a.quote_amount || a.quote_token_volume || a.quote_volume);

      // Try to detect which side is the chain native asset (SOL/ETH/BNB; Base uses ETH)
      const baseSym = String(
        a.base_token_symbol || a.base_symbol || a.base_token?.symbol || a.base?.symbol ||
        a.base_token?.data?.attributes?.symbol || a.base_token?.data?.attributes?.symbol?.toString?.() || ''
      ).trim();
      const quoteSym = String(
        a.quote_token_symbol || a.quote_symbol || a.quote_token?.symbol || a.quote?.symbol ||
        a.quote_token?.data?.attributes?.symbol || a.quote_token?.data?.attributes?.symbol?.toString?.() || ''
      ).trim();

      const nat = nativeUnit(activeNet);
      const natSet = nat === 'SOL' ? ['SOL','WSOL'] : (nat === 'BNB' ? ['BNB','WBNB'] : ['ETH','WETH']);
      const baseIsNat = baseSym && natSet.includes(baseSym.toUpperCase());
      const quoteIsNat = quoteSym && natSet.includes(quoteSym.toUpperCase());

      const nativeAmt = (baseIsNat && Number.isFinite(baseAmt)) ? baseAmt
        : ((quoteIsNat && Number.isFinite(quoteAmt)) ? quoteAmt
        : (Number.isFinite(baseAmt) ? baseAmt : (Number.isFinite(quoteAmt) ? quoteAmt : NaN)));

      return { id, type, tx, maker, tsMs, usd, price, baseAmt, quoteAmt, baseSym, quoteSym, nativeAmt };
    }

    function tradeRowHtml(tr){
      const age = timeAgo(tr.tsMs);
      const usdTxt = Number.isFinite(tr.usd) ? '$'+formatCompact(tr.usd) : 'â€”';
      const amtTxt = Number.isFinite(tr.nativeAmt) ? formatCompact(tr.nativeAmt)+' '+esc(nativeUnit(activeNet)) : 'â€”';
      const priceTxt = Number.isFinite(tr.price) ? '$'+formatPrice(tr.price) : 'â€”';

      const isNew = tr.maker ? (!seenMakers.has(tr.maker)) : false;
      if(tr.maker) seenMakers.add(tr.maker);

      const makerHtml = tr.maker
        ? `<div class="maker"><span class="addr mono" title="${esc(tr.maker)}">${esc(shortAddr(tr.maker))}</span>${isNew?'<span class="new">NEW</span>':''}</div>`
        : `<span class="mono" style="opacity:.7">â€”</span>`;

      const txUrl = tr.tx ? explorerTx(activeNet, tr.tx) : '#';
      const addrUrl = tr.maker ? explorerAddr(activeNet, tr.maker) : '#';

      return `
        <div class=\"tradeRow\" data-id=\"${esc(tr.id)}\" data-ts=\"${Number.isFinite(tr.tsMs)?tr.tsMs:0}\" data-price=\"${Number.isFinite(tr.price)?tr.price:''}\" data-usd=\"${Number.isFinite(tr.usd)?tr.usd:''}\" data-type=\"${esc(tr.type||'')}\">
          <div class=\"mono age\">${esc(age)}</div>
          <div><span class="typeBadge ${tr.type==='sell'?'sell':'buy'}">${tr.type==='sell'?'SELL':'BUY'}</span></div>
          <div class="mono">${esc(usdTxt)}</div>
          <div class="mono">${amtTxt}</div>
          <div class="mono hideM">${esc(priceTxt)}</div>
          <div class="hideM">${makerHtml}</div>
          <div>
            <a class="iconBtn" href="${esc(txUrl)}" target="_blank" rel="noreferrer" title="Open Tx">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14 3h7v7" stroke="rgba(255,255,255,.80)" stroke-width="2" stroke-linecap="round"/><path d="M21 3 10 14" stroke="rgba(255,255,255,.80)" stroke-width="2" stroke-linecap="round"/><path d="M10 5H7a4 4 0 0 0-4 4v8a4 4 0 0 0 4 4h8a4 4 0 0 0 4-4v-3" stroke="rgba(255,255,255,.55)" stroke-width="2" stroke-linecap="round"/></svg>
            </a>
          </div>
        </div>
      `;
    }

    async function geckoTrades(limit=80){
      const base = `${GECKO}/networks/${encodeURIComponent(geckoNet())}/pools/${encodeURIComponent(poolAddr)}/trades`;
      // GeckoTerminal often uses JSON:API pagination. Try page params first, then fallback to limit.
      try{
        const url1 = base + `?page=1&limit=${encodeURIComponent(limit)}`;
        const j1 = await fetchJson(url1, {timeout:14000, retries:1});
        if(Array.isArray(j1?.data) && j1.data.length) return j1.data;
      }catch(e){ /* ignore */ }

      try{
        const url2 = base + `?limit=${encodeURIComponent(limit)}`;
        const j2 = await fetchJson(url2, {timeout:14000, retries:1});
        if(Array.isArray(j2?.data)) return j2.data;
      }catch(e){ /* ignore */ }

      return [];
    }

    function renderTrades(trades, {reset=false}={}){
      const parsed = (trades||[]).map(parseTrade).filter(x=>x.id && Number.isFinite(x.tsMs));
      parsed.sort((a,b)=>b.tsMs-a.tsMs);

      if(reset){
        tradesSeen = new Set();
        seenMakers = new Set();
        // clear existing rows (keep header)
        tradesContainer().forEach(el=>{
          const head = el.querySelector('.tradeHead');
          el.innerHTML='';
          el.appendChild(head);
        });
      }

      const newly = [];

      // Only add unseen trades (prepend)
      for(const tr of parsed){
        if(tradesSeen.has(tr.id)) continue;
        tradesSeen.add(tr.id);
        newly.push(tr);

        const html = tradeRowHtml(tr);
        tradesContainer().forEach(el=>{
          const head = el.querySelector('.tradeHead');
          const wrapper = document.createElement('div');
          wrapper.innerHTML = html;
          const row = wrapper.firstElementChild;
          if(row){ row.classList.add('enter'); requestAnimationFrame(()=>{ row.classList.add('enter'); }); setTimeout(()=>{ try{ row.classList.remove('enter'); }catch(_){ } }, 420); }
          // insert after head
          el.insertBefore(row, head.nextSibling);
          // cap rows
          const rows = [...el.querySelectorAll('.tradeRow')];
          if(rows.length>120){
            rows.slice(120).forEach(r=>r.remove());
          }
        });
      }

      const total = tradesDesk.querySelectorAll('.tradeRow').length;
      tradesStat.textContent = `${total} trades`;
      tradesStatM.textContent = `${total} trades`;

      updateAges();
      return newly;
    }

    function updateAges(){
      tradesContainer().forEach(el=>{
        [...el.querySelectorAll('.tradeRow')].forEach(row=>{
          const ts = Number(row.getAttribute('data-ts')||0);
          if(!ts) return;
          const ageEl = row.querySelector('.age');
          if(ageEl) ageEl.textContent = timeAgo(ts);
        });
      });
    }

    function applyTradeToCandles(tr){
      if(!rawCandles || !rawCandles.length) return;
      if(!Number.isFinite(tr.price)) return;
      if(!Number.isFinite(activeTF?.agg) || activeTF.agg<=0) return;

      const tsSec = Math.floor(tr.tsMs/1000);
      const bucket = Math.floor(tsSec / activeTF.agg) * activeTF.agg;

      const last = rawCandles[rawCandles.length-1];
      const usdVol = Number.isFinite(tr.usd) ? tr.usd : 0;

      // ignore very old trades (keeps chart stable)
      if(bucket < last.time - activeTF.agg*5) return;

      if(bucket === last.time){
        last.close = tr.price;
        last.high = Math.max(last.high, tr.price);
        last.low  = Math.min(last.low, tr.price);
        last.volume = (Number(last.volume)||0) + usdVol;
        candleSeries.update({time:last.time, open:last.open, high:last.high, low:last.low, close:last.close});
        volumeSeries.update({time:last.time, value:last.volume, color:(last.close>=last.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
        return;
      }

      if(bucket > last.time){
        const open = Number.isFinite(last.close) ? last.close : tr.price;
        const close = tr.price;
        const high = Math.max(open, close);
        const low = Math.min(open, close);
        const c = {time: bucket, open, high, low, close, volume: usdVol};
        rawCandles.push(c);
        candleSeries.update({time:c.time, open:c.open, high:c.high, low:c.low, close:c.close});
        volumeSeries.update({time:c.time, value:c.volume, color:(c.close>=c.open)?'rgba(20,241,149,.35)':'rgba(255,77,109,.35)'});
      }
    }
    async function loadTrades(reset=false){
      if(!poolAddr) return;
      const _key0 = `${activeNet}|${poolAddr}`;
      const _reqId = (loadTrades._reqId = (loadTrades._reqId||0) + 1);
      const _my = _reqId;
      try{
        const data = await geckoTrades(80);
        if(_my !== loadTrades._reqId) return;
        if(_key0 !== `${activeNet}|${poolAddr}`) return;
        const newly = renderTrades(data, {reset}) || [];
        if(newly.length){
          // Apply oldest->newest so candle updates are correct
          newly.slice().sort((a,b)=>a.tsMs-b.tsMs).forEach(applyTradeToCandles);
        }
      }catch(e){
        // keep UI stable
      }
    }

    function stopLiveLoops(){
      LIVE.gen++;
      const st = LIVE;
      if(st.tTrades){ clearTimeout(st.tTrades); st.tTrades=null; }
      if(st.tCandles){ clearTimeout(st.tCandles); st.tCandles=null; }
      if(st.tMeta){ clearTimeout(st.tMeta); st.tMeta=null; }
      if(st.tAges){ clearInterval(st.tAges); st.tAges=null; }
    }

    const LIVE = { gen:0, tTrades:null, tCandles:null, tMeta:null, tAges:null, failTrades:0, tradeDelay:1500 };

    function startLiveLoops(){
      stopLiveLoops();
      const gen = LIVE.gen;
      LIVE.failTrades = 0;
      LIVE.tradeDelay = 1500;

      const scheduleTrades = async ()=>{
        if(gen !== LIVE.gen) return;
        try{
          await loadTrades(false);
          LIVE.failTrades = 0;
          LIVE.tradeDelay = 1500;
        }catch(_){
          LIVE.failTrades = (LIVE.failTrades||0) + 1;
          LIVE.tradeDelay = Math.min(7000, Math.round(1500 * Math.pow(1.25, LIVE.failTrades)));
        }
        LIVE.tTrades = setTimeout(scheduleTrades, LIVE.tradeDelay);
      };

      const scheduleCandles = async ()=>{
        if(gen !== LIVE.gen) return;
        try{ await refreshLatestCandles(); }catch(_){}
        LIVE.tCandles = setTimeout(scheduleCandles, 9000);
      };

      const scheduleMeta = async ()=>{
        if(gen !== LIVE.gen) return;
        try{ await loadMeta(); }catch(_){}
        LIVE.tMeta = setTimeout(scheduleMeta, 15000);
      };

      LIVE.tAges = setInterval(()=>{ if(gen === LIVE.gen) updateAges(); }, 1000);

      scheduleTrades();
      scheduleCandles();
      scheduleMeta();
    }


// -------------------- Meta (refresh price/liquidity/24h)
    async function geckoPool(){
      const url = `${GECKO}/networks/${encodeURIComponent(geckoNet())}/pools/${encodeURIComponent(poolAddr)}?include=base_token,quote_token`;
      const j = await fetchJson(url, {timeout:14000, retries:1});
      return j?.data || null;
    }

    async function loadMeta(){
      if(!poolAddr) return;
      try{
        const p = await geckoPool();
        if(!p) return;
        applyPool(p);
      }catch(e){
        // ignore
      }
    }

    
    // -------------------- Trending (match main site)
    const TREND_CACHE = new Map();

    function applyNetTheme(){
      document.body.classList.remove('net-sol','net-eth','net-bnb','net-base');
      if(activeNet==='solana') document.body.classList.add('net-sol');
      else if(activeNet==='eth') document.body.classList.add('net-eth');
      else if(activeNet==='bsc') document.body.classList.add('net-bnb');
      else if(activeNet==='base') document.body.classList.add('net-base');
    }

    function syncTrendToggle(){
      const wrap = $('trendToggle');
      if(!wrap) return;
      [...wrap.querySelectorAll('.chainBtn')].forEach(b=>{
        b.classList.toggle('active', normalizeChain(b.dataset.net)===(activeNet));
      });
    }

    async function fetchTrendingPools(net){
      const key = String(net||'');
      const cached = TREND_CACHE.get(key);
      const now = Date.now();
      if(cached && (now - cached.ts) < 45000) return cached.data;

      const url = `${GECKO}/networks/${encodeURIComponent(net)}/trending_pools?include=base_token,quote_token,dex`;
      const j = await fetchJson(url, {timeout:14000, retries:1});
      const data = Array.isArray(j?.data) ? j.data : [];
      const inc  = Array.isArray(j?.included) ? j.included : [];
      const incMap = new Map();
      for(const it of inc){ if(it?.id) incMap.set(it.id, it); }
      const out = { data, incMap };
      TREND_CACHE.set(key, {ts: now, data: out});
      return out;
    }

    
    // Render ticker items EXACT like main page
    function poolToTickerItem(p, n, incMap){
      const a = p?.attributes || {};
      const rel = p?.relationships || {};
      const baseRef = rel?.base_token?.data || null;
      const quoteRef = rel?.quote_token?.data || null;

      const baseId = baseRef?.id ? String(baseRef.id) : '';
      const baseType = baseRef?.type ? String(baseRef.type) : '';
      const quoteId = quoteRef?.id ? String(quoteRef.id) : '';
      const quoteType = quoteRef?.type ? String(quoteRef.type) : '';

      const baseT = baseId ? ((incMap.get(baseType+':' + baseId) || incMap.get(baseId))?.attributes || {}) : {};
      const quoteT = quoteId ? ((incMap.get(quoteType+':' + quoteId) || incMap.get(quoteId))?.attributes || {}) : {};

      const sym = String((baseT?.symbol || baseT?.name || '')).trim() || (a?.name ? String(a.name).split('/')[0].trim() : '') || 'TOKEN';
      const symClean = String(sym||'TOKEN').replace(/[^a-zA-Z0-9_$\.\-]/g,'').slice(0,24) || 'TOKEN';
      const symDisp = symClean.startsWith('$') ? symClean : ('$' + symClean.replace(/^\$/,''));

      const pctRaw = ((a?.price_change_percentage && (a.price_change_percentage.h24 ?? a.price_change_percentage['h24'] ?? a.price_change_percentage['24h'])) ?? a?.price_change_percentage_24h ?? a?.price_change_percentage_h24 ?? null);
      const pctNum = (pctRaw===null || pctRaw===undefined || pctRaw==='') ? NaN : Number(pctRaw);
      const pctTxt = Number.isFinite(pctNum) ? `${pctNum>0?'+':''}${pctNum.toFixed(2)}%` : '';
      const pctCls = Number.isFinite(pctNum) ? (pctNum>0?'up':(pctNum<0?'down':'')) : '';

      const logoUrlRaw = String(
        baseT?.image_url || baseT?.imageUrl || baseT?.image || baseT?.logo_url || baseT?.logoUrl ||
        quoteT?.image_url || quoteT?.imageUrl || quoteT?.image || quoteT?.logo_url || quoteT?.logoUrl ||
        a?.image_url || a?.imageUrl || a?.base_token_image_url || a?.base_token_imageUrl || a?.token_image_url || a?.token_imageUrl ||
        ''
      ).trim();
      let logoUrl = logoUrlRaw;
      if(logoUrl && logoUrl.startsWith('/')) logoUrl = 'https://www.geckoterminal.com' + logoUrl;
      const first = (symClean || 'T').slice(0,1).toUpperCase();

      // Prefer token CA (GeckoTerminal base_token id is usually the token CA)
      const tokenAddr = String((baseT?.address || baseId || '')).trim();

      const top1 = (n===0);
      const cls = `tickerItem${top1?' top1':''}`;
      const rankTxt = top1 ? `ðŸ”¥ #1` : `#${n+1}`;

      const logo = logoUrl
        ? `<span class="tickerLogoWrap"><img class="tickerLogo" src="${esc(logoUrl)}" alt="" loading="lazy" referrerpolicy="no-referrer" onerror="this.remove(); var w=this.closest('.tickerLogoWrap'); if(w){w.innerHTML='<span class=tickerLogoFallback>${esc(first)}</span>';}\"></span>`
        : `<span class="tickerLogoWrap"><span class="tickerLogoFallback">${esc(first)}</span></span>`;

      return `<a class="${cls}" href="#" data-addr="${esc(tokenAddr)}" title="Open ${esc(symDisp)}">
        <span class="rank">${esc(rankTxt)}</span>
        ${logo}
        <span class="sym">${esc(symDisp)}</span>
        ${pctTxt ? `<span class="tickerPct ${esc(pctCls)}">${esc(pctTxt)}</span>` : ''}
      </a>`;
    }

    // Make the marquee a true endless loop: distance + duration scale with content width.
    function syncTickerMarquee(){
      try{
        if(!tickerTrack) return;
        const isMobile = window.matchMedia('(max-width: 860px)').matches;
        const pxPerSec = isMobile ? 120 : 95;
        requestAnimationFrame(()=>{
          const total = tickerTrack.scrollWidth || 0;
          if(total < 20) return;
          const one = Math.max(1, Math.round(total / 2));
          document.documentElement.style.setProperty('--tickerDistance', one + 'px');
          const dur = Math.min(22, Math.max(6.5, one / pxPerSec));
          document.documentElement.style.setProperty('--tickerSpeed', dur.toFixed(2) + 's');
        });
      }catch(_e){}
    }

    let _tickerResizeT = null;
    window.addEventListener('resize', ()=>{
      clearTimeout(_tickerResizeT);
      _tickerResizeT = setTimeout(syncTickerMarquee, 120);
    }, {passive:true});

    function renderTrendingTicker(pools, incMap){
      const top = (pools||[]).slice(0, 10);
      if(!top.length){
        tickerTrack.innerHTML = `<span class="tickerItem" style="opacity:.75"><span class="rank">!</span><span class="sym">Trending unavailable</span></span>`;
        syncTickerMarquee();
        return;
      }

      const items = top.map((p,i)=>poolToTickerItem(p,i,incMap)).join('');
      tickerTrack.innerHTML = items + items;
      syncTickerMarquee();
    }

    async function startTrending(){
      applyNetTheme();
      syncTrendToggle();

      const load = async ()=>{
        try{
          const net = geckoNet();
          const res = await fetchTrendingPools(net);
          renderTrendingTicker(res.data, res.incMap);
        }catch(e){
          console.error('trending failed', e);
          tickerTrack.innerHTML = `<div class="tickerEmpty">Trending unavailable.</div>`;
        }
      };

      await load();
      statusEl.textContent = 'Live.';
      if(trendingTimer) clearInterval(trendingTimer);
      trendingTimer = setInterval(load, 25000);

      tickerTrack.onclick = (e)=>{
        const a = e.target.closest('.tickerItem');
        if(!a) return;
        e.preventDefault();
        const tAddr = a.getAttribute('data-addr') || '';
        if(tAddr) openToken(tAddr, {skipInput:true});
      };

      const toggle = $('trendToggle');
      if(toggle){
        toggle.onclick = (e)=>{
          const b = e.target.closest('.chainBtn');
          if(!b) return;
          const net = normalizeChain(b.dataset.net || 'solana');
          if(net===activeNet) return;
          activeNet = net;
          applyNetTheme();
          syncTrendToggle();
          renderNetPills();
          if(!addr || (activeNet==='solana' ? !isSolAddr(addr) : !isEvmAddr(addr))) addr = DEFAULT_MARKET_TOKEN[activeNet];
          navigate(activeNet, addr);
        };
      }
    }


    // -------------------- Navigation + Boot
    function updateUrl(){
      const u = new URL(location.href);
      u.searchParams.set('chain', activeNet);
      if(addr) u.searchParams.set('addr', addr);
      history.replaceState({}, '', u.toString());
    }

    function navigate(chain, address){
      activeNet = normalizeChain(chain);
      addr = String(address||'').trim();
      updateUrl();
      renderNetPills();
      applyNetTheme();
      startTrending();
      // if address exists, load it
      if(addr){
        openToken(addr, {skipInput:true, silent:true, boot:true});
      }
    }

    async function openToken(input, opts={}){
      try{ if(typeof stopLiveLoops==='function') stopLiveLoops(); }catch(_){ }
      const skipInput = !!opts.skipInput;
      const silent = !!opts.silent;
      const boot = !!opts.boot;

      let v = String(input||'').trim();
      if(!v){ toast('Paste a token name or address'); return; }
      if(!skipInput) q.value = v;

      // reset view
      statusEl.textContent = 'Loadingâ€¦';
      pairNameEl.textContent = 'Loadingâ€¦';
      pairMetaEl.textContent = 'Resolving best poolâ€¦';
      results.innerHTML = '';

      // Force default chart timeframe on every token selection
      setActiveTFKey('15m');


      let dsPair = null;

      // If user typed a name/symbol (not an address), resolve via DexScreener search (auto across chains)
      if(!isEvmAddr(v) && !isSolAddr(v)){
        statusEl.textContent = 'Searchingâ€¦';
        pairNameEl.textContent = 'Searchingâ€¦';
        pairMetaEl.textContent = 'Finding best matchâ€¦';
        try{
          const pairs = await dsSearch(v);
          if(!pairs.length){
            statusEl.textContent = 'Not found.';
            pairNameEl.textContent = 'Not found';
            pairMetaEl.textContent = 'Try a contract address.';
            toast('No results. Try contract address.');
            return;
          }
          const best = bestPairAnyNet(pairs);
          if(!best){
            toast('No usable pair found.');
            return;
          }
          // switch net to best match chain
          const chainId = lc(best?.chainId||'');
          const newNet = (chainId==='solana') ? 'solana' : (chainId==='ethereum' ? 'eth' : (chainId==='bsc' ? 'bsc' : (chainId==='base' ? 'base' : activeNet)));
          if(newNet !== activeNet){
            activeNet = newNet;
            renderNetPills();
            startTrending();
          }

          dsPair = best;
          v = String(best?.baseToken?.address || '').trim() || v;
          if(!skipInput) q.value = v;
        }catch(e){
          statusEl.textContent = 'Search error.';
          toast('Search failed. Try again.');
          return;
        }
      }

      // If it's an EVM address and no dsPair yet, try all EVM nets and pick best liquidity
      if(isEvmAddr(v) && !dsPair){
        const nets = ['eth','bsc','base'];
        let best = null;
        for(const n of nets){
          const arr = await dsTokenPairsV1(n, v);
          const cand = bestPairAnyNet(arr);
          if(cand && (!best || Number(cand?.liquidity?.usd||0) > Number(best?.liquidity?.usd||0))) best = cand;
        }
        if(best){
          const chainId = lc(best?.chainId||'');
          const newNet = (chainId==='ethereum') ? 'eth' : (chainId==='bsc' ? 'bsc' : (chainId==='base' ? 'base' : activeNet));
          if(newNet !== activeNet){
            activeNet = newNet;
            renderNetPills();
            startTrending();
          }
          dsPair = best;
        }
      }

      // If it's Solana address and no dsPair yet, fetch DS token-pairs on Solana
      if(isSolAddr(v) && !dsPair){
        const arr = await dsTokenPairsV1('solana', v);
        const best = bestPairAnyNet(arr);
        if(best) dsPair = best;
      }

      // preferred pool address (pairAddress is usually the AMM pool address)
      let preferredPool = dsPair?.pairAddress || dsPair?.pair_address || '';

      // Fill header from DexScreener meta (fast symbols/logos/stats)
      if(dsPair){
        const meta = dsExtractTokenMeta(dsPair, v);
        curTokenAddr = v;
        if(meta?.image) curTokenImage = meta.image;
        if(meta?.name) curTokenName = meta.name;
        applyTokenHeader(meta);

        applyStats({
          price: num(dsPair?.priceUsd),
          liq: num(dsPair?.liquidity?.usd),
          mcap: num(dsPair?.fdv),
          h24: num(dsPair?.priceChange?.h24),
        });
      }else{
        curTokenAddr = v;
        curTokenName = '';
        curTokenImage = '';
        applyTokenHeader({symbol:'TOKEN', name:'', quoteSymbol:'', image:''});
        applyStats({});
      }

      // reset caches/timers
      tradesSeen = new Set();
      seenMakers = new Set();

      try{
        // 1) preferred pool first (when available via DexScreener)
        if(preferredPool){
          poolAddr = preferredPool;
          const p = await geckoPool();
          if(p){
            applyPool(p);
            statusEl.textContent = 'Loading chartâ€¦';
            await loadCandles(true);
            statusEl.textContent = 'Loading tradesâ€¦';
            await loadTrades(true);
            statusEl.textContent = 'Live.';
            startLiveLoops();
            return;
          }
        }

        // 2) fallback: Gecko token pools -> choose best
        const pools = await resolvePoolsFromGecko(v);
        if(!pools.length){
          statusEl.textContent = 'Not found.';
          pairNameEl.textContent = 'Not found';
          pairMetaEl.textContent = 'Try a different token or chain.';
          toast('Token not found on this chain.');
          return;
        }

        const best = chooseBestPool(pools, v);
        poolChoices = pools;
        poolAddr = poolAddressFromPool(best);

        const p = await geckoPool();
        if(!p) throw new Error('Pool fetch failed');
        applyPool(p);

        statusEl.textContent = 'Loading chartâ€¦';
        await loadCandles(true);
        statusEl.textContent = 'Loading tradesâ€¦';
        await loadTrades(true);
        statusEl.textContent = 'Live.';
        startLiveLoops();
      }catch(e){
        console.error(e);
        statusEl.textContent = 'Load error.';
        // Avoid noisy toast on first load / auto-open. Show toast only after user actions.
        if(!silent && !boot){
          toast('Failed to load chart/trades. API blocked or pool unsupported.');
        }
        // One gentle auto-retry on boot (sometimes APIs are rate-limited on initial load)
        if(boot && !openToken._bootRetried){
          openToken._bootRetried = true;
          setTimeout(()=>openToken(addr, {skipInput:true, silent:true}), 1200);
        }
}
    }

    
    // Boot UI
    renderNetPills();
    renderTimeframes();
    applyNetTheme();

// Boot trending
    startTrending();

    // Open initial token if present
    if(!addr || (activeNet==='solana' ? !isSolAddr(addr) : !isEvmAddr(addr))) addr = DEFAULT_MARKET_TOKEN[activeNet];
    // auto-open default
    openToken(addr, {skipInput:true, silent:true, boot:true});

// ================================
//  UI/UX Premium Patch (Design-only)
//  - Mobile Live Trades bottom sheet
//  - Close search results on outside tap (no global scrim)
// ================================

// Sync top padding for fixed top bar (prevents content hidden underneath)
function syncTopbarSpace(){
  try{
    const tb = document.querySelector('.topbar');
    if(!tb) return;
    const cs = getComputedStyle(tb);
    const top = parseFloat(cs.top) || 0;
    const h = Math.ceil(tb.getBoundingClientRect().height || 0);
    const space = Math.max(64, h + top + 12);
    document.documentElement.style.setProperty('--topbar-space', space + 'px');
  }catch(_){}
}
requestAnimationFrame(syncTopbarSpace);
window.addEventListener('resize', ()=>requestAnimationFrame(syncTopbarSpace), {passive:true});
if(window.visualViewport){
  window.visualViewport.addEventListener('resize', ()=>requestAnimationFrame(syncTopbarSpace), {passive:true});
}


// Close search dropdown on outside interactions (no full-page dimming/blur)
document.addEventListener('pointerdown', (e)=>{
  try{
    if(results && results.style.display === 'block'){
      if(dexSearch && !dexSearch.contains(e.target)){
        hideResults();
      }
    }
  }catch(_){}
}, {capture:true});

if(searchScrim){
  // ensure scrim never blocks UI
  searchScrim.style.display = 'none';
}


// Live Trades accordion (in-page; expands downward; never overlays chart)
(function initTradesAccordion(){
  try{
    if(!tradesCard) return;
    const hd = tradesCard.querySelector('.tableHd');
    if(!hd) return;

    // Toggle button (chevron) for affordance
    let btn = tradesCard.querySelector('.accToggleBtn');
    if(!btn){
      btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'accToggleBtn';
      btn.setAttribute('aria-label','Toggle Live Trades');
      btn.innerHTML = '<svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path fill="currentColor" d="M7.41 8.58 12 13.17l4.59-4.59L18 10l-6 6-6-6z"/></svg>';
      const right = hd.querySelector('.sheetRight') || hd;
      right.appendChild(btn);
    }

    function setOpen(open){
      const isOpen = !!open;
      tradesCard.classList.toggle('open', isOpen);
      hd.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
    }

    function toggle(){
      setOpen(!tradesCard.classList.contains('open'));
    }

    // Default: open on desktop, collapsed on mobile
    const mq = window.matchMedia('(max-width: 740px)');
    setOpen(!mq.matches);
    if(mq && mq.addEventListener){ mq.addEventListener('change', ()=>{ setOpen(!mq.matches); }); }

    btn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); toggle(); });
    hd.addEventListener('click', (e)=>{ e.preventDefault(); toggle(); });

    document.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape') setOpen(false);
    });
  }catch(_){}
})();
  })();
  

// ================================
//  DexGuard Split Panel (Chart + Txns) + Drag Handle
// ================================
(function initSplitPanel(){
  try{
    const rootId = 'splitRoot';
    if(document.getElementById(rootId)) return;
    if(!chartCard || !tradesCard) return;

    // Remove legacy buttons completely
    try{ if(btnFit) btnFit.remove(); }catch(_){}
    try{ if(btnRefresh) btnRefresh.remove(); }catch(_){}

    // Hide legacy mobile tab wrapper + mobile trades wrapper (split replaces)
    try{ const mt = chartCard.querySelector('.mobileTabs'); if(mt) mt.remove(); }catch(_){}
    try{ if(mobileTradesWrap) mobileTradesWrap.style.display='none'; }catch(_){}

    // Build split DOM
    const splitRoot = document.createElement('div');
    splitRoot.id = rootId;
    splitRoot.className = 'splitRoot';

    const splitChart = document.createElement('div');
    splitChart.className = 'splitChart';

    const splitHandle = document.createElement('div');
    splitHandle.className = 'splitHandle';
    splitHandle.setAttribute('role','separator');
    splitHandle.setAttribute('aria-orientation','horizontal');
    splitHandle.title = 'Drag to resize';

    const splitPanel = document.createElement('div');
    splitPanel.className = 'splitPanel';

    const splitTabs = document.createElement('div');
    splitTabs.className = 'splitTabs';

    const mkTab = (key, label)=>{
      const b=document.createElement('button');
      b.type='button';
      b.className='splitTab';
      b.dataset.key=key;
      b.textContent=label;
      return b;
    };

    const tabBoth = mkTab('both','Chart+Txns');
    const tabChartOnly = mkTab('chart','Chart');
    const tabTxnsOnly = mkTab('txns','Txns');
    splitTabs.appendChild(tabBoth);
    splitTabs.appendChild(tabChartOnly);
    splitTabs.appendChild(tabTxnsOnly);

    const splitBody = document.createElement('div');
    splitBody.className = 'splitBody';

    splitPanel.appendChild(splitTabs);
    splitPanel.appendChild(splitBody);

    // Move chartWrap + controls into splitChart
    const chartWrapEl = document.getElementById('chartWrap');
    const controlsEl = chartCard.querySelector('.controls');
    if(chartWrapEl) splitChart.appendChild(chartWrapEl);
    if(controlsEl) splitChart.appendChild(controlsEl);

    // Move trades card into splitBody
    tradesCard.classList.remove('desktopOnly');
    splitBody.appendChild(tradesCard);

    // Insert into chartCard (after header)
    const hd = chartCard.querySelector('.cardHd');
    if(hd && hd.parentNode){
      hd.parentNode.insertBefore(splitRoot, hd.nextSibling);
    }else{
      chartCard.appendChild(splitRoot);
    }
    splitRoot.appendChild(splitChart);
    splitRoot.appendChild(splitHandle);
    splitRoot.appendChild(splitPanel);

    // Default heights
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
    const recompute = ()=>{
      const total = splitRoot.clientHeight || 0;
      const minBottom = 160;
      const maxBottom = Math.max(minBottom, total - 240);
      const cur = parseFloat(getComputedStyle(splitRoot).getPropertyValue('--split-bottom')) || 260;
      const next = clamp(cur, minBottom, maxBottom);
      splitRoot.style.setProperty('--split-bottom', next + 'px');
      requestAnimationFrame(()=>{ try{ chart.applyOptions({ width: chartEl.clientWidth, height: chartEl.clientHeight }); }catch(_){ } });
    };
    window.addEventListener('resize', recompute, {passive:true});
    requestAnimationFrame(recompute);

    // Tabs behavior
    const setMode = (mode)=>{
      tabBoth.classList.toggle('active', mode==='both');
      tabChartOnly.classList.toggle('active', mode==='chart');
      tabTxnsOnly.classList.toggle('active', mode==='txns');

      if(mode==='chart'){
        splitPanel.style.display = 'none';
        splitHandle.style.display = 'none';
        splitChart.style.flex = '1 1 auto';
      }else if(mode==='txns'){
        splitChart.style.display = 'none';
        splitHandle.style.display = 'none';
        splitPanel.style.display = 'flex';
      }else{
        splitChart.style.display = 'flex';
        splitPanel.style.display = 'flex';
        splitHandle.style.display = 'flex';
      }

      requestAnimationFrame(()=>{
        try{
          if(mode!=='txns'){
            chart.applyOptions({ width: chartEl.clientWidth, height: chartEl.clientHeight });
            chart.timeScale().fitContent();
          }
        }catch(_){}
      });
    };

    tabBoth.onclick = ()=>setMode('both');
    tabChartOnly.onclick = ()=>setMode('chart');
    tabTxnsOnly.onclick = ()=>setMode('txns');
    setMode('both');

    // Drag handle behavior
    let dragging=false, startY=0, startBottom=0;
    const onMove = (e)=>{
      if(!dragging) return;
      const y = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
      const dy = y - startY;
      const total = splitRoot.clientHeight || 0;
      const minBottom = 160;
      const maxBottom = Math.max(minBottom, total - 240);
      const next = clamp(startBottom - dy, minBottom, maxBottom);
      splitRoot.style.setProperty('--split-bottom', next + 'px');
      requestAnimationFrame(()=>{ try{ chart.applyOptions({ width: chartEl.clientWidth, height: chartEl.clientHeight }); }catch(_){ } });
      e.preventDefault?.();
    };
    const onUp = ()=>{
      if(!dragging) return;
      dragging=false;
      document.body.classList.remove('dragging');
      window.removeEventListener('pointermove', onMove, {passive:false});
      window.removeEventListener('pointerup', onUp);
      window.removeEventListener('touchmove', onMove, {passive:false});
      window.removeEventListener('touchend', onUp);
    };

    const onDown = (e)=>{
      if(tabChartOnly.classList.contains('active') || tabTxnsOnly.classList.contains('active')) return;
      dragging=true;
      startY = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
      startBottom = parseFloat(getComputedStyle(splitRoot).getPropertyValue('--split-bottom')) || 260;
      document.body.classList.add('dragging');
      if(e.pointerId && splitHandle.setPointerCapture) try{ splitHandle.setPointerCapture(e.pointerId); }catch(_){}
      window.addEventListener('pointermove', onMove, {passive:false});
      window.addEventListener('pointerup', onUp);
      window.addEventListener('touchmove', onMove, {passive:false});
      window.addEventListener('touchend', onUp);
      e.preventDefault?.();
    };

    splitHandle.addEventListener('pointerdown', onDown, {passive:false});
    splitHandle.addEventListener('touchstart', onDown, {passive:false});
  }catch(_){}
})();
</script>
</body>
</html>
