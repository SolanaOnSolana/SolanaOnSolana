<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#070711" />
  <title>$SOS — Guardian Check (Multi-Chain)</title>
  <meta name="description" content="Guardian Approved — token risk score + launch readiness checklist (on-chain verifiable)." />

  <style>
    :root{
      --bg:#070711;
      --panel: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);

      --g:#14F195;
      --c:#00D1FF;
      --p:#9945FF;

      --radius: 22px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --max: 1180px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--text);
      font: 15.5px/1.55 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: var(--bg);
      position:relative;
    }
    body::before{
      content:"";
      position:fixed; inset:0; z-index:-1; pointer-events:none;
      background:
        radial-gradient(1200px 700px at 10% 5%, rgba(153,69,255,.22), transparent 60%),
        radial-gradient(1000px 650px at 90% 10%, rgba(20,241,149,.18), transparent 55%),
        radial-gradient(900px 600px at 70% 85%, rgba(0,209,255,.14), transparent 55%),
        var(--bg);
      transform: translateZ(0);
    }

    a{color:inherit; text-decoration:none}
    .wrap{max-width:var(--max); margin:0 auto; padding:0 18px; width:100%;}
    main{padding:22px 0 42px}

    .topbar{
      position:sticky; top:0; z-index:20;
      backdrop-filter: blur(14px);
      background: rgba(7,7,17,.62);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .row{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:12px 0;
      flex-wrap:wrap;
    }
    .brand{
      display:flex; align-items:center; gap:12px;
      min-width: 260px;
      user-select:none;
    }
    .brand img{
      width:40px; height:40px; object-fit:contain;
      filter: drop-shadow(0 10px 25px rgba(0,0,0,.45));
    }
    .bt{display:flex; flex-direction:column; line-height:1.05}
    .bt .t{font-weight:1000; letter-spacing:-.2px; font-size:16px}
    .bt .s{font-weight:850; color:var(--muted); font-size:12.5px}

    .actions{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      justify-content:flex-end;
      width:100%;
    }
    @media (min-width: 980px){ .actions{width:auto} }

    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      padding:9px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      font-weight:950;
      font-size:13px;
      transition: .15s ease;
      user-select:none;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      white-space:nowrap;
    }
    .btn:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .btn.grad{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .btn[disabled]{opacity:.55; pointer-events:none}

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.05));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .inner{padding:22px}

    .hero{
      position:relative;
      overflow:hidden;
      isolation:isolate;
    }
    .hero::before{
      content:"";
      position:absolute;
      inset:-70px -40px;
      background:
        radial-gradient(900px 520px at 18% 28%, rgba(20,241,149,.16), transparent 60%),
        radial-gradient(900px 520px at 82% 20%, rgba(0,209,255,.12), transparent 60%),
        radial-gradient(900px 520px at 70% 86%, rgba(153,69,255,.14), transparent 60%);
      z-index:0; pointer-events:none;
    }
    .hero > *{position:relative; z-index:1}

    .h1{
      margin:0;
      font-weight:1000;
      letter-spacing:-1px;
      line-height:1.05;
      font-size: clamp(36px, 4.6vw, 62px);
    }
    .gradText{
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      -webkit-background-clip:text; background-clip:text; color:transparent;
    }
    .sub{
      margin-top:10px;
      color: rgba(255,255,255,.76);
      font-weight:850;
      max-width: 940px;
    }

    .classified{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; flex-wrap:wrap;
    }
    .stamp{
      font-weight:1000;
      font-size:12px;
      letter-spacing: .45px;
      text-transform:uppercase;
      color: rgba(255,255,255,.76);
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius: 999px;
      padding:7px 10px;
    }

    .layout{
      margin-top:16px;
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 980px){ .layout{grid-template-columns:1fr} }

    /* ===== MOBILE LAYOUT: clean stacked (no horizontal scroll) ===== */
    @media (max-width: 980px){
      .wrap{ padding: 0 14px; }
      .inner{ padding: 16px; }
      .panel{ padding: 14px; }

      .brand{ min-width: 0; width: 100%; }
      .actions{ width: 100%; justify-content: flex-start; }
      .actions .btn,
      .actions button.btn{
        width: 100%;
        justify-content: center;
        padding: 12px 14px;
        font-size: 14px;
      }

      .resultTop{ flex-direction: column; align-items: stretch; }
      .resultTop > div:last-child{
        width: 100%;
        justify-content: flex-start;
      }
      .resultTop .badge{ width: fit-content; }

      .tokenHead{ flex-wrap: nowrap; }
      .tokenName{ font-size: 18px; }
      .tokenSymbol{ font-size: 13px; }

      .metricV{
        flex-direction: column;
        align-items: flex-start;
        gap: 6px;
        font-size: 22px;
      }
      .metricK{
        flex-wrap: wrap;
        gap: 8px;
      }
      .metricK .badge{
        margin-left: auto;
      }

      .li{
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
      .pill{ align-self: flex-start; }

      .copyBox{
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
      .copyMono{
        white-space: normal;
        overflow: visible;
        text-overflow: initial;
      }
    }

    .panel{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 18px;
      padding:16px;
      overflow:hidden;
    }

    label{
      display:block;
      font-weight:950;
      font-size:12.5px;
      letter-spacing:.35px;
      color: rgba(255,255,255,.82);
      margin-bottom:8px
    }
    input{
      width:100%;
      padding:14px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.92);
      outline:none;
      font-weight:900;
      letter-spacing:.2px;
      font-size:16px; /* prevents iOS auto-zoom */
    }
    input:focus{
      border-color: rgba(0,209,255,.45);
      box-shadow: 0 0 0 3px rgba(0,209,255,.12);
    }

    .statusLine{
      margin-top:12px;
      color: rgba(255,255,255,.72);
      font-weight:900;
      min-height: 18px;
      font-size:13px;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    .badge{
      display:inline-flex; align-items:center; justify-content:center;
      padding:7px 11px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
    }
    .badge.good{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}
    .badge.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .badge.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}

    /* ===== RESULT ===== */
    .resultTop{
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:12px; flex-wrap:wrap;
    }
    .resultTitle{
      margin:0;
      font-weight:1000;
      font-size:22px;
      letter-spacing:-.4px;
    }
    .mono{
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-weight:900;
      color: rgba(255,255,255,.86);
      margin-top:6px;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* Token header (name/symbol/logo) */
    .tokenHead{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .tokenLogoWrap{
      width:44px; height:44px;
      border-radius:12px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      display:none; /* shown if we have a logo */
      flex:0 0 auto;
    }
    .tokenLogoWrap img{
      width:100%; height:100%;
      object-fit:cover;
      display:block;
    }
    .tokenName{
      font-weight:1000;
      font-size:16px;
      letter-spacing:-.2px;
      line-height:1.15;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .tokenSymbol{
      margin-top:2px;
      color: rgba(255,255,255,.70);
      font-weight:900;
      font-size:12.5px;
    }

    .metricStack{margin-top:12px; display:grid; gap:10px;}
    .metric{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      border-radius: 16px;
      padding:12px 12px;
    }
    .metricK{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      color: rgba(255,255,255,.70);
      font-weight:1000;
      font-size:12px;
      letter-spacing:.45px;
      text-transform:uppercase;
    }
    .metricV{
      margin-top:8px;
      font-weight:1000;
      font-size:20px;
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .metricMini{
      margin-top:6px;
      font-weight:850;
      font-size:12px;
      color: rgba(255,255,255,.62);
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .bar{
      margin-top:10px;
      height:12px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .bar > div{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      border-radius:999px;
      transition: width .25s ease;
    }

    .list{
      margin:10px 0 0;
      padding:0;
      list-style:none;
      display:grid;
      gap:10px;
    }
    .li{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      border-radius: 16px;
      padding:12px 12px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      overflow:visible;
    }
    .li .left{min-width:0;}
    .li .t{font-weight:1000; font-size:13px; letter-spacing:.2px;}
    .li .d{
      margin-top:4px;
      color: rgba(255,255,255,.70);
      font-weight:750;
      font-size:12.5px;
      line-height:1.35;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .pill{
      flex:0 0 auto;
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .pill.ok{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}
    .pill.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .pill.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}

    details.shareBox{
      margin-top:12px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      padding: 12px 12px;
    }
    details.shareBox summary{
      cursor:pointer;
      font-weight: 1000;
      color: rgba(255,255,255,.86);
      list-style:none;
    }
    details.shareBox summary::-webkit-details-marker{display:none}
    .shareInner{margin-top:12px; display:grid; gap:10px;}
    .copyBox{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
      border-radius: 16px;
      padding:12px 12px;
      cursor:pointer;
      overflow:visible;
    }
    .copyMono{
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-weight:900;
      color: rgba(255,255,255,.86);
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      max-width: 100%;
    }
    .hint{
      flex:0 0 auto;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
    }
    .hint.ok{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}

    footer{
      padding: 18px 0 34px;
      color: rgba(255,255,255,.45);
      font-weight:650;
      text-align:center;
      font-size:12px;
    }

    /* ===== Modal (for WATCH/FAIL details) ===== */
    .modalWrap{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:100;
    }
    .modal{
      width:min(920px, 100%);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(7,7,17,.92);
      box-shadow: 0 16px 50px rgba(0,0,0,.5);
      overflow:hidden;
    }
    .modalHead{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .modalTitle{
      font-weight:1000;
      letter-spacing:-.3px;
    }
    .modalBody{
      padding:14px 16px 16px;
      color: rgba(255,255,255,.82);
      font-weight:800;
      line-height:1.5;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .modalBody code{ display:none !important; }

    /* ===== Chain selector ===== */
    .chainRow{ margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; }
    .chainBtn{
      display:inline-flex; align-items:center; gap:10px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      user-select:none;
      font-weight:1000;
      font-size:13px;
      color: rgba(255,255,255,.88);
      -webkit-tap-highlight-color: transparent;
    }
    .chainBtn:hover{ background: rgba(255,255,255,.10); }
    .chainBtn.active{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .chainIcon{
      width:18px; height:18px; border-radius:6px;
      display:inline-flex; align-items:center; justify-content:center;
      overflow:hidden;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      flex:0 0 auto;
    }
    .chainIcon svg{ width:14px; height:14px; display:block; }
    .chainMiniHint{
      margin-top:10px;
      font-size:12.5px;
      color: rgba(255,255,255,.62);
      font-weight:850;
      line-height:1.35;
    }

    /* reduce motion */
    @media (prefers-reduced-motion: reduce){
      .btn:hover{transform:none}
      .bar > div{transition:none}
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="wrap">
      <div class="row">
        <div class="brand">
          <img src="../assets/logo.png" alt="$SOS" onerror="this.style.display='none'">
          <div class="bt">
            <div class="t">$SOS</div>
            <div class="s">Contract Scanner • Token Risk</div>
          </div>
        </div>

        <div class="actions">
          <a class="btn" href="https://solanax1.com/" rel="noreferrer">← Back to Main</a>
          <button class="btn grad" id="btnScan">Run Guardian Check</button>

          <!-- same element as your original; repurposed to "Copy Share Link" (no badge embed) -->
          <a class="btn" id="btnShare" href="#" rel="noreferrer" style="opacity:.55; pointer-events:none;">Copy Share Link</a>

          <!-- added export button (doesn't delete anything) -->
          <button class="btn" id="btnExport" type="button" disabled>Export Report (JSON)</button>
        </div>
      </div>
    </div>
  </div>

  <main class="wrap">
    <section class="card hero">
      <div class="inner">
        <div class="classified">
          <div class="stamp">GUARDIAN SYSTEM • MAINNET • ON-CHAIN VERIFIED</div>
          <div class="stamp" id="stampTime">—</div>
        </div>

        <h1 class="h1" style="margin-top:12px;"><span class="gradText">Guardian Contract</span> Scanner</h1>
        <div class="sub">
          Multi-chain scan: Solana + ETH + BNB + Base. WATCH/FAIL items are clickable and explain exactly what it means and what to do.
        </div>

        <div class="layout">
          <!-- INPUT -->
          <div class="panel">
            <label>Choose Chain</label>
            <div class="chainRow" id="chainRow"></div>
            <div class="chainMiniHint" id="chainHint">—</div>

            <label for="mint" style="margin-top:14px;" id="addrLabel">Token Address</label>
            <input id="mint" placeholder="Paste token address..." autocomplete="off" spellcheck="false" inputmode="text" />

            <button class="btn grad" id="btnScanInline" type="button" style="width:100%; margin-top:12px;">Run Guardian Check</button>

            <div class="statusLine" id="status"></div>

            <!-- kept your share box (NOT deleted), but it now only provides a clean share link + export hint -->
            <details class="shareBox" id="sharePanel" style="display:none;">
              <summary>Share</summary>
              <div class="shareInner">
                <!-- kept badgeCopy box but repurposed as "Share Link" to avoid removing -->
                <div class="copyBox" id="badgeCopy" role="button" tabindex="0" aria-label="Copy Share Link">
                  <div style="min-width:0">
                    <div style="font-weight:1000; font-size:12px; letter-spacing:.35px; color:rgba(255,255,255,.78); text-transform:uppercase;">Share Link</div>
                    <div class="copyMono" id="badgeHtml">—</div>
                  </div>
                  <div class="hint" id="badgeHint">Copy</div>
                </div>

                <!-- kept linkCopy box as-is -->
                <div class="copyBox" id="linkCopy" role="button" tabindex="0" aria-label="Copy Scan Link">
                  <div style="min-width:0">
                    <div style="font-weight:1000; font-size:12px; letter-spacing:.35px; color:rgba(255,255,255,.78); text-transform:uppercase;">Scan Link</div>
                    <div class="copyMono" id="scanLink">—</div>
                  </div>
                  <div class="hint" id="linkHint">Copy</div>
                </div>
              </div>
            </details>
          </div>

          <!-- RESULTS -->
          <div class="panel" id="resultsPanel">
            <div class="resultTop">
              <div>
                <div class="tokenHead">
                  <div class="tokenLogoWrap" id="tokenLogoWrap">
                    <img id="tokenLogo" alt="">
                  </div>
                  <div style="min-width:0">
                    <div class="tokenName" id="tokenName">—</div>
                    <div class="tokenSymbol" id="tokenSymbol">—</div>
                  </div>
                </div>

                <h3 class="resultTitle" id="verdictTitle">—</h3>
                <div class="mono" id="mintShort">—</div>
              </div>

              <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                <span class="badge" id="verdictBadge">—</span>
                <span class="badge good" id="scoreBadge">—</span>
              </div>
            </div>

            <div class="metricStack" id="metrics"></div>
            <div class="statusLine" id="summary">—</div>
          </div>
        </div>

        <!-- Checks -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">GUARDIAN CHECKS</div>
            <div class="stamp" id="scanHint">—</div>
          </div>
          <ul class="list" id="checksList" style="margin-top:10px;">
            <li class="li">
              <div class="left">
                <div class="t">No scan yet</div>
                <div class="d">Paste an address and run the Guardian Check.</div>
              </div>
              <span class="pill">—</span>
            </li>
          </ul>
        </div>

        <!-- Launch readiness -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">LAUNCH READINESS</div>
            <div class="stamp">ACTION LIST</div>
          </div>
          <ul class="list" id="todoList" style="margin-top:10px;">
            <li class="li">
              <div class="left">
                <div class="t">Waiting for scan</div>
                <div class="d">We generate a checklist only from verified on-chain signals.</div>
              </div>
              <span class="pill">—</span>
            </li>
          </ul>
        </div>

        <!-- Token standard details -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOKEN STANDARD DETAILS</div>
            <div class="stamp">ON-CHAIN</div>
          </div>
          <ul class="list" id="extList" style="margin-top:10px;">
            <li class="li">
              <div class="left">
                <div class="t">No scan yet</div>
                <div class="d">Standard details appear after scan.</div>
              </div>
              <span class="pill">—</span>
            </li>
          </ul>
        </div>

        <!-- Metadata / branding -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOKEN METADATA</div>
            <div class="stamp">RPC / ON-CHAIN</div>
          </div>
          <ul class="list" id="metaList" style="margin-top:10px;">
            <li class="li">
              <div class="left">
                <div class="t">No scan yet</div>
                <div class="d">Name / symbol / image / metadata details appear after scan.</div>
              </div>
              <span class="pill">—</span>
            </li>
          </ul>
        </div>

        <!-- Top holders (note: limited on EVM without indexers) -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOP HOLDERS (PREVIEW)</div>
            <div class="stamp" id="holdersStamp">MAINNET</div>
          </div>
          <ul class="list" id="holdersList" style="margin-top:10px;">
            <li class="li">
              <div class="left">
                <div class="t">No scan yet</div>
                <div class="d">Top holder preview will appear after scan (Solana full, EVM limited).</div>
              </div>
              <span class="pill">—</span>
            </li>
          </ul>
        </div>

      </div>
    </section>

    <footer>© <span id="y"></span> $SOS • Guardian Check</footer>
  </main>

  <!-- Modal -->
  <div class="modalWrap" id="modalWrap" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle" id="modalTitle">Guardian Details</div>
        <button class="btn" id="modalClose">Close</button>
      </div>
      <div class="modalBody" id="modalBody"></div>
    </div>
  </div>

<script>
/* ===================== CONFIG ===================== */

/* Solana: Helius key is already embedded in your original file.
   ETH/BNB/Base: we use public RPC endpoints (no key required). */
const HELIUS_KEY = "a16897d9-ee14-46e0-aacd-7d3c7a7d3421";

const TOKEN_PROGRAM = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
const TOKEN_2022_PROGRAM = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";

/* Chain list: Solana FIRST as requested */
const CHAINS = [
  { id:"sol", name:"Solana", kind:"solana", stamp:"MAINNET", addrLabel:"Token Mint Address", placeholder:"Paste token mint (Solana)..."},
  { id:"eth", name:"Ethereum", kind:"evm", chainId:1,   stamp:"ETH MAINNET",  addrLabel:"Token Contract Address", placeholder:"Paste ERC-20 contract (0x...)"},
  { id:"bnb", name:"BNB",      kind:"evm", chainId:56,  stamp:"BNB MAINNET",  addrLabel:"Token Contract Address", placeholder:"Paste BEP-20 contract (0x...)"},
  { id:"base",name:"Base",     kind:"evm", chainId:8453,stamp:"BASE MAINNET", addrLabel:"Token Contract Address", placeholder:"Paste Base token contract (0x...)"},
];

/* Public RPCs (browser-safe: multiple endpoints + failover)
   NOTE: Some public RPCs occasionally block CORS or rate-limit.
   We rotate + retry per request automatically. */
const EVM_RPCS = {
  1: [
    "https://ethereum.publicnode.com",
    "https://rpc.ankr.com/eth",
    "https://eth.llamarpc.com",
    "https://cloudflare-eth.com"
  ],
  56: [
    "https://bsc.publicnode.com",
    "https://rpc.ankr.com/bsc",
    "https://bsc-dataseed.binance.org"
  ],
  8453: [
    "https://base.publicnode.com",
    "https://rpc.ankr.com/base",
    "https://mainnet.base.org"
  ]
};

const $ = (id)=>document.getElementById(id);
$("y").textContent = new Date().getFullYear();

function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function shortAddr(a){ return a ? (a.slice(0,4)+"…"+a.slice(-4)) : "—"; }
function fmtInt(n){
  if(n === null || n === undefined || Number.isNaN(n)) return "—";
  try { return new Intl.NumberFormat("en-US").format(Math.round(Number(n))); } catch { return String(n); }
}
function fmtPct(n){
  if(n === null || n === undefined || Number.isNaN(n)) return "—";
  return `${Number(n).toFixed(2)}%`;
}
function setText(id, v){ const el=$(id); if(el) el.textContent = v; }
function setStatus(msg){ const el = $("status"); if(el) el.textContent = msg || ""; }
function setBadge(el, txt, mode){
  if(!el) return;
  el.textContent = txt;
  el.classList.remove("good","warn","bad");
  if(mode) el.classList.add(mode);
}
function updateStampTime(){
  const el = $("stampTime");
  if(el) el.textContent = new Date().toISOString().replace("T"," ").slice(0,19) + " UTC";
}
updateStampTime();
setInterval(updateStampTime, 1000);

/* ===== Modal ===== */
function openModal(title, body){
  $("modalTitle").textContent = title || "Guardian Details";
  $("modalBody").innerHTML = body || "";
  const w = $("modalWrap");
  w.style.display = "flex";
  w.setAttribute("aria-hidden","false");
}
function closeModal(){
  const w = $("modalWrap");
  w.style.display = "none";
  w.setAttribute("aria-hidden","true");
}
$("modalClose").addEventListener("click", closeModal);
$("modalWrap").addEventListener("click", (e)=>{ if(e.target === $("modalWrap")) closeModal(); });
document.addEventListener("keydown", (e)=>{ if(e.key==="Escape") closeModal(); });

/* ===== Clipboard helpers ===== */
async function copyText(text){
  try{ await navigator.clipboard.writeText(text); return true; }
  catch{
    const ta = document.createElement("textarea");
    ta.value = text; ta.setAttribute("readonly","");
    ta.style.position="fixed"; ta.style.top="-9999px";
    document.body.appendChild(ta);
    ta.select();
    try{ const ok = document.execCommand("copy"); document.body.removeChild(ta); return ok; }
    catch{ document.body.removeChild(ta); return false; }
  }
}
function hint(el, ok, on="Copied!", off="Copy"){
  if(!el) return;
  if(ok){
    el.textContent = on;
    el.classList.add("ok");
    setTimeout(()=>{ el.textContent = off; el.classList.remove("ok"); }, 1200);
  }else{
    el.textContent = "Failed";
    setTimeout(()=>{ el.textContent = off; }, 1200);
  }
}
function attachCopy(boxId, textId, hintId, on, off){
  const box = $(boxId), t = $(textId), h = $(hintId);
  if(!box) return;
  const go = async ()=>{
    const txt = (t?.textContent || "").trim();
    if(!txt || txt === "—") return;
    const ok = await copyText(txt);
    hint(h, ok, on, off);
  };
  box.addEventListener("click", go);
  box.addEventListener("keydown", (e)=>{ if(e.key==="Enter" || e.key===" "){ e.preventDefault(); go(); }});
}
attachCopy("badgeCopy","badgeHtml","badgeHint","Copied!","Copy");
attachCopy("linkCopy","scanLink","linkHint","Copied!","Copy");

/* ===================== CHAIN SELECTOR UI ===================== */
const ICONS = {
  sol: `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
    <path d="M6 7.5c.3-.4.7-.6 1.2-.6h14.3c.9 0 1.3 1.1.7 1.7l-2 2.2c-.3.4-.7.6-1.2.6H4.7c-.9 0-1.3-1.1-.7-1.7l2-2.2Z" fill="currentColor" opacity=".9"/>
    <path d="M6 16.5c.3-.4.7-.6 1.2-.6h14.3c.9 0 1.3 1.1.7 1.7l-2 2.2c-.3.4-.7.6-1.2.6H4.7c-.9 0-1.3-1.1-.7-1.7l2-2.2Z" fill="currentColor" opacity=".6"/>
    <path d="M18 12c-.3.4-.7.6-1.2.6H2.5c-.9 0-1.3-1.1-.7-1.7l2-2.2c.3-.4.7-.6 1.2-.6h14.3c.9 0 1.3 1.1.7 1.7l-2 2.2Z" fill="currentColor"/>
  </svg>`,
  eth: `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
    <path d="M12 2l6 10-6 3-6-3 6-10Z" fill="currentColor" opacity=".9"/>
    <path d="M12 22l6-8-6 3-6-3 6 8Z" fill="currentColor" opacity=".7"/>
  </svg>`,
  bnb: `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
    <path d="M12 2l4 4-4 4-4-4 4-4Z" fill="currentColor"/>
    <path d="M6 8l4 4-4 4-4-4 4-4Z" fill="currentColor" opacity=".8"/>
    <path d="M18 8l4 4-4 4-4-4 4-4Z" fill="currentColor" opacity=".8"/>
    <path d="M12 14l4 4-4 4-4-4 4-4Z" fill="currentColor" opacity=".6"/>
    <path d="M12 10l2 2-2 2-2-2 2-2Z" fill="currentColor" opacity=".9"/>
  </svg>`,
  base: `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
    <path d="M12 4.5c4.4 0 8 3.6 8 8s-3.6 8-8 8-8-3.6-8-8 3.6-8 8-8Z" fill="currentColor" opacity=".9"/>
    <path d="M10.2 9.2h3.1c1.9 0 3.5 1.5 3.5 3.4 0 1.9-1.6 3.4-3.5 3.4h-3.1V9.2Zm1.6 1.6v3.6h1.4c1 0 1.9-.8 1.9-1.8s-.8-1.8-1.9-1.8h-1.4Z" fill="#070711"/>
  </svg>`
};

let activeChain = CHAINS[0];

/* we store last scan (for share/export) */
let LAST_SCAN = null;

function renderChainButtons(){
  const row = $("chainRow");
  row.innerHTML = "";
  for(const c of CHAINS){
    const b = document.createElement("button");
    b.type = "button";
    b.className = "chainBtn" + (c.id === activeChain.id ? " active" : "");
    b.setAttribute("data-chain", c.id);
    b.innerHTML = `<span class="chainIcon">${ICONS[c.id] || ""}</span><span>${c.name}</span>`;
    b.addEventListener("click", ()=> setActiveChain(c.id, true));
    row.appendChild(b);
  }
}

function setActiveChain(chainId, pushUrl){
  const found = CHAINS.find(x=>x.id===chainId) || CHAINS[0];
  activeChain = found;
  renderChainButtons();

  $("holdersStamp").textContent = activeChain.stamp || "MAINNET";
  $("addrLabel").textContent = activeChain.addrLabel || "Token Address";
  $("mint").placeholder = activeChain.placeholder || "Paste token address...";
  $("chainHint").textContent =
    activeChain.kind === "solana"
      ? "Solana scan = full (mint authorities, freeze, top holders via RPC + metadata via Helius DAS)."
      : "EVM scan = fully on-chain (ERC-20 basics + ownership/proxy/pause heuristics). Top holders needs indexers, so preview is limited.";

  // reset input validation hints
  setStatus("");
  clearUI();

  if(pushUrl){
    const url = new URL(location.href);
    url.searchParams.set("chain", activeChain.id);
    history.replaceState({}, "", url.toString());
  }
}

/* ===================== VALIDATION ===================== */
function looksBase58(s){
  return typeof s === "string"
    && s.length >= 32 && s.length <= 52
    && /^[1-9A-HJ-NP-Za-km-z]+$/.test(s);
}
function looksEvmAddress(s){
  return typeof s === "string"
    && /^0x[0-9a-fA-F]{40}$/.test(s.trim());
}

/* ===================== TOKEN HEADER (shared) ===================== */
function applyTokenHeader(meta, addr){
  const nameEl = $("tokenName");
  const symEl = $("tokenSymbol");
  const logoWrap = $("tokenLogoWrap");
  const logo = $("tokenLogo");

  const fallbackName = "Token";
  const n = meta?.name ? meta.name : "";
  const s = meta?.symbol ? meta.symbol : "";

  nameEl.textContent = (n || fallbackName);
  symEl.textContent = (s ? `$${s}` : `Addr: ${shortAddr(addr)}`);

  if(meta?.image){
    logo.src = meta.image;
    logo.alt = (n || s || "Token");
    logoWrap.style.display = "block";
    logo.onerror = ()=>{ logoWrap.style.display = "none"; };
  }else{
    logoWrap.style.display = "none";
    logo.removeAttribute("src");
    logo.alt = "";
  }
}

/* ===================== SIMPLE EXPLAINERS (NO CODE/NO JSON) ===================== */
function explainSimple(title, lines){
  const safe = (s)=>String(s||"").replaceAll("<","&lt;").replaceAll(">","&gt;");
  return `
    <div style="font-weight:1000; font-size:18px; margin-bottom:10px">${safe(title)}</div>
    <div style="color:rgba(255,255,255,.70); font-weight:850; line-height:1.55">
      ${lines.map(l=>`<div style="margin:6px 0">${safe(l)}</div>`).join("")}
    </div>
  `;
}

/* Solana explainers */
function explainFreeze(){
  return explainSimple("Freeze Authority", [
    "Meaning: Someone can freeze wallets so they can’t sell or move the token.",
    "Why it matters: Buyers can get trapped.",
    "What to do: Only trust if Freeze is removed (renounced)."
  ]);
}
function explainMintAuth(){
  return explainSimple("Mint Authority", [
    "Meaning: Someone can mint (create) more tokens anytime.",
    "Why it matters: More tokens can crash the price.",
    "What to do: Only trust if Mint is renounced, or there is a clear public emission plan."
  ]);
}
function explainTop20(pct){
  const p = Number(pct||0).toFixed(2);
  return explainSimple("Top Holders Concentration", [
    `Meaning: The biggest 20 wallets hold about ${p}% of the supply.`,
    "Why it matters: A few wallets can dump and crash the chart.",
    "What to do: High % = extra caution. Check holders and project transparency."
  ]);
}
function explainTokenStandard(programType, extReadable){
  if(programType === "SPL_TOKEN"){
    return explainSimple("Token Standard: SPL Token", [
      "Meaning: Normal Solana token program used by most tokens.",
      "Why it matters: Fewer extra rules hidden inside the token.",
      "What to do: Still check authorities and distribution."
    ]);
  }
  if(programType === "TOKEN_2022"){
    return explainSimple("Token Standard: Token-2022", [
      "Meaning: Official Solana token program with optional extra rules (extensions).",
      "Why it matters: Some extensions can add fees or restrictions.",
      extReadable ? "What to do: Read the Token Standard Details list and be careful with WATCH items."
                : "What to do: If extensions are not visible, treat as WATCH until verified elsewhere."
    ]);
  }
  return explainSimple("Token Standard: Unknown Program", [
    "Meaning: Token mint is not using the common Solana token programs.",
    "Why it matters: Custom programs can add hidden rules.",
    "What to do: Treat as WATCH and verify carefully."
  ]);
}
function explainMetadataQuality(){
  return explainSimple("Token Metadata", [
    "Meaning: Name, symbol and logo help you identify the real token.",
    "Why it matters: Missing metadata makes impersonation easier.",
    "What to do: Verify name/symbol/logo match official socials and listings."
  ]);
}
function explainHolders(addr, pct){
  return explainSimple("Top Holder", [
    `Meaning: This wallet holds about ${pct}% of the supply.`,
    "Why it matters: Big holders can dump suddenly.",
    "What to do: Watch big wallets and avoid extreme concentration."
  ]);
}

/* EVM explainers */
function explainEvmOwnership(){
  return explainSimple("Contract Owner", [
    "Meaning: Many ERC-20 contracts have an owner/admin with special permissions.",
    "Why it matters: The owner may change fees, pause transfers, blacklist wallets, or upgrade logic (if proxy).",
    "What to do: Safer if owner is renounced or controlled by a trusted multi-sig with public transparency."
  ]);
}
function explainEvmProxy(){
  return explainSimple("Proxy / Upgradeable Contract", [
    "Meaning: The contract may be a proxy that points to an implementation contract.",
    "Why it matters: Logic can be upgraded (behavior can change after launch).",
    "What to do: Treat as WATCH unless upgrades are locked or transparently governed."
  ]);
}
function explainEvmPause(){
  return explainSimple("Pause / Freeze Capability (Heuristic)", [
    "Meaning: Contract may support pausing transfers (paused state).",
    "Why it matters: Users can get blocked from transferring/selling.",
    "What to do: Treat as WATCH unless you trust the admin and the rules are publicly explained."
  ]);
}
function explainEvmTokenBasics(){
  return explainSimple("ERC-20 Basics", [
    "Meaning: We check if the contract responds to standard ERC-20 calls (name/symbol/decimals/totalSupply).",
    "Why it matters: Non-standard tokens can hide surprises.",
    "What to do: Treat non-standard behavior as FAIL for memecoin launches."
  ]);
}
function explainEvmHoldersLimit(){
  return explainSimple("Top Holders (EVM)", [
    "Meaning: On EVM chains, 'top holders' is not directly queryable from raw RPC.",
    "Why it matters: Holder concentration is still a major risk factor.",
    "What to do: Use an indexer (Covalent/Bitquery/Alchemy/Etherscan APIs) if you want holder distribution inside this page."
  ]);
}

/* ===================== RENDER HELPERS ===================== */
function renderList(el, items, listTitle="Guardian Details"){
  el.innerHTML = "";
  for(const it of items){
    const li = document.createElement("li");
    li.className = "li";

    const sev = it.sev || "warn";
    const pillCls = sev === "ok" ? "pill ok" : (sev === "bad" ? "pill bad" : "pill warn");
    const pillTxt = sev === "ok" ? "PASS" : (sev === "bad" ? "FAIL" : "WATCH");

    const msgHtml = (it.clickMsg || it.msg || "").trim();
    li.innerHTML = `
      <div class="left">
        <div class="t">${(it.k || it.t || "—")}</div>
        <div class="d">${(it.d || "—")}</div>
      </div>
      <span class="${pillCls}" role="button" tabindex="0"
        data-title="${(it.k || it.t || listTitle).replaceAll('"','&quot;')}"
        data-msg="${msgHtml.replaceAll('"','&quot;')}">${pillTxt}</span>
    `;
    el.appendChild(li);
  }
}

function clearUI(){
  setShareEnabled(false);
  setText("mintShort","—");
  setText("verdictTitle","—");
  setBadge($("verdictBadge"),"—");
  setText("scoreBadge","—");
  setText("summary","—");
  setText("scanHint","—");
  $("sharePanel").style.display = "none";

  setText("tokenName","—");
  setText("tokenSymbol","—");
  $("tokenLogoWrap").style.display = "none";

  $("metrics").innerHTML = "";
  renderList($("checksList"), [{
    t:"No scan yet", sev:"warn",
    d:"Paste an address and run the Guardian Check.",
    clickMsg: explainSimple("No Scan Yet", ["Paste an address, then run the scan."])
  }], "Guardian Check Details");
  renderList($("todoList"), [{
    t:"Waiting for scan", sev:"warn",
    d:"We generate a checklist only from verified on-chain signals.",
    clickMsg: explainSimple("Launch Readiness", ["Run a scan to generate your action list."])
  }], "Launch Readiness Details");
  renderList($("extList"), [{
    t:"No scan yet", sev:"warn",
    d:"Standard details appear after scan.",
    clickMsg: explainSimple("Token Standard Details", ["Run a scan to see standard details."])
  }], "Token Standard Details");
  renderList($("metaList"), [{
    t:"No scan yet", sev:"warn",
    d:"Name / symbol / image / metadata details appear after scan.",
    clickMsg: explainMetadataQuality()
  }], "Token Metadata");
  renderList($("holdersList"), [{
    t:"No scan yet", sev:"warn",
    d:"Top holder preview appears after scan (Solana full, EVM limited).",
    clickMsg: explainSimple("Top Holders", ["Run a scan to see what is available on your chain."])
  }], "Top Holders");

  LAST_SCAN = null;
  $("btnExport").disabled = true;
  $("btnExport").textContent = "Export Report (JSON)";
}

/* Metrics (generic) */
function renderMetricsGeneric(rows){
  const wrap = $("metrics");
  wrap.innerHTML = "";
  for(const r of rows){
    const d = document.createElement("div");
    d.className = "metric";
    d.innerHTML = `
      <div class="metricK"><span>${r.label}</span><span class="badge" style="opacity:.9">${r.badge || r.value || "—"}</span></div>
      <div class="metricV">${r.value || "—"}</div>
      <div class="metricMini">${r.mini || ""}</div>
      ${typeof r.barPct === "number" ? `<div class="bar"><div style="width:${clamp(r.barPct,0,100)}%"></div></div>` : ""}
    `;
    wrap.appendChild(d);
  }
}

/* Share: clean link only (no X intent, no badge embed) */
function setShareEnabled(enabled, url){
  const a = $("btnShare");
  if(!a) return;
  if(enabled){
    a.style.opacity = "1";
    a.style.pointerEvents = "auto";
    a.href = "#";
    a.onclick = async (e)=>{
      e.preventDefault();
      const ok = await copyText(url);
      if(ok){
        a.textContent = "Copied!";
        setTimeout(()=> a.textContent = "Copy Share Link", 1100);
      }else{
        a.textContent = "Copy failed";
        setTimeout(()=> a.textContent = "Copy Share Link", 1100);
      }
    };
  }else{
    a.href = "#";
    a.style.opacity = ".55";
    a.style.pointerEvents = "none";
    a.onclick = null;
    a.textContent = "Copy Share Link";
  }
}
function buildShareLink(chainId, addr){
  const url = new URL(location.href);
  url.searchParams.set("chain", chainId);
  url.searchParams.set("mint", addr);
  // keep it "clean": drop other params if any
  return url.toString();
}

/* Export report as a JSON file (download) */
function downloadJson(filename, obj){
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
}

/* ===================== VERDICT / SCORING (shared shape) ===================== */
function verdictFrom(score, critical){
  if(critical) return {label:"FLAGGED", mode:"bad", title:"FLAGGED • High Risk"};
  if(score >= 80) return {label:"APPROVED", mode:"good", title:"APPROVED • Guardian Grade"};
  if(score >= 50) return {label:"OBSERVED", mode:"warn", title:"OBSERVED • Mixed Signals"};
  return {label:"FLAGGED", mode:"bad", title:"FLAGGED • High Risk"};
}

/* ===================== SOLANA RPC (Helius) ===================== */
const HELIUS_RPC = ()=> `https://mainnet.helius-rpc.com/?api-key=${encodeURIComponent(HELIUS_KEY)}`;
async function solRpc(method, params){
  if(!HELIUS_KEY) throw new Error("Helius key missing.");
  const res = await fetch(HELIUS_RPC(), {
    method:"POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ jsonrpc:"2.0", id:1, method, params })
  });
  if(!res.ok){
    const t = await res.text().catch(()=> "");
    throw new Error(`RPC HTTP ${res.status} ${t}`.slice(0,220));
  }
  const j = await res.json();
  if(j.error) throw new Error(j.error.message || "RPC error");
  return j.result;
}
async function getMintParsed(mint){
  const r = await solRpc("getAccountInfo", [mint, { encoding:"jsonParsed", commitment:"confirmed" }]);
  const v = r?.value;
  if(!v) return null;
  const owner = v.owner;
  const parsed = (v.data && typeof v.data === "object") ? v.data.parsed : null;
  const info = parsed?.info || null;
  const rawParsed = parsed || null;
  return { owner, info, rawParsed };
}
async function getTokenSupply(mint){
  const r = await solRpc("getTokenSupply", [mint]);
  return r?.value || null;
}
async function getLargest(mint){
  const r = await solRpc("getTokenLargestAccounts", [mint]);
  return r?.value || [];
}

/* Helius DAS metadata */
async function getAsset(mint){
  try{
    const r = await solRpc("getAsset", [mint]);
    return r || null;
  }catch(e){
    return null;
  }
}
function pickTokenMetaFromAsset(asset){
  if(!asset) return null;

  const md = asset?.content?.metadata || {};
  const name = (md?.name || asset?.metadata?.name || "").trim();
  const symbol = (md?.symbol || asset?.metadata?.symbol || "").trim();

  let image = "";
  const linksImg = asset?.content?.links?.image;
  if(typeof linksImg === "string") image = linksImg;

  if(!image && Array.isArray(asset?.content?.files)){
    const f = asset.content.files.find(x => (x?.mime || "").includes("image") && x?.uri);
    if(f?.uri) image = f.uri;
  }

  const uri = (asset?.content?.json_uri || asset?.content?.links?.external_url || "").trim();
  const description = (md?.description || asset?.content?.metadata?.description || "").trim();

  const authorities = Array.isArray(asset?.authorities) ? asset.authorities : [];
  return { name, symbol, image, uri, description, authorities, raw: asset };
}

/* Token-2022 extensions */
function parseExtensionsFromParsed(rawParsed){
  try{
    const info = rawParsed?.info || rawParsed?.parsed?.info || rawParsed?.data?.parsed?.info || null;
    if(!info) return null;

    const ex1 = info.extensions;
    const ex2 = info.extensionTypes;
    const ex3 = info.mintExtensions;

    let out = null;

    if(Array.isArray(ex1) && ex1.length){
      out = ex1.map(x=>{
        if(typeof x === "string") return { name:x, details:null };
        if(typeof x === "object" && x){
          const name = x.extension || x.type || x.name || "Extension";
          return { name, details:null };
        }
        return { name:String(x), details:null };
      });
    } else if(Array.isArray(ex2) && ex2.length){
      out = ex2.map(x=>({name:String(x), details:null}));
    } else if(ex3 && typeof ex3 === "object"){
      if(Array.isArray(ex3) && ex3.length){
        out = ex3.map(x=>({name: x?.type || x?.name || "Extension", details:null}));
      } else {
        out = Object.keys(ex3).map(k=>({name:k, details:null}));
      }
    }

    return out && out.length ? out : null;
  }catch{
    return null;
  }
}
function humanizeExtensionName(n){
  const s = String(n||"").toLowerCase();
  if(s.includes("transferfee") || s.includes("transfer_fee")) return "Transfer Fee (fee on transfers)";
  if(s.includes("permanentdelegate") || s.includes("permanent_delegate")) return "Permanent Delegate (delegate control)";
  if(s.includes("nontransferable") || s.includes("non_transferable")) return "Non-Transferable (cannot be transferred)";
  if(s.includes("interestbearing") || s.includes("interest_bearing")) return "Interest-Bearing (yield mechanics)";
  if(s.includes("confidential") ) return "Confidential Transfers (privacy mode)";
  if(s.includes("metadata")) return "Metadata Extension";
  return n;
}

/* ===================== SOLANA SCORING (same as your original) ===================== */
function scoreModelSol(sig){
  let score = 100;
  const checks = [];

  if(sig.freezeActive){
    score -= 35;
    checks.push({ k:"Freeze Authority active", sev:"bad", d:"Transfers can be frozen. High risk.", clickMsg: explainFreeze() });
  }else{
    checks.push({ k:"Freeze Authority removed", sev:"ok", d:"No freeze power detected (good).", clickMsg: explainFreeze() });
  }

  if(sig.mintAuthActive){
    score -= 30;
    checks.push({ k:"Mint Authority active", sev:"bad", d:"More supply can be minted. High risk.", clickMsg: explainMintAuth() });
  }else{
    checks.push({ k:"Mint Authority renounced", sev:"ok", d:"Supply can’t be increased (good).", clickMsg: explainMintAuth() });
  }

  const t20 = Number(sig.top20 || 0);
  if(t20 >= 75){
    score -= 28;
    checks.push({k:"Top 20 concentration very high", sev:"bad", d:`Top20 holds ~${t20.toFixed(2)}%.`, clickMsg: explainTop20(t20)});
  }else if(t20 >= 55){
    score -= 18;
    checks.push({k:"Top 20 concentration high", sev:"warn", d:`Top20 holds ~${t20.toFixed(2)}%.`, clickMsg: explainTop20(t20)});
  }else if(t20 >= 35){
    score -= 8;
    checks.push({k:"Top 20 concentration moderate", sev:"warn", d:`Top20 holds ~${t20.toFixed(2)}%.`, clickMsg: explainTop20(t20)});
  }else{
    checks.push({k:"Distribution looks healthier", sev:"ok", d:`Top20 holds ~${t20.toFixed(2)}%.`, clickMsg: explainTop20(t20)});
  }

  if(sig.programType === "TOKEN_2022"){
    score -= sig.extReadable ? 6 : 10;
    checks.push({
      k:"Token standard: Token-2022",
      sev:"warn",
      d: sig.extReadable ? "Can include extra rules (extensions)." : "Extensions not visible in this scan.",
      clickMsg: explainTokenStandard("TOKEN_2022", sig.extReadable)
    });
  }else if(sig.programType === "SPL_TOKEN"){
    checks.push({ k:"Token standard: SPL Token", sev:"ok", d:"Standard token program.", clickMsg: explainTokenStandard("SPL_TOKEN", true) });
  }else{
    score -= 10;
    checks.push({ k:"Token standard: Unknown program", sev:"warn", d:"Not a common token program.", clickMsg: explainTokenStandard("UNKNOWN", false) });
  }

  if(sig.meta && (sig.meta.name || sig.meta.symbol)){
    checks.push({ k:"Metadata present", sev:"ok", d:`Name/Symbol found.`, clickMsg: explainMetadataQuality() });
  }else{
    score -= 4;
    checks.push({ k:"Metadata missing or unreadable", sev:"warn", d:"Name/Symbol not found via metadata endpoint.", clickMsg: explainMetadataQuality() });
  }

  score = clamp(Math.round(score), 0, 100);
  const critical = !!(sig.freezeActive || sig.mintAuthActive);
  return { score, checks, critical };
}

function buildTodoSol(sig){
  const todos = [];
  if(sig.freezeActive){
    todos.push({t:"Remove Freeze Authority", sev:"bad", d:"Freezing can trap buyers.", clickMsg: explainFreeze()});
  }else{
    todos.push({t:"Freeze Authority", sev:"ok", d:"Already removed (good).", clickMsg: explainFreeze()});
  }

  if(sig.mintAuthActive){
    todos.push({t:"Renounce Mint Authority", sev:"bad", d:"Minting more tokens can crash price.", clickMsg: explainMintAuth()});
  }else{
    todos.push({t:"Mint Authority", sev:"ok", d:"Already renounced (good).", clickMsg: explainMintAuth()});
  }

  const t20 = Number(sig.top20 || 0);
  if(t20 >= 55){
    todos.push({t:"Reduce Whale Concentration", sev:"warn", d:`Top20 holds ~${t20.toFixed(2)}%.`, clickMsg: explainTop20(t20)});
  }else if(t20 >= 35){
    todos.push({t:"Monitor Distribution", sev:"warn", d:`Top20 holds ~${t20.toFixed(2)}%.`, clickMsg: explainTop20(t20)});
  }else{
    todos.push({t:"Distribution", sev:"ok", d:`Top20 ~${t20.toFixed(2)}% (healthier).`, clickMsg: explainTop20(t20)});
  }

  if(sig.programType === "TOKEN_2022"){
    todos.push({ t:"Token-2022 Safety Review", sev:"warn", d:"Token-2022 can include extra rules.", clickMsg: explainTokenStandard("TOKEN_2022", sig.extReadable) });
  } else if(sig.programType === "UNKNOWN"){
    todos.push({ t:"Verify Mint Program", sev:"warn", d:"Unknown program = extra caution.", clickMsg: explainTokenStandard("UNKNOWN", false) });
  } else {
    todos.push({ t:"Token Standard", sev:"ok", d:"Standard SPL Token.", clickMsg: explainTokenStandard("SPL_TOKEN", true) });
  }

  if(!(sig.meta && (sig.meta.name || sig.meta.symbol))){
    todos.push({ t:"Publish Token Metadata", sev:"warn", d:"Missing name/symbol makes fake copies easier.", clickMsg: explainMetadataQuality() });
  }else{
    todos.push({ t:"Metadata", sev:"ok", d:"Name/symbol present (good).", clickMsg: explainMetadataQuality() });
  }

  return todos;
}

function renderTokenStandardDetailsSol(programType, extReadable, extList){
  const el = $("extList");
  if(programType !== "TOKEN_2022"){
    const msg = programType === "SPL_TOKEN"
      ? "This mint uses the standard SPL Token program. Token-2022 extensions are not applicable."
      : "This mint does not use a standard SPL Token program. Treat unknown programs with caution.";
    renderList(el, [{
      t:"Token standard details",
      sev: programType === "SPL_TOKEN" ? "ok" : "warn",
      d: msg,
      clickMsg: explainTokenStandard(programType === "SPL_TOKEN" ? "SPL_TOKEN" : "UNKNOWN", extReadable)
    }], "Token standard details");
    return;
  }

  if(!extReadable){
    renderList(el, [{
      t:"Token-2022 extensions",
      sev:"warn",
      d:"Extensions not visible in this scan.",
      clickMsg: explainTokenStandard("TOKEN_2022", false)
    }], "Token-2022 extensions");
    return;
  }

  const items = extList.map((x)=>{
    const nameHuman = humanizeExtensionName(x.name);
    const lname = String(x.name||"").toLowerCase();

    let sev = "warn";
    let d = `Extension detected: ${nameHuman}.`;
    let lines = [
      "Meaning: Token-2022 can add extra rules.",
      "Why it matters: Some rules can add fees or restrictions.",
      "What to do: If you don’t understand it, treat as WATCH."
    ];

    if(lname.includes("transferfee")){
      lines = [
        "Meaning: Transfers may charge a fee.",
        "Why it matters: Fees can hurt buyers/sellers.",
        "What to do: Treat as WATCH unless fee is clearly disclosed."
      ];
    } else if(lname.includes("nontransferable")){
      sev = "bad";
      lines = [
        "Meaning: Token cannot be transferred normally.",
        "Why it matters: You may not be able to sell/send it.",
        "What to do: Avoid for memecoins. Treat as FAIL."
      ];
    } else if(lname.includes("permanentdelegate")){
      lines = [
        "Meaning: A delegate may have special control.",
        "Why it matters: Could enable unexpected behavior.",
        "What to do: Treat as WATCH unless explained clearly."
      ];
    } else if(lname.includes("metadata")){
      lines = [
        "Meaning: Token stores metadata rules on-chain.",
        "Why it matters: May allow updates depending on authority.",
        "What to do: Verify metadata matches official sources."
      ];
    }

    return { t: nameHuman, sev, d, clickMsg: explainSimple(nameHuman, lines) };
  });

  renderList(el, items, "Token-2022 Extension Details");
}

function renderMetadataPanelSol(meta){
  const el = $("metaList");
  if(!meta){
    renderList(el, [{
      t:"Metadata not available",
      sev:"warn",
      d:"Could not fetch metadata via getAsset.",
      clickMsg: explainMetadataQuality()
    }], "Token Metadata");
    return;
  }

  const items = [];
  items.push({
    t:"Name / Symbol",
    sev: (meta.name || meta.symbol) ? "ok" : "warn",
    d: `${meta.name || "—"} • ${meta.symbol ? "$"+meta.symbol : "—"}`,
    clickMsg: explainMetadataQuality()
  });

  items.push({
    t:"Metadata Link",
    sev: meta.uri ? "ok" : "warn",
    d: meta.uri ? "Metadata link found." : "No metadata link found.",
    clickMsg: explainSimple("Metadata Link", [
      "Meaning: A link where token info (name/logo) is hosted.",
      "Why it matters: Helps confirm you’re looking at the real token.",
      "What to do: Check it matches the official socials/listings."
    ])
  });

  items.push({
    t:"Image / Logo",
    sev: meta.image ? "ok" : "warn",
    d: meta.image ? "Logo found (shown above if loadable)." : "No logo found.",
    clickMsg: explainSimple("Token Logo", [
      "Meaning: Token picture/logo used in wallets and sites.",
      "Why it matters: Helps you avoid fake copies.",
      "What to do: Verify the logo matches official sources."
    ])
  });

  if(meta.description){
    items.push({
      t:"Description",
      sev:"ok",
      d: meta.description.slice(0,120) + (meta.description.length>120 ? "…" : ""),
      clickMsg: explainSimple("Description", [ meta.description ])
    });
  }

  if(Array.isArray(meta.authorities) && meta.authorities.length){
    items.push({
      t:"Authorities (metadata)",
      sev:"warn",
      d:"Metadata authorities exist (review).",
      clickMsg: explainSimple("Metadata Authorities", [
        "Meaning: Someone may be able to update token metadata.",
        "Why it matters: They could change name/logo/link later.",
        "What to do: Treat as WATCH unless authority is removed or clearly explained."
      ])
    });
  }

  renderList(el, items, "Token Metadata");
}

function renderHoldersSol(mint, uiSupply, largest){
  const list = $("holdersList");
  if(!uiSupply || !Array.isArray(largest) || !largest.length){
    renderList(list, [{
      t:"No holder data", sev:"warn",
      d:"Largest accounts not readable from RPC.",
      clickMsg: explainSimple("Top Holders", [
        "Meaning: We could not read the biggest holders right now.",
        "Why it matters: Holder distribution is important for risk.",
        "What to do: Try again later or use another RPC."
      ])
    }], "Top Holders");
    return;
  }
  const top = largest.slice(0,5);
  const items = top.map((x,i)=>{
    const addr = x?.address || "—";
    const amt = Number(x?.uiAmount || 0);
    const pct = uiSupply > 0 ? (amt / uiSupply) * 100 : 0;
    const sev = pct >= 10 ? "warn" : "ok";
    return {
      t: `#${i+1} ${shortAddr(addr)}`,
      sev,
      d: `${fmtInt(amt)} tokens • ${pct.toFixed(2)}%`,
      clickMsg: explainHolders(addr, pct.toFixed(2))
    };
  });
  renderList(list, items, "Top Holder Details");
}

/* ===================== EVM RPC + ERC-20 READS ===================== */

/* request timeout + retry over all RPCs */
async function evmRpc(chainId, method, params){
  const urls = EVM_RPCS[chainId] || [];
  if(!urls.length) throw new Error("No RPC configured for this chain.");

  const errors = [];
  for(let i=0;i<urls.length;i++){
    const url = urls[i];
    const ctrl = new AbortController();
    const t = setTimeout(()=>ctrl.abort(), 12000);

    try{
      const res = await fetch(url, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify({ jsonrpc:"2.0", id:1, method, params }),
        signal: ctrl.signal
      });
      clearTimeout(t);

      if(!res.ok){
        const tx = await res.text().catch(()=> "");
        errors.push(`HTTP ${res.status} ${tx}`.slice(0,180));
        continue;
      }
      const j = await res.json();
      if(j?.error){
        errors.push(String(j.error?.message || "RPC error").slice(0,180));
        continue;
      }
      return j.result;
    }catch(e){
      clearTimeout(t);
      errors.push(String(e?.message || e).slice(0,180));
      continue;
    }
  }

  throw new Error(`All RPCs failed (${urls.length}). Last errors: ${errors.slice(-3).join(" • ")}`);
}

/* Minimal ABI selectors */
const SEL = {
  name: "0x06fdde03",
  symbol: "0x95d89b41",
  decimals: "0x313ce567",
  totalSupply: "0x18160ddd",
  owner: "0x8da5cb5b",
  paused: "0x5c975abb"
};

function strip0x(h){ return (h||"").startsWith("0x") ? h.slice(2) : (h||""); }

function decodeUint256(hex){
  const h = strip0x(hex);
  if(!h || h.length === 0) return null;
  const padded = h.padStart(64,"0").slice(-64);
  try{ return BigInt("0x"+padded); }catch{ return null; }
}
function decodeAddressFrom32(hex){
  const h = strip0x(hex);
  if(!h) return null;
  const padded = h.padStart(64,"0").slice(-40);
  return "0x"+padded;
}
function bytes32ToAscii(hex){
  const h = strip0x(hex);
  if(!h || h.length !== 64) return "";
  try{
    const bytes = new Uint8Array(h.match(/.{1,2}/g).map(b=>parseInt(b,16)));
    let s = new TextDecoder().decode(bytes);
    s = (s||"").replace(/\0/g,"").trim();
    // only accept if looks printable
    if(!s) return "";
    if(/^[\x20-\x7E]+$/.test(s)) return s;
    return "";
  }catch{ return ""; }
}
function decodeString(hex){
  // Handle common cases:
  // 1) ABI string (offset + length + data)
  // 2) bytes32-returning tokens (older ERC-20 implementations)
  const data = strip0x(hex);
  if(!data) return "";

  // bytes32 direct
  if(data.length === 64){
    const b = bytes32ToAscii("0x"+data);
    if(b) return b;
  }

  // ABI string: offset(32) + length(32) + data
  if(data.length < 128) return "";
  const lenHex = data.slice(64,128);
  let len = 0;
  try{ len = Number(BigInt("0x"+lenHex)); }catch{ return ""; }
  if(!Number.isFinite(len) || len <= 0) return "";
  const strData = data.slice(128, 128 + len*2);
  if(!strData) return "";
  try{
    const bytes = new Uint8Array(strData.match(/.{1,2}/g).map(b=>parseInt(b,16)));
    const s = new TextDecoder().decode(bytes);
    return (s||"").replace(/\0/g,"").trim();
  }catch{
    return "";
  }
}

async function ethCall(chainId, to, data){
  return await evmRpc(chainId, "eth_call", [{ to, data }, "latest"]);
}
async function getCode(chainId, addr){
  return await evmRpc(chainId, "eth_getCode", [addr, "latest"]);
}

/* Proxy detection (EIP-1967 slots) */
const SLOT_IMPL = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
const SLOT_ADMIN= "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103";
async function getStorageAt(chainId, addr, slot){
  return await evmRpc(chainId, "eth_getStorageAt", [addr, slot, "latest"]);
}
async function detectProxy(chainId, addr){
  try{
    const [implRaw, adminRaw] = await Promise.all([
      getStorageAt(chainId, addr, SLOT_IMPL),
      getStorageAt(chainId, addr, SLOT_ADMIN)
    ]);
    const impl = decodeAddressFrom32(implRaw || "0x");
    const admin = decodeAddressFrom32(adminRaw || "0x");
    const implNonZero = impl && impl.toLowerCase() !== "0x0000000000000000000000000000000000000000";
    const adminNonZero = admin && admin.toLowerCase() !== "0x0000000000000000000000000000000000000000";
    return { isProxy: implNonZero || adminNonZero, implementation: implNonZero ? impl : null, admin: adminNonZero ? admin : null };
  }catch{
    return { isProxy:false, implementation:null, admin:null };
  }
}

/* ERC-20 meta (on-chain only) */
async function getErc20Meta(chainId, addr){
  const out = { name:"", symbol:"", decimals:null, totalSupply:null };

  try{
    const r = await ethCall(chainId, addr, SEL.name);
    out.name = decodeString(r);
  }catch{}

  try{
    const r = await ethCall(chainId, addr, SEL.symbol);
    out.symbol = decodeString(r);
  }catch{}

  try{
    const r = await ethCall(chainId, addr, SEL.decimals);
    const v = decodeUint256(r);
    out.decimals = (v === null) ? null : Number(v);
    if(!Number.isFinite(out.decimals)) out.decimals = null;
  }catch{}

  try{
    const r = await ethCall(chainId, addr, SEL.totalSupply);
    out.totalSupply = decodeUint256(r);
  }catch{}

  return out;
}
async function getOwner(chainId, addr){
  try{
    const r = await ethCall(chainId, addr, SEL.owner);
    const o = decodeAddressFrom32(r || "0x");
    return o;
  }catch{
    return null;
  }
}
async function getPaused(chainId, addr){
  try{
    const r = await ethCall(chainId, addr, SEL.paused);
    const v = decodeUint256(r || "0x");
    if(v === null) return null;
    return v !== 0n;
  }catch{
    return null;
  }
}

/* ===================== EVM SCORING (safe, on-chain only, no indexers) ===================== */
function scoreModelEvm(sig){
  let score = 100;
  const checks = [];

  // Contract exists
  if(!sig.hasCode){
    score = 0;
    checks.push({ k:"Contract not found", sev:"bad", d:"No bytecode at this address.", clickMsg: explainEvmTokenBasics() });
    return { score:0, checks, critical:true };
  } else {
    checks.push({ k:"Contract found", sev:"ok", d:"Bytecode exists at address.", clickMsg: explainEvmTokenBasics() });
  }

  // ERC-20 basics
  const hasName = !!sig.meta?.name;
  const hasSymbol = !!sig.meta?.symbol;
  const decOk = Number.isFinite(sig.meta?.decimals) && sig.meta.decimals >= 0 && sig.meta.decimals <= 36;

  if(!hasName || !hasSymbol){
    score -= 10;
    checks.push({ k:"ERC-20 metadata missing", sev:"warn", d:"Name or symbol could not be read (some tokens use non-standard returns).", clickMsg: explainEvmTokenBasics() });
  } else {
    checks.push({ k:"ERC-20 metadata readable", sev:"ok", d:"Name and symbol read successfully.", clickMsg: explainEvmTokenBasics() });
  }

  if(!decOk){
    score -= 12;
    checks.push({ k:"Decimals not readable / unusual", sev:"warn", d:"decimals() did not respond or out of expected range.", clickMsg: explainEvmTokenBasics() });
  } else {
    checks.push({ k:"Decimals readable", sev:"ok", d:`Decimals: ${sig.meta.decimals}`, clickMsg: explainEvmTokenBasics() });
  }

  if(sig.meta?.totalSupply === null || sig.meta?.totalSupply === undefined){
    score -= 10;
    checks.push({ k:"Total supply not readable", sev:"warn", d:"totalSupply() did not respond (or reverted).", clickMsg: explainEvmTokenBasics() });
  } else {
    checks.push({ k:"Total supply readable", sev:"ok", d:"totalSupply() responded.", clickMsg: explainEvmTokenBasics() });
  }

  // Owner (heuristic)
  if(sig.owner){
    const zero = "0x0000000000000000000000000000000000000000";
    if(sig.owner.toLowerCase() === zero){
      checks.push({ k:"Owner renounced", sev:"ok", d:"owner() is zero address.", clickMsg: explainEvmOwnership() });
    } else {
      score -= 22;
      checks.push({ k:"Owner active", sev:"warn", d:`owner(): ${shortAddr(sig.owner)}`, clickMsg: explainEvmOwnership() });
    }
  } else {
    score -= 6;
    checks.push({ k:"Owner not detectable", sev:"warn", d:"owner() not present or unreadable (common on some tokens).", clickMsg: explainEvmOwnership() });
  }

  // Proxy detection
  if(sig.proxy?.isProxy){
    score -= 18;
    checks.push({
      k:"Upgradeable / Proxy detected",
      sev:"warn",
      d:`Implementation: ${sig.proxy.implementation ? shortAddr(sig.proxy.implementation) : "unknown"} • Admin: ${sig.proxy.admin ? shortAddr(sig.proxy.admin) : "unknown"}`,
      clickMsg: explainEvmProxy()
    });
  } else {
    checks.push({ k:"No proxy detected (heuristic)", sev:"ok", d:"No EIP-1967 slots set (best-effort).", clickMsg: explainEvmProxy() });
  }

  // Pausable heuristic
  if(sig.paused === true){
    score -= 25;
    checks.push({ k:"Paused state: TRUE", sev:"bad", d:"Contract appears paused (transfers may be blocked).", clickMsg: explainEvmPause() });
  } else if(sig.paused === false){
    score -= 6;
    checks.push({ k:"Pause capability detected", sev:"warn", d:"paused() exists and is false (capability may exist).", clickMsg: explainEvmPause() });
  } else {
    checks.push({ k:"Pause not detectable", sev:"ok", d:"paused() not present (or unreadable).", clickMsg: explainEvmPause() });
  }

  score = clamp(Math.round(score), 0, 100);
  const critical = !!(sig.paused === true || !sig.hasCode);
  return { score, checks, critical };
}

function buildTodoEvm(sig){
  const todos = [];

  if(!sig.hasCode){
    todos.push({ t:"Fix address", sev:"bad", d:"No contract at this address.", clickMsg: explainEvmTokenBasics() });
    return todos;
  }

  if(sig.owner && sig.owner.toLowerCase() !== "0x0000000000000000000000000000000000000000"){
    todos.push({ t:"Renounce / Secure Owner", sev:"warn", d:"Owner/admin is active.", clickMsg: explainEvmOwnership() });
  } else if(sig.owner && sig.owner.toLowerCase() === "0x0000000000000000000000000000000000000000"){
    todos.push({ t:"Owner", sev:"ok", d:"Owner appears renounced.", clickMsg: explainEvmOwnership() });
  } else {
    todos.push({ t:"Owner review", sev:"warn", d:"Owner not detectable; review admin controls.", clickMsg: explainEvmOwnership() });
  }

  if(sig.proxy?.isProxy){
    todos.push({ t:"Upgradeability review", sev:"warn", d:"Proxy detected; upgrades can change behavior.", clickMsg: explainEvmProxy() });
  } else {
    todos.push({ t:"Upgradeability", sev:"ok", d:"No proxy detected (best-effort).", clickMsg: explainEvmProxy() });
  }

  if(sig.paused === true){
    todos.push({ t:"Unpause transfers", sev:"bad", d:"Token appears paused.", clickMsg: explainEvmPause() });
  } else if(sig.paused === false){
    todos.push({ t:"Pause capability disclosure", sev:"warn", d:"Pausable pattern detected; disclose rules.", clickMsg: explainEvmPause() });
  } else {
    todos.push({ t:"Transfer controls", sev:"ok", d:"Pause not detectable.", clickMsg: explainEvmPause() });
  }

  if(!(sig.meta?.name && sig.meta?.symbol)){
    todos.push({ t:"Fix token metadata", sev:"warn", d:"Name/symbol missing or non-standard.", clickMsg: explainEvmTokenBasics() });
  } else {
    todos.push({ t:"Metadata", sev:"ok", d:"Name/symbol readable.", clickMsg: explainEvmTokenBasics() });
  }

  // Holders note (EVM limitation)
  todos.push({ t:"Holders distribution", sev:"warn", d:"Top holders need an indexer on EVM.", clickMsg: explainEvmHoldersLimit() });

  return todos;
}

function renderStandardDetailsEvm(sig){
  const el = $("extList");
  const items = [];

  items.push({
    t:"Token standard",
    sev:"ok",
    d:"ERC-20 (checked by on-chain calls).",
    clickMsg: explainEvmTokenBasics()
  });

  items.push({
    t:"Proxy / upgradeability",
    sev: sig.proxy?.isProxy ? "warn" : "ok",
    d: sig.proxy?.isProxy ? "Proxy detected (upgradeable)." : "No proxy detected (best-effort).",
    clickMsg: explainEvmProxy()
  });

  items.push({
    t:"Pause capability (heuristic)",
    sev: sig.paused === true ? "bad" : (sig.paused === false ? "warn" : "ok"),
    d: sig.paused === true ? "Token appears paused." : (sig.paused === false ? "paused() exists (capability likely)." : "paused() not detected."),
    clickMsg: explainEvmPause()
  });

  renderList(el, items, "Token Standard Details");
}

function renderMetadataPanelEvm(meta){
  const el = $("metaList");
  const items = [];

  items.push({
    t:"Name / Symbol",
    sev: (meta?.name && meta?.symbol) ? "ok" : "warn",
    d: `${meta?.name || "—"} • ${meta?.symbol ? "$"+meta.symbol : "—"}`,
    clickMsg: explainEvmTokenBasics()
  });

  items.push({
    t:"Decimals",
    sev: Number.isFinite(meta?.decimals) ? "ok" : "warn",
    d: Number.isFinite(meta?.decimals) ? String(meta.decimals) : "Not readable",
    clickMsg: explainEvmTokenBasics()
  });

  items.push({
    t:"Total Supply",
    sev: (meta?.totalSupply !== null && meta?.totalSupply !== undefined) ? "ok" : "warn",
    d: (meta?.totalSupply !== null && meta?.totalSupply !== undefined) ? "Readable on-chain" : "Not readable",
    clickMsg: explainEvmTokenBasics()
  });

  // Note: logos are not reliably on-chain for EVM tokens without token lists or explorers.
  items.push({
    t:"Logo / Image",
    sev:"warn",
    d:"EVM logos are not reliably on-chain via raw RPC.",
    clickMsg: explainSimple("Token Logo (EVM)", [
      "Meaning: Most EVM tokens do not store a logo URI on-chain.",
      "Why it matters: UIs typically use token lists or explorer metadata.",
      "What to do: If you want logos here, add a tokenlist integration or an explorer API."
    ])
  });

  renderList(el, items, "Token Metadata");
}

function renderHoldersEvm(){
  renderList($("holdersList"), [{
    t:"Top holders not available via raw RPC",
    sev:"warn",
    d:"EVM holder ranking requires an indexer (not RPC).",
    clickMsg: explainEvmHoldersLimit()
  }], "Top Holders");
}

/* ===================== SCAN DISPATCH ===================== */
function resetBeforeScan(addr){
  setShareEnabled(false);
  setStatus("Running Guardian Check…");
  setText("mintShort", shortAddr(addr));
  setText("verdictTitle","—");
  setBadge($("verdictBadge"),"—");
  setText("scoreBadge","—");
  setText("summary","—");
  setText("scanHint","—");
  $("sharePanel").style.display = "none";

  setText("tokenName","—");
  setText("tokenSymbol","—");
  $("tokenLogoWrap").style.display = "none";

  $("metrics").innerHTML = "";

  LAST_SCAN = null;
  $("btnExport").disabled = true;
  $("btnExport").textContent = "Export Report (JSON)";
}

async function scanSolana(mint){
  const mintParsed = await getMintParsed(mint);
  if(!mintParsed || !mintParsed.info) throw new Error("Mint not readable (not a token mint).");

  const owner = mintParsed.owner;
  const info = mintParsed.info;
  const rawParsed = mintParsed.rawParsed;

  const mintAuthority = info.mintAuthority ?? null;
  const freezeAuthority = info.freezeAuthority ?? null;
  const decimals = Number(info.decimals ?? 0);

  const programType =
    owner === TOKEN_PROGRAM ? "SPL_TOKEN" :
    owner === TOKEN_2022_PROGRAM ? "TOKEN_2022" :
    "UNKNOWN";

  const [supply, largest, asset] = await Promise.all([
    getTokenSupply(mint),
    getLargest(mint),
    getAsset(mint)
  ]);

  const meta = pickTokenMetaFromAsset(asset);
  applyTokenHeader(meta, mint);
  renderMetadataPanelSol(meta);

  const uiSupply = supply ? Number(supply.uiAmount ?? 0) : null;
  const top20 = (Array.isArray(largest) ? largest.slice(0,20) : []);
  const top20Sum = top20.reduce((acc,x)=> acc + Number(x.uiAmount || 0), 0);
  const conc = (uiSupply && uiSupply > 0) ? (top20Sum / uiSupply) * 100 : 0;

  const extRaw = programType === "TOKEN_2022" ? parseExtensionsFromParsed(rawParsed) : null;
  const extReadable = !!(extRaw && extRaw.length);

  const sig = {
    mintAuthActive: !!mintAuthority,
    freezeActive: !!freezeAuthority,
    top20: conc,
    programType,
    extReadable,
    meta: meta || null
  };

  const model = scoreModelSol(sig);
  const verdict = verdictFrom(model.score, model.critical);

  setText("verdictTitle", verdict.title);
  setBadge($("verdictBadge"), verdict.label, verdict.mode);
  $("scoreBadge").textContent = `SCORE ${model.score}`;

  const authLine = `${sig.mintAuthActive ? "MINT ACTIVE" : "MINT RENOUNCED"} • ${sig.freezeActive ? "FREEZE ACTIVE" : "FREEZE REMOVED"}`;
  const programText = sig.programType === "SPL_TOKEN" ? "SPL Token" : (sig.programType === "TOKEN_2022" ? "Token-2022" : "Unknown");
  renderMetricsGeneric([
    { label:"Chain", value:"Solana", badge:"SOL", mini:"Mainnet" },
    { label:"Risk Score", value:`${model.score}/100`, badge:"SCORE", mini: model.score>=80 ? "Looks safer than average (still not guaranteed)." : (model.score>=50 ? "Mixed signals — read WATCH items." : "High risk signals — be careful."), barPct:model.score },
    { label:"Authorities", value:authLine, badge:"AUTH", mini: (sig.mintAuthActive||sig.freezeActive) ? "Authorities present = higher trust risk." : "No mint/freeze authority (good)." },
    { label:"Top 20 Concentration", value:fmtPct(sig.top20), badge:"TOP20", mini:(uiSupply ? `Top20: ${fmtInt(top20Sum)} / ${fmtInt(uiSupply)} • Decimals ${decimals}` : `Decimals ${decimals}`), barPct:sig.top20 },
    { label:"Token Standard", value:programText, badge:"STD", mini: owner ? `Mint program owner: ${shortAddr(owner)}` : "—" },
    { label:"Supply", value: uiSupply ? fmtInt(uiSupply) : "—", badge:"UI", mini:"UI supply (RPC)" },
  ]);

  setText("scanHint", `Chain: Solana • Mint: ${shortAddr(mint)}`);
  renderList($("checksList"), model.checks, "Guardian Check Details");
  renderList($("todoList"), buildTodoSol(sig), "Launch Readiness Details");
  renderTokenStandardDetailsSol(programType, extReadable, extRaw || []);
  renderHoldersSol(mint, uiSupply, largest);

  const authLineShort = `${mintAuthority ? "MINT: ACTIVE" : "MINT: RENOUNCED"} • ${freezeAuthority ? "FREEZE: ACTIVE" : "FREEZE: REMOVED"}`;
  const extLine = (programType === "TOKEN_2022")
    ? (extReadable ? ` • Extensions: visible (${(extRaw||[]).length})` : ` • Extensions: not visible`)
    : "";
  const metaLine = (meta && (meta.name || meta.symbol)) ? ` • ${meta.symbol ? "$"+meta.symbol : ""} ${meta.name ? meta.name : ""}`.trim() : "";
  setText("summary", `${verdict.label} • Score ${model.score}/100 • ${authLineShort} • Top20 ${fmtPct(conc)} • Standard ${programText}${extLine}${metaLine ? " • " + metaLine : ""} • Decimals ${decimals}`);

  // Share (clean link)
  const shareUrl = buildShareLink(activeChain.id, mint);
  setText("scanLink", shareUrl);
  setText("badgeHtml", shareUrl); // repurposed field
  $("sharePanel").style.display = "";
  setShareEnabled(true, shareUrl);

  // Export payload
  LAST_SCAN = {
    version: "guardian-check-v2",
    ts: new Date().toISOString(),
    chain: { id: activeChain.id, name: activeChain.name, kind: activeChain.kind, stamp: activeChain.stamp },
    address: mint,
    token: { name: meta?.name || "", symbol: meta?.symbol || "", image: meta?.image || "", uri: meta?.uri || "" },
    solana: {
      programOwner: owner,
      programType,
      decimals,
      mintAuthorityActive: !!mintAuthority,
      freezeAuthorityActive: !!freezeAuthority,
      top20ConcentrationPct: Number(conc || 0),
      extensions: extReadable ? (extRaw || []).map(x=>x.name) : []
    },
    verdict,
    score: model.score,
    summary: $("summary")?.textContent || "",
    checks: model.checks,
    todos: buildTodoSol(sig)
  };
  $("btnExport").disabled = false;
  $("btnExport").textContent = "Export Report (JSON)";

  setStatus(`Guardian Check complete: ${verdict.label} • Score ${model.score}/100`);
}

async function scanEvm(addr){
  const chainId = activeChain.chainId;

  const code = await getCode(chainId, addr);
  const hasCode = !!(code && code !== "0x");

  const [meta, owner, paused, proxy] = await Promise.all([
    hasCode ? getErc20Meta(chainId, addr) : Promise.resolve({name:"",symbol:"",decimals:null,totalSupply:null}),
    hasCode ? getOwner(chainId, addr) : Promise.resolve(null),
    hasCode ? getPaused(chainId, addr) : Promise.resolve(null),
    hasCode ? detectProxy(chainId, addr) : Promise.resolve({isProxy:false,implementation:null,admin:null})
  ]);

  applyTokenHeader({ name: meta?.name || "Token", symbol: meta?.symbol || "" }, addr);
  renderMetadataPanelEvm(meta);

  const sig = { hasCode, meta, owner, paused, proxy };

  const model = scoreModelEvm(sig);
  const verdict = verdictFrom(model.score, model.critical);

  setText("verdictTitle", verdict.title);
  setBadge($("verdictBadge"), verdict.label, verdict.mode);
  $("scoreBadge").textContent = `SCORE ${model.score}`;

  const ownerLine = owner ? shortAddr(owner) : "Unknown";
  const proxyLine = proxy?.isProxy ? `Proxy (impl ${proxy.implementation ? shortAddr(proxy.implementation) : "?"})` : "No proxy detected";
  const pauseLine = paused === true ? "Paused = TRUE" : (paused === false ? "Paused = FALSE (capability likely)" : "Pause not detected");

  const totalSupplyReadable = (meta?.totalSupply !== null && meta?.totalSupply !== undefined);
  const dec = Number.isFinite(meta?.decimals) ? meta.decimals : null;

  renderMetricsGeneric([
    { label:"Chain", value: activeChain.name, badge: activeChain.id.toUpperCase(), mini: activeChain.stamp },
    { label:"Risk Score", value:`${model.score}/100`, badge:"SCORE", mini: model.score>=80 ? "Looks safer than average (still not guaranteed)." : (model.score>=50 ? "Mixed signals — read WATCH items." : "High risk signals — be careful."), barPct:model.score },
    { label:"Contract", value: hasCode ? "Bytecode present" : "No code", badge:"CODE", mini: hasCode ? "Contract exists on-chain." : "This address is not a contract." },
    { label:"Owner/Admin", value: ownerLine, badge:"ADMIN", mini:"Heuristic via owner() if present." },
    { label:"Proxy", value: proxyLine, badge:"PROXY", mini:"Heuristic via EIP-1967 slots." },
    { label:"Transfers", value: pauseLine, badge:"CTRL", mini:"Heuristic via paused()." },
    { label:"Supply", value: totalSupplyReadable ? "Readable on-chain" : "Not readable", badge:"SUP", mini: dec !== null ? `Decimals: ${dec}` : "Decimals: —" },
  ]);

  setText("scanHint", `Chain: ${activeChain.name} • Addr: ${shortAddr(addr)}`);
  renderList($("checksList"), model.checks, "Guardian Check Details");
  renderList($("todoList"), buildTodoEvm(sig), "Launch Readiness Details");
  renderStandardDetailsEvm(sig);
  renderHoldersEvm();

  const tokenLine = `${meta?.symbol ? "$"+meta.symbol : "—"} • ${meta?.name || "—"}`;
  const adminLine = owner ? `OWNER: ${shortAddr(owner)}` : "OWNER: UNKNOWN";
  const standardLine = "ERC-20";
  setText("summary", `${verdict.label} • Score ${model.score}/100 • ${adminLine} • ${proxy?.isProxy ? "PROXY: YES" : "PROXY: NO"} • ${paused===true ? "PAUSED: YES" : (paused===false ? "PAUSED: NO (capable)" : "PAUSED: n/a")} • Standard ${standardLine} • ${tokenLine}`);

  // Share (clean link)
  const shareUrl = buildShareLink(activeChain.id, addr);
  setText("scanLink", shareUrl);
  setText("badgeHtml", shareUrl); // repurposed field
  $("sharePanel").style.display = "";
  setShareEnabled(true, shareUrl);

  // Export payload
  LAST_SCAN = {
    version: "guardian-check-v2",
    ts: new Date().toISOString(),
    chain: { id: activeChain.id, name: activeChain.name, kind: activeChain.kind, chainId: activeChain.chainId, stamp: activeChain.stamp },
    address: addr,
    token: { name: meta?.name || "", symbol: meta?.symbol || "" },
    evm: {
      hasCode,
      proxy,
      owner: owner || "",
      paused: paused,
      decimals: Number.isFinite(meta?.decimals) ? meta.decimals : null,
      totalSupplyReadable: totalSupplyReadable,
      totalSupply: (meta?.totalSupply !== null && meta?.totalSupply !== undefined) ? meta.totalSupply.toString() : null
    },
    verdict,
    score: model.score,
    summary: $("summary")?.textContent || "",
    checks: model.checks,
    todos: buildTodoEvm(sig),
    rpcInfo: { endpointsTried: (EVM_RPCS[chainId] || []).slice() }
  };
  $("btnExport").disabled = false;
  $("btnExport").textContent = "Export Report (JSON)";

  setStatus(`Guardian Check complete: ${verdict.label} • Score ${model.score}/100`);
}

/* ===================== MAIN SCAN ===================== */
async function scan(){
  const addr = $("mint").value.trim();
  clearErrorsOnly();

  setShareEnabled(false);

  if(activeChain.kind === "solana"){
    if(!looksBase58(addr)){ setStatus("Invalid Solana mint address."); return; }
  }else{
    if(!looksEvmAddress(addr)){ setStatus("Invalid EVM address (must be 0x + 40 hex chars)."); return; }
  }

  resetBeforeScan(addr);

  try{
    if(activeChain.kind === "solana"){
      await scanSolana(addr);
    }else{
      await scanEvm(addr);
    }
  }catch(e){
    console.error(e);
    setStatus("Scan failed: " + (e?.message || "unknown error"));
  }
}

function clearErrorsOnly(){
  setStatus("");
}

/* Click handling for pills: open modal with ONLY simple explanation */
document.addEventListener("click", (e)=>{
  const pill = e.target.closest?.(".pill");
  if(!pill) return;
  const msg = pill.getAttribute("data-msg");
  const title = pill.getAttribute("data-title") || "Guardian Details";
  if(msg && msg.trim() && msg.trim() !== "—"){
    openModal(title, msg);
  }
});
document.addEventListener("keydown", (e)=>{
  if((e.key === "Enter" || e.key === " ") && document.activeElement?.classList?.contains("pill")){
    e.preventDefault();
    const pill = document.activeElement;
    const msg = pill.getAttribute("data-msg");
    const title = pill.getAttribute("data-title") || "Guardian Details";
    if(msg && msg.trim() && msg.trim() !== "—"){
      openModal(title, msg);
    }
  }
});

$("btnScan").addEventListener("click", scan);
$("btnScanInline").addEventListener("click", scan);
$("mint").addEventListener("keydown", (e)=>{ if(e.key==="Enter") scan(); });

$("btnExport").addEventListener("click", ()=>{
  if(!LAST_SCAN) return;
  const addr = LAST_SCAN.address || "token";
  const chain = LAST_SCAN.chain?.id || "chain";
  const ts = (LAST_SCAN.ts || new Date().toISOString()).replaceAll(":","-");
  const fname = `guardian-report_${chain}_${addr.slice(0,10)}_${ts}.json`;
  downloadJson(fname, LAST_SCAN);
});

/* ===== INIT ===== */
function initFromUrl(){
  const q = new URLSearchParams(location.search);
  const chain = (q.get("chain") || "sol").trim().toLowerCase();
  const m = (q.get("mint") || "").trim();

  setActiveChain(chain, false);
  if(m){
    $("mint").value = m;
    setTimeout(()=>scan(), 120);
  }
}

renderChainButtons();
setActiveChain("sol", false);
clearUI();
initFromUrl();
</script>
</body>
</html>
