<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <!-- Mobile: kein erzwungenes Zoom-Lock, aber iOS-Input-Zoom wird durch 16px verhindert -->
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#070711" />
  <title>$SOS ‚Äî Guardian Check</title>
  <meta name="description" content="Guardian Approved ‚Äî Solana token risk score + launch readiness checklist (on-chain verifiable)." />

  <style>
    :root{
      --bg:#070711;
      --panel: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);

      --g:#14F195;
      --c:#00D1FF;
      --p:#9945FF;

      --radius: 22px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --max: 1180px;
    }

    *{box-sizing:border-box; max-width:100%}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--text);
      font: 15.5px/1.55 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: var(--bg);
      overflow-x:hidden; /* prevent accidental horizontal scroll */
      position:relative;
      touch-action: pan-y; /* keeps vertical scroll responsive on mobile */
    }
    body::before{
      content:"";
      position:fixed; inset:0; z-index:-1; pointer-events:none;
      background:
        radial-gradient(1200px 700px at 10% 5%, rgba(153,69,255,.22), transparent 60%),
        radial-gradient(1000px 650px at 90% 10%, rgba(20,241,149,.18), transparent 55%),
        radial-gradient(900px 600px at 70% 85%, rgba(0,209,255,.14), transparent 55%),
        var(--bg);
      transform: translateZ(0);
    }

    a{color:inherit; text-decoration:none}
    .wrap{max-width:var(--max); margin:0 auto; padding:0 18px}
    main{padding:22px 0 42px}

    .topbar{
      position:sticky; top:0; z-index:20;
      backdrop-filter: blur(14px);
      background: rgba(7,7,17,.62);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .row{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px;
      padding:12px 0;
      flex-wrap:wrap;
    }
    .brand{
      display:flex; align-items:center; gap:12px;
      min-width: 260px;
      user-select:none;
    }
    .brand img{
      width:40px; height:40px; object-fit:contain;
      filter: drop-shadow(0 10px 25px rgba(0,0,0,.45));
    }
    .bt{display:flex; flex-direction:column; line-height:1.05}
    .bt .t{font-weight:1000; letter-spacing:-.2px; font-size:16px}
    .bt .s{font-weight:850; color:var(--muted); font-size:12.5px}

    .actions{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      justify-content:flex-end;
      width:100%;
    }
    @media (min-width: 980px){ .actions{width:auto} }

    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      padding:9px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      font-weight:950;
      font-size:13px;
      transition: .15s ease;
      user-select:none;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      white-space:nowrap;
    }
    .btn:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .btn.grad{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .btn[disabled]{opacity:.55; pointer-events:none}

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.05));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .inner{padding:22px}

    .hero{
      position:relative;
      overflow:hidden;
      isolation:isolate;
    }
    .hero::before{
      content:"";
      position:absolute;
      inset:-70px -40px;
      background:
        radial-gradient(900px 520px at 18% 28%, rgba(20,241,149,.16), transparent 60%),
        radial-gradient(900px 520px at 82% 20%, rgba(0,209,255,.12), transparent 60%),
        radial-gradient(900px 520px at 70% 86%, rgba(153,69,255,.14), transparent 60%);
      z-index:0; pointer-events:none;
    }
    .hero > *{position:relative; z-index:1}

    .h1{
      margin:0;
      font-weight:1000;
      letter-spacing:-1px;
      line-height:1.05;
      font-size: clamp(36px, 4.6vw, 62px);
    }
    .gradText{
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      -webkit-background-clip:text; background-clip:text; color:transparent;
    }
    .sub{
      margin-top:10px;
      color: rgba(255,255,255,.76);
      font-weight:850;
      max-width: 940px;
    }

    .classified{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; flex-wrap:wrap;
    }
    .stamp{
      font-weight:1000;
      font-size:12px;
      letter-spacing: .45px;
      text-transform:uppercase;
      color: rgba(255,255,255,.76);
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius: 999px;
      padding:7px 10px;
    }

    .layout{
      margin-top:16px;
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 980px){ .layout{grid-template-columns:1fr} }

    .panel{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 18px;
      padding:16px;
      overflow:hidden;
    }

    label{
      display:block;
      font-weight:950;
      font-size:12.5px;
      letter-spacing:.35px;
      color: rgba(255,255,255,.82);
      margin-bottom:8px
    }
    input{
      width:100%;
      padding:14px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.92);
      outline:none;
      font-weight:900;
      letter-spacing:.2px;
      font-size:16px; /* prevents iOS auto-zoom */
    }
    input:focus{
      border-color: rgba(0,209,255,.45);
      box-shadow: 0 0 0 3px rgba(0,209,255,.12);
    }

    .statusLine{
      margin-top:12px;
      color: rgba(255,255,255,.72);
      font-weight:900;
      min-height: 18px;
      font-size:13px;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    .badge{
      display:inline-flex; align-items:center; justify-content:center;
      padding:7px 11px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
    }
    .badge.good{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}
    .badge.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .badge.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}

    /* ===== RESULT ===== */
    .resultTop{
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:12px; flex-wrap:wrap;
    }
    .resultTitle{
      margin:0;
      font-weight:1000;
      font-size:22px;
      letter-spacing:-.4px;
    }
    .mono{
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-weight:900;
      color: rgba(255,255,255,.86);
      margin-top:6px;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* Token header (name/symbol/logo) */
    .tokenHead{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .tokenLogoWrap{
      width:44px; height:44px;
      border-radius:12px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      display:none; /* shown if we have a logo */
      flex:0 0 auto;
    }
    .tokenLogoWrap img{
      width:100%; height:100%;
      object-fit:cover;
      display:block;
    }
    .tokenName{
      font-weight:1000;
      font-size:16px;
      letter-spacing:-.2px;
      line-height:1.15;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .tokenSymbol{
      margin-top:2px;
      color: rgba(255,255,255,.70);
      font-weight:900;
      font-size:12.5px;
    }

    .metricStack{margin-top:12px; display:grid; gap:10px;}
    .metric{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      border-radius: 16px;
      padding:12px 12px;
    }
    .metricK{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      color: rgba(255,255,255,.70);
      font-weight:1000;
      font-size:12px;
      letter-spacing:.45px;
      text-transform:uppercase;
    }
    .metricV{
      margin-top:8px;
      font-weight:1000;
      font-size:20px;
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .metricMini{
      margin-top:6px;
      font-weight:850;
      font-size:12px;
      color: rgba(255,255,255,.62);
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .bar{
      margin-top:10px;
      height:12px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .bar > div{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      border-radius:999px;
      transition: width .25s ease;
    }

    .list{
      margin:10px 0 0;
      padding:0;
      list-style:none;
      display:grid;
      gap:10px;
    }
    .li{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      border-radius: 16px;
      padding:12px 12px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      overflow:hidden;
    }
    .li .left{min-width:0;}
    .li .t{font-weight:1000; font-size:13px; letter-spacing:.2px;}
    .li .d{
      margin-top:4px;
      color: rgba(255,255,255,.70);
      font-weight:750;
      font-size:12.5px;
      line-height:1.35;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .pill{
      flex:0 0 auto;
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .pill.ok{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}
    .pill.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .pill.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}

    details.shareBox{
      margin-top:12px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      padding: 12px 12px;
    }
    details.shareBox summary{
      cursor:pointer;
      font-weight: 1000;
      color: rgba(255,255,255,.86);
      list-style:none;
    }
    details.shareBox summary::-webkit-details-marker{display:none}
    .shareInner{margin-top:12px; display:grid; gap:10px;}
    .copyBox{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.16);
      border-radius: 16px;
      padding:12px 12px;
      cursor:pointer;
      overflow:hidden;
    }
    .copyMono{
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-weight:900;
      color: rgba(255,255,255,.86);
      overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      max-width: 100%;
    }
    .hint{
      flex:0 0 auto;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
    }
    .hint.ok{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}

    footer{
      padding: 18px 0 34px;
      color: rgba(255,255,255,.45);
      font-weight:650;
      text-align:center;
      font-size:12px;
    }

    /* ===== Modal (for WATCH/FAIL details) ===== */
    .modalWrap{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:100;
    }
    .modal{
      width:min(920px, 100%);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(7,7,17,.92);
      box-shadow: 0 16px 50px rgba(0,0,0,.5);
      overflow:hidden;
    }
    .modalHead{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .modalTitle{
      font-weight:1000;
      letter-spacing:-.3px;
    }
    .modalBody{
      padding:14px 16px 16px;
      color: rgba(255,255,255,.82);
      font-weight:800;
      line-height:1.5;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* IMPORTANT: no code blocks for amateurs */
    .modalBody code{ display:none !important; }

    /* reduce motion */
    @media (prefers-reduced-motion: reduce){
      .btn:hover{transform:none}
      .bar > div{transition:none}
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="wrap">
      <div class="row">
        <div class="brand">
          <img src="../assets/logo.png" alt="$SOS" onerror="this.style.display='none'">
          <div class="bt">
            <div class="t">$SOS</div>
            <div class="s">Guardian Check ‚Ä¢ Token Risk</div>
          </div>
        </div>

        <div class="actions">
          <a class="btn" href="https://solanax1.com/" rel="noreferrer">‚Üê Back to Main</a>
          <button class="btn grad" id="btnScan">Run Guardian Check</button>
          <a class="btn" id="btnShare" href="#" target="_blank" rel="noreferrer" style="opacity:.55; pointer-events:none;">Share on X</a>
        </div>
      </div>
    </div>
  </div>

  <main class="wrap">
    <section class="card hero">
      <div class="inner">
        <div class="classified">
          <div class="stamp">GUARDIAN SYSTEM ‚Ä¢ MAINNET ‚Ä¢ ON-CHAIN VERIFIED</div>
          <div class="stamp" id="stampTime">‚Äî</div>
        </div>

        <h1 class="h1" style="margin-top:12px;"><span class="gradText">Guardian Approved</span> Check</h1>
        <div class="sub">
          On-chain scan: authorities + holder concentration + token standard + supply. WATCH/FAIL items are clickable and explain exactly what it means and what to do.
        </div>

        <div class="layout">
          <!-- INPUT -->
          <div class="panel">
            <label for="mint">Token Mint Address</label>
            <input id="mint" placeholder="Paste token mint (Solana)..." autocomplete="off" spellcheck="false" inputmode="text" />
            <div class="statusLine" id="status"></div>

            <details class="shareBox" id="sharePanel" style="display:none;">
              <summary>Share & Badge</summary>
              <div class="shareInner">
                <div class="copyBox" id="badgeCopy" role="button" tabindex="0" aria-label="Copy Badge HTML">
                  <div style="min-width:0">
                    <div style="font-weight:1000; font-size:12px; letter-spacing:.35px; color:rgba(255,255,255,.78); text-transform:uppercase;">Badge Embed (HTML)</div>
                    <div class="copyMono" id="badgeHtml">‚Äî</div>
                  </div>
                  <div class="hint" id="badgeHint">Click to copy</div>
                </div>
                <div class="copyBox" id="linkCopy" role="button" tabindex="0" aria-label="Copy Scan Link">
                  <div style="min-width:0">
                    <div style="font-weight:1000; font-size:12px; letter-spacing:.35px; color:rgba(255,255,255,.78); text-transform:uppercase;">Scan Link</div>
                    <div class="copyMono" id="scanLink">‚Äî</div>
                  </div>
                  <div class="hint" id="linkHint">Copy</div>
                </div>
              </div>
            </details>
          </div>

          <!-- RESULTS -->
          <div class="panel" id="resultsPanel">
            <div class="resultTop">
              <div>
                <!-- EXTENSION: token meta header (name/symbol/logo) -->
                <div class="tokenHead">
                  <div class="tokenLogoWrap" id="tokenLogoWrap">
                    <img id="tokenLogo" alt="">
                  </div>
                  <div style="min-width:0">
                    <div class="tokenName" id="tokenName">‚Äî</div>
                    <div class="tokenSymbol" id="tokenSymbol">‚Äî</div>
                  </div>
                </div>

                <!-- existing (unchanged) -->
                <h3 class="resultTitle" id="verdictTitle">‚Äî</h3>
                <div class="mono" id="mintShort">‚Äî</div>
              </div>

              <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                <span class="badge" id="verdictBadge">‚Äî</span>
                <span class="badge good" id="scoreBadge">‚Äî</span>
              </div>
            </div>

            <div class="metricStack" id="metrics"></div>
            <div class="statusLine" id="summary">‚Äî</div>
          </div>
        </div>

        <!-- Checks -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">GUARDIAN CHECKS</div>
            <div class="stamp" id="scanHint">‚Äî</div>
          </div>
          <ul class="list" id="checksList" style="margin-top:10px;">
            <li class="li">
              <div class="left">
                <div class="t">No scan yet</div>
                <div class="d">Paste a mint address and run the Guardian Check.</div>
              </div>
              <span class="pill">‚Äî</span>
            </li>
          </ul>
        </div>

        <!-- Launch readiness (only actionable items, no "next") -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">LAUNCH READINESS</div>
            <div class="stamp">ACTION LIST</div>
          </div>
          <ul class="list" id="todoList" style="margin-top:10px;">
            <li class="li">
              <div class="left">
                <div class="t">Waiting for scan</div>
                <div class="d">We generate a checklist only from verified on-chain signals.</div>
              </div>
              <span class="pill">‚Äî</span>
            </li>
          </ul>
        </div>

        <!-- Token-2022 details -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOKEN STANDARD DETAILS</div>
            <div class="stamp">ON-CHAIN</div>
          </div>
          <ul class="list" id="extList" style="margin-top:10px;">
            <li class="li">
              <div class="left">
                <div class="t">No scan yet</div>
                <div class="d">Extensions / token-standard details appear after scan.</div>
              </div>
              <span class="pill">‚Äî</span>
            </li>
          </ul>
        </div>

        <!-- Metadata / branding -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOKEN METADATA</div>
            <div class="stamp">DAS / RPC</div>
          </div>
          <ul class="list" id="metaList" style="margin-top:10px;">
            <li class="li">
              <div class="left">
                <div class="t">No scan yet</div>
                <div class="d">Name / symbol / image / metadata details appear after scan.</div>
              </div>
              <span class="pill">‚Äî</span>
            </li>
          </ul>
        </div>

        <!-- Top holders -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOP HOLDERS (PREVIEW)</div>
            <div class="stamp">MAINNET</div>
          </div>
          <ul class="list" id="holdersList" style="margin-top:10px;">
            <li class="li">
              <div class="left">
                <div class="t">No scan yet</div>
                <div class="d">Top holder preview will appear after scan.</div>
              </div>
              <span class="pill">‚Äî</span>
            </li>
          </ul>
        </div>

      </div>
    </section>

    <footer>¬© <span id="y"></span> $SOS ‚Ä¢ Guardian Check</footer>
  </main>

  <!-- Modal -->
  <div class="modalWrap" id="modalWrap" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle" id="modalTitle">Guardian Details</div>
        <button class="btn" id="modalClose">Close</button>
      </div>
      <div class="modalBody" id="modalBody"></div>
    </div>
  </div>

<script>
/* ===================== CONFIG ===================== */
const HELIUS_KEY = "a16897d9-ee14-46e0-aacd-7d3c7a7d3421"; // <-- replace this
const TOKEN_PROGRAM = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA";
const TOKEN_2022_PROGRAM = "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb";

const $ = (id)=>document.getElementById(id);
$("y").textContent = new Date().getFullYear();

function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function looksBase58(s){
  return typeof s === "string"
    && s.length >= 32 && s.length <= 52
    && /^[1-9A-HJ-NP-Za-km-z]+$/.test(s);
}
function shortAddr(a){ return a ? (a.slice(0,4)+"‚Ä¶"+a.slice(-4)) : "‚Äî"; }
function fmtInt(n){
  if(n === null || n === undefined || Number.isNaN(n)) return "‚Äî";
  try { return new Intl.NumberFormat("en-US").format(Math.round(Number(n))); } catch { return String(n); }
}
function fmtPct(n){
  if(n === null || n === undefined || Number.isNaN(n)) return "‚Äî";
  return `${Number(n).toFixed(2)}%`;
}
function setText(id, v){ const el=$(id); if(el) el.textContent = v; }
function setStatus(msg){ const el = $("status"); if(el) el.textContent = msg || ""; }
function setBadge(el, txt, mode){
  if(!el) return;
  el.textContent = txt;
  el.classList.remove("good","warn","bad");
  if(mode) el.classList.add(mode);
}
function updateStampTime(){
  const el = $("stampTime");
  if(el) el.textContent = new Date().toISOString().replace("T"," ").slice(0,19) + " UTC";
}
updateStampTime();
setInterval(updateStampTime, 1000);

/* ===== Modal ===== */
function openModal(title, body){
  $("modalTitle").textContent = title || "Guardian Details";
  $("modalBody").innerHTML = body || "";
  const w = $("modalWrap");
  w.style.display = "flex";
  w.setAttribute("aria-hidden","false");
}
function closeModal(){
  const w = $("modalWrap");
  w.style.display = "none";
  w.setAttribute("aria-hidden","true");
}
$("modalClose").addEventListener("click", closeModal);
$("modalWrap").addEventListener("click", (e)=>{ if(e.target === $("modalWrap")) closeModal(); });
document.addEventListener("keydown", (e)=>{ if(e.key==="Escape") closeModal(); });

/* ===== Clipboard helpers ===== */
async function copyText(text){
  try{ await navigator.clipboard.writeText(text); return true; }
  catch{
    const ta = document.createElement("textarea");
    ta.value = text; ta.setAttribute("readonly","");
    ta.style.position="fixed"; ta.style.top="-9999px";
    document.body.appendChild(ta);
    ta.select();
    try{ const ok = document.execCommand("copy"); document.body.removeChild(ta); return ok; }
    catch{ document.body.removeChild(ta); return false; }
  }
}
function hint(el, ok, on="Copied!", off="Copy"){
  if(!el) return;
  if(ok){
    el.textContent = on;
    el.classList.add("ok");
    setTimeout(()=>{ el.textContent = off; el.classList.remove("ok"); }, 1200);
  }else{
    el.textContent = "Failed";
    setTimeout(()=>{ el.textContent = off; }, 1200);
  }
}
function attachCopy(boxId, textId, hintId, on, off){
  const box = $(boxId), t = $(textId), h = $(hintId);
  if(!box) return;
  const go = async ()=>{
    const txt = (t?.textContent || "").trim();
    if(!txt || txt === "‚Äî") return;
    const ok = await copyText(txt);
    hint(h, ok, on, off);
  };
  box.addEventListener("click", go);
  box.addEventListener("keydown", (e)=>{ if(e.key==="Enter" || e.key===" "){ e.preventDefault(); go(); }});
}
attachCopy("badgeCopy","badgeHtml","badgeHint","Copied!","Click to copy");
attachCopy("linkCopy","scanLink","linkHint","Copied!","Copy");

/* ===== RPC (Helius) ===== */
const HELIUS_RPC = ()=> `https://mainnet.helius-rpc.com/?api-key=${encodeURIComponent(HELIUS_KEY)}`;
async function rpc(method, params){
  if(!HELIUS_KEY || HELIUS_KEY === "REPLACE_WITH_YOUR_HELIUS_KEY") throw new Error("Helius key missing.");
  const res = await fetch(HELIUS_RPC(), {
    method:"POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ jsonrpc:"2.0", id:1, method, params })
  });
  if(!res.ok){
    const t = await res.text().catch(()=> "");
    throw new Error(`RPC HTTP ${res.status} ${t}`.slice(0,220));
  }
  const j = await res.json();
  if(j.error) throw new Error(j.error.message || "RPC error");
  return j.result;
}

/* ===== Core on-chain reads ===== */
async function getMintParsed(mint){
  const r = await rpc("getAccountInfo", [mint, { encoding:"jsonParsed", commitment:"confirmed" }]);
  const v = r?.value;
  if(!v) return null;
  const owner = v.owner;
  const parsed = (v.data && typeof v.data === "object") ? v.data.parsed : null;
  const info = parsed?.info || null;
  const rawParsed = parsed || null;
  return { owner, info, rawParsed };
}
async function getTokenSupply(mint){
  const r = await rpc("getTokenSupply", [mint]);
  return r?.value || null;
}
async function getLargest(mint){
  const r = await rpc("getTokenLargestAccounts", [mint]);
  return r?.value || [];
}

/* ===== EXTENSION: Token Metadata (Name/Symbol/Logo) via Helius DAS ===== */
async function getAsset(mint){
  try{
    const r = await rpc("getAsset", [mint]);
    return r || null;
  }catch(e){
    return null;
  }
}
function pickTokenMetaFromAsset(asset){
  if(!asset) return null;

  const md = asset?.content?.metadata || {};
  const name = (md?.name || asset?.metadata?.name || "").trim();
  const symbol = (md?.symbol || asset?.metadata?.symbol || "").trim();

  let image = "";
  const linksImg = asset?.content?.links?.image;
  if(typeof linksImg === "string") image = linksImg;

  if(!image && Array.isArray(asset?.content?.files)){
    const f = asset.content.files.find(x => (x?.mime || "").includes("image") && x?.uri);
    if(f?.uri) image = f.uri;
  }

  const uri = (asset?.content?.json_uri || asset?.content?.links?.external_url || "").trim();
  const description = (md?.description || asset?.content?.metadata?.description || "").trim();

  const authorities = Array.isArray(asset?.authorities) ? asset.authorities : [];
  return { name, symbol, image, uri, description, authorities, raw: asset };
}
function applyTokenHeader(meta, mint){
  const nameEl = $("tokenName");
  const symEl = $("tokenSymbol");
  const logoWrap = $("tokenLogoWrap");
  const logo = $("tokenLogo");

  const fallbackName = "Token";
  const n = meta?.name ? meta.name : "";
  const s = meta?.symbol ? meta.symbol : "";

  nameEl.textContent = (n || fallbackName);
  symEl.textContent = (s ? `$${s}` : `Mint: ${shortAddr(mint)}`);

  if(meta?.image){
    logo.src = meta.image;
    logo.alt = (n || s || "Token");
    logoWrap.style.display = "block";
    logo.onerror = ()=>{ logoWrap.style.display = "none"; };
  }else{
    logoWrap.style.display = "none";
    logo.removeAttribute("src");
    logo.alt = "";
  }
}

/* ===== Verdict / scoring ===== */
function verdictFrom(score, critical){
  if(critical) return {label:"FLAGGED", mode:"bad", title:"FLAGGED ‚Ä¢ High Risk"};
  if(score >= 80) return {label:"APPROVED", mode:"good", title:"APPROVED ‚Ä¢ Guardian Grade"};
  if(score >= 50) return {label:"OBSERVED", mode:"warn", title:"OBSERVED ‚Ä¢ Mixed Signals"};
  return {label:"FLAGGED", mode:"bad", title:"FLAGGED ‚Ä¢ High Risk"};
}

/* ===== SIMPLE, IDIOT-PROOF EXPLAINERS (NO CODE/NO JSON) ===== */
function explainSimple(title, lines){
  // grey-ish, simple block
  const safe = (s)=>String(s||"").replaceAll("<","&lt;").replaceAll(">","&gt;");
  return `
    <div style="font-weight:1000; font-size:18px; margin-bottom:10px">${safe(title)}</div>
    <div style="color:rgba(255,255,255,.70); font-weight:850; line-height:1.55">
      ${lines.map(l=>`<div style="margin:6px 0">${safe(l)}</div>`).join("")}
    </div>
  `;
}

function explainFreeze(){
  return explainSimple("Freeze Authority", [
    "Meaning: Someone can freeze wallets so they can‚Äôt sell or move the token.",
    "Why it matters: Buyers can get trapped.",
    "What to do: Only trust if Freeze is removed (renounced)."
  ]);
}
function explainMintAuth(){
  return explainSimple("Mint Authority", [
    "Meaning: Someone can mint (create) more tokens anytime.",
    "Why it matters: More tokens can crash the price.",
    "What to do: Only trust if Mint is renounced, or there is a clear public emission plan."
  ]);
}
function explainTop20(pct){
  const p = Number(pct||0).toFixed(2);
  return explainSimple("Top Holders Concentration", [
    `Meaning: The biggest 20 wallets hold about ${p}% of the supply.`,
    "Why it matters: A few wallets can dump and crash the chart.",
    "What to do: High % = extra caution. Check holders and project transparency."
  ]);
}
function explainTokenStandard(programType, extReadable){
  if(programType === "SPL_TOKEN"){
    return explainSimple("Token Standard: SPL Token", [
      "Meaning: Normal Solana token program used by most tokens.",
      "Why it matters: Fewer extra rules hidden inside the token.",
      "What to do: Still check authorities and distribution."
    ]);
  }
  if(programType === "TOKEN_2022"){
    return explainSimple("Token Standard: Token-2022", [
      "Meaning: Official Solana token program with optional extra rules (extensions).",
      "Why it matters: Some extensions can add fees or restrictions.",
      extReadable ? "What to do: Read the Token Standard Details list and be careful with WATCH items."
                : "What to do: If extensions are not visible, treat as WATCH until verified elsewhere."
    ]);
  }
  return explainSimple("Token Standard: Unknown Program", [
    "Meaning: Token mint is not using the common Solana token programs.",
    "Why it matters: Custom programs can add hidden rules.",
    "What to do: Treat as WATCH and verify carefully."
  ]);
}
function explainMetadataQuality(){
  return explainSimple("Token Metadata", [
    "Meaning: Name, symbol and logo help you identify the real token.",
    "Why it matters: Missing metadata makes impersonation easier.",
    "What to do: Verify name/symbol/logo match official socials and listings."
  ]);
}
function explainHolders(addr, pct){
  return explainSimple("Top Holder", [
    `Meaning: This wallet holds about ${pct}% of the supply.`,
    "Why it matters: Big holders can dump suddenly.",
    "What to do: Watch big wallets and avoid extreme concentration."
  ]);
}

/* ===== EXTENSION: Metadata quality checks ===== */
function scoreModel(sig){
  let score = 100;
  const checks = [];

  if(sig.freezeActive){
    score -= 35;
    checks.push({ k:"Freeze Authority active", sev:"bad", d:"Transfers can be frozen. High risk.", clickMsg: explainFreeze() });
  }else{
    checks.push({ k:"Freeze Authority removed", sev:"ok", d:"No freeze power detected (good).", clickMsg: explainFreeze() });
  }

  if(sig.mintAuthActive){
    score -= 30;
    checks.push({ k:"Mint Authority active", sev:"bad", d:"More supply can be minted. High risk.", clickMsg: explainMintAuth() });
  }else{
    checks.push({ k:"Mint Authority renounced", sev:"ok", d:"Supply can‚Äôt be increased (good).", clickMsg: explainMintAuth() });
  }

  const t20 = Number(sig.top20 || 0);
  if(t20 >= 75){
    score -= 28;
    checks.push({k:"Top 20 concentration very high", sev:"bad", d:`Top20 holds ~${t20.toFixed(2)}%.`, clickMsg: explainTop20(t20)});
  }else if(t20 >= 55){
    score -= 18;
    checks.push({k:"Top 20 concentration high", sev:"warn", d:`Top20 holds ~${t20.toFixed(2)}%.`, clickMsg: explainTop20(t20)});
  }else if(t20 >= 35){
    score -= 8;
    checks.push({k:"Top 20 concentration moderate", sev:"warn", d:`Top20 holds ~${t20.toFixed(2)}%.`, clickMsg: explainTop20(t20)});
  }else{
    checks.push({k:"Distribution looks healthier", sev:"ok", d:`Top20 holds ~${t20.toFixed(2)}%.`, clickMsg: explainTop20(t20)});
  }

  if(sig.programType === "TOKEN_2022"){
    score -= sig.extReadable ? 6 : 10;
    checks.push({
      k:"Token standard: Token-2022",
      sev:"warn",
      d: sig.extReadable ? "Can include extra rules (extensions)." : "Extensions not visible in this scan.",
      clickMsg: explainTokenStandard("TOKEN_2022", sig.extReadable)
    });
  }else if(sig.programType === "SPL_TOKEN"){
    checks.push({ k:"Token standard: SPL Token", sev:"ok", d:"Standard token program.", clickMsg: explainTokenStandard("SPL_TOKEN", true) });
  }else{
    score -= 10;
    checks.push({ k:"Token standard: Unknown program", sev:"warn", d:"Not a common token program.", clickMsg: explainTokenStandard("UNKNOWN", false) });
  }

  if(sig.meta && (sig.meta.name || sig.meta.symbol)){
    checks.push({ k:"Metadata present", sev:"ok", d:`Name/Symbol found.`, clickMsg: explainMetadataQuality() });
  }else{
    score -= 4;
    checks.push({ k:"Metadata missing or unreadable", sev:"warn", d:"Name/Symbol not found via metadata endpoint.", clickMsg: explainMetadataQuality() });
  }

  score = clamp(Math.round(score), 0, 100);
  const critical = !!(sig.freezeActive || sig.mintAuthActive);
  return { score, checks, critical };
}

/* Launch readiness */
function buildTodo(sig){
  const todos = [];
  if(sig.freezeActive){
    todos.push({t:"Remove Freeze Authority", sev:"bad", d:"Freezing can trap buyers.", clickMsg: explainFreeze()});
  }else{
    todos.push({t:"Freeze Authority", sev:"ok", d:"Already removed (good).", clickMsg: explainFreeze()});
  }

  if(sig.mintAuthActive){
    todos.push({t:"Renounce Mint Authority", sev:"bad", d:"Minting more tokens can crash price.", clickMsg: explainMintAuth()});
  }else{
    todos.push({t:"Mint Authority", sev:"ok", d:"Already renounced (good).", clickMsg: explainMintAuth()});
  }

  const t20 = Number(sig.top20 || 0);
  if(t20 >= 55){
    todos.push({t:"Reduce Whale Concentration", sev:"warn", d:`Top20 holds ~${t20.toFixed(2)}%.`, clickMsg: explainTop20(t20)});
  }else if(t20 >= 35){
    todos.push({t:"Monitor Distribution", sev:"warn", d:`Top20 holds ~${t20.toFixed(2)}%.`, clickMsg: explainTop20(t20)});
  }else{
    todos.push({t:"Distribution", sev:"ok", d:`Top20 ~${t20.toFixed(2)}% (healthier).`, clickMsg: explainTop20(t20)});
  }

  if(sig.programType === "TOKEN_2022"){
    todos.push({
      t:"Token-2022 Safety Review",
      sev:"warn",
      d:"Token-2022 can include extra rules.",
      clickMsg: explainTokenStandard("TOKEN_2022", sig.extReadable)
    });
  } else if(sig.programType === "UNKNOWN"){
    todos.push({ t:"Verify Mint Program", sev:"warn", d:"Unknown program = extra caution.", clickMsg: explainTokenStandard("UNKNOWN", false) });
  } else {
    todos.push({ t:"Token Standard", sev:"ok", d:"Standard SPL Token.", clickMsg: explainTokenStandard("SPL_TOKEN", true) });
  }

  if(!(sig.meta && (sig.meta.name || sig.meta.symbol))){
    todos.push({ t:"Publish Token Metadata", sev:"warn", d:"Missing name/symbol makes fake copies easier.", clickMsg: explainMetadataQuality() });
  }else{
    todos.push({ t:"Metadata", sev:"ok", d:"Name/symbol present (good).", clickMsg: explainMetadataQuality() });
  }

  return todos;
}

/* Render list with clickable pills */
function renderList(el, items, listTitle="Guardian Details"){
  el.innerHTML = "";
  for(const it of items){
    const li = document.createElement("li");
    li.className = "li";

    const sev = it.sev || "warn";
    const pillCls = sev === "ok" ? "pill ok" : (sev === "bad" ? "pill bad" : "pill warn");
    const pillTxt = sev === "ok" ? "PASS" : (sev === "bad" ? "FAIL" : "WATCH");

    const msgHtml = (it.clickMsg || it.msg || "").trim();
    li.innerHTML = `
      <div class="left">
        <div class="t">${(it.k || it.t || "‚Äî")}</div>
        <div class="d">${(it.d || "‚Äî")}</div>
      </div>
      <span class="${pillCls}" role="button" tabindex="0"
        data-title="${(it.k || it.t || listTitle).replaceAll('"','&quot;')}"
        data-msg="${msgHtml.replaceAll('"','&quot;')}">${pillTxt}</span>
    `;
    el.appendChild(li);
  }
}

/* Metrics */
function renderMetrics(score, sig, uiSupply, top20Sum, owner, decimals){
  const wrap = $("metrics");
  wrap.innerHTML = "";

  const authLine = `${sig.mintAuthActive ? "MINT ACTIVE" : "MINT RENOUNCED"} ‚Ä¢ ${sig.freezeActive ? "FREEZE ACTIVE" : "FREEZE REMOVED"}`;
  const programText = sig.programType === "SPL_TOKEN" ? "SPL Token" : (sig.programType === "TOKEN_2022" ? "Token-2022" : "Unknown");

  const metric = (label, value, mini, barPct=null)=>{
    const d = document.createElement("div");
    d.className = "metric";
    d.innerHTML = `
      <div class="metricK"><span>${label}</span><span class="badge" style="opacity:.9">${value}</span></div>
      <div class="metricV">${label === "Risk Score" ? `<span>${score}/100</span><span class="badge good">SCORE</span>` : `<span>${value}</span>`}</div>
      <div class="metricMini">${mini || ""}</div>
      ${barPct===null ? "" : `<div class="bar"><div style="width:${clamp(barPct,0,100)}%"></div></div>`}
    `;
    wrap.appendChild(d);
  };

  const nm = sig?.meta?.name || "‚Äî";
  const sy = sig?.meta?.symbol || "‚Äî";
  metric("Token", (sy && sy!=="‚Äî") ? `$${sy}` : "‚Äî", nm !== "‚Äî" ? `Name: ${nm}` : "Name: ‚Äî");

  metric("Risk Score", `${score}/100`,
    score>=80 ? "Looks safer than average (still not guaranteed)." :
    (score>=50 ? "Mixed signals ‚Äî read WATCH items." : "High risk signals ‚Äî be careful."),
    score
  );

  metric("Authorities", authLine,
    sig.mintAuthActive||sig.freezeActive ? "Authorities present = higher trust risk." : "No mint/freeze authority (good)."
  );

  metric("Top 20 Concentration", fmtPct(sig.top20),
    (uiSupply ? `Top20: ${fmtInt(top20Sum)} / ${fmtInt(uiSupply)} ‚Ä¢ Decimals ${decimals}` : `Decimals ${decimals}`),
    sig.top20
  );

  metric("Token Standard", programText,
    owner ? `Mint program owner: ${shortAddr(owner)}` : "‚Äî"
  );

  metric("Supply", uiSupply ? fmtInt(uiSupply) : "‚Äî",
    "UI supply (RPC)"
  );
}

/* Share */
function setShareEnabled(enabled, url){
  const a = $("btnShare");
  if(!a) return;
  if(enabled){
    a.href = url;
    a.style.opacity = "1";
    a.style.pointerEvents = "auto";
  }else{
    a.href = "#";
    a.style.opacity = ".55";
    a.style.pointerEvents = "none";
  }
}
function buildShareText(mint, verdict, score, sig){
  const link = location.origin + location.pathname + `?mint=${encodeURIComponent(mint)}`;
  const programText = sig.programType === "SPL_TOKEN" ? "SPL Token" : (sig.programType === "TOKEN_2022" ? "Token-2022" : "Unknown");
  const authLine = `${sig.mintAuthActive ? "MINT: ACTIVE" : "MINT: RENOUNCED"} ‚Ä¢ ${sig.freezeActive ? "FREEZE: ACTIVE" : "FREEZE: REMOVED"}`;

  const lines = [
    `üõ°Ô∏è GUARDIAN CHECK ‚Äî Token Risk (on-chain)`,
    ``,
    `Mint: ${shortAddr(mint)}`,
    `Token: ${(sig?.meta?.symbol ? "$"+sig.meta.symbol : "‚Äî")} ‚Ä¢ ${(sig?.meta?.name || "‚Äî")}`,
    `Verdict: ${verdict.label}`,
    `Score: ${score}/100`,
    `Authorities: ${authLine}`,
    `Top20: ${fmtPct(sig.top20)}`,
    `Standard: ${programText}`,
    ``,
    `Run yours: ${link}`,
    `#Solana #Memecoins #Guardian`
  ];
  return lines.join("\n");
}
function badgeHtmlSnippet(mint, verdictLabel, score){
  const url = `https://solanax1.com/guardian?mint=${encodeURIComponent(mint)}`;
  return `<a href="${url}" target="_blank" rel="noreferrer" style="text-decoration:none">
  <span style="display:inline-flex;align-items:center;gap:8px;padding:10px 12px;border-radius:999px;font:700 12px ui-sans-serif,system-ui;letter-spacing:.3px;color:#061012;background:linear-gradient(90deg,#14F195,#00D1FF,#9945FF);box-shadow:0 10px 24px rgba(0,0,0,.25)">
    üõ°Ô∏è GUARDIAN ${verdictLabel} ‚Ä¢ ${score}/100
  </span>
</a>`;
}

/* Holders */
function renderHolders(mint, uiSupply, largest){
  const list = $("holdersList");
  if(!uiSupply || !Array.isArray(largest) || !largest.length){
    renderList(list, [{t:"No holder data", sev:"warn", d:"Largest accounts not readable from RPC.", clickMsg: explainSimple("Top Holders", [
      "Meaning: We could not read the biggest holders right now.",
      "Why it matters: Holder distribution is important for risk.",
      "What to do: Try again later or use another RPC."
    ])}]);
    return;
  }
  const top = largest.slice(0,5);
  const items = top.map((x,i)=>{
    const addr = x?.address || "‚Äî";
    const amt = Number(x?.uiAmount || 0);
    const pct = uiSupply > 0 ? (amt / uiSupply) * 100 : 0;
    const sev = pct >= 10 ? "warn" : "ok";
    return {
      t: `#${i+1} ${shortAddr(addr)}`,
      sev,
      d: `${fmtInt(amt)} tokens ‚Ä¢ ${pct.toFixed(2)}%`,
      clickMsg: explainHolders(addr, pct.toFixed(2))
    };
  });
  renderList(list, items, "Top Holder Details");
}

/* Token-2022 extensions / token-standard details (NO JSON) */
function parseExtensionsFromParsed(rawParsed){
  try{
    const info = rawParsed?.info || rawParsed?.parsed?.info || rawParsed?.data?.parsed?.info || null;
    if(!info) return null;

    const ex1 = info.extensions;
    const ex2 = info.extensionTypes;
    const ex3 = info.mintExtensions;

    let out = null;

    if(Array.isArray(ex1) && ex1.length){
      out = ex1.map(x=>{
        if(typeof x === "string") return { name:x, details:null };
        if(typeof x === "object" && x){
          const name = x.extension || x.type || x.name || "Extension";
          return { name, details:null };
        }
        return { name:String(x), details:null };
      });
    } else if(Array.isArray(ex2) && ex2.length){
      out = ex2.map(x=>({name:String(x), details:null}));
    } else if(ex3 && typeof ex3 === "object"){
      if(Array.isArray(ex3) && ex3.length){
        out = ex3.map(x=>({name: x?.type || x?.name || "Extension", details:null}));
      } else {
        out = Object.keys(ex3).map(k=>({name:k, details:null}));
      }
    }

    return out && out.length ? out : null;
  }catch{
    return null;
  }
}
function humanizeExtensionName(n){
  const s = String(n||"").toLowerCase();
  if(s.includes("transferfee") || s.includes("transfer_fee")) return "Transfer Fee (fee on transfers)";
  if(s.includes("permanentdelegate") || s.includes("permanent_delegate")) return "Permanent Delegate (delegate control)";
  if(s.includes("nontransferable") || s.includes("non_transferable")) return "Non-Transferable (cannot be transferred)";
  if(s.includes("interestbearing") || s.includes("interest_bearing")) return "Interest-Bearing (yield mechanics)";
  if(s.includes("confidential") ) return "Confidential Transfers (privacy mode)";
  if(s.includes("metadata")) return "Metadata Extension";
  return n;
}
function renderTokenStandardDetails(programType, extReadable, extList){
  const el = $("extList");
  if(programType !== "TOKEN_2022"){
    const msg = programType === "SPL_TOKEN"
      ? "This mint uses the standard SPL Token program. Token-2022 extensions are not applicable."
      : "This mint does not use a standard SPL Token program. Treat unknown programs with caution.";
    renderList(el, [{
      t:"Token standard details",
      sev: programType === "SPL_TOKEN" ? "ok" : "warn",
      d: msg,
      clickMsg: explainTokenStandard(programType === "SPL_TOKEN" ? "SPL_TOKEN" : "UNKNOWN", extReadable)
    }]);
    return;
  }

  if(!extReadable){
    renderList(el, [{
      t:"Token-2022 extensions",
      sev:"warn",
      d:"Extensions not visible in this scan.",
      clickMsg: explainTokenStandard("TOKEN_2022", false)
    }]);
    return;
  }

  const items = extList.map((x)=>{
    const nameHuman = humanizeExtensionName(x.name);
    const lname = String(x.name||"").toLowerCase();

    let sev = "warn";
    let d = `Extension detected: ${nameHuman}.`;
    let lines = [
      "Meaning: Token-2022 can add extra rules.",
      "Why it matters: Some rules can add fees or restrictions.",
      "What to do: If you don‚Äôt understand it, treat as WATCH."
    ];

    if(lname.includes("transferfee")){
      lines = [
        "Meaning: Transfers may charge a fee.",
        "Why it matters: Fees can hurt buyers/sellers.",
        "What to do: Treat as WATCH unless fee is clearly disclosed."
      ];
    } else if(lname.includes("nontransferable")){
      sev = "bad";
      lines = [
        "Meaning: Token cannot be transferred normally.",
        "Why it matters: You may not be able to sell/send it.",
        "What to do: Avoid for memecoins. Treat as FAIL."
      ];
    } else if(lname.includes("permanentdelegate")){
      lines = [
        "Meaning: A delegate may have special control.",
        "Why it matters: Could enable unexpected behavior.",
        "What to do: Treat as WATCH unless explained clearly."
      ];
    } else if(lname.includes("metadata")){
      lines = [
        "Meaning: Token stores metadata rules on-chain.",
        "Why it matters: May allow updates depending on authority.",
        "What to do: Verify metadata matches official sources."
      ];
    }

    return {
      t: nameHuman,
      sev,
      d,
      clickMsg: explainSimple(nameHuman, lines)
    };
  });

  renderList(el, items, "Token-2022 Extension Details");
}

/* Metadata panel (NO JSON) */
function renderMetadataPanel(meta, mint){
  const el = $("metaList");
  if(!meta){
    renderList(el, [{
      t:"Metadata not available",
      sev:"warn",
      d:"Could not fetch metadata via getAsset.",
      clickMsg: explainMetadataQuality()
    }], "Token Metadata");
    return;
  }

  const items = [];

  items.push({
    t:"Name / Symbol",
    sev: (meta.name || meta.symbol) ? "ok" : "warn",
    d: `${meta.name || "‚Äî"} ‚Ä¢ ${meta.symbol ? "$"+meta.symbol : "‚Äî"}`,
    clickMsg: explainMetadataQuality()
  });

  items.push({
    t:"Metadata Link",
    sev: meta.uri ? "ok" : "warn",
    d: meta.uri ? "Metadata link found." : "No metadata link found.",
    clickMsg: explainSimple("Metadata Link", [
      "Meaning: A link where token info (name/logo) is hosted.",
      "Why it matters: Helps confirm you‚Äôre looking at the real token.",
      "What to do: Check it matches the official socials/listings."
    ])
  });

  items.push({
    t:"Image / Logo",
    sev: meta.image ? "ok" : "warn",
    d: meta.image ? "Logo found (shown above if loadable)." : "No logo found.",
    clickMsg: explainSimple("Token Logo", [
      "Meaning: Token picture/logo used in wallets and sites.",
      "Why it matters: Helps you avoid fake copies.",
      "What to do: Verify the logo matches official sources."
    ])
  });

  if(meta.description){
    items.push({
      t:"Description",
      sev:"ok",
      d: meta.description.slice(0,120) + (meta.description.length>120 ? "‚Ä¶" : ""),
      clickMsg: explainSimple("Description", [
        meta.description
      ])
    });
  }

  if(Array.isArray(meta.authorities) && meta.authorities.length){
    items.push({
      t:"Authorities (metadata)",
      sev:"warn",
      d:"Metadata authorities exist (review).",
      clickMsg: explainSimple("Metadata Authorities", [
        "Meaning: Someone may be able to update token metadata.",
        "Why it matters: They could change name/logo/link later.",
        "What to do: Treat as WATCH unless authority is removed or clearly explained."
      ])
    });
  }

  renderList(el, items, "Token Metadata");
}

/* ===== Scan ===== */
async function scan(){
  const mint = $("mint").value.trim();
  setShareEnabled(false);

  if(!looksBase58(mint)){ setStatus("Invalid mint address."); return; }

  setStatus("Running Guardian Check‚Ä¶");
  setText("mintShort", shortAddr(mint));
  setText("verdictTitle","‚Äî");
  setBadge($("verdictBadge"),"‚Äî");
  setText("scoreBadge","‚Äî");
  setText("summary","‚Äî");
  setText("scanHint","‚Äî");
  $("sharePanel").style.display = "none";

  // clear token header
  setText("tokenName","‚Äî");
  setText("tokenSymbol","‚Äî");
  $("tokenLogoWrap").style.display = "none";

  try{
    const mintParsed = await getMintParsed(mint);
    if(!mintParsed || !mintParsed.info) throw new Error("Mint not readable (not a token mint).");

    const owner = mintParsed.owner;
    const info = mintParsed.info;
    const rawParsed = mintParsed.rawParsed;

    const mintAuthority = info.mintAuthority ?? null;
    const freezeAuthority = info.freezeAuthority ?? null;
    const decimals = Number(info.decimals ?? 0);

    const programType =
      owner === TOKEN_PROGRAM ? "SPL_TOKEN" :
      owner === TOKEN_2022_PROGRAM ? "TOKEN_2022" :
      "UNKNOWN";

    const [supply, largest, asset] = await Promise.all([
      getTokenSupply(mint),
      getLargest(mint),
      getAsset(mint)
    ]);

    const meta = pickTokenMetaFromAsset(asset);
    applyTokenHeader(meta, mint);
    renderMetadataPanel(meta, mint);

    const uiSupply = supply ? Number(supply.uiAmount ?? 0) : null;
    const top20 = (Array.isArray(largest) ? largest.slice(0,20) : []);
    const top20Sum = top20.reduce((acc,x)=> acc + Number(x.uiAmount || 0), 0);
    const conc = (uiSupply && uiSupply > 0) ? (top20Sum / uiSupply) * 100 : 0;

    const extRaw = programType === "TOKEN_2022" ? parseExtensionsFromParsed(rawParsed) : null;
    const extReadable = !!(extRaw && extRaw.length);

    const sig = {
      mintAuthActive: !!mintAuthority,
      freezeActive: !!freezeAuthority,
      top20: conc,
      programType,
      extReadable,
      meta: meta || null
    };

    const model = scoreModel(sig);
    const verdict = verdictFrom(model.score, model.critical);

    setText("verdictTitle", verdict.title);
    setBadge($("verdictBadge"), verdict.label, verdict.mode);
    $("scoreBadge").textContent = `SCORE ${model.score}`;

    renderMetrics(model.score, sig, uiSupply, top20Sum, owner, decimals);

    setText("scanHint", `Mint: ${shortAddr(mint)}`);
    renderList($("checksList"), model.checks, "Guardian Check Details");
    renderList($("todoList"), buildTodo(sig), "Launch Readiness Details");
    renderTokenStandardDetails(programType, extReadable, extRaw || []);
    renderHolders(mint, uiSupply, largest);

    const programText = programType === "SPL_TOKEN" ? "SPL Token" : (programType === "TOKEN_2022" ? "Token-2022" : "Unknown");
    const authLine = `${mintAuthority ? "MINT: ACTIVE" : "MINT: RENOUNCED"} ‚Ä¢ ${freezeAuthority ? "FREEZE: ACTIVE" : "FREEZE: REMOVED"}`;
    const extLine = (programType === "TOKEN_2022")
      ? (extReadable ? ` ‚Ä¢ Extensions: visible (${(extRaw||[]).length})` : ` ‚Ä¢ Extensions: not visible`)
      : "";
    const metaLine = (meta && (meta.name || meta.symbol)) ? ` ‚Ä¢ ${meta.symbol ? "$"+meta.symbol : ""} ${meta.name ? meta.name : ""}`.trim() : "";
    setText("summary", `${verdict.label} ‚Ä¢ Score ${model.score}/100 ‚Ä¢ ${authLine} ‚Ä¢ Top20 ${fmtPct(conc)} ‚Ä¢ Standard ${programText}${extLine}${metaLine ? " ‚Ä¢ " + metaLine : ""} ‚Ä¢ Decimals ${decimals}`);

    const scanUrl = `https://solanax1.com/guardian?mint=${encodeURIComponent(mint)}`;
    setText("scanLink", scanUrl);
    setText("badgeHtml", badgeHtmlSnippet(mint, verdict.label, model.score));
    $("sharePanel").style.display = "";

    const tweet = new URL("https://x.com/intent/tweet");
    tweet.searchParams.set("text", buildShareText(mint, verdict, model.score, sig));
    setShareEnabled(true, tweet.toString());

    setStatus(`Guardian Check complete: ${verdict.label} ‚Ä¢ Score ${model.score}/100`);
  }catch(e){
    console.error(e);
    setStatus("Scan failed: " + (e?.message || "unknown error"));
  }
}

/* Click handling for pills: open modal with ONLY simple explanation */
document.addEventListener("click", (e)=>{
  const pill = e.target.closest?.(".pill");
  if(!pill) return;
  const msg = pill.getAttribute("data-msg");
  const title = pill.getAttribute("data-title") || "Guardian Details";
  if(msg && msg.trim() && msg.trim() !== "‚Äî"){
    openModal(title, msg); // IMPORTANT: no extra title duplication inside body
  }
});
document.addEventListener("keydown", (e)=>{
  if((e.key === "Enter" || e.key === " ") && document.activeElement?.classList?.contains("pill")){
    e.preventDefault();
    const pill = document.activeElement;
    const msg = pill.getAttribute("data-msg");
    const title = pill.getAttribute("data-title") || "Guardian Details";
    if(msg && msg.trim() && msg.trim() !== "‚Äî"){
      openModal(title, msg); // IMPORTANT: no extra title duplication inside body
    }
  }
});

$("btnScan").addEventListener("click", scan);
$("mint").addEventListener("keydown", (e)=>{ if(e.key==="Enter") scan(); });

/* auto-scan from URL */
(function(){
  const q = new URLSearchParams(location.search);
  const m = (q.get("mint") || "").trim();
  if(m){ $("mint").value = m; setTimeout(()=>scan(), 120); }
})();
</script>
</body>
</html>
