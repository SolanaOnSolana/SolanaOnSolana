<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#070711" />
  <title>$SOS — Guardian Check (Multi-Chain)</title>
  <meta name="description" content="Guardian Approved — token risk score + launch readiness checklist (on-chain verifiable)." />
  <style>
    :root{
      --bg:#070711;
      --panel: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --g:#14F195;
      --c:#00D1FF;
      --p:#9945FF;
      --radius: 22px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --max: 1180px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--text);
      font: 15.5px/1.55 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: var(--bg);
      position:relative;
      overflow-x:hidden;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      z-index:-1;
      pointer-events:none;
      background:
        radial-gradient(1200px 700px at 10% 5%, rgba(153,69,255,.22), transparent 60%),
        radial-gradient(1000px 650px at 90% 10%, rgba(20,241,149,.18), transparent 55%),
        radial-gradient(900px 600px at 70% 85%, rgba(0,209,255,.14), transparent 55%),
        var(--bg);
      transform: translateZ(0);
    }
    a{color:inherit; text-decoration:none}
    .wrap{max-width:var(--max); margin:0 auto; padding:0 18px; width:100%;}
    main{padding:22px 0 42px}
    .topbar{
      position:sticky; top:0; z-index:20;
      backdrop-filter: blur(14px);
      background: rgba(7,7,17,.62);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .row{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; padding:12px 0; flex-wrap:wrap;
    }
    .brand{
      display:flex; align-items:center; gap:12px; min-width: 260px; user-select:none;
    }
    .brand img{
      width:40px; height:40px; object-fit:contain;
      filter: drop-shadow(0 10px 25px rgba(0,0,0,.45));
    }
    .bt{display:flex; flex-direction:column; line-height:1.05}
    .bt .t{font-weight:1000; letter-spacing:-.2px; font-size:16px}
    .bt .s{font-weight:850; color:var(--muted); font-size:12.5px}
    .actions{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end; width:100%;}
    @media (min-width: 980px){ .actions{width:auto} }
    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      padding:9px 12px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      font-weight:950; font-size:13px;
      transition: .15s ease;
      user-select:none; cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      white-space:nowrap;
    }
    .btn:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .btn.grad{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .btn[disabled]{opacity:.55; pointer-events:none}
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.05));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .inner{padding:22px}
    .hero{position:relative; overflow:hidden; isolation:isolate;}
    .hero::before{
      content:"";
      position:absolute; inset:-70px -40px;
      background:
        radial-gradient(900px 520px at 18% 28%, rgba(20,241,149,.16), transparent 60%),
        radial-gradient(900px 520px at 82% 20%, rgba(0,209,255,.12), transparent 60%),
        radial-gradient(900px 520px at 70% 86%, rgba(153,69,255,.14), transparent 60%);
      z-index:0; pointer-events:none;
    }
    .hero > *{position:relative; z-index:1}
    .h1{
      margin:0; font-weight:1000; letter-spacing:-1px; line-height:1.05;
      font-size: clamp(36px, 4.6vw, 62px);
    }
    .gradText{
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      -webkit-background-clip:text; background-clip:text; color:transparent;
    }
    .sub{margin-top:10px; color: rgba(255,255,255,.76); font-weight:850; max-width: 940px;}
    .classified{display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;}
    .stamp{
      font-weight:1000; font-size:12px; letter-spacing: .45px; text-transform:uppercase;
      color: rgba(255,255,255,.76);
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius: 999px;
      padding:7px 10px;
    }
    .layout{margin-top:16px; display:grid; grid-template-columns: 1.05fr .95fr; gap:16px; align-items:start;}
    @media (max-width: 980px){ .layout{grid-template-columns:1fr} }

    /* Mobile clean stacked */
    @media (max-width: 980px){
      .wrap{ padding: 0 14px; }
      .inner{ padding: 16px; }
      .panel{ padding: 14px; }
      .brand{ min-width: 0; width: 100%; }
      .actions{ width: 100%; justify-content: flex-start; }
      .actions .btn{ width: 100%; justify-content: center; padding: 12px 14px; font-size: 14px; }
      .resultTop{ flex-direction: column; align-items: stretch; }
      .resultTop > div:last-child{ width: 100%; justify-content: flex-start; }
      .resultTop .badge{ width: fit-content; }
      .tokenHead{ flex-wrap: nowrap; }
      .tokenName{ font-size: 18px; }
      .tokenSymbol{ font-size: 13px; }
      .metricV{ flex-direction: column; align-items: flex-start; gap: 6px; font-size: 22px; }
      .metricK{ flex-wrap: wrap; gap: 8px; }
      .metricK .badge{ margin-left: auto; }
      .li{ flex-direction: column; align-items: flex-start; gap: 10px; }
      .pillRow{ width:100%; justify-content:flex-start; flex-wrap:wrap; }
      .modal{ width:100%; }
      .toast{ left:14px; right:14px; transform:none; width:auto; }
    }

    .panel{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 18px;
      padding:16px;
      overflow:hidden;
    }
    label{
      display:block;
      font-weight:950; font-size:12.5px; letter-spacing:.35px;
      color: rgba(255,255,255,.82);
      margin-bottom:8px;
    }
    input{
      width:100%; padding:14px 14px; border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.92);
      outline:none;
      font-weight:900; letter-spacing:.2px; font-size:16px;
      max-width:100%;
    }
    input:focus{ border-color: rgba(0,209,255,.45); box-shadow: 0 0 0 3px rgba(0,209,255,.12); }
    .statusLine{
      margin-top:12px; color: rgba(255,255,255,.72);
      font-weight:900; min-height: 18px; font-size:13px;
      overflow-wrap:anywhere; word-break:break-word;
    }
    .badge{
      display:inline-flex; align-items:center; justify-content:center;
      padding:7px 11px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000; font-size:12px; white-space:nowrap;
    }
    .badge.good{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}
    .badge.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .badge.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}
    .resultTop{display:flex; align-items:flex-start; justify-content:space-between; gap:12px; flex-wrap:wrap;}
    .resultTitle{margin:0; font-weight:1000; font-size:22px; letter-spacing:-.4px;}
    .mono{font-family: ui-monospace, Menlo, Consolas, monospace; font-weight:900; color: rgba(255,255,255,.86); margin-top:6px; overflow-wrap:anywhere; word-break:break-word;}
    .tokenHead{display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:10px; min-width:0;}
    .tokenLogoWrap{
      width:44px; height:44px; border-radius:12px; overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      display:none; flex:0 0 auto;
    }
    .tokenLogoWrap img{ width:100%; height:100%; object-fit:cover; display:block; }
    .tokenName{ font-weight:1000; font-size:16px; letter-spacing:-.2px; line-height:1.15; overflow-wrap:anywhere; word-break:break-word; }
    .tokenSymbol{ margin-top:2px; color: rgba(255,255,255,.70); font-weight:900; font-size:12.5px; }
    .metricStack{margin-top:12px; display:grid; gap:10px;}
    .metric{ border:1px solid rgba(255,255,255,.10); background: rgba(255,255,255,.04); border-radius: 16px; padding:12px 12px; }
    .metricK{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      color: rgba(255,255,255,.70); font-weight:1000; font-size:12px;
      letter-spacing:.45px; text-transform:uppercase;
    }
    .metricV{
      margin-top:8px; font-weight:1000; font-size:20px;
      display:flex; align-items:baseline; justify-content:space-between; gap:12px; flex-wrap:wrap;
    }
    .metricMini{ margin-top:6px; font-weight:850; font-size:12px; color: rgba(255,255,255,.62); overflow-wrap:anywhere; word-break:break-word; }
    .bar{ margin-top:10px; height:12px; border-radius:999px; background: rgba(255,255,255,.08); border: 1px solid rgba(255,255,255,.10); overflow:hidden; }
    .bar > div{ height:100%; width:0%; background: linear-gradient(90deg, var(--g), var(--c), var(--p)); border-radius:999px; transition: width .25s ease; }
    .list{ margin:10px 0 0; padding:0; list-style:none; display:grid; gap:10px; }
    .li{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      border-radius: 16px;
      padding:12px 12px;
      display:flex; gap:10px;
      align-items:flex-start; justify-content:space-between;
      min-width:0;
    }
    .li .left{min-width:0;}
    .li .t{font-weight:1000; font-size:13px; letter-spacing:.2px;}
    .li .d{ margin-top:4px; color: rgba(255,255,255,.70); font-weight:750; font-size:12.5px; line-height:1.35; overflow-wrap:anywhere; word-break:break-word; }

    .pillRow{ display:flex; gap:8px; align-items:center; flex:0 0 auto; justify-content:flex-end; }
    .pill{
      padding:6px 10px; border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight:1000; font-size:12px; white-space:nowrap;
      user-select:none; -webkit-tap-highlight-color: transparent;
      cursor:pointer;
    }
    .pill.ok{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}
    .pill.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .pill.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}

    .infoBtn{
      width:26px; height:26px; border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.86);
      display:inline-flex; align-items:center; justify-content:center;
      cursor:pointer; user-select:none;
      font-weight:1000; font-size:13px; line-height:1;
      -webkit-tap-highlight-color: transparent;
    }
    .infoBtn:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }
    .infoBtn:active{ transform: translateY(0px); }
    .infoBtn span{ transform: translateY(-0.5px); }

    .explorerBtn{
      display:inline-flex; align-items:center; justify-content:center;
      padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000; font-size:12px; white-space:nowrap;
      cursor:pointer; user-select:none; -webkit-tap-highlight-color: transparent;
    }
    .explorerBtn:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }

    footer{ padding: 18px 0 34px; color: rgba(255,255,255,.45); font-weight:650; text-align:center; font-size:12px; }

    .modalWrap{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      display:none; align-items:center; justify-content:center;
      padding:18px; z-index:100;
    }
    .modal{
      width:min(920px, 100%);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(7,7,17,.92);
      box-shadow: 0 16px 50px rgba(0,0,0,.5);
      overflow:hidden;
    }
    .modalHead{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .modalTitle{ font-weight:1000; letter-spacing:-.3px; }
    .modalBody{
      padding:14px 16px 16px;
      color: rgba(255,255,255,.84);
      font-weight:850;
      line-height:1.5;
      overflow-wrap:anywhere; word-break:break-word;
    }

    .chainRow{ margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; }
    .chainBtn{
      display:inline-flex; align-items:center; gap:10px;
      padding:10px 12px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      cursor:pointer; user-select:none;
      font-weight:1000; font-size:13px;
      color: rgba(255,255,255,.88);
      -webkit-tap-highlight-color: transparent;
    }
    .chainBtn:hover{ background: rgba(255,255,255,.10); }
    .chainBtn.active{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .chainIcon{
      width:18px; height:18px; border-radius:6px;
      display:inline-flex; align-items:center; justify-content:center;
      overflow:hidden;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      flex:0 0 auto;
    }
    .chainIcon svg{ width:14px; height:14px; display:block; }
    .chainMiniHint{
      margin-top:10px;
      font-size:12.5px;
      color: rgba(255,255,255,.62);
      font-weight:850;
      line-height:1.35;
    }

    .toast{
      position:fixed;
      top: max(16px, env(safe-area-inset-top));
      left:50%;
      transform:translateX(-50%);
      width:min(920px, calc(100% - 28px));
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(7,7,17,.90);
      box-shadow: 0 16px 50px rgba(0,0,0,.45);
      padding:14px 14px;
      display:none;
      z-index:120;
      backdrop-filter: blur(12px);
    }
    .toastRow{display:flex; align-items:center; justify-content:space-between; gap:12px;}
    .toastTitle{font-weight:1000; font-size:18px; letter-spacing:-.3px;}
    .toastClose{
      padding:9px 12px; border-radius:999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      font-weight:950; cursor:pointer;
    }
    .toastClose:hover{background: rgba(255,255,255,.10);}

    @media (prefers-reduced-motion: reduce){
      .btn:hover{transform:none}
      .bar > div{transition:none}
      .infoBtn:hover{transform:none}
      .explorerBtn:hover{transform:none}
    }
  </style>
</head>

<body>
  <!-- Toast -->
  <div class="toast" id="toast">
    <div class="toastRow">
      <div class="toastTitle" id="toastTitle">—</div>
      <button class="toastClose" id="toastClose" type="button">Close</button>
    </div>
  </div>

  <div class="topbar">
    <div class="wrap">
      <div class="row">
        <div class="brand">
          <img src="/assets/logo.png" alt="$SOS" onerror="this.style.display='none'">
          <div class="bt">
            <div class="t">$SOS</div>
            <div class="s">Contract Scanner • Token Risk</div>
          </div>
        </div>
        <div class="actions">
          <a class="btn" href="https://solanax1.com/" rel="noreferrer">← Back to Main</a>
          <button class="btn grad" id="btnScan" type="button">Run Guardian Check</button>
          <button class="btn grad" id="btnExport" type="button" disabled>Download Scan Report</button>
        </div>
      </div>
    </div>
  </div>

  <main class="wrap">
    <section class="card hero">
      <div class="inner">
        <div class="classified">
          <div class="stamp">GUARDIAN SYSTEM • MAINNET • ON-CHAIN VERIFIED</div>
          <div class="stamp" id="stampTime">—</div>
        </div>

        <h1 class="h1" style="margin-top:12px;">
          <span class="gradText">Guardian Contract</span> Scanner
        </h1>

        <!-- CLEAN: only this line -->
        <div class="sub">
          Multi-chain scan: Solana + ETH + BNB + Base.
        </div>

        <div class="layout">
          <!-- INPUT -->
          <div class="panel">
            <label>Choose Chain</label>
            <div class="chainRow" id="chainRow"></div>
            <div class="chainMiniHint" id="chainHint">—</div>

            <label for="mint" style="margin-top:14px;" id="addrLabel">Token Address</label>
            <input id="mint" placeholder="Paste token address..." autocomplete="off" spellcheck="false" inputmode="text" />

            <button class="btn grad" id="btnScanInline" type="button" style="width:100%; margin-top:12px;">Run Guardian Check</button>
            <div class="statusLine" id="status"></div>
          </div>

          <!-- RESULTS -->
          <div class="panel" id="resultsPanel">
            <div class="resultTop">
              <div style="min-width:0">
                <div class="tokenHead">
                  <div class="tokenLogoWrap" id="tokenLogoWrap"><img id="tokenLogo" alt=""></div>
                  <div style="min-width:0">
                    <div class="tokenName" id="tokenName">—</div>
                    <div class="tokenSymbol" id="tokenSymbol">—</div>
                  </div>
                </div>
                <h3 class="resultTitle" id="verdictTitle">—</h3>
                <div class="mono" id="mintShort">—</div>
              </div>
              <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                <span class="badge" id="verdictBadge">—</span>
                <span class="badge good" id="scoreBadge">—</span>
              </div>
            </div>

            <div class="metricStack" id="metrics"></div>
            <div class="statusLine" id="summary">—</div>
          </div>
        </div>

        <!-- Checks -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">GUARDIAN CHECKS</div>
            <div class="stamp" id="scanHint">—</div>
          </div>
          <ul class="list" id="checksList" style="margin-top:10px;"></ul>
        </div>

        <!-- Launch readiness -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">LAUNCH READINESS</div>
            <div class="stamp">ACTION LIST</div>
          </div>
          <ul class="list" id="todoList" style="margin-top:10px;"></ul>
        </div>

        <!-- Token standard details -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOKEN STANDARD DETAILS</div>
            <div class="stamp">ON-CHAIN</div>
          </div>
          <ul class="list" id="extList" style="margin-top:10px;"></ul>
        </div>

        <!-- Metadata -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOKEN METADATA</div>
            <div class="stamp">RPC / ON-CHAIN</div>
          </div>
          <ul class="list" id="metaList" style="margin-top:10px;"></ul>
        </div>

        <!-- Top holders -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOP HOLDERS (PREVIEW)</div>
            <div class="stamp" id="holdersStamp">MAINNET</div>
          </div>
          <ul class="list" id="holdersList" style="margin-top:10px;"></ul>
        </div>
      </div>
    </section>

    <footer>© <span id="y"></span> $SOS • Guardian Check</footer>
  </main>

  <!-- Modal -->
  <div class="modalWrap" id="modalWrap" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle" id="modalTitle">Guardian Details</div>
        <button class="btn" id="modalClose" type="button">Close</button>
      </div>
      <div class="modalBody" id="modalBody"></div>
    </div>
  </div>

  <script>
    /* =========================================================
      GUARDIAN CHECK v2.4 — CLEAN SINGLE-FILE (ENGLISH + CLEAN REPORT)

      ✅ Everything translated to EN (no German strings left)
      ✅ Hero subline cleaned (only multi-chain line)
      ✅ Info buttons: short + clear (what it means + why PASS/WATCH/FAIL)
      ✅ Export: CLEAN HTML Scan Report (same design) + SVG charts + optional $SOS Approved brandmark
      ✅ Keeps existing code structure/features (no feature deletions)
    ========================================================= */

    /* ===================== CONFIG ===================== */
    const CFG = {
      HELIUS_KEY: "b566a086-57d4-4433-8661-faed9ad07ba0",
      // Optional Moralis for EVM logos/metadata:
      EVM_METADATA_KEY: "",
      // Covalent GoldRush (holders for EVM)
      GOLDRUSH_API_KEY: "cqt_rQVTMTXwYkPJBrwf7ff6JWmdkywR",

      TOKEN_PROGRAM: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
      TOKEN_2022_PROGRAM: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",

      CHAINS: [
        { id:"sol",  name:"Solana",   kind:"solana", stamp:"MAINNET",      addrLabel:"Token Mint Address",     placeholder:"Paste token mint (Solana)..." },
        { id:"eth",  name:"Ethereum", kind:"evm", chainId:1,    stamp:"ETH MAINNET",  addrLabel:"Token Contract Address", placeholder:"Paste ERC-20 contract (0x...)" },
        { id:"bnb",  name:"BNB",      kind:"evm", chainId:56,   stamp:"BNB MAINNET",  addrLabel:"Token Contract Address", placeholder:"Paste BEP-20 contract (0x...)" },
        { id:"base", name:"Base",     kind:"evm", chainId:8453, stamp:"BASE MAINNET", addrLabel:"Token Contract Address", placeholder:"Paste Base token contract (0x...)" }
      ],

      EVM_RPCS: {
        1:    ["https://ethereum.publicnode.com", "https://rpc.ankr.com/eth", "https://eth.llamarpc.com", "https://cloudflare-eth.com"],
        56:   ["https://bsc.publicnode.com",      "https://rpc.ankr.com/bsc", "https://bsc-dataseed.binance.org"],
        8453: ["https://base.publicnode.com",     "https://rpc.ankr.com/base", "https://mainnet.base.org"]
      }
    };

    /* ===================== ICONS ===================== */
    const ICONS = {
      sol: `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M6 7.5c.3-.4.7-.6 1.2-.6h14.3c.9 0 1.3 1.1.7 1.7l-2 2.2c-.3.4-.7.6-1.2.6H4.7c-.9 0-1.3-1.1-.7-1.7l2-2.2Z" fill="currentColor" opacity=".9"/>
        <path d="M6 16.5c.3-.4.7-.6 1.2-.6h14.3c.9 0 1.3 1.1.7 1.7l-2 2.2c-.3.4-.7.6-1.2.6H4.7c-.9 0-1.3-1.1-.7-1.7l2-2.2Z" fill="currentColor" opacity=".6"/>
        <path d="M18 12c-.3.4-.7.6-1.2.6H2.5c-.9 0-1.3-1.1-.7-1.7l2-2.2c.3-.4.7-.6 1.2-.6h14.3c.9 0 1.3 1.1.7 1.7l-2 2.2Z" fill="currentColor"/>
      </svg>`,
      eth: `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M12 2l6 10-6 3-6-3 6-10Z" fill="currentColor" opacity=".9"/>
        <path d="M12 22l6-8-6 3-6-3 6 8Z" fill="currentColor" opacity=".7"/>
      </svg>`,
      bnb: `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M12 2l4 4-4 4-4-4 4-4Z" fill="currentColor"/>
        <path d="M6 8l4 4-4 4-4-4 4-4Z" fill="currentColor" opacity=".8"/>
        <path d="M18 8l4 4-4 4-4-4 4-4Z" fill="currentColor" opacity=".8"/>
        <path d="M12 14l4 4-4 4-4-4 4-4Z" fill="currentColor" opacity=".6"/>
        <path d="M12 10l2 2-2 2-2-2 2-2Z" fill="currentColor" opacity=".9"/>
      </svg>`,
      base: `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M12 4.5c4.4 0 8 3.6 8 8s-3.6 8-8 8-8-3.6-8-8 3.6-8 8-8Z" fill="currentColor" opacity=".9"/>
        <path d="M10.2 9.2h3.1c1.9 0 3.5 1.5 3.5 3.4 0 1.9-1.6 3.4-3.5 3.4h-3.1V9.2Zm1.6 1.6v3.6h1.4c1 0 1.9-.8 1.9-1.8s-.8-1.8-1.9-1.8h-1.4Z" fill="#070711"/>
      </svg>`
    };

    /* ===================== SAFE DOM HELPERS ===================== */
    const qs = (id) => document.getElementById(id);
    const setText = (id, v) => { const el = qs(id); if (el) el.textContent = (v ?? ""); };
    const setHTML = (id, v) => { const el = qs(id); if (el) el.innerHTML = (v ?? ""); };
    const on = (id, ev, fn) => { const el = qs(id); if (el) el.addEventListener(ev, fn); };
    const esc = (x) => String(x ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;");

    /* ===================== GLOBAL STATE ===================== */
    let activeChain = CFG.CHAINS[0];
    let LAST_SCAN = null;
    let SCANNING = false;

    /* ===================== UTIL ===================== */
    function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }
    function shortAddr(a){ return a ? (a.slice(0,4) + "…" + a.slice(-4)) : "—"; }
    function fmtInt(n){
      if (n === null || n === undefined || Number.isNaN(n)) return "—";
      try { return new Intl.NumberFormat("en-US").format(Math.round(Number(n))); }
      catch { return String(n); }
    }
    function fmtPct(n){
      if (n === null || n === undefined || Number.isNaN(n)) return "—";
      return `${Number(n).toFixed(2)}%`;
    }
    function setStatus(msg){ setText("status", msg || ""); }
    function setBadge(el, txt, mode){
      if(!el) return;
      el.textContent = txt ?? "";
      el.classList.remove("good","warn","bad");
      if(mode) el.classList.add(mode);
    }
    function updateStampTime(){
      const el = qs("stampTime");
      if(!el) return;
      el.textContent = new Date().toISOString().replace("T"," ").slice(0,19) + " UTC";
    }

    /* ===================== VALIDATION ===================== */
    function looksBase58(s){
      return typeof s === "string" && s.length >= 32 && s.length <= 52 && /^[1-9A-HJ-NP-Za-km-z]+$/.test(s);
    }
    function looksEvmAddress(s){
      return typeof s === "string" && /^0x[0-9a-fA-F]{40}$/.test(s.trim());
    }

    /* ===================== MODAL + TOAST ===================== */
    function openModal(title, bodyHtml){
      setText("modalTitle", title || "Guardian Details");
      setHTML("modalBody", bodyHtml || "");
      const w = qs("modalWrap");
      if(w){
        w.style.display = "flex";
        w.setAttribute("aria-hidden","false");
      }
    }
    function closeModal(){
      const w = qs("modalWrap");
      if(w){
        w.style.display = "none";
        w.setAttribute("aria-hidden","true");
      }
    }
    function showToast(title){
      const t = qs("toast");
      if(!t) return;
      setText("toastTitle", title || "");
      t.style.display = "block";
    }
    function hideToast(){
      const t = qs("toast");
      if(!t) return;
      t.style.display = "none";
    }

    /* ===================== EXPLANATION BUILDER ===================== */
    function explain(title, bullets){
      const body = (bullets||[]).map(b => `<div style="margin:6px 0">${esc(b)}</div>`).join("");
      return `
        <div style="font-weight:1000; font-size:18px; margin-bottom:10px">${esc(title)}</div>
        <div style="color:rgba(255,255,255,.72); font-weight:850; line-height:1.55">${body}</div>
      `;
    }
    function explainStatus(sev, why){
      const head = sev==="ok" ? "PASS" : sev==="bad" ? "FAIL" : "WATCH";
      const base = sev==="ok"
        ? [
          "Meaning: No clear red flag detected for this specific check.",
          "Note: This does NOT guarantee safety — it only covers this item."
        ]
        : sev==="bad"
        ? [
          "Meaning: A strong risk signal was detected for this check.",
          "Why it matters: This can block transfers/sells, change supply, or enable admin abuse."
        ]
        : [
          "Meaning: Something is unclear or potentially abusable.",
          "Why it matters: You should understand it before buying — verify with docs/team."
        ];
      const extra = why ? [`Why this result: ${why}`] : [];
      return explain(head, [...base, ...extra]);
    }

    /* ===================== DATA-HTML SAFE MAP ===================== */
    const INFO_MAP = new Map();
    function newInfoId(){ return "i_" + Math.random().toString(36).slice(2) + Date.now().toString(36); }
    function registerInfo(html){ const id = newInfoId(); INFO_MAP.set(id, html); return id; }
    function getInfo(id){ return INFO_MAP.get(id) || ""; }

    /* ===================== UI RENDER ===================== */
    function applyTokenHeader(meta, addr){
      const nameEl = qs("tokenName");
      const symEl = qs("tokenSymbol");
      const wrap = qs("tokenLogoWrap");
      const img = qs("tokenLogo");

      const name = (meta?.name || "Token").trim() || "Token";
      const sym = (meta?.symbol || "").trim();

      if(nameEl) nameEl.textContent = name;
      if(symEl) symEl.textContent = sym ? `$${sym}` : `Addr: ${shortAddr(addr)}`;

      if(wrap && img){
        if(meta?.image){
          img.src = meta.image;
          img.alt = name;
          wrap.style.display = "block";
          img.onerror = () => { wrap.style.display = "none"; };
        }else{
          wrap.style.display = "none";
          img.removeAttribute("src");
          img.alt = "";
        }
      }
    }

    function pillLabel(sev){ return sev==="ok" ? "PASS" : sev==="bad" ? "FAIL" : "WATCH"; }
    function pillClass(sev){ return sev==="ok" ? "pill ok" : sev==="bad" ? "pill bad" : "pill warn"; }

    function renderList(listEl, items, defaultTitle){
      if(!listEl) return;
      listEl.innerHTML = "";

      for(const it of items){
        const sev = it.sev || "warn";
        const title = it.t || defaultTitle || "Details";
        const desc = it.d || "—";
        const infoTitle = it.infoTitle || title;

        const html = (it.infoHtml && String(it.infoHtml).trim())
          ? String(it.infoHtml)
          : explainStatus(sev, it.why || "");

        const infoId = registerInfo(html);

        const li = document.createElement("li");
        li.className = "li";
        li.innerHTML = `
          <div class="left">
            <div class="t">${esc(title)}</div>
            <div class="d">${esc(desc)}</div>
          </div>
          <div class="pillRow">
            <span class="${pillClass(sev)}" role="button" tabindex="0" data-open="1" data-title="${esc(infoTitle)}" data-info="${esc(infoId)}">${pillLabel(sev)}</span>
            <button class="infoBtn" type="button" aria-label="Info" data-open="1" data-title="${esc(infoTitle)}" data-info="${esc(infoId)}"><span>i</span></button>
          </div>
        `;
        listEl.appendChild(li);
      }
    }

    function renderMetrics(rows){
      const wrap = qs("metrics");
      if(!wrap) return;
      wrap.innerHTML = "";

      for(const r of rows){
        const d = document.createElement("div");
        d.className = "metric";

        const bar = (typeof r.barPct === "number")
          ? `<div class="bar"><div style="width:${clamp(r.barPct,0,100)}%"></div></div>`
          : "";

        d.innerHTML = `
          <div class="metricK">
            <span>${esc(r.label || "—")}</span>
            <span class="badge" style="opacity:.9">${esc(r.badge || r.value || "—")}</span>
          </div>
          <div class="metricV">${esc(r.value || "—")}</div>
          <div class="metricMini">${esc(r.mini || "")}</div>
          ${bar}
        `;
        wrap.appendChild(d);
      }
    }

    function clearUI(){
      setText("mintShort","—");
      setText("verdictTitle","—");
      setBadge(qs("verdictBadge"),"—");
      setText("scoreBadge","—");
      setText("summary","—");
      setText("scanHint","—");
      setText("tokenName","—");
      setText("tokenSymbol","—");

      const lw = qs("tokenLogoWrap");
      if(lw) lw.style.display = "none";

      renderMetrics([]);

      renderList(qs("checksList"), [{
        t:"No scan yet",
        sev:"warn",
        d:"Paste a token address and run the Guardian Check.",
        why:"No scan data is available yet."
      }], "Guardian Checks");

      renderList(qs("todoList"), [{
        t:"Waiting for scan",
        sev:"warn",
        d:"Launch checklist will appear after the scan.",
        why:"Run a scan to generate action items."
      }], "Launch Readiness");

      renderList(qs("extList"), [{
        t:"No scan yet",
        sev:"warn",
        d:"Token standard details appear after the scan.",
        why:"Run a scan to load standard/extension details."
      }], "Token Standard Details");

      renderList(qs("metaList"), [{
        t:"No scan yet",
        sev:"warn",
        d:"Name / symbol / logo appear after the scan.",
        why:"Run a scan to load token metadata."
      }], "Token Metadata");

      renderHoldersEmpty();

      LAST_SCAN = null;
      const ex = qs("btnExport");
      if(ex){
        ex.disabled = true;
        ex.textContent = "Download Scan Report";
      }
    }

    /* ===================== HOLDERS UI (Explorer Buttons) ===================== */
    function explorerBase(chain){
      if(chain.id === "sol")  return {name:"Solscan",  base:"https://solscan.io/account/"};
      if(chain.id === "eth")  return {name:"Etherscan",base:"https://etherscan.io/address/"};
      if(chain.id === "bnb")  return {name:"BscScan",  base:"https://bscscan.com/address/"};
      if(chain.id === "base") return {name:"BaseScan", base:"https://basescan.org/address/"};
      return {name:"Explorer", base:"#"};
    }

    function renderHoldersEmpty(){
      const el = qs("holdersList");
      if(!el) return;

      const msg = activeChain.kind === "solana"
        ? "Top holders appear after the scan (RPC: largest accounts)."
        : (CFG.GOLDRUSH_API_KEY
          ? "Holders appear if the indexer returns data (GoldRush)."
          : "EVM holder lists require an indexer (RPC alone can't enumerate holders).");

      renderList(el, [{
        t:"No holder data",
        sev:"warn",
        d: msg,
        infoHtml: explain("Top holders (preview)", [
          "Meaning: Distribution shows whale risk and potential dump pressure.",
          "Solana: fetched via RPC largest accounts.",
          "EVM: requires an indexer (e.g., GoldRush)."
        ])
      }], "Top Holders");
    }

    function renderHoldersWithExplorer(items, chain, infoForRow){
      const el = qs("holdersList");
      if(!el) return;
      el.innerHTML = "";

      const ex = explorerBase(chain);

      for(const it of items){
        const title = it.t;
        const desc = it.d;
        const addr = it.addr;

        const infoId = registerInfo(
          it.infoHtml || infoForRow || explain("Top holder", [
            "Meaning: Share of total supply.",
            "Why it matters: Higher % = higher whale/dump risk.",
            "Tip: Check if this is LP, burn, team, or treasury."
          ])
        );

        const li = document.createElement("li");
        li.className = "li";
        li.innerHTML = `
          <div class="left">
            <div class="t">${esc(title)}</div>
            <div class="d">${esc(desc)}</div>
          </div>
          <div class="pillRow">
            <a class="explorerBtn" href="${esc(ex.base + addr)}" target="_blank" rel="noreferrer">${esc(ex.name)}</a>
            <button class="infoBtn" type="button" aria-label="Info" data-open="1" data-title="${esc(title)}" data-info="${esc(infoId)}"><span>i</span></button>
          </div>
        `;
        el.appendChild(li);
      }
    }

    /* ===================== CHAIN UI ===================== */
    function renderChainButtons(){
      const row = qs("chainRow");
      if(!row) return;
      row.innerHTML = "";

      for(const c of CFG.CHAINS){
        const b = document.createElement("button");
        b.type = "button";
        b.className = "chainBtn" + (c.id === activeChain.id ? " active" : "");
        b.innerHTML = `
          <span class="chainIcon">${ICONS[c.id] || ""}</span>
          <span>${esc(c.name)}</span>
        `;
        b.addEventListener("click", () => setActiveChain(c.id, true));
        row.appendChild(b);
      }
    }

    function setActiveChain(chainId, pushUrl){
      const found = CFG.CHAINS.find(x => x.id === chainId) || CFG.CHAINS[0];
      activeChain = found;

      renderChainButtons();
      setText("holdersStamp", activeChain.stamp || "MAINNET");
      setText("addrLabel", activeChain.addrLabel || "Token Address");

      const mint = qs("mint");
      if(mint) mint.placeholder = activeChain.placeholder || "Paste token address...";

      const hint = (activeChain.kind === "solana")
        ? "Solana: Mint/Freeze authorities + largest holders (RPC) + metadata (Helius)."
        : (CFG.GOLDRUSH_API_KEY
          ? "EVM: ERC-20 calls + owner/proxy/controls. Holders via GoldRush (indexer) + % from totalSupply."
          : "EVM: ERC-20 calls + owner/proxy/controls. Holders require an indexer (GoldRush).");

      setText("chainHint", hint);
      setStatus("");
      clearUI();

      if(pushUrl){
        const url = new URL(location.href);
        url.searchParams.set("chain", activeChain.id);
        history.replaceState({}, "", url.toString());
      }
    }

    /* ===================== VERDICT / SCORING ===================== */
    function verdictFrom(score, critical){
      if(critical) return {label:"FLAGGED", mode:"bad", title:"FLAGGED • High Risk"};
      if(score >= 80) return {label:"APPROVED", mode:"good", title:"APPROVED • Guardian Grade"};
      if(score >= 50) return {label:"OBSERVED", mode:"warn", title:"OBSERVED • Mixed Signals"};
      return {label:"FLAGGED", mode:"bad", title:"FLAGGED • High Risk"};
    }

    /* ===================== SOLANA RPC (Helius) ===================== */
    function HELIUS_RPC(){
      return `https://mainnet.helius-rpc.com/?api-key=${encodeURIComponent(CFG.HELIUS_KEY)}`;
    }

    async function solRpc(method, params){
      if(!CFG.HELIUS_KEY) throw new Error("Helius key missing.");
      const res = await fetch(HELIUS_RPC(), {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ jsonrpc:"2.0", id:1, method, params })
      });
      if(!res.ok){
        const t = await res.text().catch(()=> "");
        throw new Error(`Solana RPC HTTP ${res.status}: ${t.slice(0,220)}`);
      }
      const j = await res.json();
      if(j?.error) throw new Error(j.error.message || "Solana RPC error");
      return j.result;
    }

    async function getMintParsed(mint){
      const r = await solRpc("getAccountInfo", [mint, { encoding:"jsonParsed", commitment:"confirmed" }]);
      const v = r?.value;
      if(!v) return null;
      const owner = v.owner;
      const parsed = (v.data && typeof v.data === "object") ? v.data.parsed : null;
      const info = parsed?.info || null;
      return { owner, info, rawParsed: parsed };
    }

    async function getTokenSupply(mint){
      const r = await solRpc("getTokenSupply", [mint]);
      return r?.value || null;
    }

    async function getLargest(mint){
      const r = await solRpc("getTokenLargestAccounts", [mint]);
      return r?.value || [];
    }

    async function getAsset(mint){
      try { return await solRpc("getAsset", [mint]); }
      catch { return null; }
    }

    function pickTokenMetaFromAsset(asset){
      if(!asset) return null;
      const md = asset?.content?.metadata || {};
      const name = (md?.name || asset?.metadata?.name || "").trim();
      const symbol = (md?.symbol || asset?.metadata?.symbol || "").trim();

      let image = "";
      const linksImg = asset?.content?.links?.image;
      if(typeof linksImg === "string") image = linksImg;

      if(!image && Array.isArray(asset?.content?.files)){
        const f = asset.content.files.find(x => (x?.mime || "").includes("image") && x?.uri);
        if(f?.uri) image = f.uri;
      }

      const uri = (asset?.content?.json_uri || asset?.content?.links?.external_url || "").trim();
      const description = (md?.description || asset?.content?.metadata?.description || "").trim();
      const authorities = Array.isArray(asset?.authorities) ? asset.authorities : [];

      return { name, symbol, image, uri, description, authorities };
    }

    function parseExtensionsFromParsed(rawParsed){
      try{
        const info = rawParsed?.info || null;
        if(!info) return null;
        const ex = info.extensions || info.extensionTypes || info.mintExtensions;

        if(Array.isArray(ex) && ex.length){
          return ex.map(x => ({ name: (typeof x === "string") ? x : (x?.type || x?.name || "Extension") }));
        }
        if(ex && typeof ex === "object"){
          return Object.keys(ex).map(k => ({ name:k }));
        }
        return null;
      }catch{ return null; }
    }

    function humanizeExtensionName(n){
      const s = String(n||"").toLowerCase();
      if(s.includes("transferfee") || s.includes("transfer_fee")) return "Transfer Fee (fees on transfers)";
      if(s.includes("permanentdelegate") || s.includes("permanent_delegate")) return "Permanent Delegate (delegate control)";
      if(s.includes("nontransferable") || s.includes("non_transferable")) return "Non-Transferable (cannot be transferred)";
      if(s.includes("interestbearing") || s.includes("interest_bearing")) return "Interest-Bearing (yield mechanics)";
      if(s.includes("confidential")) return "Confidential Transfers (privacy mode)";
      if(s.includes("metadata")) return "Metadata Extension";
      return n;
    }

    function scoreSol(sig){
      let score = 100;
      const checks = [];

      if(sig.freezeActive){
        score -= 35;
        checks.push({
          t:"Freeze Authority",
          sev:"bad",
          d:"Freeze authority is active — wallets can be frozen.",
          why:"Freeze authority is set (not removed).",
          infoHtml: explain("Freeze Authority", [
            "Meaning: Admin can freeze token accounts.",
            "Why it matters: Holders may be unable to transfer/sell.",
            "PASS would be: freezeAuthority = null (removed/renounced)."
          ])
        });
      }else{
        checks.push({
          t:"Freeze Authority",
          sev:"ok",
          d:"Freeze authority is removed (good).",
          why:"freezeAuthority is not set.",
          infoHtml: explain("Freeze Authority", [
            "Meaning: Admin cannot freeze accounts.",
            "Why PASS: freezeAuthority is null / not present."
          ])
        });
      }

      if(sig.mintAuthActive){
        score -= 30;
        checks.push({
          t:"Mint Authority",
          sev:"bad",
          d:"Mint authority is active — supply can be increased.",
          why:"Mint authority is set (not renounced).",
          infoHtml: explain("Mint Authority", [
            "Meaning: Admin can mint new tokens.",
            "Why it matters: Inflation can crush price.",
            "PASS would be: mintAuthority = null (renounced)."
          ])
        });
      }else{
        checks.push({
          t:"Mint Authority",
          sev:"ok",
          d:"Mint authority is renounced (good).",
          why:"mintAuthority is not set.",
          infoHtml: explain("Mint Authority", [
            "Meaning: Supply cannot be increased by an admin mint.",
            "Why PASS: mintAuthority is null / not present."
          ])
        });
      }

      const t20 = Number(sig.top20 || 0);
      if(t20 >= 75){
        score -= 28;
        checks.push({
          t:"Holder distribution (Top20)",
          sev:"bad",
          d:`Top 20 hold ~${t20.toFixed(2)}% (very high).`,
          why:"Extremely concentrated distribution.",
          infoHtml: explain("Top20 Distribution", [
            `Top20 share: ~${t20.toFixed(2)}%`,
            "Why it matters: Few wallets can dump hard.",
            "FAIL: extreme whale concentration."
          ])
        });
      }else if(t20 >= 55){
        score -= 18;
        checks.push({
          t:"Holder distribution (Top20)",
          sev:"warn",
          d:`Top 20 hold ~${t20.toFixed(2)}% (high).`,
          why:"Highly concentrated distribution.",
          infoHtml: explain("Top20 Distribution", [
            `Top20 share: ~${t20.toFixed(2)}%`,
            "Why it matters: Elevated whale/dump risk.",
            "WATCH: identify LP/burn/team wallets."
          ])
        });
      }else if(t20 >= 35){
        score -= 8;
        checks.push({
          t:"Holder distribution (Top20)",
          sev:"warn",
          d:`Top 20 hold ~${t20.toFixed(2)}% (moderate).`,
          why:"Moderate concentration.",
          infoHtml: explain("Top20 Distribution", [
            `Top20 share: ~${t20.toFixed(2)}%`,
            "WATCH: still verify large wallets."
          ])
        });
      }else{
        checks.push({
          t:"Holder distribution (Top20)",
          sev:"ok",
          d:`Top 20 hold ~${t20.toFixed(2)}% (better).`,
          why:"Lower concentration.",
          infoHtml: explain("Top20 Distribution", [
            `Top20 share: ~${t20.toFixed(2)}%`,
            "Why PASS: healthier distribution signal."
          ])
        });
      }

      if(sig.programType === "TOKEN_2022"){
        score -= sig.extReadable ? 6 : 10;
        checks.push({
          t:"Token Standard",
          sev:"warn",
          d: sig.extReadable ? "Token-2022 detected (extensions possible)." : "Token-2022 detected (extensions not readable).",
          why:"Token-2022 can add extra rules.",
          infoHtml: explain("Token-2022", [
            "Meaning: SPL Token program with optional extensions.",
            "Why it matters: Extensions can add fees/restrictions.",
            "WATCH: Review Token Standard Details (extensions)."
          ])
        });
      }else if(sig.programType === "SPL_TOKEN"){
        checks.push({
          t:"Token Standard",
          sev:"ok",
          d:"Standard SPL Token program.",
          why:"Mint owner is the standard token program.",
          infoHtml: explain("SPL Token", [
            "Meaning: Standard Solana Token program.",
            "Why PASS: No Token-2022 extension surface."
          ])
        });
      }else{
        score -= 10;
        checks.push({
          t:"Token Standard",
          sev:"warn",
          d:"Unknown token program (caution).",
          why:"Mint owner is not Tokenkeg or Token-2022.",
          infoHtml: explain("Unknown Token Program", [
            "Meaning: Not running on the standard programs.",
            "Why it matters: Custom programs can hide rules.",
            "WATCH: Verify extremely carefully."
          ])
        });
      }

      if(sig.meta && (sig.meta.name || sig.meta.symbol)){
        checks.push({
          t:"Metadata",
          sev:"ok",
          d:"Name/symbol metadata found.",
          why:"Token metadata could be fetched.",
          infoHtml: explain("Metadata", [
            "Meaning: Easier to verify token identity.",
            "Why PASS: Metadata was readable."
          ])
        });
      }else{
        score -= 4;
        checks.push({
          t:"Metadata",
          sev:"warn",
          d:"Metadata missing or unreadable.",
          why:"No name/symbol found via metadata endpoint.",
          infoHtml: explain("Metadata", [
            "Meaning: Missing metadata makes impersonation easier.",
            "WATCH: Compare with official links and explorers."
          ])
        });
      }

      score = clamp(Math.round(score), 0, 100);
      const critical = !!(sig.freezeActive || sig.mintAuthActive);
      return { score, checks, critical };
    }

    function todoSol(sig){
      const t = [];

      t.push(sig.freezeActive
        ? {t:"Remove Freeze Authority", sev:"bad", d:"Freeze can block holders from selling/transferring.", why:"Freeze authority is active — remove it."}
        : {t:"Freeze Authority", sev:"ok", d:"Already removed.", why:"Freeze authority is not active."}
      );

      t.push(sig.mintAuthActive
        ? {t:"Renounce Mint Authority", sev:"bad", d:"Mint can inflate supply.", why:"Mint authority is active — renounce it."}
        : {t:"Mint Authority", sev:"ok", d:"Already renounced.", why:"Mint authority is not active."}
      );

      const t20 = Number(sig.top20 || 0);
      if(t20 >= 55) t.push({t:"Reduce Whale Concentration", sev:"warn", d:`Top20 ~${t20.toFixed(2)}%.`, why:"High concentration — identify large wallets."});
      else if(t20 >= 35) t.push({t:"Monitor Distribution", sev:"warn", d:`Top20 ~${t20.toFixed(2)}%.`, why:"Moderate concentration — keep an eye on whales."});
      else t.push({t:"Distribution", sev:"ok", d:`Top20 ~${t20.toFixed(2)}% (better).`, why:"Distribution signal looks healthier."});

      if(sig.programType === "TOKEN_2022"){
        t.push({t:"Review Token-2022 Extensions", sev:"warn", d:"Extensions can change transfer rules/fees.", why:"Token-2022 detected."});
      }else if(sig.programType === "UNKNOWN"){
        t.push({t:"Verify Mint Program", sev:"warn", d:"Unknown program = extra caution.", why:"Not a standard token program."});
      }else{
        t.push({t:"Token Standard", sev:"ok", d:"Standard SPL Token.", why:"No Token-2022 extension surface."});
      }

      if(!(sig.meta && (sig.meta.name || sig.meta.symbol))){
        t.push({t:"Publish/Verify Metadata", sev:"warn", d:"Missing metadata makes spoofing easier.", why:"Metadata missing/unreadable."});
      }else{
        t.push({t:"Metadata", sev:"ok", d:"Name/symbol present.", why:"Metadata readable."});
      }

      return t.map(x => ({
        ...x,
        infoHtml: explain(x.t, [
          x.d,
          "Why it matters: reduces scam/abuse risk for buyers.",
          `Status: ${pillLabel(x.sev)}`
        ])
      }));
    }

    function renderExtSol(programType, extReadable, extList){
      const el = qs("extList");
      if(!el) return;

      if(programType !== "TOKEN_2022"){
        renderList(el, [{
          t:"Token standard details",
          sev: programType==="SPL_TOKEN" ? "ok" : "warn",
          d: programType==="SPL_TOKEN"
            ? "Standard SPL Token. Token-2022 extensions not applicable."
            : "Unknown program. Treat with caution.",
          infoHtml: explain("Token standard details", [
            "Token-2022 extensions only apply when Token-2022 is detected.",
            "If program is unknown: verify extremely carefully."
          ])
        }], "Token standard details");
        return;
      }

      if(!extReadable){
        renderList(el, [{
          t:"Token-2022 extensions",
          sev:"warn",
          d:"Extensions could not be read from the parsed mint.",
          infoHtml: explain("Token-2022 extensions", [
            "Token-2022 can include additional rules.",
            "WATCH: If extensions aren't readable, verify via explorer/tools."
          ])
        }], "Token-2022 extensions");
        return;
      }

      const items = (extList || []).map(x => {
        const nameHuman = humanizeExtensionName(x.name);
        const lname = String(x.name||"").toLowerCase();
        let sev = "warn";
        if(lname.includes("nontransferable")) sev = "bad";

        return {
          t: nameHuman,
          sev,
          d: `Extension detected: ${nameHuman}.`,
          infoHtml: explain(nameHuman, [
            "Meaning: An additional rule in the Token-2022 standard.",
            sev==="bad" ? "Risk: Can prevent transfers." : "WATCH: Safe only if fully understood."
          ])
        };
      });

      renderList(el, items.length
        ? items
        : [{
          t:"No extensions listed",
          sev:"ok",
          d:"No Token-2022 extensions detected.",
          infoHtml: explain("Extensions", [
            "Meaning: No extra Token-2022 rules detected from the parsed response."
          ])
        }],
        "Token-2022 Extension Details"
      );
    }

    function renderMetaSol(meta){
      const el = qs("metaList");
      if(!el) return;

      if(!meta){
        renderList(el, [{
          t:"Metadata not available",
          sev:"warn",
          d:"Could not fetch metadata via getAsset.",
          infoHtml: explain("Token metadata", [
            "Meaning: Name/symbol/logo help detect fake tokens.",
            "Why WATCH: Metadata could not be loaded."
          ])
        }], "Token Metadata");
        return;
      }

      const items = [];
      items.push({
        t:"Name / Symbol",
        sev:(meta.name || meta.symbol) ? "ok" : "warn",
        d:`${meta.name || "—"} • ${meta.symbol ? "$"+meta.symbol : "—"}`,
        infoHtml: explain("Name / Symbol", [
          "Meaning: Token identity fields.",
          (meta.name || meta.symbol) ? "Why PASS: Values are present." : "Why WATCH: Missing/unreadable."
        ])
      });

      items.push({
        t:"Metadata Link",
        sev: meta.uri ? "ok" : "warn",
        d: meta.uri ? "Metadata link found." : "No metadata link found.",
        infoHtml: explain("Metadata Link", [
          "Meaning: Off-chain JSON (image/description).",
          meta.uri ? "Why PASS: Link exists." : "Why WATCH: Link not found."
        ])
      });

      items.push({
        t:"Image / Logo",
        sev: meta.image ? "ok" : "warn",
        d: meta.image ? "Logo found." : "No logo found.",
        infoHtml: explain("Logo", [
          "Meaning: Helps verify the correct token visually.",
          meta.image ? "Why PASS: Logo exists." : "Why WATCH: No logo found."
        ])
      });

      if(meta.description){
        items.push({
          t:"Description",
          sev:"ok",
          d: meta.description.slice(0,120) + (meta.description.length>120 ? "…" : ""),
          infoHtml: explain("Description", [ meta.description ])
        });
      }

      if(Array.isArray(meta.authorities) && meta.authorities.length){
        items.push({
          t:"Metadata authorities",
          sev:"warn",
          d:"Metadata authorities exist (review).",
          infoHtml: explain("Metadata authorities", [
            "Meaning: Someone may be able to change name/logo later.",
            "WATCH: Acceptable only if transparent / renounced / controlled."
          ])
        });
      }

      renderList(el, items, "Token Metadata");
    }

    function renderHoldersSol(mint, uiSupply, largest){
      if(!uiSupply || !largest || !largest.length){
        renderHoldersEmpty();
        return;
      }

      const top = largest.slice(0,10);
      const items = top.map((x,i) => {
        const addr = x?.address || "";
        const amt = Number(x?.uiAmount || 0);
        const pct = uiSupply > 0 ? (amt / uiSupply) * 100 : 0;

        return {
          t:`#${i+1} ${shortAddr(addr)}`,
          d:`${fmtInt(amt)} tokens • ${pct.toFixed(2)}%`,
          addr,
          infoHtml: explain("Top holder", [
            `This wallet holds ~${pct.toFixed(2)}% of supply.`,
            "Why it matters: High % = higher dump risk.",
            "Tip: Identify LP/burn/team/treasury wallets."
          ])
        };
      });

      renderHoldersWithExplorer(items, activeChain);
    }

    /* ===================== EVM RPC + ERC-20 ===================== */
    async function evmRpc(chainId, method, params){
      const urls = CFG.EVM_RPCS[chainId] || [];
      if(!urls.length) throw new Error("No RPC configured for this chain.");

      const errors = [];
      for(const url of urls){
        const ctrl = new AbortController();
        const timer = setTimeout(() => ctrl.abort(), 12000);

        try{
          const res = await fetch(url, {
            method:"POST",
            headers:{ "Content-Type":"application/json" },
            body: JSON.stringify({ jsonrpc:"2.0", id:1, method, params }),
            signal: ctrl.signal
          });
          clearTimeout(timer);

          if(!res.ok){
            const t = await res.text().catch(()=> "");
            errors.push(`HTTP ${res.status} ${t.slice(0,160)}`);
            continue;
          }
          const j = await res.json();
          if(j?.error){
            errors.push(String(j.error?.message || "RPC error").slice(0,160));
            continue;
          }
          return j.result;
        }catch(e){
          clearTimeout(timer);
          errors.push(String(e?.message || e).slice(0,160));
        }
      }

      throw new Error(`All RPCs failed. ${errors.slice(-3).join(" • ")}`);
    }

    async function ethCall(chainId, to, data){
      return await evmRpc(chainId, "eth_call", [{to, data}, "latest"]);
    }
    async function getCode(chainId, addr){
      return await evmRpc(chainId, "eth_getCode", [addr, "latest"]);
    }
    async function getStorageAt(chainId, addr, slot){
      return await evmRpc(chainId, "eth_getStorageAt", [addr, slot, "latest"]);
    }

    const SEL = {
      name: "0x06fdde03",
      symbol: "0x95d89b41",
      decimals: "0x313ce567",
      totalSupply: "0x18160ddd",
      owner: "0x8da5cb5b",
      paused: "0x5c975abb"
    };

    function strip0x(h){ return (h||"").startsWith("0x") ? h.slice(2) : (h||""); }

    function decodeUint256(hex){
      const h = strip0x(hex);
      if(!h) return null;
      const padded = h.padStart(64,"0").slice(-64);
      try { return BigInt("0x"+padded); } catch { return null; }
    }

    function decodeAddressFrom32(hex){
      const h = strip0x(hex);
      if(!h) return null;
      const padded = h.padStart(64,"0").slice(-40);
      return "0x" + padded;
    }

    function bytes32ToAscii(hex){
      const h = strip0x(hex);
      if(h.length !== 64) return "";
      try{
        const bytes = new Uint8Array(h.match(/.{1,2}/g).map(b => parseInt(b,16)));
        let s = new TextDecoder().decode(bytes).replace(/\0/g,"").trim();
        if(!s) return "";
        if(/^[\x20-\x7E]+$/.test(s)) return s;
        return "";
      }catch{ return ""; }
    }

    function decodeString(hex){
      const data = strip0x(hex);
      if(!data) return "";

      // bytes32 style
      if(data.length === 64){
        const b = bytes32ToAscii("0x"+data);
        if(b) return b;
      }

      // ABI string style
      if(data.length < 128) return "";
      const lenHex = data.slice(64,128);

      let len = 0;
      try { len = Number(BigInt("0x"+lenHex)); } catch { return ""; }
      if(!Number.isFinite(len) || len <= 0) return "";

      const strData = data.slice(128, 128 + len*2);
      if(!strData) return "";

      try{
        const bytes = new Uint8Array(strData.match(/.{1,2}/g).map(b => parseInt(b,16)));
        return new TextDecoder().decode(bytes).replace(/\0/g,"").trim();
      }catch{ return ""; }
    }

    async function getErc20Meta(chainId, addr){
      const out = { name:"", symbol:"", decimals:null, totalSupply:null };
      try { out.name = decodeString(await ethCall(chainId, addr, SEL.name)); } catch {}
      try { out.symbol = decodeString(await ethCall(chainId, addr, SEL.symbol)); } catch {}
      try {
        const v = decodeUint256(await ethCall(chainId, addr, SEL.decimals));
        out.decimals = (v === null) ? null : Number(v);
        if(!Number.isFinite(out.decimals)) out.decimals = null;
      } catch {}
      try { out.totalSupply = decodeUint256(await ethCall(chainId, addr, SEL.totalSupply)); } catch {}
      return out;
    }

    async function getOwner(chainId, addr){
      try{
        const r = await ethCall(chainId, addr, SEL.owner);
        return decodeAddressFrom32(r || "0x");
      }catch{ return null; }
    }

    // paused():
    //  true  => currently paused (FAIL)
    //  false => pausability exists (WATCH)
    //  null  => not found/unreadable (PASS for this specific item)
    async function getPaused(chainId, addr){
      try{
        const r = await ethCall(chainId, addr, SEL.paused);
        const v = decodeUint256(r || "0x");
        if(v === null) return null;
        return v !== 0n;
      }catch{ return null; }
    }

    /* Proxy detection (EIP-1967) */
    const SLOT_IMPL  = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
    const SLOT_ADMIN = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103";

    async function detectProxy(chainId, addr){
      try{
        const [implRaw, adminRaw] = await Promise.all([
          getStorageAt(chainId, addr, SLOT_IMPL),
          getStorageAt(chainId, addr, SLOT_ADMIN)
        ]);

        const impl = decodeAddressFrom32(implRaw || "0x");
        const admin = decodeAddressFrom32(adminRaw || "0x");
        const zero = "0x0000000000000000000000000000000000000000";

        const implNonZero = impl && impl.toLowerCase() !== zero;
        const adminNonZero = admin && admin.toLowerCase() !== zero;

        return {
          isProxy: implNonZero || adminNonZero,
          implementation: implNonZero ? impl : null,
          admin: adminNonZero ? admin : null
        };
      }catch{
        return {isProxy:false, implementation:null, admin:null};
      }
    }

    /* Optional Moralis metadata */
    function moralisChainParam(chainId){
      if(chainId === 1) return "eth";
      if(chainId === 56) return "bsc";
      if(chainId === 8453) return "base";
      return "eth";
    }

    async function getEvmMetaViaApi(chainId, addr){
      if(!CFG.EVM_METADATA_KEY) return null;
      const chain = moralisChainParam(chainId);
      const url = `https://deep-index.moralis.io/api/v2.2/erc20/metadata?chain=${encodeURIComponent(chain)}&addresses=${encodeURIComponent(addr)}`;

      try{
        const res = await fetch(url, {
          method:"GET",
          headers:{ "accept":"application/json", "x-api-key": CFG.EVM_METADATA_KEY }
        });
        if(!res.ok) return null;

        const data = await res.json();
        const item = Array.isArray(data) ? data[0] : null;
        if(!item) return null;

        return {
          name: (item.name || "").trim(),
          symbol: (item.symbol || "").trim(),
          image: (item.logo || item.thumbnail || "").trim(),
          decimals: Number.isFinite(Number(item.decimals)) ? Number(item.decimals) : null
        };
      }catch{ return null; }
    }

    /* Optional GoldRush holders */
    function goldrushChain(chainId){
      if(chainId === 1) return "eth-mainnet";
      if(chainId === 56) return "bsc-mainnet";
      if(chainId === 8453) return "base-mainnet";
      return "eth-mainnet";
    }

    async function goldrushHolders(chainId, addr){
      if(!CFG.GOLDRUSH_API_KEY) return [];
      const url = `https://api.covalenthq.com/v1/${goldrushChain(chainId)}/tokens/${addr}/token_holders/?page-size=10&key=${encodeURIComponent(CFG.GOLDRUSH_API_KEY)}`;
      try{
        const r = await fetch(url);
        if(!r.ok) return [];
        const j = await r.json();
        return Array.isArray(j?.data?.items) ? j.data.items : [];
      }catch{ return []; }
    }

    /* EVM scoring (clean explanations) */
    function scoreEvm(sig){
      let score = 100;
      const checks = [];

      if(!sig.hasCode){
        checks.push({
          t:"Contract found",
          sev:"bad",
          d:"No bytecode at this address.",
          why:"Address is not a contract (or wrong chain).",
          infoHtml: explain("Contract found", [
            "Meaning: A token must be a deployed contract (bytecode must exist).",
            "Why FAIL: Address returned empty code."
          ])
        });
        return { score:0, checks, critical:true };
      }

      checks.push({
        t:"Contract found",
        sev:"ok",
        d:"Bytecode exists (contract).",
        why:"eth_getCode returned non-empty code.",
        infoHtml: explain("Contract found", [
          "Meaning: Address is a smart contract.",
          "Why PASS: Bytecode exists."
        ])
      });

      const hasName = !!sig.metaOnChain?.name;
      const hasSymbol = !!sig.metaOnChain?.symbol;

      if(!hasName || !hasSymbol){
        score -= 10;
        checks.push({
          t:"ERC-20 metadata",
          sev:"warn",
          d:"Name or symbol is not cleanly readable.",
          why:"name()/symbol() reverted or non-standard ABI.",
          infoHtml: explain("ERC-20 metadata", [
            "Meaning: name()/symbol() help identify the token.",
            "Why WATCH: Calls did not return cleanly."
          ])
        });
      }else{
        checks.push({
          t:"ERC-20 metadata",
          sev:"ok",
          d:"Name & symbol readable.",
          why:"name()/symbol() responded.",
          infoHtml: explain("ERC-20 metadata", [
            "Meaning: Standard token calls work.",
            "Why PASS: name()/symbol() returned successfully."
          ])
        });
      }

      const decOk = Number.isFinite(sig.metaOnChain?.decimals) && sig.metaOnChain.decimals >= 0 && sig.metaOnChain.decimals <= 36;

      if(!decOk){
        score -= 12;
        checks.push({
          t:"Decimals",
          sev:"warn",
          d:"decimals() is not readable or unusual.",
          why:"decimals() missing/reverted/out of range.",
          infoHtml: explain("Decimals", [
            "Meaning: Decimals are used for UI display and supply math.",
            "Why WATCH: decimals() not clearly available."
          ])
        });
      }else{
        checks.push({
          t:"Decimals",
          sev:"ok",
          d:`Decimals: ${sig.metaOnChain.decimals}`,
          why:"decimals() responded.",
          infoHtml: explain("Decimals", [
            "Meaning: Standard ERC-20 property.",
            "Why PASS: decimals() returned successfully."
          ])
        });
      }

      const supplyReadable = sig.metaOnChain?.totalSupply !== null && sig.metaOnChain?.totalSupply !== undefined;
      if(!supplyReadable){
        score -= 10;
        checks.push({
          t:"Total supply",
          sev:"warn",
          d:"totalSupply() is not readable.",
          why:"totalSupply() reverted/unavailable.",
          infoHtml: explain("Total supply", [
            "Meaning: Supply is needed to compute holder % and tokenomics.",
            "Why WATCH: totalSupply() not clearly available."
          ])
        });
      }else{
        checks.push({
          t:"Total supply",
          sev:"ok",
          d:"Supply readable on-chain.",
          why:"totalSupply() responded.",
          infoHtml: explain("Total supply", [
            "Meaning: Supply enables holder % math and transparency.",
            "Why PASS: totalSupply() returned successfully."
          ])
        });
      }

      // Owner check
      const zero = "0x0000000000000000000000000000000000000000";
      if(sig.owner){
        if(sig.owner.toLowerCase() === zero){
          checks.push({
            t:"Owner / Admin",
            sev:"ok",
            d:"Owner appears renounced (0x0).",
            why:"owner() == zero address.",
            infoHtml: explain("Owner / Admin", [
              "Meaning: Owner can often change fees/blacklists/limits (contract-dependent).",
              "Why PASS: owner() is 0x0 (renounced)."
            ])
          });
        }else{
  score -= 22;
  checks.push({
    t:"Owner / Admin",
    sev:"warn",
    d:`Owner active: ${shortAddr(sig.owner)}`,
    why:"owner() returned a non-zero address.",
    infoHtml: explain("Owner / Admin", [
      "Meaning: The contract has an active owner/admin.",
      "Why WATCH: Owner can often change fees, limits, or other rules (contract-dependent).",
      "Tip: Prefer renounced ownership, multisig, or timelock-controlled admin."
    ])
  });
}

// Pausable check
if(sig.paused === true){
  score -= 25;
  checks.push({
    t:"Pausable",
    sev:"bad",
    d:"Contract is currently paused.",
    why:"paused() returned TRUE.",
    infoHtml: explain("Pausable", [
      "Meaning: Transfers are currently paused.",
      "Why FAIL: You may not be able to buy/sell/transfer.",
      "Action: Verify if pause is temporary and who controls it."
    ])
  });
}else if(sig.paused === false){
  score -= 6;
  checks.push({
    t:"Pausable",
    sev:"warn",
    d:"Pausable capability detected.",
    why:"paused() exists but returned FALSE.",
    infoHtml: explain("Pausable", [
      "Meaning: Contract can be paused by an admin.",
      "Why WATCH: Transfers could be halted later."
    ])
  });
}else{
  checks.push({
    t:"Pausable",
    sev:"ok",
    d:"No pausable mechanism detected.",
    why:"paused() not found or not implemented.",
    infoHtml: explain("Pausable", [
      "Meaning: No pause switch detected.",
      "Why PASS: Transfers cannot be globally stopped."
    ])
  });
}

// Proxy / upgradeability
if(sig.proxy?.isProxy){
  score -= 28;
  checks.push({
    t:"Proxy / Upgradeability",
    sev:"warn",
    d:"Upgradeable proxy detected.",
    why:"EIP-1967 storage slots are non-zero.",
    infoHtml: explain("Proxy / Upgradeability", [
      "Meaning: Contract logic can be upgraded.",
      "Why WATCH: Behavior may change after deployment.",
      `Implementation: ${sig.proxy.implementation || "unknown"}`,
      `Admin: ${sig.proxy.admin || "unknown"}`
    ])
  });
}else{
  checks.push({
    t:"Proxy / Upgradeability",
    sev:"ok",
    d:"No proxy detected.",
    why:"EIP-1967 slots are empty.",
    infoHtml: explain("Proxy / Upgradeability", [
      "Meaning: Contract logic is fixed.",
      "Why PASS: No upgrade mechanism detected."
    ])
  });
}

// Final score clamp
score = clamp(Math.round(score), 0, 100);
const critical = (sig.paused === true);

// return final EVM result
return { score, checks, critical };
