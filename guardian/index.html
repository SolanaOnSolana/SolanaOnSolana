<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#070711" />
  <title>$SOS — Guardian Check (Multi-Chain)</title>
  <meta name="description" content="Guardian Approved — token risk score + launch readiness checklist (on-chain verifiable)." />

  <style>
    :root{
      --bg:#070711;
      --panel: rgba(255,255,255,.06);
      --stroke: rgba(255,255,255,.12);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --g:#14F195;
      --c:#00D1FF;
      --p:#9945FF;
      --radius: 22px;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --max: 1180px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--text);
      font: 15.5px/1.55 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: var(--bg);
      position:relative;
    }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      z-index:-1;
      pointer-events:none;
      background:
        radial-gradient(1200px 700px at 10% 5%, rgba(153,69,255,.22), transparent 60%),
        radial-gradient(1000px 650px at 90% 10%, rgba(20,241,149,.18), transparent 55%),
        radial-gradient(900px 600px at 70% 85%, rgba(0,209,255,.14), transparent 55%),
        var(--bg);
      transform: translateZ(0);
    }

    a{color:inherit; text-decoration:none}
    .wrap{max-width:var(--max); margin:0 auto; padding:0 18px; width:100%;}
    main{padding:22px 0 42px}

    .topbar{
      position:sticky; top:0; z-index:20;
      backdrop-filter: blur(14px);
      background: rgba(7,7,17,.62);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .row{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; padding:12px 0; flex-wrap:wrap;
    }
    .brand{
      display:flex; align-items:center; gap:12px;
      min-width: 260px; user-select:none;
    }
    .brand img{
      width:40px; height:40px; object-fit:contain;
      filter: drop-shadow(0 10px 25px rgba(0,0,0,.45));
    }
    .bt{display:flex; flex-direction:column; line-height:1.05}
    .bt .t{font-weight:1000; letter-spacing:-.2px; font-size:16px}
    .bt .s{font-weight:850; color:var(--muted); font-size:12.5px}

    .actions{
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      justify-content:flex-end; width:100%;
    }
    @media (min-width: 980px){ .actions{width:auto} }

    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      padding:9px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.88);
      font-weight:950;
      font-size:13px;
      transition: .15s ease;
      user-select:none;
      cursor:pointer;
      -webkit-tap-highlight-color: transparent;
      white-space:nowrap;
    }
    .btn:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .btn.grad{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .btn[disabled]{opacity:.55; pointer-events:none}

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.05));
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .inner{padding:22px}

    .hero{ position:relative; overflow:hidden; isolation:isolate; }
    .hero::before{
      content:"";
      position:absolute; inset:-70px -40px;
      background:
        radial-gradient(900px 520px at 18% 28%, rgba(20,241,149,.16), transparent 60%),
        radial-gradient(900px 520px at 82% 20%, rgba(0,209,255,.12), transparent 60%),
        radial-gradient(900px 520px at 70% 86%, rgba(153,69,255,.14), transparent 60%);
      z-index:0; pointer-events:none;
    }
    .hero > *{position:relative; z-index:1}

    .h1{
      margin:0;
      font-weight:1000;
      letter-spacing:-1px;
      line-height:1.05;
      font-size: clamp(36px, 4.6vw, 62px);
    }
    .gradText{
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      -webkit-background-clip:text;
      background-clip:text;
      color:transparent;
    }
    .sub{
      margin-top:10px;
      color: rgba(255,255,255,.76);
      font-weight:850;
      max-width: 940px;
    }

    .classified{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; flex-wrap:wrap;
    }
    .stamp{
      font-weight:1000;
      font-size:12px;
      letter-spacing: .45px;
      text-transform:uppercase;
      color: rgba(255,255,255,.76);
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius: 999px;
      padding:7px 10px;
    }

    .layout{
      margin-top:16px;
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:16px;
      align-items:start;
    }
    @media (max-width: 980px){ .layout{grid-template-columns:1fr} }

    /* Mobile clean stacked */
    @media (max-width: 980px){
      .wrap{ padding: 0 14px; }
      .inner{ padding: 16px; }
      .panel{ padding: 14px; }
      .brand{ min-width: 0; width: 100%; }
      .actions{ width: 100%; justify-content: flex-start; }
      .actions .btn{ width: 100%; justify-content: center; padding: 12px 14px; font-size: 14px; }
      .resultTop{ flex-direction: column; align-items: stretch; }
      .resultTop > div:last-child{ width: 100%; justify-content: flex-start; }
      .resultTop .badge{ width: fit-content; }
      .tokenHead{ flex-wrap: nowrap; }
      .tokenName{ font-size: 18px; }
      .tokenSymbol{ font-size: 13px; }
      .metricV{ flex-direction: column; align-items: flex-start; gap: 6px; font-size: 22px; }
      .metricK{ flex-wrap: wrap; gap: 8px; }
      .metricK .badge{ margin-left: auto; }
      .li{ flex-direction: column; align-items: flex-start; gap: 10px; }
      .pillRow{ width:100%; justify-content:flex-start; }
      .copyBox{ flex-direction: column; align-items: flex-start; gap: 10px; }
    }

    .panel{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 18px;
      padding:16px;
      overflow:hidden;
    }

    label{
      display:block;
      font-weight:950;
      font-size:12.5px;
      letter-spacing:.35px;
      color: rgba(255,255,255,.82);
      margin-bottom:8px;
    }
    input{
      width:100%;
      padding:14px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.92);
      outline:none;
      font-weight:900;
      letter-spacing:.2px;
      font-size:16px;
    }
    input:focus{
      border-color: rgba(0,209,255,.45);
      box-shadow: 0 0 0 3px rgba(0,209,255,.12);
    }

    .statusLine{
      margin-top:12px;
      color: rgba(255,255,255,.72);
      font-weight:900;
      min-height: 18px;
      font-size:13px;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:7px 11px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
    }
    .badge.good{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}
    .badge.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .badge.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}

    .resultTop{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .resultTitle{
      margin:0;
      font-weight:1000;
      font-size:22px;
      letter-spacing:-.4px;
    }
    .mono{
      font-family: ui-monospace, Menlo, Consolas, monospace;
      font-weight:900;
      color: rgba(255,255,255,.86);
      margin-top:6px;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    .tokenHead{
      display:flex;
      gap:12px;
      align-items:center;
      flex-wrap:wrap;
      margin-bottom:10px;
    }
    .tokenLogoWrap{
      width:44px; height:44px;
      border-radius:12px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      display:none;
      flex:0 0 auto;
    }
    .tokenLogoWrap img{ width:100%; height:100%; object-fit:cover; display:block; }
    .tokenName{
      font-weight:1000;
      font-size:16px;
      letter-spacing:-.2px;
      line-height:1.15;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .tokenSymbol{
      margin-top:2px;
      color: rgba(255,255,255,.70);
      font-weight:900;
      font-size:12.5px;
    }

    .metricStack{margin-top:12px; display:grid; gap:10px;}
    .metric{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      border-radius: 16px;
      padding:12px 12px;
    }
    .metricK{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      color: rgba(255,255,255,.70);
      font-weight:1000;
      font-size:12px;
      letter-spacing:.45px;
      text-transform:uppercase;
    }
    .metricV{
      margin-top:8px;
      font-weight:1000;
      font-size:20px;
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .metricMini{
      margin-top:6px;
      font-weight:850;
      font-size:12px;
      color: rgba(255,255,255,.62);
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .bar{
      margin-top:10px;
      height:12px;
      border-radius:999px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .bar > div{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      border-radius:999px;
      transition: width .25s ease;
    }

    .list{
      margin:10px 0 0;
      padding:0;
      list-style:none;
      display:grid;
      gap:10px;
    }
    .li{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.14);
      border-radius: 16px;
      padding:12px 12px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      justify-content:space-between;
      overflow:visible;
    }
    .li .left{min-width:0;}
    .li .t{font-weight:1000; font-size:13px; letter-spacing:.2px;}
    .li .d{
      margin-top:4px;
      color: rgba(255,255,255,.70);
      font-weight:750;
      font-size:12.5px;
      line-height:1.35;
      overflow-wrap:anywhere;
      word-break:break-word;
    }

    /* PASS/WATCH/FAIL row with info icon (like your screenshots) */
    .pillRow{
      display:flex;
      gap:8px;
      align-items:center;
      flex:0 0 auto;
      justify-content:flex-end;
    }
    .pill{
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-weight:1000;
      font-size:12px;
      white-space:nowrap;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .pill.ok{border:0; background: linear-gradient(90deg,var(--g),var(--c),var(--p)); color:#061012}
    .pill.warn{border-color: rgba(255,220,130,.35); background: rgba(255,220,130,.08); color: rgba(255,240,210,.92)}
    .pill.bad{border-color: rgba(255,120,150,.35); background: rgba(255,120,150,.10); color: rgba(255,190,205,.95)}

    .infoBtn{
      width:26px;
      height:26px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.86);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      user-select:none;
      font-weight:1000;
      font-size:13px;
      line-height:1;
      -webkit-tap-highlight-color: transparent;
    }
    .infoBtn:hover{ background: rgba(255,255,255,.10); transform: translateY(-1px); }
    .infoBtn:active{ transform: translateY(0px); }
    .infoBtn span{ transform: translateY(-0.5px); }

    footer{
      padding: 18px 0 34px;
      color: rgba(255,255,255,.45);
      font-weight:650;
      text-align:center;
      font-size:12px;
    }

    /* Modal */
    .modalWrap{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:100;
    }
    .modal{
      width:min(920px, 100%);
      border-radius: 20px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(7,7,17,.92);
      box-shadow: 0 16px 50px rgba(0,0,0,.5);
      overflow:hidden;
    }
    .modalHead{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .modalTitle{ font-weight:1000; letter-spacing:-.3px; }
    .modalBody{
      padding:14px 16px 16px;
      color: rgba(255,255,255,.82);
      font-weight:800;
      line-height:1.5;
      overflow-wrap:anywhere;
      word-break:break-word;
    }
    .modalBody code{ display:none !important; }

    /* Chain selector */
    .chainRow{ margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; }
    .chainBtn{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      cursor:pointer;
      user-select:none;
      font-weight:1000;
      font-size:13px;
      color: rgba(255,255,255,.88);
      -webkit-tap-highlight-color: transparent;
    }
    .chainBtn:hover{ background: rgba(255,255,255,.10); }
    .chainBtn.active{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .chainIcon{
      width:18px; height:18px;
      border-radius:6px;
      display:inline-flex; align-items:center; justify-content:center;
      overflow:hidden;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      flex:0 0 auto;
    }
    .chainIcon svg{ width:14px; height:14px; display:block; }
    .chainMiniHint{
      margin-top:10px;
      font-size:12.5px;
      color: rgba(255,255,255,.62);
      font-weight:850;
      line-height:1.35;
    }

    /* Small toast (optional, matches your top screenshot vibe) */
    .toast{
      position:fixed;
      top:16px;
      left:50%;
      transform:translateX(-50%);
      width:min(920px, calc(100% - 28px));
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(7,7,17,.90);
      box-shadow: 0 16px 50px rgba(0,0,0,.45);
      padding:14px 14px;
      display:none;
      z-index:120;
      backdrop-filter: blur(12px);
    }
    .toastRow{display:flex; align-items:center; justify-content:space-between; gap:12px;}
    .toastTitle{font-weight:1000; font-size:22px; letter-spacing:-.4px;}
    .toastClose{padding:9px 12px; border-radius:999px; border: 1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.06); color: rgba(255,255,255,.88); font-weight:950; cursor:pointer;}
    .toastClose:hover{background: rgba(255,255,255,.10);}

    @media (prefers-reduced-motion: reduce){
      .btn:hover{transform:none}
      .bar > div{transition:none}
      .infoBtn:hover{transform:none}
    }
  </style>
</head>

<body>
  <!-- Toast -->
  <div class="toast" id="toast">
    <div class="toastRow">
      <div class="toastTitle" id="toastTitle">—</div>
      <button class="toastClose" id="toastClose" type="button">Close</button>
    </div>
  </div>

  <div class="topbar">
    <div class="wrap">
      <div class="row">
        <div class="brand">
          <img src="/assets/logo.png" alt="$SOS" onerror="this.style.display='none'">
          <div class="bt">
            <div class="t">$SOS</div>
            <div class="s">Contract Scanner • Token Risk</div>
          </div>
        </div>
        <div class="actions">
          <a class="btn" href="https://solanax1.com/" rel="noreferrer">← Back to Main</a>
          <button class="btn grad" id="btnScan" type="button">Run Guardian Check</button>
          <button class="btn grad" id="btnExport" type="button" disabled>Download Scan Report</button>
        </div>
      </div>
    </div>
  </div>

  <main class="wrap">
    <section class="card hero">
      <div class="inner">
        <div class="classified">
          <div class="stamp">GUARDIAN SYSTEM • MAINNET • ON-CHAIN VERIFIED</div>
          <div class="stamp" id="stampTime">—</div>
        </div>

        <h1 class="h1" style="margin-top:12px;">
          <span class="gradText">Guardian Contract</span> Scanner
        </h1>
        <div class="sub">
          Multi-chain scan: Solana + ETH + BNB + Base.
          Every PASS / WATCH / FAIL has an <b>info icon</b> so even beginners understand what it means.
        </div>

        <div class="layout">
          <!-- INPUT -->
          <div class="panel">
            <label>Choose Chain</label>
            <div class="chainRow" id="chainRow"></div>
            <div class="chainMiniHint" id="chainHint">—</div>

            <label for="mint" style="margin-top:14px;" id="addrLabel">Token Address</label>
            <input id="mint" placeholder="Paste token address..." autocomplete="off" spellcheck="false" inputmode="text" />
            <button class="btn grad" id="btnScanInline" type="button" style="width:100%; margin-top:12px;">Run Guardian Check</button>

            <div class="statusLine" id="status"></div>
          </div>

          <!-- RESULTS -->
          <div class="panel" id="resultsPanel">
            <div class="resultTop">
              <div>
                <div class="tokenHead">
                  <div class="tokenLogoWrap" id="tokenLogoWrap"><img id="tokenLogo" alt=""></div>
                  <div style="min-width:0">
                    <div class="tokenName" id="tokenName">—</div>
                    <div class="tokenSymbol" id="tokenSymbol">—</div>
                  </div>
                </div>
                <h3 class="resultTitle" id="verdictTitle">—</h3>
                <div class="mono" id="mintShort">—</div>
              </div>

              <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
                <span class="badge" id="verdictBadge">—</span>
                <span class="badge good" id="scoreBadge">—</span>
              </div>
            </div>

            <div class="metricStack" id="metrics"></div>
            <div class="statusLine" id="summary">—</div>
          </div>
        </div>

        <!-- Checks -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">GUARDIAN CHECKS</div>
            <div class="stamp" id="scanHint">—</div>
          </div>
          <ul class="list" id="checksList" style="margin-top:10px;"></ul>
        </div>

        <!-- Launch readiness -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">LAUNCH READINESS</div>
            <div class="stamp">ACTION LIST</div>
          </div>
          <ul class="list" id="todoList" style="margin-top:10px;"></ul>
        </div>

        <!-- Token standard details -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOKEN STANDARD DETAILS</div>
            <div class="stamp">ON-CHAIN</div>
          </div>
          <ul class="list" id="extList" style="margin-top:10px;"></ul>
        </div>

        <!-- Metadata -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOKEN METADATA</div>
            <div class="stamp">RPC / ON-CHAIN</div>
          </div>
          <ul class="list" id="metaList" style="margin-top:10px;"></ul>
        </div>

        <!-- Top holders -->
        <div class="panel" style="margin-top:16px;">
          <div class="classified">
            <div class="stamp">TOP HOLDERS (PREVIEW)</div>
            <div class="stamp" id="holdersStamp">MAINNET</div>
          </div>
          <ul class="list" id="holdersList" style="margin-top:10px;"></ul>
        </div>
      </div>
    </section>

    <footer>© <span id="y"></span> $SOS • Guardian Check</footer>
  </main>

  <!-- Modal -->
  <div class="modalWrap" id="modalWrap" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle" id="modalTitle">Guardian Details</div>
        <button class="btn" id="modalClose" type="button">Close</button>
      </div>
      <div class="modalBody" id="modalBody"></div>
    </div>
  </div>

  <script>
    /* =========================================================
      GUARDIAN CHECK v2.2 — CLEAN SINGLE-FILE (NO JSX)
      - Robust DOMContentLoaded init (no null crashes)
      - PASS/WATCH/FAIL now ALWAYS has an info icon (like your screenshots)
      - Clicking info icon (or the pill) opens a modal with explanation
      - Solana via Helius JSON-RPC
      - EVM via public RPC failover (ETH/BNB/Base)
      - Optional Moralis metadata (logos) + optional GoldRush holders
    ========================================================= */

    /* ===================== CONFIG ===================== */
    const CFG = {
      HELIUS_KEY: "b566a086-57d4-4433-8661-faed9ad07ba0",

      // Optional:
      // Moralis for EVM logos/metadata:
      // EVM_METADATA_KEY: "YOUR_MORALIS_KEY",
      EVM_METADATA_KEY: "",

      // Optional: Covalent GoldRush (holders for EVM)
      GOLDRUSH_API_KEY: "cqt_rQVTMTXwYkPJBrwf7ff6JWmdkywR",

      TOKEN_PROGRAM: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
      TOKEN_2022_PROGRAM: "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb",

      CHAINS: [
        { id:"sol",  name:"Solana",   kind:"solana", stamp:"MAINNET",      addrLabel:"Token Mint Address",     placeholder:"Paste token mint (Solana)..." },
        { id:"eth",  name:"Ethereum", kind:"evm",    chainId:1,    stamp:"ETH MAINNET",  addrLabel:"Token Contract Address", placeholder:"Paste ERC-20 contract (0x...)" },
        { id:"bnb",  name:"BNB",      kind:"evm",    chainId:56,   stamp:"BNB MAINNET",  addrLabel:"Token Contract Address", placeholder:"Paste BEP-20 contract (0x...)" },
        { id:"base", name:"Base",     kind:"evm",    chainId:8453, stamp:"BASE MAINNET", addrLabel:"Token Contract Address", placeholder:"Paste Base token contract (0x...)" }
      ],

      EVM_RPCS: {
        1:    ["https://ethereum.publicnode.com", "https://rpc.ankr.com/eth",  "https://eth.llamarpc.com", "https://cloudflare-eth.com"],
        56:   ["https://bsc.publicnode.com",      "https://rpc.ankr.com/bsc",  "https://bsc-dataseed.binance.org"],
        8453: ["https://base.publicnode.com",     "https://rpc.ankr.com/base", "https://mainnet.base.org"]
      }
    };

    /* ===================== ICONS (SVG STRINGS) ===================== */
    const ICONS = {
      sol:  `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M6 7.5c.3-.4.7-.6 1.2-.6h14.3c.9 0 1.3 1.1.7 1.7l-2 2.2c-.3.4-.7.6-1.2.6H4.7c-.9 0-1.3-1.1-.7-1.7l2-2.2Z" fill="currentColor" opacity=".9"/>
              <path d="M6 16.5c.3-.4.7-.6 1.2-.6h14.3c.9 0 1.3 1.1.7 1.7l-2 2.2c-.3.4-.7.6-1.2.6H4.7c-.9 0-1.3-1.1-.7-1.7l2-2.2Z" fill="currentColor" opacity=".6"/>
              <path d="M18 12c-.3.4-.7.6-1.2.6H2.5c-.9 0-1.3-1.1-.7-1.7l2-2.2c.3-.4.7-.6 1.2-.6h14.3c.9 0 1.3 1.1.7 1.7l-2 2.2Z" fill="currentColor"/>
            </svg>`,
      eth:  `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M12 2l6 10-6 3-6-3 6-10Z" fill="currentColor" opacity=".9"/>
              <path d="M12 22l6-8-6 3-6-3 6 8Z" fill="currentColor" opacity=".7"/>
            </svg>`,
      bnb:  `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M12 2l4 4-4 4-4-4 4-4Z" fill="currentColor"/>
              <path d="M6 8l4 4-4 4-4-4 4-4Z" fill="currentColor" opacity=".8"/>
              <path d="M18 8l4 4-4 4-4-4 4-4Z" fill="currentColor" opacity=".8"/>
              <path d="M12 14l4 4-4 4-4-4 4-4Z" fill="currentColor" opacity=".6"/>
              <path d="M12 10l2 2-2 2-2-2 2-2Z" fill="currentColor" opacity=".9"/>
            </svg>`,
      base: `<svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M12 4.5c4.4 0 8 3.6 8 8s-3.6 8-8 8-8-3.6-8-8 3.6-8 8-8Z" fill="currentColor" opacity=".9"/>
              <path d="M10.2 9.2h3.1c1.9 0 3.5 1.5 3.5 3.4 0 1.9-1.6 3.4-3.5 3.4h-3.1V9.2Zm1.6 1.6v3.6h1.4c1 0 1.9-.8 1.9-1.8s-.8-1.8-1.9-1.8h-1.4Z" fill="#070711"/>
            </svg>`
    };

    /* ===================== SAFE DOM HELPERS ===================== */
    const qs = (id) => document.getElementById(id);

    const setText = (id, v) => {
      const el = qs(id);
      if (el) el.textContent = (v ?? "");
    };

    const setHTML = (id, v) => {
      const el = qs(id);
      if (el) el.innerHTML = (v ?? "");
    };

    const on = (id, ev, fn) => {
      const el = qs(id);
      if (el) el.addEventListener(ev, fn);
    };

    const safe = (x) => String(x ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;");

    /* ===================== GLOBAL STATE ===================== */
    let activeChain = CFG.CHAINS[0];
    let LAST_SCAN = null;
    let SCANNING = false;

    /* ===================== UTIL ===================== */
    function clamp(n, min, max){ return Math.max(min, Math.min(max, n)); }
    function shortAddr(a){ return a ? (a.slice(0,4) + "…" + a.slice(-4)) : "—"; }

    function fmtInt(n){
      if (n === null || n === undefined || Number.isNaN(n)) return "—";
      try { return new Intl.NumberFormat("en-US").format(Math.round(Number(n))); }
      catch { return String(n); }
    }

    function fmtPct(n){
      if (n === null || n === undefined || Number.isNaN(n)) return "—";
      return `${Number(n).toFixed(2)}%`;
    }

    function setStatus(msg){ setText("status", msg || ""); }

    function setBadge(el, txt, mode){
      if(!el) return;
      el.textContent = txt ?? "";
      el.classList.remove("good","warn","bad");
      if(mode) el.classList.add(mode);
    }

    function updateStampTime(){
      const el = qs("stampTime");
      if(!el) return;
      el.textContent = new Date().toISOString().replace("T"," ").slice(0,19) + " UTC";
    }

    /* ===================== VALIDATION ===================== */
    function looksBase58(s){
      return typeof s === "string" &&
        s.length >= 32 && s.length <= 52 &&
        /^[1-9A-HJ-NP-Za-km-z]+$/.test(s);
    }

    function looksEvmAddress(s){
      return typeof s === "string" && /^0x[0-9a-fA-F]{40}$/.test(s.trim());
    }

    /* ===================== MODAL + TOAST ===================== */
    function openModal(title, bodyHtml){
      setText("modalTitle", title || "Guardian Details");
      setHTML("modalBody", bodyHtml || "");
      const w = qs("modalWrap");
      if(w){
        w.style.display = "flex";
        w.setAttribute("aria-hidden","false");
      }
    }

    function closeModal(){
      const w = qs("modalWrap");
      if(w){
        w.style.display = "none";
        w.setAttribute("aria-hidden","true");
      }
    }

    function showToast(title){
      const t = qs("toast");
      if(!t) return;
      setText("toastTitle", title || "");
      t.style.display = "block";
    }

    function hideToast(){
      const t = qs("toast");
      if(!t) return;
      t.style.display = "none";
    }

    /* ===================== EXPLAINERS ===================== */
    function explainBlock(title, lines){
      const body = lines.map(l => `<div style="margin:6px 0">${safe(l)}</div>`).join("");
      return `
        <div style="font-weight:1000; font-size:18px; margin-bottom:10px">${safe(title)}</div>
        <div style="color:rgba(255,255,255,.70); font-weight:850; line-height:1.55">
          ${body}
        </div>
      `;
    }

    // General legend explanation for pill meanings
    function legendExplain(sev){
      if(sev === "ok"){
        return explainBlock("PASS", [
          "Meaning: No major red flag detected for this check.",
          "Why it matters: Lower risk on this specific item (still not guaranteed overall).",
          "What to do: Continue checking the WATCH / FAIL items and verify with official sources."
        ]);
      }
      if(sev === "bad"){
        return explainBlock("FAIL", [
          "Meaning: High-risk signal detected for this check.",
          "Why it matters: This can trap buyers, allow abuse, or cause sudden changes.",
          "What to do: Treat as dangerous unless fully explained and verified."
        ]);
      }
      return explainBlock("WATCH", [
        "Meaning: Mixed/uncertain signal or a capability that could be abused.",
        "Why it matters: It may still be safe — but you must understand the rules.",
        "What to do: Read the details and verify the project’s documentation and on-chain setup."
      ]);
    }

    const EXPL = {
      freeze: () => explainBlock("Freeze Authority", [
        "Meaning: Someone can freeze wallets so they can’t sell or move the token.",
        "Why it matters: Buyers can get trapped.",
        "What to do: Only trust if Freeze is removed (renounced)."
      ]),
      mint: () => explainBlock("Mint Authority", [
        "Meaning: Someone can mint (create) more tokens anytime.",
        "Why it matters: More tokens can crash the price.",
        "What to do: Only trust if Mint is renounced, or there is a clear public emission plan."
      ]),
      meta: () => explainBlock("Token Metadata", [
        "Meaning: Name, symbol and logo help you identify the real token.",
        "Why it matters: Missing metadata makes impersonation easier.",
        "What to do: Verify name/symbol/logo match official socials and listings."
      ]),
      evmBasics: () => explainBlock("ERC-20 Basics", [
        "Meaning: We call standard ERC-20 functions (name/symbol/decimals/totalSupply).",
        "Why it matters: Non-standard tokens can hide surprises or break tooling.",
        "What to do: Treat unreadable or reverting calls as higher risk."
      ]),
      evmOwner: () => explainBlock("Contract Owner / Admin", [
        "Meaning: Owner/admin may have special permissions.",
        "Why it matters: Owner can change fees, pause, blacklist, or upgrade logic (if proxy).",
        "What to do: Safer if renounced (0x0) or secured by a reputable multi-sig."
      ]),
      evmProxy: () => explainBlock("Proxy / Upgradeable Contract", [
        "Meaning: Contract may be upgradeable via a proxy.",
        "Why it matters: Logic can change after launch.",
        "What to do: Treat as WATCH unless upgrades are locked or transparently governed."
      ]),
      evmPause: () => explainBlock("Pause / Freeze Capability (Heuristic)", [
        "Meaning: Contract may support pausing transfers.",
        "Why it matters: Users can be blocked from transferring/selling.",
        "What to do: Treat as WATCH unless you trust the admin and rules are clear."
      ]),
      evmHolders: () => explainBlock("Top Holders (EVM)", [
        "Meaning: Raw EVM RPC can’t list holders directly.",
        "Why it matters: Holder concentration is a major risk factor.",
        "What to do: Enable GoldRush (Covalent) key to fetch holders in this UI."
      ])
    };

    /* ===================== UI RENDER ===================== */
    function applyTokenHeader(meta, addr){
      const nameEl = qs("tokenName");
      const symEl  = qs("tokenSymbol");
      const wrap   = qs("tokenLogoWrap");
      const img    = qs("tokenLogo");

      const name = (meta?.name || "Token").trim() || "Token";
      const sym  = (meta?.symbol || "").trim();

      if(nameEl) nameEl.textContent = name;
      if(symEl)  symEl.textContent  = sym ? `$${sym}` : `Addr: ${shortAddr(addr)}`;

      if(wrap && img){
        if(meta?.image){
          img.src = meta.image;
          img.alt = name;
          wrap.style.display = "block";
          img.onerror = () => { wrap.style.display = "none"; };
        }else{
          wrap.style.display = "none";
          img.removeAttribute("src");
          img.alt = "";
        }
      }
    }

    function pillLabel(sev){
      if(sev === "ok") return "PASS";
      if(sev === "bad") return "FAIL";
      return "WATCH";
    }

    function pillClass(sev){
      if(sev === "ok") return "pill ok";
      if(sev === "bad") return "pill bad";
      return "pill warn";
    }

    // Render list items with:
    //  - Left: title/desc
    //  - Right: pill + info icon
    // Info icon ALWAYS exists and opens the correct explanation.
    function renderList(listEl, items, defaultTitle){
      if(!listEl) return;
      listEl.innerHTML = "";

      for(const it of items){
        const sev = it.sev || "warn";
        const title = it.t || it.k || defaultTitle || "Guardian Details";
        const desc  = it.d || "—";

        // Explanation (per item) + fallback legend explanation so every pill has meaning
        const infoTitle = it.infoTitle || title;
        const infoHtml =
          (it.infoHtml && String(it.infoHtml).trim())
            ? String(it.infoHtml)
            : (it.clickMsg && String(it.clickMsg).trim() ? String(it.clickMsg) : legendExplain(sev));

        const li = document.createElement("li");
        li.className = "li";
        li.innerHTML = `
          <div class="left">
            <div class="t">${safe(title)}</div>
            <div class="d">${safe(desc)}</div>
          </div>

          <div class="pillRow">
            <span class="${pillClass(sev)}"
                  role="button"
                  tabindex="0"
                  data-open="1"
                  data-title="${safe(infoTitle)}"
                  data-html="${safe(infoHtml)}">${pillLabel(sev)}</span>

            <button class="infoBtn"
                    type="button"
                    aria-label="Info"
                    data-open="1"
                    data-title="${safe(infoTitle)}"
                    data-html="${safe(infoHtml)}"><span>i</span></button>
          </div>
        `;
        listEl.appendChild(li);
      }
    }

    function renderMetrics(rows){
      const wrap = qs("metrics");
      if(!wrap) return;
      wrap.innerHTML = "";

      for(const r of rows){
        const d = document.createElement("div");
        d.className = "metric";

        const bar = (typeof r.barPct === "number")
          ? `<div class="bar"><div style="width:${clamp(r.barPct,0,100)}%"></div></div>`
          : "";

        d.innerHTML = `
          <div class="metricK">
            <span>${safe(r.label || "—")}</span>
            <span class="badge" style="opacity:.9">${safe(r.badge || r.value || "—")}</span>
          </div>
          <div class="metricV">${safe(r.value || "—")}</div>
          <div class="metricMini">${safe(r.mini || "")}</div>
          ${bar}
        `;
        wrap.appendChild(d);
      }
    }

    function clearUI(){
      setText("mintShort","—");
      setText("verdictTitle","—");
      setBadge(qs("verdictBadge"),"—");
      setText("scoreBadge","—");
      setText("summary","—");
      setText("scanHint","—");
      setText("tokenName","—");
      setText("tokenSymbol","—");

      const lw = qs("tokenLogoWrap");
      if(lw) lw.style.display = "none";

      renderMetrics([]);

      renderList(qs("checksList"), [{
        t:"No scan yet",
        sev:"warn",
        d:"Paste an address and run the Guardian Check.",
        infoHtml: explainBlock("No Scan Yet", [
          "Paste an address, then run the scan.",
          "Every PASS/WATCH/FAIL has an info icon you can click."
        ])
      }], "Guardian Check Details");

      renderList(qs("todoList"), [{
        t:"Waiting for scan",
        sev:"warn",
        d:"We generate a checklist only from verified on-chain signals.",
        infoHtml: explainBlock("Launch Readiness", [
          "Run a scan to generate the action list.",
          "The goal is to remove FAIL items and explain WATCH items."
        ])
      }], "Launch Readiness Details");

      renderList(qs("extList"), [{
        t:"No scan yet",
        sev:"warn",
        d:"Standard details appear after scan.",
        infoHtml: explainBlock("Token Standard Details", [
          "Run a scan to see token standard details.",
          "Token-2022 extensions will appear here on Solana when detected."
        ])
      }], "Token Standard Details");

      renderList(qs("metaList"), [{
        t:"No scan yet",
        sev:"warn",
        d:"Name / symbol / image / metadata details appear after scan.",
        infoHtml: EXPL.meta()
      }], "Token Metadata");

      renderList(qs("holdersList"), [{
        t:"No scan yet",
        sev:"warn",
        d:"Top holder preview appears after scan (Solana full, EVM limited).",
        infoHtml: explainBlock("Top Holders", [
          "Solana: we can fetch largest holders from RPC.",
          "EVM: holders require an external indexer (GoldRush) — optional."
        ])
      }], "Top Holders");

      LAST_SCAN = null;
      const ex = qs("btnExport");
      if(ex){
        ex.disabled = true;
        ex.textContent = "Download Scan Report";
      }
    }

    /* ===================== CHAIN UI ===================== */
    function renderChainButtons(){
      const row = qs("chainRow");
      if(!row) return;
      row.innerHTML = "";

      for(const c of CFG.CHAINS){
        const b = document.createElement("button");
        b.type = "button";
        b.className = "chainBtn" + (c.id === activeChain.id ? " active" : "");
        b.innerHTML = `
          <span class="chainIcon">${ICONS[c.id] || ""}</span>
          <span>${safe(c.name)}</span>
        `;
        b.addEventListener("click", () => setActiveChain(c.id, true));
        row.appendChild(b);
      }
    }

    function setActiveChain(chainId, pushUrl){
      const found = CFG.CHAINS.find(x => x.id === chainId) || CFG.CHAINS[0];
      activeChain = found;

      renderChainButtons();

      setText("holdersStamp", activeChain.stamp || "MAINNET");
      setText("addrLabel", activeChain.addrLabel || "Token Address");

      const mint = qs("mint");
      if(mint) mint.placeholder = activeChain.placeholder || "Paste token address...";

      const hint = (activeChain.kind === "solana")
        ? "Solana scan = full (mint authorities, freeze authority, largest holders via RPC + metadata via Helius DAS)."
        : (CFG.GOLDRUSH_API_KEY
            : "EVM scan = on-chain (ERC-20 basics + ownership/proxy/pause heuristics). Top holders need GoldRush.");

      setText("chainHint", hint);

      setStatus("");
      clearUI();

      if(pushUrl){
        const url = new URL(location.href);
        url.searchParams.set("chain", activeChain.id);
        history.replaceState({}, "", url.toString());
      }
    }

    /* ===================== VERDICT / SCORING ===================== */
    function verdictFrom(score, critical){
      if(critical) return {label:"FLAGGED", mode:"bad", title:"FLAGGED • High Risk"};
      if(score >= 80) return {label:"APPROVED", mode:"good", title:"APPROVED • Guardian Grade"};
      if(score >= 50) return {label:"OBSERVED", mode:"warn", title:"OBSERVED • Mixed Signals"};
      return {label:"FLAGGED", mode:"bad", title:"FLAGGED • High Risk"};
    }

    /* ===================== SOLANA RPC (Helius) ===================== */
    function HELIUS_RPC(){
      return `https://mainnet.helius-rpc.com/?api-key=${encodeURIComponent(CFG.HELIUS_KEY)}`;
    }

    async function solRpc(method, params){
      if(!CFG.HELIUS_KEY) throw new Error("Helius key missing.");
      const res = await fetch(HELIUS_RPC(), {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ jsonrpc:"2.0", id:1, method, params })
      });

      if(!res.ok){
        const t = await res.text().catch(()=> "");
        throw new Error(`Solana RPC HTTP ${res.status}: ${t.slice(0,220)}`);
      }
      const j = await res.json();
      if(j?.error) throw new Error(j.error.message || "Solana RPC error");
      return j.result;
    }

    async function getMintParsed(mint){
      const r = await solRpc("getAccountInfo", [mint, { encoding:"jsonParsed", commitment:"confirmed" }]);
      const v = r?.value;
      if(!v) return null;

      const owner = v.owner;
      const parsed = (v.data && typeof v.data === "object") ? v.data.parsed : null;
      const info = parsed?.info || null;

      return { owner, info, rawParsed: parsed };
    }

    async function getTokenSupply(mint){
      const r = await solRpc("getTokenSupply", [mint]);
      return r?.value || null;
    }

    async function getLargest(mint){
      const r = await solRpc("getTokenLargestAccounts", [mint]);
      return r?.value || [];
    }

    async function getAsset(mint){
      try { return await solRpc("getAsset", [mint]); }
      catch { return null; }
    }

    function pickTokenMetaFromAsset(asset){
      if(!asset) return null;
      const md = asset?.content?.metadata || {};
      const name = (md?.name || asset?.metadata?.name || "").trim();
      const symbol = (md?.symbol || asset?.metadata?.symbol || "").trim();

      let image = "";
      const linksImg = asset?.content?.links?.image;
      if(typeof linksImg === "string") image = linksImg;

      if(!image && Array.isArray(asset?.content?.files)){
        const f = asset.content.files.find(x => (x?.mime || "").includes("image") && x?.uri);
        if(f?.uri) image = f.uri;
      }

      const uri = (asset?.content?.json_uri || asset?.content?.links?.external_url || "").trim();
      const description = (md?.description || asset?.content?.metadata?.description || "").trim();
      const authorities = Array.isArray(asset?.authorities) ? asset.authorities : [];

      return { name, symbol, image, uri, description, authorities };
    }

    /* Token-2022 extensions best-effort */
    function parseExtensionsFromParsed(rawParsed){
      try{
        const info = rawParsed?.info || null;
        if(!info) return null;

        const ex = info.extensions || info.extensionTypes || info.mintExtensions;
        if(Array.isArray(ex) && ex.length){
          return ex.map(x => ({ name: (typeof x === "string") ? x : (x?.type || x?.name || "Extension") }));
        }
        if(ex && typeof ex === "object"){
          return Object.keys(ex).map(k => ({ name:k }));
        }
        return null;
      }catch{
        return null;
      }
    }

    function humanizeExtensionName(n){
      const s = String(n||"").toLowerCase();
      if(s.includes("transferfee") || s.includes("transfer_fee")) return "Transfer Fee (fee on transfers)";
      if(s.includes("permanentdelegate") || s.includes("permanent_delegate")) return "Permanent Delegate (delegate control)";
      if(s.includes("nontransferable") || s.includes("non_transferable")) return "Non-Transferable (cannot be transferred)";
      if(s.includes("interestbearing") || s.includes("interest_bearing")) return "Interest-Bearing (yield mechanics)";
      if(s.includes("confidential")) return "Confidential Transfers (privacy mode)";
      if(s.includes("metadata")) return "Metadata Extension";
      return n;
    }

    /* Solana scoring */
    function scoreSol(sig){
      let score = 100;
      const checks = [];

      if(sig.freezeActive){
        score -= 35;
        checks.push({
          t:"Freeze Authority active",
          sev:"bad",
          d:"Transfers can be frozen. High risk.",
          infoHtml: EXPL.freeze()
        });
      }else{
        checks.push({
          t:"Freeze Authority removed",
          sev:"ok",
          d:"No freeze power detected (good).",
          infoHtml: EXPL.freeze()
        });
      }

      if(sig.mintAuthActive){
        score -= 30;
        checks.push({
          t:"Mint Authority active",
          sev:"bad",
          d:"More supply can be minted. High risk.",
          infoHtml: EXPL.mint()
        });
      }else{
        checks.push({
          t:"Mint Authority renounced",
          sev:"ok",
          d:"Supply can’t be increased (good).",
          infoHtml: EXPL.mint()
        });
      }

      const t20 = Number(sig.top20 || 0);
      const concExplain = explainBlock("Top Holders Concentration", [
        `Meaning: Biggest 20 wallets hold about ${t20.toFixed(2)}% of supply.`,
        "Why it matters: A few wallets can dump and crash the chart.",
        "What to do: High % = extra caution. Verify holders and liquidity."
      ]);

      if(t20 >= 75){
        score -= 28;
        checks.push({ t:"Top 20 concentration very high", sev:"bad", d:`Top20 holds ~${t20.toFixed(2)}%.`, infoHtml: concExplain });
      }else if(t20 >= 55){
        score -= 18;
        checks.push({ t:"Top 20 concentration high", sev:"warn", d:`Top20 holds ~${t20.toFixed(2)}%.`, infoHtml: concExplain });
      }else if(t20 >= 35){
        score -= 8;
        checks.push({ t:"Top 20 concentration moderate", sev:"warn", d:`Top20 holds ~${t20.toFixed(2)}%.`, infoHtml: concExplain });
      }else{
        checks.push({ t:"Distribution looks healthier", sev:"ok", d:`Top20 holds ~${t20.toFixed(2)}%.`, infoHtml: concExplain });
      }

      if(sig.programType === "TOKEN_2022"){
        score -= sig.extReadable ? 6 : 10;
        checks.push({
          t:"Token standard: Token-2022",
          sev:"warn",
          d: sig.extReadable ? "Can include extra rules (extensions)." : "Extensions not visible in this scan.",
          infoHtml: explainBlock("Token Standard: Token-2022", [
            "Meaning: Official Solana token program with optional extra rules (extensions).",
            "Why it matters: Some extensions can add fees or restrictions.",
            "What to do: Read Token Standard Details and be careful with WATCH items."
          ])
        });
      }else if(sig.programType === "SPL_TOKEN"){
        checks.push({
          t:"Token standard: SPL Token",
          sev:"ok",
          d:"Standard token program.",
          infoHtml: explainBlock("Token Standard: SPL Token", [
            "Meaning: Normal Solana token program used by most tokens.",
            "Why it matters: Fewer extra rules hidden inside the token.",
            "What to do: Still check authorities and distribution."
          ])
        });
      }else{
        score -= 10;
        checks.push({
          t:"Token standard: Unknown program",
          sev:"warn",
          d:"Not a common token program.",
          infoHtml: explainBlock("Token Standard: Unknown", [
            "Meaning: Mint not using the common token programs.",
            "Why it matters: Custom programs can add hidden rules.",
            "What to do: Treat as WATCH and verify carefully."
          ])
        });
      }

      if(sig.meta && (sig.meta.name || sig.meta.symbol)){
        checks.push({ t:"Metadata present", sev:"ok", d:"Name/Symbol found.", infoHtml: EXPL.meta() });
      }else{
        score -= 4;
        checks.push({ t:"Metadata missing/unreadable", sev:"warn", d:"Name/Symbol not found via metadata endpoint.", infoHtml: EXPL.meta() });
      }

      score = clamp(Math.round(score), 0, 100);
      const critical = !!(sig.freezeActive || sig.mintAuthActive);
      return { score, checks, critical };
    }

    function todoSol(sig){
      const t = [];
      t.push(sig.freezeActive
        ? {t:"Remove Freeze Authority", sev:"bad", d:"Freezing can trap buyers.", infoHtml: EXPL.freeze()}
        : {t:"Freeze Authority", sev:"ok", d:"Already removed (good).", infoHtml: EXPL.freeze()}
      );

      t.push(sig.mintAuthActive
        ? {t:"Renounce Mint Authority", sev:"bad", d:"Minting more tokens can crash price.", infoHtml: EXPL.mint()}
        : {t:"Mint Authority", sev:"ok", d:"Already renounced (good).", infoHtml: EXPL.mint()}
      );

      const t20 = Number(sig.top20 || 0);
      const concInfo = explainBlock("Top 20 concentration", [
        `Current Top20: ~${t20.toFixed(2)}%`,
        "Higher concentration increases dump risk."
      ]);

      if(t20 >= 55) t.push({t:"Reduce Whale Concentration", sev:"warn", d:`Top20 holds ~${t20.toFixed(2)}%.`, infoHtml: concInfo});
      else if(t20 >= 35) t.push({t:"Monitor Distribution", sev:"warn", d:`Top20 holds ~${t20.toFixed(2)}%.`, infoHtml: concInfo});
      else t.push({t:"Distribution", sev:"ok", d:`Top20 ~${t20.toFixed(2)}% (healthier).`, infoHtml: concInfo});

      if(sig.programType === "TOKEN_2022"){
        t.push({t:"Token-2022 review", sev:"warn", d:"Extensions can add rules.", infoHtml: explainBlock("Token-2022", ["Review extensions carefully."])});
      }else if(sig.programType === "UNKNOWN"){
        t.push({t:"Verify mint program", sev:"warn", d:"Unknown program = extra caution.", infoHtml: explainBlock("Unknown program", ["Verify authenticity carefully."])});
      }else{
        t.push({t:"Token standard", sev:"ok", d:"Standard SPL Token.", infoHtml: explainBlock("SPL Token", ["Standard token program."])});
      }

      if(!(sig.meta && (sig.meta.name || sig.meta.symbol))){
        t.push({t:"Publish token metadata", sev:"warn", d:"Missing metadata makes fake copies easier.", infoHtml: EXPL.meta()});
      }else{
        t.push({t:"Metadata", sev:"ok", d:"Name/symbol present.", infoHtml: EXPL.meta()});
      }

      return t;
    }

    function renderExtSol(programType, extReadable, extList){
      const el = qs("extList");
      if(!el) return;

      if(programType !== "TOKEN_2022"){
        renderList(el, [{
          t:"Token standard details",
          sev: programType==="SPL_TOKEN" ? "ok" : "warn",
          d: programType==="SPL_TOKEN"
            ? "Standard SPL Token. Token-2022 extensions not applicable."
            : "Unknown program. Treat with caution.",
          infoHtml: explainBlock("Token Standard Details", [
            "This section lists Token-2022 extensions when applicable.",
            "If you see Token-2022, review every extension carefully."
          ])
        }], "Token standard details");
        return;
      }

      if(!extReadable){
        renderList(el, [{
          t:"Token-2022 extensions",
          sev:"warn",
          d:"Extensions not visible in this scan.",
          infoHtml: explainBlock("Token-2022 extensions", [
            "Extensions can add fees or restrictions.",
            "If not visible, treat as WATCH until verified elsewhere."
          ])
        }], "Token-2022 extensions");
        return;
      }

      const items = (extList || []).map(x => {
        const nameHuman = humanizeExtensionName(x.name);
        const lname = String(x.name||"").toLowerCase();
        let sev = "warn";
        if(lname.includes("nontransferable")) sev = "bad";

        return {
          t: nameHuman,
          sev,
          d: `Extension detected: ${nameHuman}.`,
          infoHtml: explainBlock(nameHuman, [
            "Token-2022 can add extra rules.",
            (sev === "bad")
              ? "This extension may block transfers. Treat as FAIL."
              : "Treat as WATCH unless clearly understood."
          ])
        };
      });

      renderList(el, items.length ? items : [{
        t:"No extensions listed",
        sev:"ok",
        d:"No Token-2022 extensions detected.",
        infoHtml: explainBlock("Extensions", ["No extra rules detected."])
      }], "Token-2022 Extension Details");
    }

    function renderMetaSol(meta){
      const el = qs("metaList");
      if(!el) return;

      if(!meta){
        renderList(el, [{
          t:"Metadata not available",
          sev:"warn",
          d:"Could not fetch metadata via getAsset.",
          infoHtml: EXPL.meta()
        }], "Token Metadata");
        return;
      }

      const items = [];
      items.push({
        t:"Name / Symbol",
        sev:(meta.name || meta.symbol) ? "ok" : "warn",
        d:`${meta.name || "—"} • ${meta.symbol ? "$"+meta.symbol : "—"}`,
        infoHtml: EXPL.meta()
      });

      items.push({
        t:"Metadata Link",
        sev: meta.uri ? "ok" : "warn",
        d: meta.uri ? "Metadata link found." : "No metadata link found.",
        infoHtml: explainBlock("Metadata link", [
          "Check it matches official sources.",
          "Be careful with fake links."
        ])
      });

      items.push({
        t:"Image / Logo",
        sev: meta.image ? "ok" : "warn",
        d: meta.image ? "Logo found." : "No logo found.",
        infoHtml: explainBlock("Token logo", [
          "Verify logo matches official sources.",
          "Scammers often copy names and use different logos."
        ])
      });

      if(meta.description){
        items.push({
          t:"Description",
          sev:"ok",
          d: meta.description.slice(0,120) + (meta.description.length>120 ? "…" : ""),
          infoHtml: explainBlock("Description", [meta.description])
        });
      }

      if(Array.isArray(meta.authorities) && meta.authorities.length){
        items.push({
          t:"Metadata authorities",
          sev:"warn",
          d:"Metadata authorities exist (review).",
          infoHtml: explainBlock("Metadata authorities", [
            "Someone may be able to update name/logo later.",
            "Treat as WATCH unless authority is removed or clearly explained."
          ])
        });
      }

      renderList(el, items, "Token Metadata");
    }

    function renderHoldersSol(mint, uiSupply, largest){
      const el = qs("holdersList");
      if(!el) return;

      if(!uiSupply || !largest || !largest.length){
        renderList(el, [{
          t:"No holder data",
          sev:"warn",
          d:"Largest accounts not readable from RPC right now.",
          infoHtml: explainBlock("Top holders", [
            "RPC may be rate-limited or temporarily unavailable.",
            "Try again later or use another RPC."
          ])
        }], "Top Holders");
        return;
      }

      const top = largest.slice(0,10);
      const items = top.map((x,i) => {
        const addr = x?.address || "—";
        const amt = Number(x?.uiAmount || 0);
        const pct = uiSupply > 0 ? (amt / uiSupply) * 100 : 0;

        return {
          t:`#${i+1} ${shortAddr(addr)}`,
          sev: pct >= 10 ? "warn" : "ok",
          d:`${fmtInt(amt)} tokens • ${pct.toFixed(2)}%`,
          infoHtml: explainBlock("Top holder", [
            `This wallet holds ~${pct.toFixed(2)}% of supply.`,
            "High % increases dump risk.",
            "Verify if it is LP, burn, team, treasury, etc."
          ])
        };
      });

      renderList(el, items, "Top Holder Details");
    }

    /* ===================== EVM RPC + ERC-20 ===================== */
    async function evmRpc(chainId, method, params){
      const urls = CFG.EVM_RPCS[chainId] || [];
      if(!urls.length) throw new Error("No RPC configured for this chain.");

      const errors = [];
      for(const url of urls){
        const ctrl = new AbortController();
        const timer = setTimeout(() => ctrl.abort(), 12000);

        try{
          const res = await fetch(url, {
            method:"POST",
            headers:{ "Content-Type":"application/json" },
            body: JSON.stringify({ jsonrpc:"2.0", id:1, method, params }),
            signal: ctrl.signal
          });
          clearTimeout(timer);

          if(!res.ok){
            const t = await res.text().catch(()=> "");
            errors.push(`HTTP ${res.status} ${t.slice(0,160)}`);
            continue;
          }

          const j = await res.json();
          if(j?.error){
            errors.push(String(j.error?.message || "RPC error").slice(0,160));
            continue;
          }
          return j.result;
        }catch(e){
          clearTimeout(timer);
          errors.push(String(e?.message || e).slice(0,160));
        }
      }

      throw new Error(`All RPCs failed. ${errors.slice(-3).join(" • ")}`);
    }

    async function ethCall(chainId, to, data){
      return await evmRpc(chainId, "eth_call", [{to, data}, "latest"]);
    }

    async function getCode(chainId, addr){
      return await evmRpc(chainId, "eth_getCode", [addr, "latest"]);
    }

    async function getStorageAt(chainId, addr, slot){
      return await evmRpc(chainId, "eth_getStorageAt", [addr, slot, "latest"]);
    }

    const SEL = {
      name: "0x06fdde03",
      symbol: "0x95d89b41",
      decimals: "0x313ce567",
      totalSupply: "0x18160ddd",
      owner: "0x8da5cb5b",
      paused: "0x5c975abb"
    };

    function strip0x(h){ return (h||"").startsWith("0x") ? h.slice(2) : (h||""); }

    function decodeUint256(hex){
      const h = strip0x(hex);
      if(!h) return null;
      const padded = h.padStart(64,"0").slice(-64);
      try { return BigInt("0x"+padded); } catch { return null; }
    }

    function decodeAddressFrom32(hex){
      const h = strip0x(hex);
      if(!h) return null;
      const padded = h.padStart(64,"0").slice(-40);
      return "0x" + padded;
    }

    function bytes32ToAscii(hex){
      const h = strip0x(hex);
      if(h.length !== 64) return "";
      try{
        const bytes = new Uint8Array(h.match(/.{1,2}/g).map(b => parseInt(b,16)));
        let s = new TextDecoder().decode(bytes).replace(/\0/g,"").trim();
        if(!s) return "";
        if(/^[\x20-\x7E]+$/.test(s)) return s;
        return "";
      }catch{
        return "";
      }
    }

    function decodeString(hex){
      const data = strip0x(hex);
      if(!data) return "";

      // bytes32 style
      if(data.length === 64){
        const b = bytes32ToAscii("0x"+data);
        if(b) return b;
      }

      // ABI string style
      if(data.length < 128) return "";

      const lenHex = data.slice(64,128);
      let len = 0;
      try { len = Number(BigInt("0x"+lenHex)); }
      catch { return ""; }

      if(!Number.isFinite(len) || len <= 0) return "";

      const strData = data.slice(128, 128 + len*2);
      if(!strData) return "";

      try{
        const bytes = new Uint8Array(strData.match(/.{1,2}/g).map(b => parseInt(b,16)));
        return new TextDecoder().decode(bytes).replace(/\0/g,"").trim();
      }catch{
        return "";
      }
    }

    async function getErc20Meta(chainId, addr){
      const out = { name:"", symbol:"", decimals:null, totalSupply:null };

      try { out.name = decodeString(await ethCall(chainId, addr, SEL.name)); } catch {}
      try { out.symbol = decodeString(await ethCall(chainId, addr, SEL.symbol)); } catch {}
      try {
        const v = decodeUint256(await ethCall(chainId, addr, SEL.decimals));
        out.decimals = (v === null) ? null : Number(v);
        if(!Number.isFinite(out.decimals)) out.decimals = null;
      } catch {}
      try { out.totalSupply = decodeUint256(await ethCall(chainId, addr, SEL.totalSupply)); } catch {}

      return out;
    }

    async function getOwner(chainId, addr){
      try{
        const r = await ethCall(chainId, addr, SEL.owner);
        return decodeAddressFrom32(r || "0x");
      }catch{
        return null;
      }
    }

    async function getPaused(chainId, addr){
      try{
        const r = await ethCall(chainId, addr, SEL.paused);
        const v = decodeUint256(r || "0x");
        if(v === null) return null;
        return v !== 0n;
      }catch{
        return null;
      }
    }

    /* Proxy detection (EIP-1967) */
    const SLOT_IMPL  = "0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc";
    const SLOT_ADMIN = "0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103";

    async function detectProxy(chainId, addr){
      try{
        const [implRaw, adminRaw] = await Promise.all([
          getStorageAt(chainId, addr, SLOT_IMPL),
          getStorageAt(chainId, addr, SLOT_ADMIN)
        ]);

        const impl = decodeAddressFrom32(implRaw || "0x");
        const admin = decodeAddressFrom32(adminRaw || "0x");
        const zero = "0x0000000000000000000000000000000000000000";

        const implNonZero = impl && impl.toLowerCase() !== zero;
        const adminNonZero = admin && admin.toLowerCase() !== zero;

        return {
          isProxy: implNonZero || adminNonZero,
          implementation: implNonZero ? impl : null,
          admin: adminNonZero ? admin : null
        };
      }catch{
        return {isProxy:false, implementation:null, admin:null};
      }
    }

    /* Optional Moralis metadata */
    function moralisChainParam(chainId){
      if(chainId === 1) return "eth";
      if(chainId === 56) return "bsc";
      if(chainId === 8453) return "base";
      return "eth";
    }

    async function getEvmMetaViaApi(chainId, addr){
      if(!CFG.EVM_METADATA_KEY) return null;

      const chain = moralisChainParam(chainId);
      const url = `https://deep-index.moralis.io/api/v2.2/erc20/metadata?chain=${encodeURIComponent(chain)}&addresses=${encodeURIComponent(addr)}`;

      try{
        const res = await fetch(url, {
          method:"GET",
          headers:{ "accept":"application/json", "x-api-key": CFG.EVM_METADATA_KEY }
        });
        if(!res.ok) return null;

        const data = await res.json();
        const item = Array.isArray(data) ? data[0] : null;
        if(!item) return null;

        return {
          name: (item.name || "").trim(),
          symbol: (item.symbol || "").trim(),
          image: (item.logo || item.thumbnail || "").trim(),
          decimals: Number.isFinite(Number(item.decimals)) ? Number(item.decimals) : null
        };
      }catch{
        return null;
      }
    }

    /* Optional GoldRush holders */
    function goldrushChain(chainId){
      if(chainId === 1) return "eth-mainnet";
      if(chainId === 56) return "bsc-mainnet";
      if(chainId === 8453) return "base-mainnet";
      return "eth-mainnet";
    }

    async function goldrushHolders(chainId, addr){
      if(!CFG.GOLDRUSH_API_KEY) return [];

      const url = `https://api.covalenthq.com/v1/${goldrushChain(chainId)}/tokens/${addr}/token_holders/?page-size=10&key=${encodeURIComponent(CFG.GOLDRUSH_API_KEY)}`;
      try{
        const r = await fetch(url);
        if(!r.ok) return [];
        const j = await r.json();
        return Array.isArray(j?.data?.items) ? j.data.items : [];
      }catch{
        return [];
      }
    }

    /* EVM scoring */
    function scoreEvm(sig){
      let score = 100;
      const checks = [];

      if(!sig.hasCode){
        checks.push({ t:"Contract not found", sev:"bad", d:"No bytecode at this address.", infoHtml: EXPL.evmBasics() });
        return { score:0, checks, critical:true };
      }else{
        checks.push({ t:"Contract found", sev:"ok", d:"Bytecode exists at address.", infoHtml: EXPL.evmBasics() });
      }

      const hasName = !!sig.metaOnChain?.name;
      const hasSymbol = !!sig.metaOnChain?.symbol;

      if(!hasName || !hasSymbol){
        score -= 10;
        checks.push({ t:"ERC-20 metadata missing", sev:"warn", d:"Name or symbol could not be read (some tokens are non-standard).", infoHtml: EXPL.evmBasics() });
      }else{
        checks.push({ t:"ERC-20 metadata readable", sev:"ok", d:"Name and symbol read successfully.", infoHtml: EXPL.evmBasics() });
      }

            const decOk = Number.isFinite(sig.metaOnChain?.decimals) && sig.metaOnChain.decimals >= 0 && sig.metaOnChain.decimals <= 36;
      if(!decOk){
        score -= 12;
        checks.push({
          t:"Decimals not readable / unusual",
          sev:"warn",
          d:"decimals() did not respond or out of expected range.",
          infoHtml: EXPL.evmBasics()
        });
      }else{
        checks.push({
          t:"Decimals readable",
          sev:"ok",
          d:`Decimals: ${sig.metaOnChain.decimals}`,
          infoHtml: EXPL.evmBasics()
        });
      }

      const supplyReadable = sig.metaOnChain?.totalSupply !== null && sig.metaOnChain?.totalSupply !== undefined;
      if(!supplyReadable){
        score -= 10;
        checks.push({
          t:"Total supply not readable",
          sev:"warn",
          d:"totalSupply() did not respond (or reverted).",
          infoHtml: EXPL.evmBasics()
        });
      }else{
        checks.push({
          t:"Total supply readable",
          sev:"ok",
          d:"totalSupply() responded.",
          infoHtml: EXPL.evmBasics()
        });
      }

      if(sig.owner){
        const zero = "0x0000000000000000000000000000000000000000";
        if(sig.owner.toLowerCase() === zero){
          checks.push({
            t:"Owner renounced",
            sev:"ok",
            d:"owner() is zero address.",
            infoHtml: EXPL.evmOwner()
          });
        }else{
          score -= 22;
          checks.push({
            t:"Owner active",
            sev:"warn",
            d:`owner(): ${shortAddr(sig.owner)}`,
            infoHtml: EXPL.evmOwner()
          });
        }
      }else{
        score -= 6;
        checks.push({
          t:"Owner not detectable",
          sev:"warn",
          d:"owner() not present or unreadable.",
          infoHtml: EXPL.evmOwner()
        });
      }

      if(sig.proxy?.isProxy){
        score -= 18;
        checks.push({
          t:"Upgradeable / Proxy detected",
          sev:"warn",
          d:`Implementation: ${sig.proxy.implementation ? shortAddr(sig.proxy.implementation) : "unknown"} • Admin: ${sig.proxy.admin ? shortAddr(sig.proxy.admin) : "unknown"}`,
          infoHtml: EXPL.evmProxy()
        });
      }else{
        checks.push({
          t:"No proxy detected (heuristic)",
          sev:"ok",
          d:"No EIP-1967 slots set (best-effort).",
          infoHtml: EXPL.evmProxy()
        });
      }

      if(sig.paused === true){
        score -= 25;
        checks.push({
          t:"Paused state: TRUE",
          sev:"bad",
          d:"Contract appears paused (transfers may be blocked).",
          infoHtml: EXPL.evmPause()
        });
      }else if(sig.paused === false){
        score -= 6;
        checks.push({
          t:"Pause capability detected",
          sev:"warn",
          d:"paused() exists and is false (capability may exist).",
          infoHtml: EXPL.evmPause()
        });
      }else{
        checks.push({
          t:"Pause not detectable",
          sev:"ok",
          d:"paused() not present (or unreadable).",
          infoHtml: EXPL.evmPause()
        });
      }

      score = clamp(Math.round(score), 0, 100);
      const critical = !!(sig.paused === true || !sig.hasCode);
      return { score, checks, critical };
    }

    function todoEvm(sig){
      const t = [];
      if(!sig.hasCode){
        t.push({ t:"Fix address", sev:"bad", d:"No contract at this address.", infoHtml: EXPL.evmBasics() });
        return t;
      }

      const zero = "0x0000000000000000000000000000000000000000";
      if(sig.owner && sig.owner.toLowerCase() !== zero){
        t.push({ t:"Renounce / Secure Owner", sev:"warn", d:"Owner/admin is active.", infoHtml: EXPL.evmOwner() });
      }else if(sig.owner && sig.owner.toLowerCase() === zero){
        t.push({ t:"Owner", sev:"ok", d:"Owner appears renounced.", infoHtml: EXPL.evmOwner() });
      }else{
        t.push({ t:"Owner review", sev:"warn", d:"Owner not detectable; review admin controls.", infoHtml: EXPL.evmOwner() });
      }

      if(sig.proxy?.isProxy){
        t.push({ t:"Upgradeability review", sev:"warn", d:"Proxy detected; upgrades can change behavior.", infoHtml: EXPL.evmProxy() });
      }else{
        t.push({ t:"Upgradeability", sev:"ok", d:"No proxy detected (best-effort).", infoHtml: EXPL.evmProxy() });
      }

      if(sig.paused === true){
        t.push({ t:"Unpause transfers", sev:"bad", d:"Token appears paused.", infoHtml: EXPL.evmPause() });
      }else if(sig.paused === false){
        t.push({ t:"Pause capability disclosure", sev:"warn", d:"Pausable pattern detected; disclose rules.", infoHtml: EXPL.evmPause() });
      }else{
        t.push({ t:"Transfer controls", sev:"ok", d:"Pause not detectable.", infoHtml: EXPL.evmPause() });
      }

      t.push({ t:"Holders distribution", sev:"warn", d:"Top holders shown if GoldRush is enabled.", infoHtml: EXPL.evmHolders() });
      return t;
    }

    function renderStandardEvm(sig){
      renderList(qs("extList"), [
        { t:"Token standard", sev:"ok", d:"ERC-20 (checked by on-chain calls).", infoHtml: EXPL.evmBasics() },
        { t:"Proxy / upgradeability", sev: sig.proxy?.isProxy ? "warn" : "ok", d: sig.proxy?.isProxy ? "Proxy detected (upgradeable)." : "No proxy detected (best-effort).", infoHtml: EXPL.evmProxy() },
        { t:"Pause capability (heuristic)", sev: sig.paused===true ? "bad" : (sig.paused===false ? "warn" : "ok"), d: sig.paused===true ? "Token appears paused." : (sig.paused===false ? "paused() exists (capability likely)." : "paused() not detected."), infoHtml: EXPL.evmPause() }
      ], "Token Standard Details");
    }

    function renderMetaEvm(metaMerged, metaOnChain){
      const items = [];
      items.push({
        t:"Name / Symbol",
        sev:(metaMerged?.name && metaMerged?.symbol) ? "ok" : "warn",
        d:`${metaMerged?.name || "—"} • ${metaMerged?.symbol ? ("$"+metaMerged.symbol) : "—"}`,
        infoHtml: EXPL.evmBasics()
      });
      items.push({
        t:"Decimals",
        sev:Number.isFinite(metaOnChain?.decimals) ? "ok" : "warn",
        d:Number.isFinite(metaOnChain?.decimals) ? String(metaOnChain.decimals) : "Not readable",
        infoHtml: EXPL.evmBasics()
      });
      items.push({
        t:"Total Supply",
        sev:(metaOnChain?.totalSupply!==null && metaOnChain?.totalSupply!==undefined) ? "ok" : "warn",
        d:(metaOnChain?.totalSupply!==null && metaOnChain?.totalSupply!==undefined) ? "Readable on-chain" : "Not readable",
        infoHtml: EXPL.evmBasics()
      });

      if(metaMerged?.image){
        items.push({
          t:"Logo / Image",
          sev:"ok",
          d:"Logo via metadata provider (API key).",
          infoHtml: explainBlock("Token Logo (EVM)", [
            "Most EVM tokens do not store logos on-chain.",
            "UIs rely on tokenlists/explorers/metadata providers."
          ])
        });
      }else{
        items.push({
          t:"Logo / Image",
          sev:"warn",
          d: CFG.EVM_METADATA_KEY ? "No logo returned by metadata API." : "EVM logos need an API key integration (optional).",
          infoHtml: explainBlock("Token Logo (EVM)", [
            "Set EVM_METADATA_KEY to enable logos (optional)."
          ])
        });
      }

      renderList(qs("metaList"), items, "Token Metadata");
    }

    function renderHoldersEvm(items){
      const el = qs("holdersList");
      if(!el) return;

      if(!items || !items.length){
        renderList(el, [{
          t:"No holder data",
          sev:"warn",
          d: CFG.GOLDRUSH_API_KEY ? "GoldRush returned no holders (or rate-limited)." : "GoldRush key not set.",
          infoHtml: EXPL.evmHolders()
        }], "Top Holders");
        return;
      }

      const parsed = items.slice(0,10).map((h,i) => {
        const address = h?.address || "—";
        const pct = Number(h?.balance_percentage || 0);
        return {
          t:`#${i+1} ${shortAddr(address)}`,
          sev: pct >= 10 ? "warn" : "ok",
          d:`${pct.toFixed(2)}%`,
          infoHtml: explainBlock("Top holder", [
            `This wallet holds ~${pct.toFixed(2)}% of supply.`,
            "High % increases dump risk."
          ])
        };
      });

      renderList(el, parsed, "Top Holder Details");
    }

    /* ===================== SCAN FLOW ===================== */
    function setScanning(isOn){
      SCANNING = isOn;
      const b1 = qs("btnScan");
      const b2 = qs("btnScanInline");
      if(b1) b1.disabled = isOn;
      if(b2) b2.disabled = isOn;
    }

    function resetBeforeScan(addr){
      setStatus("Running Guardian Check…");
      setText("mintShort", shortAddr(addr));
      setText("verdictTitle","—");
      setBadge(qs("verdictBadge"),"—");
      setText("scoreBadge","—");
      setText("summary","—");
      setText("scanHint","—");
      setText("tokenName","—");
      setText("tokenSymbol","—");

      const lw = qs("tokenLogoWrap");
      if(lw) lw.style.display = "none";

      renderMetrics([]);
      LAST_SCAN = null;

      const ex = qs("btnExport");
      if(ex){
        ex.disabled = true;
        ex.textContent = "Download Scan Report";
      }
    }

    async function scanSolana(mint){
      const mintParsed = await getMintParsed(mint);
      if(!mintParsed?.info) throw new Error("Mint not readable (not a token mint).");

      const owner = mintParsed.owner;
      const info = mintParsed.info;

      const mintAuthority = (info.mintAuthority ?? null);
      const freezeAuthority = (info.freezeAuthority ?? null);
      const decimals = Number(info.decimals ?? 0);

      const programType =
        (owner === CFG.TOKEN_PROGRAM) ? "SPL_TOKEN" :
        (owner === CFG.TOKEN_2022_PROGRAM) ? "TOKEN_2022" :
        "UNKNOWN";

      const [supply, largest, asset] = await Promise.all([
        getTokenSupply(mint),
        getLargest(mint),
        getAsset(mint)
      ]);

      const meta = pickTokenMetaFromAsset(asset);
      applyTokenHeader(meta, mint);
      renderMetaSol(meta);

      const uiSupply = supply ? Number(supply.uiAmount ?? 0) : null;

      const top20 = (Array.isArray(largest) ? largest.slice(0,20) : []);
      const top20Sum = top20.reduce((acc,x)=> acc + Number(x.uiAmount || 0), 0);
      const conc = (uiSupply && uiSupply > 0) ? (top20Sum / uiSupply) * 100 : 0;

      const extRaw = (programType === "TOKEN_2022") ? parseExtensionsFromParsed(mintParsed.rawParsed) : null;
      const extReadable = !!(extRaw && extRaw.length);

      const sig = {
        mintAuthActive: !!mintAuthority,
        freezeActive: !!freezeAuthority,
        top20: conc,
        programType,
        extReadable,
        meta: meta || null
      };

      const model = scoreSol(sig);
      const verdict = verdictFrom(model.score, model.critical);

      setText("verdictTitle", verdict.title);
      setBadge(qs("verdictBadge"), verdict.label, verdict.mode);
      setText("scoreBadge", `SCORE ${model.score}`);

      const authLine = `${sig.mintAuthActive ? "MINT ACTIVE" : "MINT RENOUNCED"} • ${sig.freezeActive ? "FREEZE ACTIVE" : "FREEZE REMOVED"}`;
      const programText = (sig.programType === "SPL_TOKEN") ? "SPL Token" : (sig.programType === "TOKEN_2022" ? "Token-2022" : "Unknown");

      renderMetrics([
        { label:"Chain", value:"Solana", badge:"SOL", mini:"Mainnet" },
        { label:"Risk Score", value:`${model.score}/100`, badge:"SCORE", mini: model.score>=80 ? "Looks safer than average (still not guaranteed)." : (model.score>=50 ? "Mixed signals — read WATCH items." : "High risk signals — be careful."), barPct:model.score },
        { label:"Authorities", value:authLine, badge:"AUTH", mini:(sig.mintAuthActive||sig.freezeActive) ? "Authorities present = higher risk." : "No mint/freeze authority (good)." },
        { label:"Top 20 Concentration", value:fmtPct(sig.top20), badge:"TOP20", mini:(uiSupply ? `Top20: ${fmtInt(top20Sum)} / ${fmtInt(uiSupply)} • Decimals ${decimals}` : `Decimals ${decimals}`), barPct:sig.top20 },
        { label:"Token Standard", value:programText, badge:"STD", mini: owner ? `Mint program owner: ${shortAddr(owner)}` : "—" },
        { label:"Supply", value: uiSupply ? fmtInt(uiSupply) : "—", badge:"UI", mini:"UI supply (RPC)" }
      ]);

      setText("scanHint", `Chain: Solana • Mint: ${shortAddr(mint)}`);

      renderList(qs("checksList"), model.checks, "Guardian Check Details");
      renderList(qs("todoList"), todoSol(sig), "Launch Readiness Details");
      renderExtSol(programType, extReadable, extRaw || []);
      renderHoldersSol(mint, uiSupply, largest);

      setText("summary", `${verdict.label} • Score ${model.score}/100 • MINT: ${sig.mintAuthActive ? "ACTIVE" : "RENOUNCED"} • FREEZE: ${sig.freezeActive ? "ACTIVE" : "REMOVED"} • Top20 ${fmtPct(conc)} • Standard ${programText} • Decimals ${decimals}`);

      LAST_SCAN = {
        version:"guardian-check-v2.2",
        ts:new Date().toISOString(),
        chain:{id:activeChain.id,name:activeChain.name,kind:activeChain.kind,stamp:activeChain.stamp},
        address:mint,
        token:{name:meta?.name||"",symbol:meta?.symbol||"",image:meta?.image||"",uri:meta?.uri||""},
        score:model.score,
        verdict,
        summary: qs("summary")?.textContent || "",
        checks:model.checks,
        todos:todoSol(sig),
        holders: (Array.isArray(largest)?largest.slice(0,10):[]).map(x=>{
          const amt = Number(x?.uiAmount||0);
          const pct = (uiSupply && uiSupply>0) ? (amt/uiSupply)*100 : 0;
          return { address: x?.address || "", pct };
        }),
        solana:{
          programOwner:owner,
          programType,
          decimals,
          mintAuthorityActive:!!mintAuthority,
          freezeAuthorityActive:!!freezeAuthority,
          top20ConcentrationPct:Number(conc||0),
          extensions: extReadable ? (extRaw||[]).map(x=>x.name) : []
        }
      };

      const ex = qs("btnExport");
      if(ex){
        ex.disabled = false;
        ex.textContent = "Download Scan Report";
      }

      setStatus(`Guardian Check complete: ${verdict.label} • Score ${model.score}/100`);
      showToast(sig.freezeActive ? "Freeze Authority active" : "Freeze Authority removed");
    }

    async function scanEvm(addr){
      const chainId = activeChain.chainId;

      const code = await getCode(chainId, addr);
      const hasCode = !!(code && code !== "0x");

      const [metaOnChain, owner, paused, proxy, metaApi, holdersGR] = await Promise.all([
        hasCode ? getErc20Meta(chainId, addr) : Promise.resolve({name:"",symbol:"",decimals:null,totalSupply:null}),
        hasCode ? getOwner(chainId, addr) : Promise.resolve(null),
        hasCode ? getPaused(chainId, addr) : Promise.resolve(null),
        hasCode ? detectProxy(chainId, addr) : Promise.resolve({isProxy:false,implementation:null,admin:null}),
        hasCode ? getEvmMetaViaApi(chainId, addr) : Promise.resolve(null),
        hasCode ? goldrushHolders(chainId, addr) : Promise.resolve([])
      ]);

      const metaMerged = {
        name: (metaApi?.name || metaOnChain?.name || "").trim(),
        symbol: (metaApi?.symbol || metaOnChain?.symbol || "").trim(),
        image: (metaApi?.image || "").trim()
      };

      applyTokenHeader({name: metaMerged.name || "Token", symbol: metaMerged.symbol || "", image: metaMerged.image || ""}, addr);
      renderMetaEvm(metaMerged, metaOnChain);

      const sig = { hasCode, metaOnChain, owner, paused, proxy };
      const model = scoreEvm(sig);
      const verdict = verdictFrom(model.score, model.critical);

      setText("verdictTitle", verdict.title);
      setBadge(qs("verdictBadge"), verdict.label, verdict.mode);
      setText("scoreBadge", `SCORE ${model.score}`);

      const ownerLine = owner ? shortAddr(owner) : "Unknown";
      const proxyLine = proxy?.isProxy ? `Proxy (impl ${proxy.implementation ? shortAddr(proxy.implementation) : "?"})` : "No proxy detected";
      const pauseLine = paused === true ? "Paused = TRUE" : (paused === false ? "Paused = FALSE (capability likely)" : "Pause not detected");

      const supplyReadable = metaOnChain?.totalSupply !== null && metaOnChain?.totalSupply !== undefined;
      const dec = Number.isFinite(metaOnChain?.decimals) ? metaOnChain.decimals : null;

      renderMetrics([
        { label:"Chain", value: activeChain.name, badge: activeChain.id.toUpperCase(), mini: activeChain.stamp },
        { label:"Risk Score", value:`${model.score}/100`, badge:"SCORE", mini: model.score>=80 ? "Looks safer than average (still not guaranteed)." : (model.score>=50 ? "Mixed signals — read WATCH items." : "High risk signals — be careful."), barPct:model.score },
        { label:"Contract", value: hasCode ? "Bytecode present" : "No code", badge:"CODE", mini: hasCode ? "Contract exists on-chain." : "This address is not a contract." },
        { label:"Owner/Admin", value: ownerLine, badge:"ADMIN", mini:"Heuristic via owner() if present." },
        { label:"Proxy", value: proxyLine, badge:"PROXY", mini:"Heuristic via EIP-1967 slots." },
        { label:"Transfers", value: pauseLine, badge:"CTRL", mini:"Heuristic via paused()." },
        { label:"Supply", value: supplyReadable ? "Readable on-chain" : "Not readable", badge:"SUP", mini: dec !== null ? `Decimals: ${dec}` : "Decimals: —" }
      ]);

      setText("scanHint", `Chain: ${activeChain.name} • Addr: ${shortAddr(addr)}`);

      renderList(qs("checksList"), model.checks, "Guardian Check Details");
      renderList(qs("todoList"), todoEvm(sig), "Launch Readiness Details");
      renderStandardEvm(sig);
      renderHoldersEvm(holdersGR);

      setText("summary",
        `${verdict.label} • Score ${model.score}/100 • OWNER: ${owner ? shortAddr(owner) : "UNKNOWN"} • PROXY: ${proxy?.isProxy ? "YES" : "NO"} • PAUSED: ${paused===true ? "YES" : (paused===false ? "NO (capable)" : "n/a")} • ${metaMerged.symbol ? "$"+metaMerged.symbol : "—"} • ${metaMerged.name || "—"}`
      );

      LAST_SCAN = {
        version:"guardian-check-v2.2",
        ts:new Date().toISOString(),
        chain:{id:activeChain.id,name:activeChain.name,kind:activeChain.kind,chainId:activeChain.chainId,stamp:activeChain.stamp},
        address:addr,
        token:{name:metaMerged.name||"",symbol:metaMerged.symbol||"",image:metaMerged.image||""},
        score:model.score,
        verdict,
        summary: qs("summary")?.textContent || "",
        checks:model.checks,
        todos:todoEvm(sig),
        holders: (holdersGR||[]).slice(0,10).map(h=>({address:h?.address||"", pct:Number(h?.balance_percentage||0)})),
        evm:{
          hasCode,
          proxy,
          owner: owner || "",
          paused,
          decimals: dec,
          totalSupplyReadable: supplyReadable,
          totalSupply: supplyReadable ? String(metaOnChain.totalSupply) : null,
          holdersProvider: CFG.GOLDRUSH_API_KEY ? "goldrush" : "none"
        }
      };

      const ex = qs("btnExport");
      if(ex){
        ex.disabled = false;
        ex.textContent = "Download Scan Report";
      }

      setStatus(`Guardian Check complete: ${verdict.label} • Score ${model.score}/100`);
    }

    async function scan(){
      if(SCANNING) return;

      const mintEl = qs("mint");
      const addr = (mintEl?.value || "").trim();
      setStatus("");

      if(activeChain.kind === "solana"){
        if(!looksBase58(addr)){
          setStatus("Invalid Solana mint address.");
          return;
        }
      }else{
        if(!looksEvmAddress(addr)){
          setStatus("Invalid EVM address (must be 0x + 40 hex chars).");
          return;
        }
      }

      resetBeforeScan(addr);
      setScanning(true);

      try{
        if(activeChain.kind === "solana") await scanSolana(addr);
        else await scanEvm(addr);
      }catch(e){
        console.error(e);
        setStatus("Scan failed: " + (e?.message || "unknown error"));
      }finally{
        setScanning(false);
      }
    }

    /* ===================== EXPORT (HTML report) ===================== */
    function downloadHtmlReport(){
      if(!LAST_SCAN) return;

      const s = LAST_SCAN;
      const tokenName = safe(s.token?.name || "Token");
      const tokenSym  = safe(s.token?.symbol || "");
      const chainName = safe(s.chain?.name || s.chain?.id || "Chain");
      const addrFull  = safe(s.address || "");
      const verdict   = safe(s.verdict?.label || "SCAN");
      const score     = (typeof s.score === "number") ? String(s.score) : safe(s.score || "");
      const summary   = safe(s.summary || "");

      const holders = Array.isArray(s.holders) ? s.holders : [];
      const checks  = Array.isArray(s.checks) ? s.checks : [];
      const todos   = Array.isArray(s.todos) ? s.todos : [];

      const html = `<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Guardian Scan Report</title>
<style>
  :root{--bg:#070711;--text:rgba(255,255,255,.92);--muted:rgba(255,255,255,.70);--g:#14F195;--c:#00D1FF;--p:#9945FF;}
  body{margin:0;background:varպիս:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:1100px;margin:0 auto;padding:22px}
  .card{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);border-radius:18px;padding:16px;margin-bottom:12px}
  .top{display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:flex-start}
  .h1{font-weight:1000;font-size:26px;margin:0}
  .muted{color:var(--muted);font-weight:850}
  .badge{display:inline-flex;align-items:center;justify-content:center;padding:7px 11px;border-radius:999px;font-weight:1000;font-size:12px;background:linear-gradient(90deg,var(--g),var(--c),var(--p));color:#061012}
  .kv{display:grid;grid-template-columns:180px 1fr;gap:8px;margin-top:10px}
  .k{color:var(--muted);font-weight:950;text-transform:uppercase;letter-spacing:.35px;font-size:12px}
  .v{font-weight:900;overflow-wrap:anywhere}
  .li{padding:12px;border-radius:14px;background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.10);margin-top:10px}
  .li .t{font-weight:1000}
  .li .d{color:var(--muted);font-weight:850;margin-top:4px;line-height:1.4}
  h3{margin:0 0 6px;font-size:14px;letter-spacing:.35px;text-transform:uppercase;color:rgba(255,255,255,.80)}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="top">
      <div>
        <div class="h1">${tokenName}${tokenSym ? ` ($${tokenSym})` : ""}</div>
        <div class="muted">${chainName} • ${safe(s.ts || "")}</div>
      </div>
      <div><div class="badge">${verdict}${score ? ` • SCORE ${safe(score)}` : ""}</div></div>
    </div>
    <div class="kv">
      <div class="k">Address</div><div class="v">${addrFull}</div>
      <div class="k">Summary</div><div class="v">${summary || "—"}</div>
    </div>
  </div>

  <div class="card">
    <h3>Top Holders</h3>
    ${holders.length ? holders.map(h => `
      <div class="li">
        <div class="t">${safe(h.address || "")}</div>
        <div class="d">${Number(h.pct||0).toFixed(2)}%</div>
      </div>`).join("") : `<div class="muted">No holder data available.</div>`}
  </div>

  <div class="card">
    <h3>Guardian Checks</h3>
    ${checks.length ? checks.map(c => `
      <div class="li">
        <div class="t">${safe(c.t || c.k || "")}</div>
        <div class="d">${safe(c.d || "")}</div>
      </div>`).join("") : `<div class="muted">No checks available.</div>`}
  </div>

  <div class="card">
    <h3>Launch Readiness</h3>
    ${todos.length ? todos.map(t => `
      <div class="li">
        <div class="t">${safe(t.t || "")}</div>
        <div class="d">${safe(t.d || "")}</div>
      </div>`).join("") : `<div class="muted">No action items.</div>`}
  </div>
</div>
</body>
</html>`;

      const blob = new Blob([html], {type:"text/html;charset=utf-8"});
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);

      const namePart = `${(s.chain?.id || "chain")}_${(s.token?.symbol || "token")}_${(s.address || "").slice(0,6)}`;
      a.download = `guardian_report_${namePart}.html`;

      document.body.appendChild(a);
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 0);
    }

    /* ===================== EVENTS ===================== */
    function wireEvents(){
      on("btnScan","click", scan);
      on("btnScanInline","click", scan);
      on("btnExport","click", downloadHtmlReport);

      on("mint","keydown",(e)=>{ if(e.key==="Enter") scan(); });

      on("modalClose","click", closeModal);

      const mw = qs("modalWrap");
      if(mw){
        mw.addEventListener("click",(e)=>{ if(e.target === mw) closeModal(); });
      }

      document.addEventListener("keydown",(e)=>{ if(e.key==="Escape") closeModal(); });

      // Open modal from ANY element that has data-open="1"
      document.addEventListener("click",(e)=>{
        const el = e.target.closest?.('[data-open="1"]');
        if(!el) return;
        const title = el.getAttribute("data-title") || "Guardian Details";
        const html = el.getAttribute("data-html") || "";
        if(html && html.trim()) openModal(title, html);
      });

      // Keyboard open for pill
      document.addEventListener("keydown",(e)=>{
        if((e.key==="Enter" || e.key===" ") && document.activeElement){
          const el = document.activeElement;
          if(el.getAttribute && el.getAttribute("data-open")==="1"){
            e.preventDefault();
            const title = el.getAttribute("data-title") || "Guardian Details";
            const html = el.getAttribute("data-html") || "";
            if(html && html.trim()) openModal(title, html);
          }
        }
      });

      on("toastClose","click", hideToast);
    }

    /* ===================== INIT (SAFE) ===================== */
    function init(){
      const y = qs("y");
      if(y) y.textContent = new Date().getFullYear();

      updateStampTime();
      setInterval(updateStampTime, 1000);

      const p = new URLSearchParams(location.search);
      const chain = p.get("chain");

      if(chain && CFG.CHAINS.some(c=>c.id===chain)){
        activeChain = CFG.CHAINS.find(c=>c.id===chain);
      }else{
        activeChain = CFG.CHAINS[0];
      }

      wireEvents();
      renderChainButtons();
      setActiveChain(activeChain.id, false);
    }

    document.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
