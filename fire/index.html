<!doctype html>
<!--
DexGuard DexLike LiveChart v1

(1) Endpoints used:
- DexScreener (no key):
  - Search: https://api.dexscreener.com/latest/dex/search?q=...
  - Pair info: https://api.dexscreener.com/latest/dex/pairs/{chainId}/{pairId}
  - Token pools: https://api.dexscreener.com/token-pairs/v1/{chainId}/{tokenAddress}
  - Boosted/Trending tokens (for Trending row): https://api.dexscreener.com/token-boosts/top/v1 (fallback: token-boosts/latest/v1)
- GeckoTerminal (no key, used for candles + trades):
  - OHLCV: https://api.geckoterminal.com/api/v2/networks/{network}/pools/{poolAddress}/ohlcv/{timeframe}?aggregate=...
  - Trades: https://api.geckoterminal.com/api/v2/networks/{network}/pools/{poolAddress}/trades

(2) Optional Proxy URL (Settings):
- If set, ALL API requests go through your proxy to bypass CORS.
- Supported formats:
  a) If Proxy contains "{url}", it will be replaced with encodeURIComponent(targetUrl)
  b) Otherwise: PROXY + ( "?" or "&" ) + "url=" + encodeURIComponent(targetUrl)

(3) Optional keys (stored locally in your browser only):
- BIRDEYE_API_KEY (Solana-only enrichment/candles fallback; app still works without it)
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#070711" />
  <title>DexGuard — DexLike Live</title>

  <link rel="preconnect" href="https://api.dexscreener.com" crossorigin />
  <link rel="preconnect" href="https://api.geckoterminal.com" crossorigin />
  <link rel="preconnect" href="https://public-api.birdeye.so" crossorigin />
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin />

  <style>
    :root{
      --bg:#070711;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.085);
      --stroke: rgba(255,255,255,.12);

      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.68);
      --muted2: rgba(255,255,255,.56);

      --g:#14F195;
      --c:#00D1FF;
      --p:#9945FF;

      --good: rgba(20,241,149,.90);
      --bad: rgba(255,104,121,.86);
      --warn: rgba(255,205,98,.85);

      --radius: 22px;
      --radius2: 18px;
      --shadow: 0 14px 44px rgba(0,0,0,.45);
      --shadowSoft: 0 10px 28px rgba(0,0,0,.28);
      --ring: 0 0 0 6px rgba(20,241,149,.08);

      --max: 1240px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    *{box-sizing:border-box}
    html{height:100%; scroll-behavior:smooth}
    body{
      min-height:100%;
      min-height:100dvh;
      margin:0;
      font: 14px/1.55 var(--sans);
      color:var(--text);
      background:var(--bg);
      overflow-x:hidden;
    }
    body::before{
      content:"";
      position: fixed;
      inset: 0;
      z-index: -1;
      pointer-events: none;
      background:
        radial-gradient(1200px 760px at 10% 5%, rgba(153,69,255,.24), transparent 60%),
        radial-gradient(1000px 720px at 90% 10%, rgba(20,241,149,.18), transparent 58%),
        radial-gradient(900px 640px at 72% 92%, rgba(0,209,255,.14), transparent 58%),
        radial-gradient(900px 640px at 0% 95%, rgba(0,209,255,.06), transparent 60%),
        var(--bg);
      transform: translateZ(0);
    }

    a{color:inherit; text-decoration:none}
    button,input{font:inherit}
    img{max-width:100%; height:auto; display:block}

    :focus-visible{outline:none; box-shadow:var(--ring); border-radius:14px}

    .wrap{max-width:var(--max); margin:0 auto; padding:0 16px}
    .header{
      position:sticky;
      top:0;
      z-index:50;
      backdrop-filter: blur(14px);
      background: rgba(7,7,17,.70);
      border-bottom: 1px solid rgba(255,255,255,.08);
    }

    .headerRow{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:12px;
      align-items:center;
      padding:12px 0;
    }

    .brand{
      display:none; align-items:center; gap:12px;
      min-width: 0;
    }
    .logo{
      width:40px; height:40px;
      border-radius: 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.05));
      border: 1px solid rgba(255,255,255,.12);
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
      display:grid; place-items:center;
      position:relative;
      overflow:hidden;
    }
    .logo::before{
      content:"";
      position:absolute; inset:-40%;
      background: conic-gradient(from 180deg, rgba(20,241,149,.0), rgba(20,241,149,.45), rgba(0,209,255,.35), rgba(153,69,255,.35), rgba(20,241,149,.0));
      filter: blur(10px);
      opacity:.65;
      animation: spin 6s linear infinite;
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    .logo span{
      position:relative;
      font-weight: 1000;
      letter-spacing: .08em;
      font-size: 12px;
      color: rgba(255,255,255,.92);
      text-shadow: 0 10px 30px rgba(0,0,0,.6);
    }
    .brandText{min-width:0}
    .brandTop{
      display:flex; align-items:center; gap:10px;
      line-height:1.1;
      flex-wrap:wrap;
    }
    .brandName{
      font-weight:1000;
      letter-spacing:.04em;
      text-transform:uppercase;
      font-size:12px;
      opacity:.92;
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      white-space:nowrap;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .pill b{
      font-size:11px;
      letter-spacing:.08em;
      text-transform:uppercase;
      opacity:.82;
    }
    .liveDot{
      width:8px; height:8px;
      border-radius:999px;
      background: var(--good);
      box-shadow: 0 0 0 6px rgba(20,241,149,.10);
      animation: pulse 1.4s ease-in-out infinite;
    }
    @keyframes pulse{
      0%,100%{transform:scale(1); opacity:1}
      50%{transform:scale(1.12); opacity:.72}
    }
    .sub{
      color: var(--muted);
      font-size: 12px;
      margin-top: 2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .actions{display:flex; gap:10px; align-items:center; justify-content:flex-end; flex-wrap:wrap}
    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      padding:9px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.90);
      font-weight:900;
      font-size:13px;
      transition: transform .15s ease, background .15s ease, box-shadow .15s ease, border-color .15s ease, opacity .15s ease;
      white-space: nowrap;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor:pointer;
    }
    .rActions{display:flex; gap:10px; align-items:center; justify-content:flex-end;}
    .btn.dgChartBtn{letter-spacing:.02em;}
    .btn.dgScanBtn{
      border-color: rgba(20,241,149,.35);
      background: rgba(20,241,149,.12);
    }
    .btn.dgScanBtn:hover{ filter: brightness(1.08); }
    .search .scanInline{
      margin-left:10px;
      padding:8px 12px;
      font-size:12px;
      white-space:nowrap;
    }
    .linkPill.scanPill{
      border-color: rgba(20,241,149,.35) !important;
      background: rgba(20,241,149,.10) !important;
      color: rgba(220,255,235,.95) !important;
    }

    .btn:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .btn:active{transform: translateY(0px) scale(.99)}
    .btn:disabled{opacity:.5; cursor:not-allowed}
    .btn.grad{
      border:0;
      background: linear-gradient(90deg, var(--g), var(--c), var(--p));
      color:#061012;
      box-shadow: 0 14px 28px rgba(0,0,0,.28);
    }
    .btn.ghost{ background: rgba(255,255,255,.06); }
    .btn.icon{ width:44px; padding:9px 0; letter-spacing:2px; font-weight:1000; }

    .main{ padding:16px 0 28px; }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.075), rgba(255,255,255,.045));
      border: 1px solid rgba(255,255,255,.11);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      position: relative;
      overflow:hidden;
    }
    .card::before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(500px 240px at 10% 10%, rgba(20,241,149,.12), transparent 70%),
                  radial-gradient(520px 260px at 90% 20%, rgba(0,209,255,.10), transparent 70%),
                  radial-gradient(520px 260px at 60% 110%, rgba(153,69,255,.10), transparent 70%);
      pointer-events:none;
      opacity:.9;
    }
    .card > *{position:relative}

    .toolbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
      gap:12px;
      padding:14px 14px 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
    }

    .chainTabs{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .tab{
      padding:8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.86);
      font-weight:1000;
      letter-spacing:.06em;
      font-size:12px;
      text-transform:uppercase;
      cursor:pointer;
      transition: transform .15s ease, background .15s ease, border-color .15s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .tab:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .tab.active{
      border:0;
      background: linear-gradient(90deg, rgba(20,241,149,.90), rgba(0,209,255,.85), rgba(153,69,255,.85));
      color:#061012;
      box-shadow: 0 14px 26px rgba(0,0,0,.28);
    }

    .searchWrap{ display:flex; gap:10px; align-items:center; flex:1; min-width: 240px; }
    .search{ position:relative; flex:1; min-width: 200px; }
    .search input{
      width:100%;
      padding:11px 14px 11px 40px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.92);
      outline:none;
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
    }
    .search input::placeholder{color: rgba(255,255,255,.42)}
    .searchIcon{
      position:absolute;
      left:14px;
      top:50%;
      transform: translateY(-50%);
      opacity:.72;
      font-weight:1000;
      letter-spacing:.06em;
      font-size: 12px;
      user-select:none;
      pointer-events:none;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:12px;
      padding: 12px;
    }
    /* Token view: stack chart + trades vertically (trades under chart) */
    .tokenGrid{
      grid-template-columns: 1fr;
    }
    .tokenGrid > .panel{
      width: 100%;
    }
    /* keep trades list usable when stacked */
    .tokenGrid .tableWrap{
      max-height: 360px;
    }
    @media (max-width: 980px){
      .tokenGrid .tableWrap{ max-height: 360px; }
    }

    @media (max-width: 980px){ .grid{grid-template-columns: 1fr;} }

    .panel{
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: var(--radius2);
      overflow:hidden;
      min-width:0;
    }
    .panelHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px 12px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .title{
      display:flex; align-items:center; gap:10px;
      font-weight: 1000;
      letter-spacing:.06em;
      text-transform:uppercase;
      font-size:12px;
      color: rgba(255,255,255,.86);
      min-width:0;
    }
    .hint{
      font-size: 12px;
      color: var(--muted);
      display:flex;
      align-items:center;
      gap:10px;
      white-space:nowrap;
    }
    .kbd{
      font-family: var(--mono);
      font-size: 11px;
      padding: 2px 7px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.86);
    }

    .trendingRow{
      display:flex;
      gap:10px;
      overflow:auto;
      padding: 12px;
      scroll-snap-type: x mandatory;
      -webkit-overflow-scrolling: touch;
    }
    .trendingRow::-webkit-scrollbar{height:8px}
    .trendingRow::-webkit-scrollbar-thumb{background: rgba(255,255,255,.10); border-radius:999px}

    .tokenCard{
      flex: 0 0 240px;
      scroll-snap-align:start;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.075), rgba(255,255,255,.04));
      box-shadow: 0 10px 24px rgba(0,0,0,.24);
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .15s ease, border-color .15s ease, background .15s ease;
      min-height: 84px;
    }
    .tokenCard:hover{transform: translateY(-2px); border-color: rgba(255,255,255,.22)}
    .tokenCard:active{transform: translateY(0px) scale(.995)}
    .tokenCardTop{
      display:flex;
      gap:10px;
      padding: 12px 12px 10px;
      align-items:center;
    }
    .tLogo{
      width:36px; height:36px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      overflow:hidden;
      display:grid; place-items:center;
      flex: 0 0 auto;
    }
    .tLogo img{width:100%; height:100%; object-fit:cover}
    .tText{min-width:0}
    .tName{
      font-weight: 1000;
      font-size: 13px;
      line-height: 1.15;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .tMeta{
      display:flex;
      align-items:center;
      gap:8px;
      margin-top: 4px;
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .chip{
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size: 11px;
      font-weight: 900;
      letter-spacing:.06em;
      text-transform: uppercase;
      color: rgba(255,255,255,.84);
    }
    .chip.good{border-color: rgba(20,241,149,.35); background: rgba(20,241,149,.08); color: rgba(20,241,149,.95)}
    .chip.bad{border-color: rgba(255,104,121,.35); background: rgba(255,104,121,.08); color: rgba(255,104,121,.92)}

    .metricRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:6px;
      padding: 0 12px 12px;
    }
    .metric{
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      padding: 8px 10px;
      min-width:0;
    }
    .metric .k{
      font-size: 10px;
      letter-spacing: .10em;
      text-transform: uppercase;
      color: rgba(255,255,255,.56);
      margin-bottom: 3px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .metric .v{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,.90);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .results{ padding: 10px 12px 12px; display:none; max-height: 360px; overflow:auto; overscroll-behavior: contain; }
    .results.show{display:block}
    .resultItem{
      display:grid;
      grid-template-columns: auto 1fr auto;
      gap:12px;
      align-items:center;
      padding: 10px 10px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      margin-bottom: 8px;
      cursor:pointer;
      transition: transform .12s ease, background .12s ease, border-color .12s ease;
    }
    .resultItem:hover{background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.18); transform: translateY(-1px)}
    .resultItem:last-child{margin-bottom:0}
    .rMain{min-width:0}
    .rTop{display:flex; align-items:center; gap:8px; min-width:0}
    .rName{font-weight:1000; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .rSub{
      font-size: 12px;
      color: var(--muted);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      margin-top: 2px;
    }

    .tokenView{padding:12px}
    .tokenHeader{
      padding: 14px 14px 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex;
      gap:12px;
      align-items:flex-start;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .tokenLeft{display:flex; gap:12px; align-items:center; min-width: 0;}
    .bigLogo{
      width:44px; height:44px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      overflow:hidden;
      display:grid; place-items:center;
      flex: 0 0 auto;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
    }
    .bigLogo img{width:100%; height:100%; object-fit:cover}
    .tokenNames{min-width:0}
    .tokenNames .sym{
      font-weight: 1100;
      letter-spacing:.04em;
      font-size: 16px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .tokenNames .addr{
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      margin-top: 4px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .tokenRight{ display:flex; flex-direction:column; gap:8px; align-items:flex-end; }
    .linksRow{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}
    .linkPill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-weight: 900;
      font-size: 12px;
      color: rgba(255,255,255,.86);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .15s ease, background .15s ease;
    }
    .linkPill:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .linkPill:active{transform: translateY(0px) scale(.99)}

    .statsGrid{
      display:grid;
      grid-template-columns: repeat(6, minmax(0,1fr));
      gap:8px;
      padding: 12px 14px 14px;
    }
    @media (max-width: 980px){ .statsGrid{grid-template-columns: repeat(3, minmax(0,1fr));} }
    @media (max-width: 520px){ .statsGrid{grid-template-columns: repeat(2, minmax(0,1fr));} }
    .stat{
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      padding: 10px 12px;
      min-width:0;
    }
    .stat .k{
      font-size: 10px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color: rgba(255,255,255,.56);
      margin-bottom: 6px;
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .stat .v{
      font-family: var(--mono);
      font-size: 12px;
      color: rgba(255,255,255,.92);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }
    .delta.good{color: var(--good)}
    .delta.bad{color: var(--bad)}

    .chartPanel{display:flex; flex-direction:column; min-width:0}
    .chartTop{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .tfRow{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    .tf{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      font-weight: 1000;
      font-size: 12px;
      letter-spacing:.06em;
      color: rgba(255,255,255,.86);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .12s ease, background .12s ease;
    }
    .tf:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .tf.active{border:0; background: linear-gradient(90deg, rgba(20,241,149,.92), rgba(0,209,255,.86), rgba(153,69,255,.86)); color:#061012}

    .yZoomRow{
      display:flex;
      gap:8px;
      align-items:center;
      flex-basis:100%;
      margin-top:6px;
    }
    .yZoomBtn{
      height:30px;
      min-width:36px;
      padding:0 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      color: rgba(255,255,255,.90);
      font-weight: 1000;
      font-size: 15px;
      line-height: 1;
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      -webkit-tap-highlight-color: transparent;
      transition: transform .12s ease, background .12s ease;
    }
    .yZoomBtn:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .yZoomBtn:active{transform: translateY(0px) scale(.99)}
    .yZoomBtn:disabled{
      opacity:.35;
      cursor:not-allowed;
      transform:none;
    }
    @media (max-width: 720px){
      .yZoomBtn{ height:34px; min-width:42px; font-size:16px; }
      .yZoomRow{ margin-top:8px; }
    }

    .stTabs{display:flex; gap:6px; flex-wrap:wrap; margin-top:8px}
    .stPill{
      padding:5px 9px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      font-weight: 900;
      font-size: 11px;
      letter-spacing:.04em;
      color: rgba(255,255,255,.86);
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      transition: transform .12s ease, background .12s ease;
    }
    .stPill:hover{background: rgba(255,255,255,.10); transform: translateY(-1px)}
    .stPill.on{border:0; background: rgba(255,255,255,.18); color: rgba(255,255,255,.95)}
    .stMain{display:flex; align-items:baseline; justify-content:space-between; gap:10px; line-height:1.1}
    .stMain .delta{font-size:16px}
    .stTabsTight{margin-top:10px}
    .stMiniGrid{
      margin-top:10px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:8px 10px;
    }
    .stMiniItem{
      padding:8px 10px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      min-width:0;
    }
    .stMiniK{
      font-size:10px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color: rgba(255,255,255,.56);
      font-weight: 1000;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .stMiniV{
      margin-top:4px;
      font-size:13px;
      font-weight: 1000;
      color: rgba(255,255,255,.92);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      font-family: var(--mono);
    }
    .chartMeta{
      display:flex; align-items:center; gap:10px;
      color: var(--muted);
      font-size: 12px;
      font-family: var(--mono);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 100%;
    }
    .chartPanel{ scroll-margin-top: 90px; }
    .chartWrap{
      height: clamp(260px, 52vh, 520px);
      min-height: 240px;
      position:relative;
      touch-action: pan-y pinch-zoom;
    }
    @media (max-width: 980px){ .chartWrap{height: clamp(240px, 48vh, 420px);} }
    @media (max-width: 520px){ .chartWrap{height: clamp(220px, 44vh, 360px);} }
    #chart{ position:absolute; inset:0; width:100%; height:100%; }
    .chartWrap.loading #chart{opacity:1}
    .chartWrap.loading::after{
      content: '';
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-family: var(--mono);
      color: rgba(255,255,255,.72);
      letter-spacing:.06em;
      font-size: 12px;
      pointer-events: none;
    }

    .chartFooter{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
      padding: 10px 12px 12px;
      border-top: 1px solid rgba(255,255,255,.08);
      color: var(--muted);
      font-size: 12px;
    }
    .status{ display:flex; align-items:center; gap:10px; white-space:nowrap; }
    .status .dot{
      width:8px; height:8px; border-radius:999px;
      background: rgba(255,255,255,.35);
      box-shadow: 0 0 0 6px rgba(255,255,255,.06);
    }
    .status.live .dot{ background: var(--good); box-shadow: 0 0 0 6px rgba(20,241,149,.08); }
    .status.warn .dot{ background: var(--warn); box-shadow: 0 0 0 6px rgba(255,205,98,.08); }
    .status.bad .dot{ background: var(--bad); box-shadow: 0 0 0 6px rgba(255,104,121,.08); }

    .table{ width:100%; border-collapse:separate; border-spacing:0; font-size: 12px; }
    .table th, .table td{
      padding: 10px 10px;
      border-bottom: 1px solid rgba(255,255,255,.07);
      text-align:left;
      vertical-align:middle;
      white-space:nowrap;
    }
    .table th{
      font-size: 10px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color: rgba(255,255,255,.56);
      font-weight: 1000;
      background: rgba(255,255,255,.03);
      position:sticky;
      top:0;
      z-index:2;
    }
    .tableWrap{
      max-height: 520px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }
    @media (max-width: 980px){ .tableWrap{max-height: 360px} }

    .side{
      font-weight: 1000;
      letter-spacing:.06em;
      font-size: 11px;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      background: rgba(255,255,255,.04);
    }
    .side.buy{border-color: rgba(20,241,149,.34); background: rgba(20,241,149,.08); color: rgba(20,241,149,.95)}
    .side.sell{border-color: rgba(255,104,121,.34); background: rgba(255,104,121,.08); color: rgba(255,104,121,.92)}

    .mono{font-family: var(--mono)}
    .muted{color: var(--muted)}
    .muted2{color: var(--muted2)}
    .right{ text-align:right }
    .center{ text-align:center }
    .ellipsis{overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width: 100%}

    .empty{
      padding: 14px 12px 16px;
      color: var(--muted);
      font-size: 13px;
      display:flex;
      gap:10px;
      align-items:flex-start;
    }
    #searchHint{display:none !important;}

    .empty b{color: rgba(255,255,255,.86)}
    .sep{ opacity:.35; margin: 0 6px; }

    /* Modal */
    .modalBack{
      position: fixed;
      pointer-events: none;
      inset: 0;
      z-index: 1000;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(10px);
      display:none;
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    .modalBack.show{display:flex; pointer-events:auto}
    .modal{
      width: min(640px, 100%);
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.04));
      box-shadow: 0 26px 90px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modalHead{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      padding: 14px 14px;
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .modalTitle{
      font-weight: 1000;
      letter-spacing:.06em;
      text-transform: uppercase;
      font-size: 12px;
      color: rgba(255,255,255,.86);
    }
    .modalBody{padding: 14px}
    .field{
      display:grid;
      grid-template-columns: 1fr;
      gap:8px;
      margin-bottom: 12px;
    }
    .label{
      font-size: 11px;
      letter-spacing:.12em;
      text-transform: uppercase;
      color: rgba(255,255,255,.60);
      font-weight: 1000;
    }
    .input{
      width:100%;
      padding: 11px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.22);
      color: rgba(255,255,255,.92);
      outline:none;
      font-family: var(--mono);
      font-size: 12px;
    }
    .help{ font-size: 12px; color: var(--muted); line-height: 1.45; }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .footerBtns{display:flex; gap:10px; justify-content:flex-end; padding: 12px 14px 14px; border-top: 1px solid rgba(255,255,255,.08)}

    .toast{
      position: fixed;
      pointer-events: none;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      z-index: 1200;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(7,7,17,.72);
      backdrop-filter: blur(12px);
      box-shadow: 0 18px 55px rgba(0,0,0,.45);
      color: rgba(255,255,255,.88);
      font-size: 12px;
      display:none;
      align-items:center;
      gap:10px;
      max-width: min(92vw, 840px);
    }
    .toast.show{display:flex}
    .toast .tDot{
      width:8px; height:8px; border-radius:999px;
      background: var(--warn);
      box-shadow: 0 0 0 6px rgba(255,205,98,.08);
      flex:0 0 auto;
    }
  
    /* Trades: subtle "new row" animation (no overlays) */
    @keyframes dgTradeIn{
      from{ opacity:.55; background-color: rgba(20,241,149,.10); }
      to  { opacity:1; background-color: transparent; }
    }
    tr.tradeNew{
      animation: dgTradeIn .55s ease both;
    }
    tr.tradeNew td{
      transition: background-color .6s ease;
    }

    /* Row tint like DexScreener (do not tint Age column) */
    tbody tr.tradeBuy td{
      background: rgba(20,241,149,.040);
    }
    tbody tr.tradeSell td{
      background: rgba(255,104,121,.040);
    }
    /* Strong, full-color TYPE column (first cell) */
    tbody tr.tradeBuy td.typeCell{
      background: rgba(20,241,149,.28) !important;
    }
    tbody tr.tradeSell td.typeCell{
      background: rgba(255,104,121,.28) !important;
    }
    tbody tr.tradeBuy:hover td{
      background: rgba(20,241,149,.065);
    }
    tbody tr.tradeSell:hover td{
      background: rgba(255,104,121,.065);
    }
    tbody tr.tradeBuy:hover td.typeCell{
      background: rgba(20,241,149,.34) !important;
    }
    tbody tr.tradeSell:hover td.typeCell{
      background: rgba(255,104,121,.34) !important;
    }

  

/* =========================================================
   Ultra Visual Overhaul (Desktop-first) — PATCH ONLY
   Futuristic trading terminal design system (tokens + polish)
   No DOM/ID changes. Minimal CSS overrides. Performance-safe.
   ========================================================= */

:root{
  /* Design tokens */
  --bg: #05060a;
  --panel: rgba(255,255,255,.045);
  --glass: rgba(12,14,20,.64);
  --stroke: rgba(255,255,255,.10);
  --text: rgba(255,255,255,.92);
  --muted: rgba(255,255,255,.64);
  --accent: #7c5cff;
  --good: rgba(45, 212, 191, .95);
  --bad: rgba(251, 113, 133, .92);
  --shadow: 0 22px 70px rgba(0,0,0,.55);
  --radius: 18px;

  /* Back-compat mapping (keeps existing CSS stable) */
  --panel2: rgba(255,255,255,.07);
  --muted2: rgba(255,255,255,.52);
  --warn: rgba(255,205,98,.86);
  --radius2: var(--radius);
  --shadowSoft: 0 14px 44px rgba(0,0,0,.40);
  --ring: 0 0 0 6px rgba(124, 92, 255, .10);
}

/* Global typography + rendering */
html, body{
  background: var(--bg);
  color: var(--text);
}
body{
  letter-spacing: .01em;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: geometricPrecision;
}

/* Layered terminal backdrop (lightweight; no blur spam) */
body::before{
  background:
    radial-gradient(1200px 760px at 10% 8%, rgba(124,92,255,.22), transparent 62%),
    radial-gradient(1050px 720px at 92% 14%, rgba(45,212,191,.16), transparent 60%),
    radial-gradient(920px 680px at 78% 92%, rgba(0,209,255,.10), transparent 60%),
    radial-gradient(760px 520px at 18% 86%, rgba(251,113,133,.08), transparent 60%),
    linear-gradient(180deg, rgba(255,255,255,.03), transparent 22%, rgba(0,0,0,.22));
}
/* Subtle grain (cheap + tasteful) */
body::after{
  content:"";
  position:fixed;
  inset:0;
  pointer-events:none;
  z-index:-1;
  opacity:.10;
  background-image:
    repeating-linear-gradient(0deg, rgba(255,255,255,.08) 0px, rgba(255,255,255,.08) 1px, transparent 1px, transparent 3px),
    repeating-linear-gradient(90deg, rgba(255,255,255,.05) 0px, rgba(255,255,255,.05) 1px, transparent 1px, transparent 4px);
  mix-blend-mode: overlay;
}

/* Consistent radii + spacing rhythm */
.card{ background: transparent; border: 0; box-shadow: none; }
.wrap{ max-width: var(--max); }
.panel,
.modal,
.stat,
.trend,
.result,
.bigLogo,
.chartWrap,
.tableWrap{
  border-radius: var(--radius);
}

/* Glass panels */
.panel{
  background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
  border: 1px solid var(--stroke);
  box-shadow: 0 12px 40px rgba(0,0,0,.30);
}
@supports (backdrop-filter: blur(1px)){
  .panel{
    background: linear-gradient(180deg, rgba(12,14,20,.62), rgba(12,14,20,.46));
    backdrop-filter: blur(10px);
  }
}
.panelHead{
  padding: 14px 14px 12px;
  border-bottom: 1px solid rgba(255,255,255,.08);
}
.title{
  font-weight: 900;
  letter-spacing: .02em;
}
.hint{
  color: var(--muted);
}
.kbd{
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(0,0,0,.22);
  border-radius: 999px;
}

/* Header: terminal bar */
.header{
  border-bottom: 1px solid rgba(255,255,255,.10);
  background: rgba(10,12,18,.55);
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
}
@supports (backdrop-filter: blur(1px)){
  .header{ backdrop-filter: blur(10px); }
}
.logo{
  border: 1px solid rgba(255,255,255,.14);
  background: radial-gradient(120% 120% at 20% 20%, rgba(124,92,255,.35), rgba(45,212,191,.18) 55%, rgba(255,255,255,.06));
  box-shadow: 0 14px 44px rgba(0,0,0,.45);
}
.pill{
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(0,0,0,.25);
}

/* Inputs + buttons — aligned, consistent height */
.btn, .input, .search{
  height: 40px;
  border-radius: var(--radius);
}
.search{
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.22);
}
.search input,
.input{
  font-variant-numeric: tabular-nums;
}
.input{
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.22);
}
.btn{
  padding: 0 14px;
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(255,255,255,.06);
  box-shadow: 0 8px 20px rgba(0,0,0,.25);
}
.btn:hover{
  border-color: rgba(255,255,255,.22);
  background: rgba(255,255,255,.10);
}
.btn:active{ transform: translateY(0px) scale(.99); }
.btn.grad{
  background: linear-gradient(135deg, rgba(124,92,255,.95), rgba(45,212,191,.85));
  border-color: rgba(255,255,255,.18);
  box-shadow: 0 12px 28px rgba(124,92,255,.18), 0 10px 22px rgba(45,212,191,.12);
}
.btn.ghost{
  background: rgba(0,0,0,.18);
}

/* Tabs / TF buttons: terminal toggles */
.tab, .tf{
  height: 34px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.22);
}
.tab.active, .tf.active{
  border-color: rgba(124,92,255,.45);
  box-shadow: 0 0 0 4px rgba(124,92,255,.10);
  background: linear-gradient(180deg, rgba(124,92,255,.22), rgba(0,0,0,.22));
}

/* Token header */
.tokenHeader{
  border-bottom: 1px solid rgba(255,255,255,.08);
}
.sym{
  font-size: 18px;
  font-weight: 1000;
}
.addr{
  color: var(--muted);
}
.linkPill{
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.22);
}
.linkPill:hover{
  border-color: rgba(255,255,255,.20);
}

/* Stats: clearer hierarchy */
.statsGrid{ gap: 10px; }
.stat{
  background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.22));
  border: 1px solid rgba(255,255,255,.10);
}
@supports (backdrop-filter: blur(1px)){
  .stat{ background: rgba(12,14,20,.46); backdrop-filter: blur(8px); }
}
.stat .k{
  color: rgba(255,255,255,.58);
}
.stat .v{
  font-variant-numeric: tabular-nums;
  letter-spacing: .005em;
}

/* Chart panel: premium frame */
.chartWrap{
  border: 1px solid rgba(255,255,255,.10);
  background: radial-gradient(120% 120% at 50% 0%, rgba(124,92,255,.10), transparent 55%),
              radial-gradient(120% 120% at 0% 100%, rgba(45,212,191,.08), transparent 55%),
              rgba(0,0,0,.20);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.06);
}

/* Tables: tabular numbers + alignment */
.table{
  font-variant-numeric: tabular-nums;
}
.table th{
  color: rgba(255,255,255,.70);
  letter-spacing: .08em;
  text-transform: uppercase;
  font-size: 10px;
}
.table td{
  border-bottom: 1px solid rgba(255,255,255,.06);
}
.table th.right, .table td.right{ text-align: right; }
.table th.center, .table td.center{ text-align: center; }
.table tbody td:nth-child(2),
.table tbody td:nth-child(3),
.table tbody td:nth-child(4),
.table tbody td:nth-child(5){
  text-align: right;
}

/* Side pills */
.side.buy{ color: var(--good); }
.side.sell{ color: var(--bad); }

/* Status / microcopy */
.status{ border: 1px solid rgba(255,255,255,.10); background: rgba(0,0,0,.22); }
.muted2{ color: var(--muted2); }

/* Modal: same system */
.modalBack{ background: rgba(0,0,0,.65); }
.modal{
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(12,14,20,.72);
  box-shadow: var(--shadow);
  border-radius: calc(var(--radius) + 6px);
}
@supports (backdrop-filter: blur(1px)){
  .modal{ backdrop-filter: blur(12px); }
}

/* Toast: premium */
.toast{
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(12,14,20,.72);
  box-shadow: var(--shadowSoft);
}



/* =========================================================
   STEP2 — CEX(DEX Topbar) PATCH ONLY
   - Hide: Settings/Clear/Open-on-DexScreener in UI
   - Add: X icon (top-right) + optional status pill
   - Build: Topbar layout (brand | command search | right actions)
   - Settings remains functional via Shift+S; button shows only in ?debug=1
   ========================================================= */

#btnClear, #btnDS { display: none !important; }
#btnSettings { display: none; } /* JS will reveal in ?debug=1 */

.headerRow{
  grid-template-columns: auto 1fr auto;
  gap: 14px;
  align-items: center;
}
.brand{
  display:flex !important;
  min-width: 240px;
}
.brandTop .pill,
#subline{
  display:none !important;
}

.topCenter{
  display:flex;
  align-items:center;
  justify-content:center;
  min-width:0;
}
.searchWrap.cmdSearch{
  width: min(760px, 100%);
  justify-content:center;
}
.searchWrap.cmdSearch .search{
  flex:1;
  min-width: 260px;
}
.searchWrap.cmdSearch .search input{
  background: rgba(0,0,0,.26);
  border: 1px solid rgba(255,255,255,.14);
  box-shadow: 0 10px 26px rgba(0,0,0,.26);
}
.searchWrap.cmdSearch .search input::placeholder{
  color: rgba(255,255,255,.46);
}
.searchWrap.cmdSearch .searchIcon{
  opacity:.85;
}
.searchWrap.cmdSearch #btnSearch{
  min-width: 104px;
}

.actions{
  gap: 10px;
  align-items: center;
  flex-wrap: nowrap;
}
.xBtn{
  width: 40px;
  height: 40px;
  padding: 0;
  border-radius: 12px;
  display:inline-flex;
}
.xBtn svg{
  width: 18px;
  height: 18px;
  display:block;
}
.statusPill{
  height: 32px;
  padding: 0 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.18);
  box-shadow: 0 10px 22px rgba(0,0,0,.22);
}
.statusPill b{
  font-size: 10px;
  letter-spacing: .10em;
}

/* Toolbar becomes a compact "secondary rail" (chains only) */
.toolbar{
  justify-content: flex-start;
  gap: 12px;
}
.toolbar .chainTabs{
  flex: 0 0 auto;
}

/* Responsive: keep topbar usable without layout break */
@media (max-width: 980px){
  .headerRow{
    grid-template-columns: 1fr;
    gap: 10px;
    padding: 10px 0;
  }
  .brand{min-width:0}
  .topCenter{justify-content:stretch}
  .searchWrap.cmdSearch{width:100%}
  .actions{justify-content: flex-start; flex-wrap: wrap}
}

/* ===== DexGuard PATCH: Command Search Dropdown (STEP3) ===== */
.grid[data-cmd="1"]{ grid-template-columns: 1fr !important; overflow: visible !important; }
/* Keep legacy results panel in DOM (JS hooks), but hide it to avoid duplicate results.
   Results are shown in the Command Search dropdown (topbar). */
section[aria-label="Search results"]{ display:none !important; }
/* Ensure dropdown can escape the search panel and sit above content. */
.panel[aria-label="Search"]{
  overflow: visible;
  position: relative;
  z-index: 5;
}

/* Docked results panel under search input */
#searchDock .searchResultsDock{
  margin-top: 10px;
}
#searchDock .searchResultsDock .panelHead{
  padding: 10px 12px 8px;
}
#searchDock .searchResultsDock .title{
  font-size: 11px;
}

.searchWrap.cmdSearch{ position: relative; }
#cmdDropdown{
  position:absolute;
  top: calc(100% + 10px);
  left: 0;
  right: 0;
  z-index: 1200;
  display:none;
}
#cmdDropdown.show{ display:block; }
#cmdDropdown .cmdPanel{
  border-radius: calc(var(--radius) + 4px);
  border: 1px solid rgba(255,255,255,.14);
  background: rgba(6,10,16,.72);
  box-shadow: 0 24px 70px rgba(0,0,0,.55);
  overflow: hidden;
}
#cmdDropdown .cmdList{
  max-height: 356px; /* ~8 rows */
  overflow:auto;
  scrollbar-gutter: stable;
}
#cmdDropdown .cmdRow{
  display:grid;
  grid-template-columns: 36px 1fr auto;
  gap: 12px;
  align-items:center;
  padding: 10px 12px;
  cursor: pointer;
  user-select: none;
}
#cmdDropdown .cmdRow + .cmdRow{ border-top: 1px solid rgba(255,255,255,.06); }
#cmdDropdown .cmdRow:hover{ background: rgba(255,255,255,.06); }
#cmdDropdown .cmdRow.active{ background: rgba(104,195,255,.10); }
#cmdDropdown .cmdLogo{
  width: 28px;
  height: 28px;
  border-radius: 10px;
  display:flex;
  align-items:center;
  justify-content:center;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.18);
  overflow:hidden;
}
#cmdDropdown .cmdLogo img{ width: 100%; height: 100%; object-fit: cover; display:block; }
#cmdDropdown .cmdMain{ min-width:0; }
#cmdDropdown .cmdTop{
  display:flex;
  align-items:center;
  gap: 10px;
  min-width:0;
}
#cmdDropdown .cmdName{
  font-weight: 650;
  letter-spacing: .01em;
  min-width:0;
}
#cmdDropdown .cmdSym{ opacity:.72; font-weight: 600; }
#cmdDropdown .cmdSub{
  margin-top: 2px;
  font-size: 12px;
  color: rgba(255,255,255,.56);
  display:flex;
  gap: 8px;
  min-width:0;
}
#cmdDropdown .cmdSub .addr{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
#cmdDropdown .cmdSub .sep{ opacity:.4; }
#cmdDropdown .cmdMeta{
  display:flex;
  align-items:center;
  gap: 10px;
  justify-content:flex-end;
  text-align:right;
  font-variant-numeric: tabular-nums;
  font-feature-settings: "tnum" 1;
}
#cmdDropdown .cmdMeta .px{
  font-weight: 650;
}
#cmdDropdown .cmdMeta .chg.good{ color: var(--good); }
#cmdDropdown .cmdMeta .chg.bad{ color: var(--bad); }
#cmdDropdown .cmdBadge{
  font-size: 11px;
  padding: 4px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.18);
  letter-spacing: .08em;
  text-transform: uppercase;
}
#cmdDropdown .cmdFooter{
  display:flex;
  justify-content: space-between;
  gap: 10px;
  padding: 8px 12px;
  border-top: 1px solid rgba(255,255,255,.08);
  font-size: 12px;
  color: rgba(255,255,255,.56);
  background: rgba(0,0,0,.14);
}
#cmdDropdown .cmdFooter kbd{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
  font-size: 11px;
  padding: 2px 6px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.18);
}
#cmdDropdown .cmdHead{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.14);
}
#cmdDropdown .cmdHeadTitle{
  font-size: 11px;
  letter-spacing: .12em;
  text-transform: uppercase;
  color: rgba(255,255,255,.70);
  font-weight: 1000;
}
#cmdDropdown .cmdClearRecents{
  height: 30px;
  padding: 0 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.18);
  color: rgba(255,255,255,.82);
  font-weight: 900;
  letter-spacing: .06em;
  text-transform: uppercase;
  font-size: 10px;
  cursor:pointer;
}
#cmdDropdown .cmdClearRecents:hover{
  border-color: rgba(255,255,255,.20);
  background: rgba(255,255,255,.06);
}
#cmdDropdown .skel .bar{
  height: 10px;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(255,255,255,.06), rgba(255,255,255,.14), rgba(255,255,255,.06));
  background-size: 220px 100%;
  animation: dg_skel 1.15s ease-in-out infinite;
}
#cmdDropdown .skel .bar.sm{ width: 46%; }
#cmdDropdown .skel .bar.md{ width: 72%; }
#cmdDropdown .skel .bar.lg{ width: 88%; }
@keyframes dg_skel{
  0%{ background-position: 0 0; }
  100%{ background-position: 220px 0; }
}

/* =========================================================
   STEP17 — Remove Trending UI + dock Search under chain logos (PATCH ONLY)
   - Trending UI removed from DOM
   - Reuse existing command search, docked into main card under chains
   - Keep desktop stable: header collapses to brand + actions when docked
   ========================================================= */
body.dgSearchDocked .topCenter{ display:none !important; }
body.dgSearchDocked .headerRow{ grid-template-columns: 1fr auto !important; }
body.dgSearchDocked .brand{ min-width: 0 !important; }

#searchDock{
  width: 100%;
}
#searchDock .searchWrap.cmdSearch{
  width: 100% !important;
  justify-content: stretch !important;
}
#searchDock .searchWrap.cmdSearch .search{
  flex: 1 1 auto !important;
  min-width: 0 !important;
}
#searchDock #cmdDropdown{
  left: 0 !important;
  right: 0 !important;
}
/* ========================================================= */

/* ===== /PATCH ===== */


/* =========================================================
   STEP7 — Terminal Layout Desktop (PATCH ONLY)
   - True terminal grid: Chart hero + Trades panel (desktop)
   - Stats become compact ticker strip
   - Tables: aligned numbers, consistent rows, subtle zebra + hover
   - Timeframes: premium segmented control
   ========================================================= */

/* Token stats => ticker strip (desktop-first) */
.statsGrid{
  display:flex !important;
  flex-wrap: nowrap;
  gap: 10px !important;
  overflow-x:auto;
  -webkit-overflow-scrolling: touch;
  padding: 10px 14px 12px !important;
  grid-template-columns: none !important;
  border-bottom: 1px solid rgba(255,255,255,.08);
}
.statsGrid::-webkit-scrollbar{ height: 8px; }
.statsGrid::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.10); border-radius: 999px; }
.stat{
  flex: 0 0 auto;
  min-width: 168px;
  height: 56px;
  display:flex;
  flex-direction:column;
  justify-content:center;
  padding: 10px 12px !important;
}
.stat .k{ margin-bottom: 6px !important; }
.stat .v{ font-size: 13px; }

/* Terminal grid for token view */
.grid.tokenGrid{
  display:grid;
  grid-template-columns: 1.65fr .95fr;
  gap: 12px;
  padding: 12px 0 0;
}
.grid.tokenGrid > .panel{ min-width:0; }

/* Chart hero sizing */
.chartWrap{
  height: clamp(320px, 62vh, 640px) !important;
  min-height: 300px !important;
}

/* Trades panel: match hero feel, keep scroll */
.grid.tokenGrid section[aria-label="Live trades"] .tableWrap{
  max-height: calc(clamp(320px, 62vh, 640px) + 64px) !important;
}

/* Responsive: stack panels */
@media (max-width: 980px){
  .grid.tokenGrid{ grid-template-columns: 1fr; }
  .statsGrid{ padding: 10px 12px 12px !important; }
  .stat{ min-width: 150px; }
}

/* Tables: terminal-grade rows */
.tableWrap{ scrollbar-gutter: stable; }
.table th, .table td{
  height: 40px;
  padding-top: 9px;
  padding-bottom: 9px;
}
.table tbody tr:nth-child(odd) td{
  background: rgba(255,255,255,.018);
}
.table tbody tr:hover td{
  background: rgba(255,255,255,.045) !important;
}
.table td, .table th{
  font-variant-numeric: tabular-nums;
  font-feature-settings: "tnum" 1;
}
/* Keep the existing tint rows, but soften zebra under tint */
tbody tr.tradeBuy td:not(:nth-child(5)){
  background: color-mix(in srgb, rgba(45, 212, 191, .06) 70%, rgba(255,255,255,.015)) !important;
}
tbody tr.tradeSell td:not(:nth-child(5)){
  background: color-mix(in srgb, rgba(251, 113, 133, .06) 70%, rgba(255,255,255,.015)) !important;
}
tbody tr.tradeBuy:hover td:not(:nth-child(5)){
  background: rgba(45, 212, 191, .10) !important;
}
tbody tr.tradeSell:hover td:not(:nth-child(5)){
  background: rgba(251, 113, 133, .10) !important;
}

/* Right-align numeric columns (safer: only cells marked .right) */
.table td.right, .table th.right{ text-align:right !important; }
.table td.center, .table th.center{ text-align:center !important; }

/* Timeframes: segmented control */
.chartTop{
  gap: 12px;
  padding: 12px 12px 10px !important;
}
.tfRow{
  display:inline-flex;
  gap: 0 !important;
  padding: 4px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.20);
  box-shadow: inset 0 1px 0 rgba(255,255,255,.05);
}
.tf{
  border: 0 !important;
  background: transparent !important;
  border-radius: 12px !important;
  height: 34px !important;
  padding: 0 12px !important;
  margin: 0 !important;
  color: rgba(255,255,255,.78) !important;
  box-shadow: none !important;
  transform: none !important;
}
.tf + .tf{ margin-left: 2px !important; }
.tf:hover{
  background: rgba(255,255,255,.06) !important;
}
.tf.active{
  background: linear-gradient(135deg, rgba(124,92,255,.28), rgba(45,212,191,.18)) !important;
  color: rgba(255,255,255,.95) !important;
  box-shadow: 0 10px 22px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.06) !important;
}

/* Token header -> compact ticker strip feel */
.tokenHeader{
  padding: 12px 14px 10px !important;
}
.tokenRight .linksRow .linkPill{
  height: 34px;
  padding: 0 10px;
  display:inline-flex;
}



/* =========================================================
   STEP8 — Mobile App Feel (PATCH ONLY)
   - safe-area padding + sticky topbar
   - bottom-sheet command search dropdown
   - >=44px touch targets
   - optional bottom nav (Chart / Trades / Info) as UI only
   - no horizontal scroll, stacked cards/sheets
   ========================================================= */

@media (max-width: 720px){
  /* Safe-area + avoid horizontal scroll */
  body{ overflow-x:hidden; }
  .wrap{
    padding-left: max(14px, env(safe-area-inset-left));
    padding-right: max(14px, env(safe-area-inset-right));
  }
  .header{
    padding-top: env(safe-area-inset-top);
  }
  .main{
    padding-bottom: calc(28px + 74px + env(safe-area-inset-bottom));
  }

  /* App-like topbar: tighter, sticky */
  .headerRow{ gap: 10px; }
  .brand{ min-width:0; }
  .actions{ gap: 8px; }
  .pill.statusPill{ display:none; } /* cleaner on mobile */

  /* Bigger touch targets */
  .btn{ height: 44px !important; }
  .btn.icon{ width: 44px !important; }
  .searchWrap.cmdSearch #btnSearch{ min-width: 92px; }
  .tab, .tf, .linkPill{ min-height: 44px; }
  .tab{ padding: 0 14px; display:inline-flex; align-items:center; justify-content:center; }
  .tfRow{ padding: 6px; }
  .tf{ height: 40px !important; padding: 0 14px !important; }
  .linkPill{ padding: 0 12px; height: 40px; display:inline-flex; align-items:center; }

  /* Stack panels as cards; remove any "wide" layouts */
  .grid{ grid-template-columns: 1fr !important; padding: 10px; gap: 10px; }
  .grid.tokenGrid{ grid-template-columns: 1fr !important; padding: 10px 0 0 !important; }
  .panel{ border-radius: 18px; }
  .panelHead{ padding: 12px 12px 10px; }

  /* Stats strip becomes wrapped (no horizontal scroll) */
  .statsGrid{
    flex-wrap: wrap !important;
    overflow-x: hidden !important;
    gap: 10px !important;
  }
  .stat{
    flex: 1 1 calc(50% - 10px) !important;
    min-width: 0 !important;
    height: 58px !important;
  }

  /* Command dropdown (mobile): keep opening DOWN under the input (iOS Safari-safe)
     - Use STEP10 visualViewport positioning (dgFixed + CSS vars)
     - No full-screen sheet, no transparent scrims
  */
  #cmdDropdown{
    padding: 0 !important;
    bottom: auto !important;
    top: auto !important;
    left: 0 !important;
    right: 0 !important;
    z-index: 1400 !important;
  } 

  /* Trending row stays swipeable but avoids page horizontal scrolling */
  .trendingRow{ padding: 10px; }

  /* Tables: bigger rows */
  .table th, .table td{ height: 44px; padding-top: 11px; padding-bottom: 11px; }
}

/* Bottom navigation (mobile only) */
.mNav{
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 1350;
  display: none;
  padding: 10px 12px calc(env(safe-area-inset-bottom) + 10px);
  background: rgba(10,12,18,.68);
  border-top: 1px solid rgba(255,255,255,.10);
  backdrop-filter: blur(10px);
}
.mNav .mNavInner{
  max-width: var(--max);
  margin: 0 auto;
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 10px;
}
.mNav button{
  height: 44px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.22);
  color: rgba(255,255,255,.90);
  font-weight: 1000;
  letter-spacing: .06em;
  text-transform: uppercase;
  font-size: 11px;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
}
.mNav button:active{ transform: scale(.99); }
.mNav button.on{
  border-color: rgba(124,92,255,.40);
  background: linear-gradient(180deg, rgba(124,92,255,.20), rgba(0,0,0,.22));
  box-shadow: 0 10px 22px rgba(0,0,0,.25);
}
@media (max-width: 720px){
  .mNav{ display:flex; }
}



/* ===== PATCH: Chain logo tabs (STEP9) — keep behavior, replace labels with logos ===== */
.chainTabs .tab{
  position: relative;
  overflow: hidden;
}
.chainTabs .tab .chainTextHold{
  opacity: 0;              /* keeps exact button sizing without visible text */
  pointer-events: none;
}
.chainTabs .tab .chainIcon{
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  pointer-events: none;    /* never interferes with click handling */
}
.chainTabs .tab .chainIcon svg{
  width: 22px;
  height: 22px;
  display: block;
  filter: drop-shadow(0 2px 8px rgba(0,0,0,.35));
}
.chainTabs .tab:not(.active) .chainIcon svg{
  filter: drop-shadow(0 2px 10px rgba(0,0,0,.45));
}
/* Make sure icons don't look "swallowed" on bright active gradients */
.chainTabs .tab.active .chainIcon svg{
  filter: drop-shadow(0 2px 12px rgba(0,0,0,.55));
}
/* Visually hidden text helper (a11y-safe; no visible text) */
.srOnly{
  position:absolute !important;
  width:1px !important;
  height:1px !important;
  padding:0 !important;
  margin:-1px !important;
  overflow:hidden !important;
  clip:rect(0,0,0,0) !important;
  white-space:nowrap !important;
  border:0 !important;
}
/* ===== /PATCH ===== */



/* ===== PATCH: Search overlay / dropdown viewport-safe (STEP10) =====
   Goals:
   - No transparency bleed-through inside search panel
   - Dropdown always opens downward & stays within viewport
   - iOS Safari keyboard-safe via visualViewport-driven CSS vars
   - No persistent scrims/overlays when closed
*/
:root{
  --dgVvh: 100vh;          /* set by JS on iOS via visualViewport */
  --dgCmdLeft: 16px;
  --dgCmdTop: 72px;
  --dgCmdWidth: 520px;
  --dgCmdListMax: 356px;
}

/* Make dropdown panel visually solid (no "see-through") */
#cmdDropdown .cmdPanel{
  background: rgba(6,8,14,.96) !important;
  border: 1px solid rgba(255,255,255,.16) !important;
  box-shadow: 0 26px 80px rgba(0,0,0,.62) !important;
}
@supports (backdrop-filter: blur(1px)){
  #cmdDropdown .cmdPanel{
    background: rgba(10,12,18,.94) !important;
    backdrop-filter: blur(14px);
  }
}

/* Ensure the list is the scroller and never overflows off-screen */
#cmdDropdown .cmdList{
  max-height: var(--dgCmdListMax, 356px) !important;
  overflow: auto !important;
  overscroll-behavior: contain;
  -webkit-overflow-scrolling: touch;
}

/* Desktop/tablet: when open we pin dropdown to visual viewport under the input */
#cmdDropdown.dgFixed{
  position: fixed !important;
  left: var(--dgCmdLeft) !important;
  top: var(--dgCmdTop) !important;
  right: auto !important;
  width: var(--dgCmdWidth) !important;
  max-width: calc(100vw - 20px) !important;
  z-index: 1400 !important;
}

/* Slightly stronger row backgrounds for clarity */
#cmdDropdown .cmdRow{
  background: transparent;
}
#cmdDropdown .cmdRow:hover{
  background: rgba(255,255,255,.06);
}
#cmdDropdown .cmdRow.active{
  background: rgba(104,195,255,.12);
}

/* Mobile: keep dropdown pinned under the input (keyboard-safe via visualViewport vars) */
@media (max-width: 720px){
  #cmdDropdown.dgFixed{
    max-height: calc(var(--dgVvh) - 8px) !important;
  }
  #cmdDropdown.dgFixed .cmdPanel{
    /* Cap the panel inside the *visual* viewport; list scrolls inside */
    max-height: calc(var(--dgVvh) - var(--dgCmdTop) - 12px - env(safe-area-inset-bottom)) !important;
  }
}
  #cmdDropdown .cmdPanel{
    max-height: calc(var(--dgVvh) - 12px - env(safe-area-inset-bottom)) !important;
  }
  #cmdDropdown .cmdList{
    /* Leave room for header + handle; list scrolls inside */
    max-height: calc(var(--dgVvh) - 220px - env(safe-area-inset-bottom)) !important;
  }
}
/* ===== /PATCH ===== */



/* ===== PATCH: Trades BUY/Sell columns — loud + consistent (STEP11) ===== */
/* Strong, consistent tints (no dark/black bars) */
:root{
  --dgBuyBg: rgba(20,241,149,.14);
  --dgBuyBgHover: rgba(20,241,149,.20);
  --dgSellBg: rgba(255,104,121,.14);
  --dgSellBgHover: rgba(255,104,121,.20);
  --dgBuyText: rgba(20,241,149,.98);
  --dgSellText: rgba(255,104,121,.98);
}

/* Override any zebra backgrounds on trade rows */
.table tbody tr.tradeBuy td,
.table tbody tr.tradeSell td{
  background-image: none !important;
  box-shadow: none !important;
}

/* Whole row tint */
.table tbody tr.tradeBuy td{
  background: var(--dgBuyBg) !important;
}
.table tbody tr.tradeSell td{
  background: var(--dgSellBg) !important;
}
.table tbody tr.tradeBuy:hover td{ background: var(--dgBuyBgHover) !important; }
.table tbody tr.tradeSell:hover td{ background: var(--dgSellBgHover) !important; }

/* First column ("Side") = full strength signal */
.table tbody tr.tradeBuy td:first-child{
  background: rgba(20,241,149,.24) !important;
}
.table tbody tr.tradeSell td:first-child{
  background: rgba(255,104,121,.24) !important;
}

/* Make BUY/SELL pill unmistakable + bright */
.side.buy{
  color: var(--dgBuyText) !important;
  border-color: rgba(20,241,149,.65) !important;
  background: rgba(20,241,149,.18) !important;
  text-shadow: 0 0 18px rgba(20,241,149,.20);
}
.side.sell{
  color: var(--dgSellText) !important;
  border-color: rgba(255,104,121,.65) !important;
  background: rgba(255,104,121,.18) !important;
  text-shadow: 0 0 18px rgba(255,104,121,.18);
}

/* Optional: emphasize numeric values without killing readability */
.table tbody tr.tradeBuy td:nth-child(2),
.table tbody tr.tradeBuy td:nth-child(3),
.table tbody tr.tradeBuy td:nth-child(4){
  color: rgba(235,255,247,.94) !important;
}
.table tbody tr.tradeSell td:nth-child(2),
.table tbody tr.tradeSell td:nth-child(3),
.table tbody tr.tradeSell td:nth-child(4){
  color: rgba(255,238,242,.94) !important;
}

/* Keep wallet/age readable but not "black bars" */
.table tbody tr.tradeBuy td:nth-child(5),
.table tbody tr.tradeBuy td:nth-child(6){
  color: rgba(255,255,255,.84) !important;
}
.table tbody tr.tradeSell td:nth-child(5),
.table tbody tr.tradeSell td:nth-child(6){
  color: rgba(255,255,255,.84) !important;
}

/* Tx button inherits row tint; keep it clean */
.table tbody tr.tradeBuy td:last-child a.linkPill{
  border-color: rgba(20,241,149,.30) !important;
}
.table tbody tr.tradeSell td:last-child a.linkPill{
  border-color: rgba(255,104,121,.30) !important;
}
/* ===== /PATCH ===== */



/* ===== PATCH: Token header metrics alignment + remove Explorer/Pair/DexScreener buttons (STEP14) ===== */

/* A) Remove the 3 link pills completely from view (no gaps) */
#lnkExplorer, #lnkPair, #lnkDex{ display:none !important; }

/* B) Metrics grid/strip: make every stat tile same height + same internal baseline */
.statsGrid{
  align-items: stretch !important;      /* when STEP7 turns it into flex strip */
}
.statsGrid .stat{
  height: 78px !important;             /* enough room for Change card tabs */
  display:flex !important;
  flex-direction:column !important;
  justify-content:center !important;
  gap: 6px !important;
  padding-top: 10px !important;
  padding-bottom: 10px !important;
}
.statsGrid .stat .k{
  line-height: 1.05 !important;
  margin: 0 !important;
}
.statsGrid .stat .v{
  line-height: 1.12 !important;
  display:flex;
  align-items:center;
  gap: 8px;
  min-height: 18px;                    /* consistent baseline */
}

/* Change card inner layout: keep % perfectly aligned and tabs inside the same tile */
.statsGrid .stat .stMain{
  display:flex;
  align-items:center !important;        /* fixes "percent higher" feel */
  justify-content:space-between;
  gap: 10px;
  line-height: 1.1 !important;
}
.statsGrid .stat .stMain .delta{
  line-height: 1.1 !important;
  margin: 0 !important;
}
.statsGrid .stat .stTabs{
  margin-top: 6px !important;
  gap: 6px !important;
  flex-wrap: nowrap !important;         /* avoid wrapping that breaks tile height */
  overflow:hidden;                      /* keep clean */
}
.statsGrid .stat .stPill{
  height: 22px !important;
  padding: 0 8px !important;
  font-size: 10px !important;
  border-radius: 10px !important;
  line-height: 22px !important;
}

/* Mobile: slightly taller for touch + keep consistent alignment */
@media (max-width: 720px){
  .statsGrid .stat{
    height: 82px !important;
  }
  .statsGrid .stat .stPill{
    height: 26px !important;
    line-height: 26px !important;
    padding: 0 10px !important;
    font-size: 10px !important;
  }
}

/* ===== /PATCH ===== */


/* ===== PATCH: Single Search (no buttons, no dropdown) ===== */
.searchWrap.cmdSearch #btnSearch{ display:none !important; }
#cmdDropdown{ display:none !important; } /* removed from DOM, extra safety */
.dgInstantResults{ margin-top: 10px; }
.dgInstantResults .results{ display:block; } /* results moved out of hidden panel */
.dgInstantResults .empty{ margin-top: 0; }
/* Make results sit tight under the input (no big gap) */
.dgInstantResults .resultItem{ margin-top: 0; }
/* ===== /PATCH ===== */



/* Debug-only helper text (only visible with ?debug=1) */
.dgDebugOnly{ display:none !important; }
html.dgDebug .dgDebugOnly{ display:block !important; }

/* ===== PATCH: Copyable Contract (CA) ===== */
.dgCopy{ color: rgba(90,170,255,.95); cursor:pointer; }
.dgCopy:hover{ text-decoration: underline; }
/* ===== /PATCH ===== */


    /* DG patch: hide the empty 'Search and open...' hint card */
    #tokenEmpty{display:none!important;}
</style>
</head>

<body>
  <header class="header">
    <div class="wrap">
      <div class="headerRow">
        <div class="brand" aria-label="DexGuard">
          <div class="logo" aria-hidden="true"><span>DG</span></div>
          <div class="brandText">
            <div class="brandTop">
              <div class="pill" title="Live feeds are enabled (quiet mode)">
                <span class="liveDot" aria-hidden="true"></span>
                <b>LIVE</b>
              </div>
              <div class="brandName">DexGuard • DexLike</div>
            </div>
            <div id="subline" class="sub">Search + Live chart + Live trades. No ads. No overlays.</div>
          </div>
        </div>

        <div class="topCenter">
          <div class="searchWrap cmdSearch">
                      <div class="search" role="search">
                        <span class="searchIcon">⌕</span>
                        <input id="q" aria-label="Command Search" autocapitalize="off" autocomplete="off" spellcheck="false" placeholder="Search Token / Symbol / Contract...." />
                        
                      </div>
</div>
        </div>

        <div class="actions">
          <button id="btnSettings" class="btn ghost" title="Settings">Settings</button>
          <button id="btnClear" class="btn" title="Clear view">Clear</button>
          <a id="btnDS" class="btn grad" href="#" target="_blank" rel="noreferrer noopener" title="Open current pool on DexScreener">Open on DexScreener</a>

          <a id="btnX" class="btn icon xBtn" href="https://www.x.com/solana_x1" target="_blank" rel="noreferrer noopener" title="X (Twitter)">
            <svg viewBox="0 0 1200 1227" aria-hidden="true" focusable="false">
              <path d="M714 519L1160 0H1053L667 450L360 0H0L468 681L0 1227H107L515 756L840 1227H1200L714 519ZM566 691L521 627L164 105H302L590 520L635 584L1010 1122H872L566 691Z" fill="currentColor"/>
            </svg>
          </a>
          <div class="pill statusPill" title="UI status (visual)">
            <span class="liveDot" aria-hidden="true"></span>
            <b>Connected</b>
          </div>
        </div>
      </div>
    </div>
  </header>

  <main class="main">
    <div class="wrap">
      <div class="card">
        <div class="toolbar">
          <div class="chainTabs" role="tablist" aria-label="Chains">
            <button class="tab active" data-chain="solana" role="tab" aria-selected="true"><span class="chainTextHold" aria-hidden="true">SOL</span><span class="chainIcon" aria-hidden="true"><svg viewBox="0 0 256 256" aria-hidden="true" focusable="false">
  <defs>
    <linearGradient id="solg" x1="0" y1="0" x2="1" y2="1">
      <stop offset="0" stop-color="#14F195"/>
      <stop offset="0.5" stop-color="#00D1FF"/>
      <stop offset="1" stop-color="#9945FF"/>
    </linearGradient>
  </defs>
  <g transform="translate(34,52) skewX(-12)">
    <rect x="0" y="0" width="188" height="34" rx="10" fill="url(#solg)"/>
    <rect x="0" y="60" width="188" height="34" rx="10" fill="url(#solg)"/>
    <rect x="0" y="120" width="188" height="34" rx="10" fill="url(#solg)"/>
  </g>
</svg></span><span class="srOnly">SOL</span></button>
            <button class="tab" data-chain="ethereum" role="tab" aria-selected="false"><span class="chainTextHold" aria-hidden="true">ETH</span><span class="chainIcon" aria-hidden="true"><svg viewBox="0 0 256 256" aria-hidden="true" focusable="false">
  <g fill="currentColor">
    <path d="M128 16L54 128l74-34 74 34-74-112z"/>
    <path d="M128 104l-74 34 74 44 74-44-74-34z" opacity=".92"/>
    <path d="M54 144l74 96 74-96-74 44-74-44z" opacity=".88"/>
  </g>
</svg></span><span class="srOnly">ETH</span></button>
            <button class="tab" data-chain="bsc" role="tab" aria-selected="false"><span class="chainTextHold" aria-hidden="true">BNB</span><span class="chainIcon" aria-hidden="true"><svg viewBox="0 0 256 256" aria-hidden="true" focusable="false">
  <g fill="currentColor">
    <path d="M128 24l36 36-36 36-36-36 36-36z"/>
    <path d="M60 92l36 36-36 36-36-36 36-36z" opacity=".96"/>
    <path d="M196 92l36 36-36 36-36-36 36-36z" opacity=".96"/>
    <path d="M128 92l36 36-36 36-36-36 36-36z"/>
    <path d="M128 160l36 36-36 36-36-36 36-36z"/>
  </g>
</svg></span><span class="srOnly">BNB</span></button>
            <button class="tab" data-chain="base" role="tab" aria-selected="false"><span class="chainTextHold" aria-hidden="true">BASE</span><span class="chainIcon" aria-hidden="true"><svg viewBox="0 0 256 256" aria-hidden="true" focusable="false">
  <defs>
    <radialGradient id="baseg" cx="30%" cy="30%" r="80%">
      <stop offset="0" stop-color="#3B82F6"/>
      <stop offset="1" stop-color="#1D4ED8"/>
    </radialGradient>
  </defs>
  <circle cx="128" cy="128" r="110" fill="url(#baseg)"/>
  <circle cx="128" cy="128" r="70" fill="none" stroke="#FFFFFF" stroke-width="26" stroke-linecap="round"/>
  <circle cx="188" cy="128" r="10" fill="#FFFFFF"/>
</svg></span><span class="srOnly">BASE</span></button>
          </div>

          
        </div>

        <div class="grid">

          <section class="panel" aria-label="Search">
            <div class="panelHead">
              <div class="title">Search</div>
</div>
            <div class="tokenView" style="padding:12px">
              <div id="searchDock" aria-label="Search dock"></div>
            </div>
          </section>

<section class="panel" aria-label="Search results">
            <div class="panelHead">
              <div class="title">Search Results</div>
              <div class="hint"><span class="kbd">Enter</span> to search</div>
            </div>
            <div id="results" class="results"></div>
            <div id="resultsEmpty" class="empty" style="display:none"></div>
              <div><b>Search a token.</b> Results show logo, name, symbol, chain and an “Open” action.</div>
            </div>
          </section>
        </div>

        <section class="panel" aria-label="Token view">
          <div class="tokenView">
            <div id="tokenEmpty" class="empty" id="searchHint">
              <div>🧭</div>
              <div><b>Search</b> and open a pair to load the live chart + trades.</div>
            </div>

            <div id="tokenBlock" style="display:none">
              <div class="tokenHeader">
                <div class="tokenLeft">
                  <div class="bigLogo" id="tokenLogo"><span class="muted mono">DG</span></div>
                  <div class="tokenNames">
                    <div id="tokenTitle" class="sym">—</div>
                    <div id="tokenSub" class="addr">—</div>
                  </div>
                </div>
                <div class="tokenRight">
                  <div class="linksRow">
                    <a id="lnkExplorer" class="linkPill" href="#" target="_blank" rel="noreferrer noopener">Explorer</a>
                    <a id="lnkPair" class="linkPill" href="#" target="_blank" rel="noreferrer noopener">Pair</a>
                    <a id="lnkDex" class="linkPill" href="#" target="_blank" rel="noreferrer noopener">DexScreener</a>
                                      <a id="lnkScan" class="linkPill scanPill" href="#" rel="noreferrer noopener">Scan</a>
                  </div>
                </div>
              </div>

              <div class="statsGrid">
                <div class="stat"><div class="k">Price</div><div id="stPrice" class="v">—</div></div>
                <div class="stat"><div class="k">Statistics</div><div id="stChg" class="v">—</div></div>
                <div class="stat"><div class="k">Volume</div><div id="stVol" class="v">—</div></div>
                <div class="stat"><div class="k">Liquidity</div><div id="stLiq" class="v">—</div></div>
                <div class="stat"><div class="k">Market Cap</div><div id="stMcap" class="v">—</div></div>
                <div class="stat"><div class="k">Pool</div><div id="stPool" class="v">—</div></div>
              </div>

              <div class="grid tokenGrid" style="padding-top:0">
                <section class="panel chartPanel" aria-label="Live chart">
                  <div class="chartTop">
                    <div class="tfRow" aria-label="Timeframes">
                      <button class="tf" data-tf="1m">1m</button>
                      <button class="tf" data-tf="5m">5m</button>
                      <button class="tf active" data-tf="15m">15m</button>
                      <button class="tf" data-tf="1h">1h</button>
                      <button class="tf" data-tf="4h">4h</button>
                      <button class="tf" data-tf="1d">1d</button>
                    </div>
                    <div id="chartMeta" class="chartMeta ellipsis">—</div>
                    <div class="yZoomRow" aria-label="Y Scale Controls">
                      <button id="yZoomIn" class="yZoomBtn" type="button" aria-label="Y Zoom In" title="Y Zoom In">+</button>
                      <button id="yZoomOut" class="yZoomBtn" type="button" aria-label="Y Zoom Out" title="Y Zoom Out">−</button>
                    </div>
                  </div>

                  <div class="chartWrap" id="chartWrap">
                    <div id="chart"></div>
                  </div>

                  <div class="chartFooter">
                    <div id="status" class="status"><span class="dot"></span><span id="statusTxt">Idle</span></div>
                    <div class="muted2 dgDebugOnly">Live: trades → last price → safe fallback. Quiet errors (console only).</div>
                  </div>
                </section>

                <section class="panel" aria-label="Live trades">
                  <div class="panelHead">
                    <div class="title">Live Trades</div>
                    <div class="hint" style="display:none"><span id="tradeCount" class="kbd">0</span></div>
                  </div>
                  <div class="tableWrap">
                    <table class="table">
                      <thead>
                        <tr>
                          <th class="center">Type</th>
                          <th class="right">Time</th>
                          <th class="right">USD</th>
                          <th class="right">Price</th>
                          <th class="right">Amount</th>
                          <th>Wallet</th>
                          <th class="center">Tx</th>
                        </tr>
                      </thead>
                      <tbody id="tradesBody"></tbody>
                    </table>
                  </div>
                  <div id="tradesEmpty" class="empty" style="display:none">
                    <div>⏱️</div>
                    <div><b>No trades yet.</b> We'll keep polling quietly.</div>
                  </div>
                </section>
              </div>
            </div>
          </div>
        </section>
      </div>
    </div>
  </main>

  <!-- Mobile Bottom Navigation (UI only) -->
  <nav id="mNav" class="mNav" aria-label="Mobile navigation">
    <div class="mNavInner">
      <button type="button" data-nav="chart" aria-label="Go to Chart">Chart</button>
      <button type="button" data-nav="trades" aria-label="Go to Trades">Trades</button>
      <button type="button" data-nav="info" aria-label="Go to Info">Info</button>
    </div>
  </nav>


  <!-- Settings Modal -->
  <div id="modalBack" class="modalBack" role="dialog" aria-modal="true" aria-label="Settings">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle">Settings</div>
        <button id="btnCloseModal" class="btn icon" aria-label="Close">×</button>
      </div>
      <div class="modalBody">
        <div class="field">
          <div class="label">Proxy URL (optional)</div>
          <input id="proxyUrl" class="input" placeholder="https://your-worker.example.com/?url=" />
          <div class="help">
            Use this if your environment blocks API calls via CORS. You can use <span class="kbd">{url}</span> token,
            e.g. <span class="kbd">https://worker.tld/fetch?u={url}</span>.
          </div>
        </div>

        <div class="field">
          <div class="label">BIRDEYE_API_KEY (optional, Solana only)</div>
          <input id="birdeyeKey" class="input" placeholder="(stored locally — never hardcoded)" />
          <div class="help">
            Optional Solana enrichment / candle fallback. App works without it.
          </div>
        </div>

        <div class="field">
          <div class="label">Polling</div>
          <div class="row">
            <button id="btnResetPolling" class="btn">Reset to defaults</button>
            <span class="help">Trades/price: <span class="kbd" id="pollLive">2.5s</span> • When tab hidden: <span class="kbd" id="pollHidden">12s</span></span>
          </div>
        </div>

        <div class="field" style="margin-bottom:0">
          <div class="label">Local cache</div>
          <div class="row">
            <button id="btnClearCache" class="btn">Clear local cache</button>
            <span class="help">Candles cached briefly to reduce rate limits.</span>
          </div>
        </div>
      </div>
      <div class="footerBtns">
        <button id="btnSaveSettings" class="btn grad">Save</button>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite">
    <span class="tDot" aria-hidden="true"></span>
    <span id="toastTxt">—</span>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>

  <script>
  (() => {
    'use strict';

    // ========= Global guard (prevents duplicate boot/bind on accidental re-inits) =========
    const __DGW = (window.__DEXGUARD__ = window.__DEXGUARD__ || {});
    if (__DGW.__active){
      console.warn('[DexGuard] duplicate script load ignored');
      return;
    }
    __DGW.__active = true;

    // Debug UI flag (only reveals hidden controls; no user-visible debug text)
    const __DG_DEBUG_UI = (new URLSearchParams(window.location.search)).get('debug') === '1';
    try{ document.documentElement.classList.toggle('dgDebug', !!__DG_DEBUG_UI); }catch(e){}


    // ========= Utilities =========
    const $ = (sel, root=document) => root.querySelector(sel);
    const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
    const nowSec = () => Math.floor(Date.now()/1000);
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    const fmtNum = (n, digits=2) => {
      if (n === null || n === undefined || !isFinite(n)) return '—';
      const abs = Math.abs(n);
      const d = abs >= 1000 ? 0 : digits;
      return n.toLocaleString(undefined, {maximumFractionDigits:d});
    };
    const fmtUSD = (n) => {
      if (n === null || n === undefined || !isFinite(n)) return '—';
      const abs = Math.abs(n);
      const digits = abs >= 1000 ? 0 : abs >= 1 ? 2 : abs >= 0.01 ? 4 : abs >= 0.0001 ? 6 : 10;
      return '$' + n.toLocaleString(undefined, {maximumFractionDigits:digits});
    };
    const fmtPrice = (n) => {
      if (n === null || n === undefined || !isFinite(n)) return '—';
      const abs = Math.abs(n);
      const digits = abs >= 1 ? 6 : abs >= 0.01 ? 8 : 10;
      return n.toLocaleString(undefined, {maximumFractionDigits:digits});
    };

    // Trade formatting (DexScreener-like; fixed separators & decimals)
    const fmtAmt = (n) => {
      if (n === null || n === undefined || !isFinite(n)) return '—';
      const abs = Math.abs(n);
      let digits = 0;
      if (abs >= 10000) digits = 0;
      else if (abs >= 1000) digits = 2;
      else if (abs >= 1) digits = 3;
      else if (abs >= 0.01) digits = 6;
      else digits = 8;
      return n.toLocaleString('en-US', { maximumFractionDigits: digits });
    };

    const fmtUsd2 = (n) => {
      if (n === null || n === undefined || !isFinite(n)) return '—';
      const abs = Math.abs(n);
      const digits = abs >= 0.01 ? 2 : 4;
      return '$' + n.toLocaleString('en-US', { minimumFractionDigits: digits, maximumFractionDigits: digits });
    };

    const shortAddr = (a) => {
      if (!a) return '—';
      if (a.length <= 12) return a;
      return a.slice(0,6) + '…' + a.slice(-4);
    };
    const timeAgo = (tsSec) => {
      if (!tsSec || !isFinite(tsSec)) return '—';
      const d = Math.max(0, nowSec() - Math.floor(tsSec));
      if (d < 60) return d + 's';
      const m = Math.floor(d/60);
      if (m < 60) return m + 'm';
      const h = Math.floor(m/60);
      if (h < 48) return h + 'h';
      const days = Math.floor(h/24);
      return days + 'd';
    };
    const escapeHtml = (s) => String(s ?? '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    const cleanText = (val) => {
      const s = (val ?? '').toString().trim();
      return s && s !== '—' ? s : null;
    };
    const toNum = (x) => {
      const n = typeof x === 'string' ? parseFloat(x) : (typeof x === 'number' ? x : NaN);
      return isFinite(n) ? n : null;
    };

    // ========= Quiet toast (only user-triggered) =========
    let __DG_SUPPRESS_TOAST = false;
    let toastTimer = null;
    function toast(msg){
      if (__DG_SUPPRESS_TOAST) return;
      const el = $('#toast');
      $('#toastTxt').textContent = msg;
      el.classList.add('show');
      clearTimeout(toastTimer);
      toastTimer = setTimeout(()=> el.classList.remove('show'), 2200);
    }

    // ========= Scan redirect helper (Dex -> /contract) =========
    function dgBuildScanUrl(chain, address, pool){
      try{
        const u = new URL('/contract/', location.origin);
        if (chain) u.searchParams.set('chain', String(chain));
        if (address) u.searchParams.set('address', String(address));
        if (pool) u.searchParams.set('pool', String(pool));
        // Hint for scanners that support it
        u.searchParams.set('autostart', '1');
        return u.toString();
      }catch(e){
        // Fallback (relative)
        const qs = `?chain=${encodeURIComponent(chain||'')}&address=${encodeURIComponent(address||'')}&pool=${encodeURIComponent(pool||'')}&autostart=1`;
        return '/contract/' + qs;
      }
    }
    function dgGoScan({chain, address, pool}){
      const payload = { chain: chain || state.chain, address: address || '', pool: pool || '', ts: Date.now() };
      try{ sessionStorage.setItem('dg_scan_target_v1', JSON.stringify(payload)); }catch(e){}
      location.href = dgBuildScanUrl(payload.chain, payload.address, payload.pool);
    }



    // ========= Settings (local only) =========
    const LS = {
      proxy: 'dg_proxy_url_v1',
      birdeye: 'dg_birdeye_key_v1',
      cache: 'dg_cache_v1',
    };
    const settings = {
      proxyUrl: localStorage.getItem(LS.proxy) || '',
      birdeyeKey: localStorage.getItem(LS.birdeye) || '',
      pollLiveMs: 2500,
      pollHiddenMs: 12000,
    };

    // ========= Simple cache (mem + localStorage TTL) =========
    const memCache = new Map(); // key -> {t, ttl, v}
    function cacheGet(key){
      const m = memCache.get(key);
      if (m && (Date.now()-m.t) < m.ttl) return m.v;
      try{
        const raw = localStorage.getItem(LS.cache);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        const ent = obj[key];
        if (!ent) return null;
        if ((Date.now() - ent.t) > ent.ttl) return null;
        return ent.v;
      }catch(e){ return null; }
    }
    function cacheSet(key, v, ttl){
      memCache.set(key, {t:Date.now(), ttl, v});
      try{
        const raw = localStorage.getItem(LS.cache);
        const obj = raw ? JSON.parse(raw) : {};
        obj[key] = {t:Date.now(), ttl, v};
        const keys = Object.keys(obj);
        if (keys.length > 140){
          keys.sort((a,b)=> (obj[a].t||0) - (obj[b].t||0));
          for (let i=0;i<keys.length-140;i++) delete obj[keys[i]];
        }
        localStorage.setItem(LS.cache, JSON.stringify(obj));
      }catch(e){}
    }
    function cacheClear(){
      memCache.clear();
      try{ localStorage.removeItem(LS.cache); }catch(e){}
    }

    // ========= Proxy wrapper =========
    function applyProxy(url){
      const p = (settings.proxyUrl || '').trim();
      if (!p) return url;
      const enc = encodeURIComponent(url);
      if (p.includes('{url}')) return p.split('{url}').join(enc);
      const join = p.includes('?') ? '&' : '?';
      return p + join + 'url=' + enc;
    }

    // ========= Fetch (Abort + backoff + dedupe) =========
    const DG_CORS_FALLBACK = 'https://api.allorigins.win/raw?url=';
    const dgCorsFallbackHosts = [
      'https://api.dexscreener.com/',
      'https://io.dexscreener.com/',
    ];
    const inflight = new Map(); // finalUrl -> promise

    function dgShouldUseCorsFallback(url){
      if (!url) return false;
      return dgCorsFallbackHosts.some(h => url.startsWith(h));
    }
    function dgIsCorsLikeError(err){
      const msg = String(err && (err.message || err));
      return msg.includes('Failed to fetch') || msg.includes('NetworkError') || msg.includes('CORS');
    }
    async function dgFetchJsonDirect(url, {signal=null, headers=null}={}){
      const res = await fetch(url, {
        method:'GET',
        headers: Object.assign({'accept':'application/json'}, headers || {}),
        signal,
        cache:'no-store',
        mode:'cors',
      });
      if (!res.ok) {
        const txt = await res.text().catch(()=> '');
        const err = new Error('HTTP '+res.status+' '+res.statusText);
        err.status = res.status;
        err.body = txt.slice(0,200);
        throw err;
      }
      return res.json();
    }

    async function fetchJson(url, {ttl=0, signal=null, headers=null}={}){
      const finalUrl = applyProxy(url);
      const cacheKey = finalUrl;
      if (ttl > 0){
        const cached = cacheGet(cacheKey);
        if (cached) return cached;
      }
      if (inflight.has(cacheKey)) return inflight.get(cacheKey);

      const p = (async ()=>{
        let data;
        const proxyActive = !!(settings.proxyUrl || '').trim();
        const canFallback = !proxyActive && dgShouldUseCorsFallback(url);
        try{
          data = await dgFetchJsonDirect(finalUrl, {signal, headers});
        }catch(err){
          if (canFallback && dgIsCorsLikeError(err)){
            const fallbackUrl = DG_CORS_FALLBACK + encodeURIComponent(url);
            data = await dgFetchJsonDirect(fallbackUrl, {signal, headers});
          } else {
            throw err;
          }
        }
        if (ttl > 0) cacheSet(cacheKey, data, ttl);
        return data;
      })();

      inflight.set(cacheKey, p);
      try{ return await p; }
      finally{ inflight.delete(cacheKey); }
    }

    async function withBackoff(fn, {tries=3, baseMs=350, maxMs=2800, signal=null}={}){
      let lastErr = null;
      for (let i=0;i<tries;i++){
        if (signal?.aborted) throw new DOMException('Aborted','AbortError');
        try{ return await fn(); }
        catch(e){
          lastErr = e;
          const msg = String(e && (e.message||e));
          if (msg.includes('AbortError')) throw e;
          const wait = clamp(baseMs * (2**i) + Math.random()*120, baseMs, maxMs);
          await sleep(wait);
        }
      }
      throw lastErr;
    }

    // ========= Chain mappings =========
    const CHAINS = {
      solana:  {label:'SOL', ds:'solana', gt:'solana', explorer:'https://solscan.io'},
      ethereum:{label:'ETH', ds:'ethereum', gt:'eth', explorer:'https://etherscan.io'},
      bsc:     {label:'BNB', ds:'bsc', gt:'bsc', explorer:'https://bscscan.com'},
      base:    {label:'BASE',ds:'base', gt:'base', explorer:'https://basescan.org'},
    };

    // ========= API helpers =========
    const dsSearchUrl = (q) => `https://api.dexscreener.com/latest/dex/search?q=${encodeURIComponent(q)}`;
    const dsPairsUrl = (chainId, pairId) => `https://api.dexscreener.com/latest/dex/pairs/${encodeURIComponent(chainId)}/${encodeURIComponent(pairId)}`;
    const dsTokenPairsUrl = (chainId, token) => `https://api.dexscreener.com/token-pairs/v1/${encodeURIComponent(chainId)}/${encodeURIComponent(token)}`;

    const dsTradesUrl = (chainId, pairId, limit=60) => `https://io.dexscreener.com/dex/trades/v1/${encodeURIComponent(chainId)}/${encodeURIComponent(pairId)}?limit=${limit}&ts=${Date.now()}`;
    const dsBoostTopUrl = () => `https://api.dexscreener.com/token-boosts/top/v1`;
    const dsBoostLatestUrl = () => `https://api.dexscreener.com/token-boosts/latest/v1`;

    const gtPoolUrl = (network, pool) => `https://api.geckoterminal.com/api/v2/networks/${encodeURIComponent(network)}/pools/${encodeURIComponent(pool)}`;
    const gtTradesUrl = (network, pool) => `https://api.geckoterminal.com/api/v2/networks/${encodeURIComponent(network)}/pools/${encodeURIComponent(pool)}/trades?page=1&ts=${Date.now()}`;
    function tfToGT(tf){
      switch(tf){
        case '1m': return {timeframe:'minute', aggregate:1, sec:60};
        case '5m': return {timeframe:'minute', aggregate:5, sec:300};
        case '15m': return {timeframe:'minute', aggregate:15, sec:900};
        case '1h': return {timeframe:'hour', aggregate:1, sec:3600};
        case '4h': return {timeframe:'hour', aggregate:4, sec:14400};
        case '1d': return {timeframe:'day', aggregate:1, sec:86400};
        default: return {timeframe:'minute', aggregate:15, sec:900};
      }
    }
    function gtOhlcvUrl(network, pool, tf, token='base', before, limitOverride){
      const map = tfToGT(tf);
      const limit = limitOverride || (map.timeframe === 'day' ? 260 : map.timeframe === 'hour' ? 520 : 700);
      const cutoff = before || nowSec();
      const currency = 'usd';
      // Gecko supports token=base|quote; some pools only have one side priced reliably in USD.
      return `https://api.geckoterminal.com/api/v2/networks/${encodeURIComponent(network)}/pools/${encodeURIComponent(pool)}/ohlcv/${encodeURIComponent(map.timeframe)}?aggregate=${map.aggregate}&before_timestamp=${cutoff}&limit=${limit}&currency=${currency}&token=${encodeURIComponent(token)}`;
    }

    const birdeyeTokenOverviewUrl = (token) => `https://public-api.birdeye.so/defi/token_overview?address=${encodeURIComponent(token)}`;
    const birdeyeOhlcvUrl = (token, tf) => {
      const interval = tf === '1m' ? '1m' : tf === '5m' ? '5m' : tf === '15m' ? '15m' : tf === '1h' ? '1H' : tf === '4h' ? '4H' : '1D';
      const limit = tf === '1d' ? 260 : tf === '4h' ? 520 : tf === '1h' ? 700 : 900;
      const to = nowSec();
      const secs = tf === '1m' ? 60 : tf === '5m' ? 300 : tf === '15m' ? 900 : tf === '1h' ? 3600 : tf === '4h' ? 14400 : 86400;
      const from = to - secs * limit;
      return `https://public-api.birdeye.so/defi/ohlcv?address=${encodeURIComponent(token)}&type=token&time_from=${from}&time_to=${to}&interval=${encodeURIComponent(interval)}`;
    };
    async function fetchBirdeyeOhlcv(meta, tf, {sid, signal}){
      if (!settings.birdeyeKey) return null;
      if (!meta || !meta.token) return null;
      const url = birdeyeOhlcvUrl(meta.token, tf);
      const be = await withBackoff(() => fetchJson(url, {
        ttl: 10_000,
        signal,
        headers: {'X-API-KEY': settings.birdeyeKey},
      }), {tries:2, signal});
      if (sid !== state.sessionId) return null;

      // Birdeye shapes vary; try common layouts
      const data = be?.data?.data || be?.data || be;
      const items = data?.items || data?.data?.items || data?.data || data?.items || [];
      if (!Array.isArray(items) || !items.length) return null;

      const candles = [];
      for (const it of items){
        const t = toNum(it?.unixTime ?? it?.time ?? it?.t);
        const o = toNum(it?.o ?? it?.open);
        const h = toNum(it?.h ?? it?.high);
        const l = toNum(it?.l ?? it?.low);
        const c = toNum(it?.c ?? it?.close);
        const v = toNum(it?.v ?? it?.volume);
        if (!isFinite(t) || !isFinite(c)) continue;
        candles.push({time: t|0, open:o, high:h, low:l, close:c, volume:v});
      }
      return candles.length ? candles : null;
    }


    function explorerLink(chain, address, kind='token'){
      const base = CHAINS[chain]?.explorer || '';
      if (!base) return '#';
      if (chain === 'solana'){
        if (kind === 'tx') return `${base}/tx/${address}`;
        return `${base}/address/${address}`;
      }
      if (kind === 'tx') return `${base}/tx/${address}`;
      return `${base}/address/${address}`;
    }
    function dexLink(chain, pairId){
      const dsChain = CHAINS[chain]?.ds || chain;
      return `https://dexscreener.com/${dsChain}/${pairId}`;
    }

    // ========= DOM =========
    const el = {
      btnSettings: $('#btnSettings'),
      btnClear: $('#btnClear'),
      btnDS: $('#btnDS'),
      tabs: $$('.tab'),
      q: $('#q'),
      btnSearch: $('#btnSearch'),
      trending: $('#trending'),
      trendingEmpty: $('#trendingEmpty'),
      results: $('#results'),
      resultsEmpty: $('#resultsEmpty'),
      tokenEmpty: $('#tokenEmpty'),
      tokenBlock: $('#tokenBlock'),
      tokenLogo: $('#tokenLogo'),
      tokenTitle: $('#tokenTitle'),
      tokenSub: $('#tokenSub'),
      stPrice: $('#stPrice'),
      stChg: $('#stChg'),
      stVol: $('#stVol'),
      stLiq: $('#stLiq'),
      stMcap: $('#stMcap'),
      stPool: $('#stPool'),
      lnkExplorer: $('#lnkExplorer'),
      lnkDex: $('#lnkDex'),
      lnkPair: $('#lnkPair'),
      lnkScan: $('#lnkScan'),
      tfs: $$('.tf'),
      chartWrap: $('#chartWrap'),
      chartMeta: $('#chartMeta'),
      yZoomIn: $('#yZoomIn'),
      yZoomOut: $('#yZoomOut'),
      status: $('#status'),
      statusTxt: $('#statusTxt'),
      tradesBody: $('#tradesBody'),
      tradesEmpty: $('#tradesEmpty'),
      tradeCount: $('#tradeCount'),
      modalBack: $('#modalBack'),
      btnCloseModal: $('#btnCloseModal'),
      btnSaveSettings: $('#btnSaveSettings'),
      proxyUrl: $('#proxyUrl'),
      birdeyeKey: $('#birdeyeKey'),
      btnClearCache: $('#btnClearCache'),
      btnResetPolling: $('#btnResetPolling'),
      pollLive: $('#pollLive'),
      pollHidden: $('#pollHidden'),
    };

    // ========= Topbar UI controls (CEX-style) =========
    (function applyTopbarUI(){
      try{
        if (el.btnClear) el.btnClear.style.display = 'none';
        if (el.btnDS) el.btnDS.style.display = 'none';
        if (el.btnSettings) el.btnSettings.style.display = __DG_DEBUG_UI ? 'inline-flex' : 'none';
      }catch(e){ console.warn('[DexGuard] topbar UI apply failed', e); }
    })();


    // ========= Runtime guards: tolerate missing DOM nodes (no crash; console only) =========
    const NULL_EL = new Proxy({
      clientWidth: 0, clientHeight: 0,
      style: {},
      classList: { add(){}, remove(){}, toggle(){}, contains(){return false;} },
      setAttribute(){}, getAttribute(){return null;},
      addEventListener(){}, removeEventListener(){},
      appendChild(){}, remove(){}, focus(){},
      querySelector(){return null;}, querySelectorAll(){return [];},
      closest(){return null;},
      innerHTML: '', textContent: '', value: '', href: '#'
    }, {
      get(t,p){ return (p in t) ? t[p] : undefined; },
      set(t,p,v){ t[p] = v; return true; }
    });

    (function patchMissingEls(){
      try{
        for (const k of Object.keys(el)){
          const v = el[k];
          if (Array.isArray(v)) { el[k] = v.filter(Boolean); continue; }
          if (!v){
            console.warn('[DexGuard] missing element:', k);
            el[k] = NULL_EL;
          }
        }
      }catch(e){
        console.warn('[DexGuard] guard init failed', e);
      }
    })();


    // ========= App State =========
    const state = {
      chain: 'solana',
      tf: '15m',
      // Which search UI should show results: 'panel' or 'cmd'
      searchUI: 'panel',
      _cmdFocusUntil: 0,
      sessionId: 0,
      current: null, // meta

      // Trades state
      lastTradeId: null,
      tradesMap: new Map(),   // id -> trade
      tradesList: [],         // sorted desc (max 60)
      ageTimer: null,         // 1s age updater

      liveTimer: null,
      _onVis: null,
      abort: null,

      chart: null,
      series: null,
      yZoomOff: 0,
      yZoomBase: { top: 0.10, bottom: 0.12 },
      ro: null,
      lastCandle: null,
      candles: [],
      lastPriceByPool: new Map(),
      candleSideByKey: new Map(),
      candleRetryAt: new Map(),
      candleRefreshLock: false,
      _backfilling: false,
      _backfillTimer: 0,
      _rangeSub: false,
      metaByPool: new Map(),
      metaByToken: new Map(),
      _tfSwitching: false,
      _tfSwitchSid: 0,
      _autoFollow: true,
      _usingFallbackCandles: false,
      _fallbackRetryAt: new Map(),
      _fallbackTimer: 0,
    };

    

    function inferPriceFormat(price){
      if (!isFinite(price) || price <= 0) return {precision: 2, minMove: 0.01};
      const abs = Math.abs(price);
      // Target ~2 significant decimals for >=1, more for micro prices (up to 12)
      const log10 = Math.floor(Math.log10(abs));
      const precision = clamp((log10 >= 0) ? 6 : (-log10 + 4), 2, 12);
      const minMove = Math.pow(10, -precision);
      return {precision, minMove};
    }

    function applySeriesPrecision(price){
      if (!state.series) return;
      const pf = inferPriceFormat(price);
      try{
        state.series.applyOptions({ priceFormat: { type: 'price', precision: pf.precision, minMove: pf.minMove } });
      }catch(e){}
    }
function setStatus(kind, txt){
      el.status.className = 'status ' + (kind || '');
      el.statusTxt.textContent = txt || '';
    }
    function setTradesEmpty(mode){
      if (!el.tradesEmpty) return;
      if (mode === 'hide'){
        el.tradesEmpty.style.display = 'none';
        return;
      }
      if (mode === 'loading'){
        el.tradesEmpty.innerHTML = `
          <div>⏳</div>
          <div><b>Loading trades…</b> Fetching the latest activity now.</div>
        `;
      } else {
        el.tradesEmpty.innerHTML = `
          <div>⏱️</div>
          <div><b>No trades yet.</b> We'll keep polling quietly.</div>
        `;
      }
      el.tradesEmpty.style.display = '';
    }
    function setChartLoading(on){
      el.chartWrap?.classList.toggle('loading', !!on);
    }
    function scoreCandles(list, refPrice){
      if (!list || !list.length || !isFinite(refPrice) || refPrice <= 0) return null;
      const last = list[list.length-1];
      const close = last?.close;
      if (!isFinite(close) || close <= 0) return null;
      const ratio = Math.max(close, refPrice) / Math.max(1e-12, Math.min(close, refPrice));
      return ratio;
    }
    function pickBestCandles(a, b, refPrice){
      if (a && a.length && b && b.length){
        if (!isFinite(refPrice) || refPrice <= 0) return a;
        const sa = scoreCandles(a, refPrice);
        const sb = scoreCandles(b, refPrice);
        if (sa != null && sb != null) return (sa <= sb) ? a : b;
        return a;
      }
      return (a && a.length) ? a : (b && b.length ? b : null);
    }
    function poolKey(meta){ return `${meta.chain}|${meta.pool}`; }
    function tokenKey(chain, token){ return `${chain}|${normAddr(chain, token)}`; }
    function rememberMeta(meta){
      if (!meta) return;
      if (meta.pool) state.metaByPool.set(poolKey(meta), {...meta});
      if (meta.token) state.metaByToken.set(tokenKey(meta.chain, meta.token), {...meta});
    }
    function mergeMeta(target, source){
      if (!source) return;
      const fieldsText = ['baseSymbol','baseName','quoteSymbol','logoUrl','token','dexId'];
      for (const f of fieldsText){
        if (!target[f]){
          const v = cleanText(source[f]);
          if (v) target[f] = v;
        }
      }
      const fieldsNum = ['priceUsd','change5m','change1h','change6h','change24h','volume5mUsd','volume1hUsd','volume6hUsd','volume24hUsd','liquidityUsd','marketCapUsd'];
      for (const f of fieldsNum){
        if (target[f] == null && isFinite(source[f])) target[f] = source[f];
      }
    }
    function primeChart(meta){
      const ck = candleCacheKey(meta, state.tf);
      const cached = candleCache.get(ck);
      if (cached && cached.data && cached.data.length){
        applyCandlesToChart(cached.data);
        return true;
      }
      const hintPrice = chartPriceFor(meta);
      if (isFinite(hintPrice) && hintPrice > 0){
        applyCandlesToChart(generateFlatCandles(hintPrice, state.tf, 220));
        return true;
      }
      return false;
    }

    function resetChartForNewToken(meta){
      // Prevent old token candles staying visible while new token loads.
      initChart();
      try{ state.series && state.series.setData([]); }catch(e){}
      try{ state.chart && state.chart.timeScale && state.chart.timeScale().resetTimeScale(); }catch(e){}
      state._pinToRight = true;
      state._autoFollow = true;
      state._usingFallbackCandles = false;

      // show a quick flat baseline as soon as we have a reference price (from DS meta or live trades)
      const sid = state.sessionId;
      (async () => {
        try{
          const px = await waitForRefPrice(meta, 1400);
          if (sid !== state.sessionId) return;
          if (state.candles && state.candles.length) return; // real candles already loaded
          if (isFinite(px) && px > 0){
            applyCandlesToChart(generateFlatCandles(px, state.tf, 220));
          }
        }catch(e){}
      })();
    }

    const normAddr = (chain, addr) => {
      if (!addr) return '';
      const s = String(addr);
      return (chain === 'solana') ? s : s.toLowerCase();
    };
    const addrEq = (chain, a, b) => !!a && !!b && normAddr(chain, a) === normAddr(chain, b);

    const pickGtSide = (meta) => {
      // GeckoTerminal defines its own base/quote tokens for the pool. We must match the user's token against THAT.
      const chain = meta?.chain;
      const want = meta?.token;
      const gb = meta?.gtBaseAddr;
      const gq = meta?.gtQuoteAddr;
      if (addrEq(chain, want, gb)) return 'base';
      if (addrEq(chain, want, gq)) return 'quote';
      // fallback: if we at least know quote is the chain native (e.g. SOL/WETH/BNB) and the user token isn't it, prefer the other
      return meta?.gtSideHint || 'base';
    };


    // ========= Chart init =========

    // ========= Y-Scale controls (STEP12) =========
    const DG_YZOOM = { step: 0.03, min: 0.02, max: 0.40 };

    function dgApplyYZoom(){
      if (!state.chart) return;
      const base = state.yZoomBase || { top: 0.10, bottom: 0.12 };
      const off0 = (state.yZoomOff!=null && isFinite(state.yZoomOff)) ? Number(state.yZoomOff) : 0;

      // clamp offset so BOTH margins stay in bounds
      const minOff = DG_YZOOM.min - Math.min(base.top, base.bottom);
      const maxOff = DG_YZOOM.max - Math.max(base.top, base.bottom);
      const off = clamp(off0, minOff, maxOff);
      state.yZoomOff = off;

      const top = clamp(base.top + off, DG_YZOOM.min, DG_YZOOM.max);
      const bottom = clamp(base.bottom + off, DG_YZOOM.min, DG_YZOOM.max);

      try{
        state.chart.applyOptions({ rightPriceScale: { scaleMargins: { top, bottom } } });
      }catch(e){}

      try{
        if (el.yZoomIn) el.yZoomIn.disabled = (top <= DG_YZOOM.min + 1e-6 || bottom <= DG_YZOOM.min + 1e-6);
        if (el.yZoomOut) el.yZoomOut.disabled = (top >= DG_YZOOM.max - 1e-6 || bottom >= DG_YZOOM.max - 1e-6);
      }catch(e){}
    }

    function dgYZoom(delta){
      const base = state.yZoomBase || { top: 0.10, bottom: 0.12 };
      const minOff = DG_YZOOM.min - Math.min(base.top, base.bottom);
      const maxOff = DG_YZOOM.max - Math.max(base.top, base.bottom);
      const next = clamp(((state.yZoomOff!=null && isFinite(state.yZoomOff)) ? Number(state.yZoomOff) : 0) + delta, minOff, maxOff);
      state.yZoomOff = next;
      dgApplyYZoom();
    }

    function initChart(){
      if (state.chart) return;
      const wrap = el.chartWrap;
      const w = wrap.clientWidth|0;
      const h = wrap.clientHeight|0;
      if (w < 40 || h < 160) return;

      state.chart = LightweightCharts.createChart($('#chart'), {
        width: w,
        height: h,
        layout: {
          background: { type:'solid', color:'rgba(0,0,0,0)' },
          textColor: 'rgba(255,255,255,0.82)',
          fontSize: 12,
          fontFamily: getComputedStyle(document.documentElement).getPropertyValue('--mono') || 'monospace',
        },
        grid: {
          vertLines: { color:'rgba(255,255,255,0.06)' },
          horzLines: { color:'rgba(255,255,255,0.06)' },
        },
        rightPriceScale: {
          borderColor:'rgba(255,255,255,0.08)',
          scaleMargins: { top: 0.10, bottom: 0.12 },
        },
        timeScale: {
          borderColor:'rgba(255,255,255,0.08)',
          timeVisible: true,
          secondsVisible: false,
        },
        crosshair: {
          mode: LightweightCharts?.CrosshairMode?.Normal ?? 0,
          vertLine: { color:'rgba(255,255,255,0.16)', width:1 },
          horzLine: { color:'rgba(255,255,255,0.16)', width:1 },
        },
        handleScroll: { mouseWheel:true, pressedMouseMove:true, horzTouchDrag:true, vertTouchDrag:false },
        handleScale: { axisPressedMouseMove:true, pinch:true, mouseWheel:true },
      });

      state.series = state.chart.addCandlestickSeries({
        priceFormat: { type:'price', precision: 8, minMove: 0.00000001 },
        upColor: 'rgba(20,241,149,0.88)',
        downColor: 'rgba(255,104,121,0.82)',
        borderUpColor: 'rgba(20,241,149,0.88)',
        borderDownColor: 'rgba(255,104,121,0.82)',
        wickUpColor: 'rgba(20,241,149,0.70)',
        wickDownColor: 'rgba(255,104,121,0.70)',
      });

      // Apply persisted Y-zoom margins (STEP12)
      dgApplyYZoom();

      if (!state._rangeSub){
        state.chart.timeScale().subscribeVisibleLogicalRangeChange((range) => {
          if (!range || !state.current) return;
          const total = state.candles?.length || 0;
          if (total > 0 && isFinite(range.to)){
            state._pinToRight = range.to >= (total - 2);
          } else {
            state._pinToRight = true;
          }
          if (!state._pinToRight) state._autoFollow = false;
          if (range.from > 10) return;
          clearTimeout(state._backfillTimer);
          state._backfillTimer = setTimeout(() => {
            if (!state.current) return;
            const sid = state.sessionId;
            const signal = state.abort?.signal;
            void backfillCandles(state.current, {sid, signal});
          }, 200);
        });
        state._rangeSub = true;
      }

      // ResizeObserver with rAF throttle + suppress noisy RO errors
      let raf = 0;
      state.ro = new ResizeObserver(() => {
        cancelAnimationFrame(raf);
        raf = requestAnimationFrame(() => {
          try{
            const w2 = wrap.clientWidth|0;
            const h2 = wrap.clientHeight|0;
            if (!state.chart || w2 < 40 || h2 < 160) return;
            state.chart.resize(w2, h2);
          }catch(e){
            const msg = String(e && e.message || e);
            if (!msg.includes('ResizeObserver')) console.warn('[DexGuard] resize', msg);
          }
        });
      });
      state.ro.observe(wrap);
    }

    // ========= UI builders =========
    function clearResults(){
      el.results.classList.remove('show');
      el.results.innerHTML = '';
      el.resultsEmpty.style.display = '';
      try{
        cmdHide(); cmdSetItems([]);
        // If command search is focused & empty, show recents
        const qv = (el.q && el.q.value ? String(el.q.value).trim() : '');
        const focused = (document.activeElement === el.q);
        if (focused && !qv){
          cmdShowRecents();
        }

    // Ensure empty query resets results immediately (live update on delete)
    function dgShowInstantDefaults(){
      try{ clearResults(); }catch(e){}
    }
      }catch(e){}
    }

// ========= Command Search Dropdown (STEP3) =========
const cmd = { open:false, loading:false, items:[], active:-1, lastQuery:'' };
cmd.mode = 'results';

// ========= Recents (STEP4) =========
const DG_RECENTS_KEY = 'dg_recents_v1';
function dgReadRecents(){
  try{
    const raw = localStorage.getItem(DG_RECENTS_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    return Array.isArray(arr) ? arr.filter(Boolean) : [];
  }catch(e){ return []; }
}
function dgWriteRecents(arr){
  try{ localStorage.setItem(DG_RECENTS_KEY, JSON.stringify(arr||[])); }catch(e){}
}
function dgClearRecents(){
  try{ localStorage.removeItem(DG_RECENTS_KEY); }catch(e){}
}
function dgRecentsPush(meta){
  try{
    if (!meta || !meta.chain) return;
    const chain = String(meta.chain || '');
    const pool = meta.pool ? String(meta.pool) : '';
    const token = meta.token ? String(meta.token) : '';
    const key = chain + '|' + (pool || token || '');
    if (!key.endsWith('|')){} else { return; }
    const item = {
      k: key,
      chain,
      pairId: pool || null,
      tokenAddress: token || null,
      baseName: meta.baseName ? String(meta.baseName) : '',
      baseSymbol: meta.baseSymbol ? String(meta.baseSymbol) : '',
      quoteSymbol: meta.quoteSymbol ? String(meta.quoteSymbol) : '',
      logoUrl: meta.logoUrl ? String(meta.logoUrl) : '',
      dexId: meta.dexId ? String(meta.dexId) : '',
      priceUsd: (meta.priceUsd!=null && isFinite(meta.priceUsd)) ? Number(meta.priceUsd) : null,
      change24h: (meta.change24h!=null && isFinite(meta.change24h)) ? Number(meta.change24h) : null,
      ts: Date.now()
    };
    const list = dgReadRecents();
    const next = [item, ...list.filter(x => (x && x.k) ? x.k !== key : true)];
    dgWriteRecents(next.slice(0, 12));
  }catch(e){ console.warn('[DexGuard] recents push failed', e); }
}

// ========= Last State Persistence (STEP5) =========
const DG_LAST_STATE_KEY = 'dg_last_state_v1';

// Also persist last opened token in the URL hash (so refresh/back keeps context)
function dgReadHashState(){
  try{
    const h = String(location.hash || '');
    if (!h.startsWith('#dg=')) return null;
    const qs = new URLSearchParams(h.slice(4));
    const chain = qs.get('chain') ? String(qs.get('chain')).toLowerCase() : '';
    const pairId = qs.get('pair') || '';
    const tokenAddress = qs.get('token') || '';
    const tf = qs.get('tf') || '';
    if (!chain || (!pairId && !tokenAddress)) return null;
    return { chain, pairId, tokenAddress, tf };
  }catch(e){ return null; }
}

function dgWriteHashState(meta){
  try{
    if (!meta || !meta.chain) return;
    const chain = String(meta.chain || '').toLowerCase();
    const pairId = meta.pool ? String(meta.pool) : (meta.pairId ? String(meta.pairId) : '');
    const tokenAddress = meta.token ? String(meta.token) : (meta.tokenAddress ? String(meta.tokenAddress) : '');
    if (!chain || (!pairId && !tokenAddress)) return;

    const qs = new URLSearchParams();
    qs.set('chain', chain);
    if (pairId) qs.set('pair', pairId);
    if (tokenAddress) qs.set('token', tokenAddress);
    if (state && state.tf) qs.set('tf', String(state.tf));
    const newHash = '#dg=' + qs.toString();

    // replaceState avoids scroll-jumps that location.hash assignment can cause
    if (location.hash !== newHash){
      try{
        history.replaceState(null, '', location.pathname + location.search + newHash);
      }catch(_){
        try{ location.hash = newHash; }catch(__){}
      }
    }
  }catch(e){}
}

// Ensure we have a last-known state even if user reloads immediately
try{
  window.addEventListener('beforeunload', () => {
    try{
      if (state && state.current) dgPersistLastStateFromMeta(state.current);
    }catch(e){}
  });
}catch(e){}


function dgReadLastState(){
  try{
    const raw = localStorage.getItem(DG_LAST_STATE_KEY);
    const obj = raw ? JSON.parse(raw) : null;
    return (obj && typeof obj === 'object') ? obj : null;
  }catch(e){ return null; }
}

function dgWriteLastState(partial){
  try{
    const prev = dgReadLastState() || {};
    const next = Object.assign({}, prev, partial || {}, { ts: Date.now() });
    // keep it small / safe
    localStorage.setItem(DG_LAST_STATE_KEY, JSON.stringify(next));
  }catch(e){}
}

function dgPersistLastStateFromMeta(meta){
  try{
    if (!meta || !meta.chain) return;
    const chain = String(meta.chain || '').toLowerCase();
    const pairId = meta.pool ? String(meta.pool) : (meta.pairId ? String(meta.pairId) : '');
    const token = meta.token ? String(meta.token) : (meta.tokenAddress ? String(meta.tokenAddress) : '');
    const baseSymbol = meta.baseSymbol ? String(meta.baseSymbol) : '';
    const baseName = meta.baseName ? String(meta.baseName) : '';
    const quoteSymbol = meta.quoteSymbol ? String(meta.quoteSymbol) : '';
    const logoUrl = meta.logoUrl ? String(meta.logoUrl) : '';
    const idKey = chain + '|' + (pairId || token || '');
    if (!idKey.endsWith('|')){} else { return; }

    dgWriteLastState({
      view: 'token',
      chain,
      pairId: pairId || null,
      tokenAddress: token || null,
      tf: (state && state.tf) ? String(state.tf) : '15m',
      scrollY: (typeof window!=='undefined' && window.scrollY!=null) ? Number(window.scrollY)||0 : 0,
      baseSymbol,
      baseName,
      quoteSymbol,
      logoUrl
    });
      try{ dgWriteHashState({chain, pool: pairId || null, token: token || null}); }catch(e){}
  }catch(e){}
}

function dgPersistLastStateTf(tf){
  try{
    if (!tf) return;
    const tfs = String(tf);
    if (state && state.current){
      dgPersistLastStateFromMeta(state.current);
    } else {
      dgWriteLastState({ tf: tfs });
    }
  }catch(e){}
}

function dgApplyTfUi(tf){
  try{
    const t = String(tf || '');
    if (!t) return;
    state.tf = t;
    if (el && el.tfs && Array.isArray(el.tfs)){
      el.tfs.forEach(b => { try{ b.classList.toggle('active', b.dataset.tf === t); }catch(e){} });
    }
  }catch(e){}
}

// DG patch: keep last state fresh + restore-friendly
(function(){
  try{
    const __dgOrigApply = dgApplyTfUi;
    dgApplyTfUi = function(tf){
      const r = __dgOrigApply(tf);
      try{ dgPersistLastStateTf(tf); }catch(e){}
      return r;
    };
  }catch(e){}

  try{
    if (typeof openPool === 'function'){
      const __dgOrigOpenPool = openPool;
      openPool = async function(payload){
        const res = await __dgOrigOpenPool(payload);
        try{ if (state && state.current) dgPersistLastStateFromMeta(state.current); }catch(e){}
        return res;
      };
    }
  }catch(e){}

  try{
    if (typeof setChain === 'function'){
      const __dgOrigSetChain = setChain;
      setChain = function(chain){
        const r = __dgOrigSetChain(chain);
        try{ if (state && state.current) dgPersistLastStateFromMeta(state.current); }catch(e){}
        return r;
      };
    }
  }catch(e){}

  // Also persist scroll position (throttled)
  try{
    let __dgScrollT = 0;
    window.addEventListener('scroll', () => {
      const now = Date.now();
      if (now - __dgScrollT < 250) return;
      __dgScrollT = now;
      try{ dgWriteLastState({ scrollY: Number(window.scrollY)||0 }); }catch(e){}
    }, { passive:true });
  }catch(e){}
})();

async function dgRestoreLastState(){
  const hstate = dgReadHashState();
  const base = dgReadLastState() || {};
  const saved = hstate ? Object.assign({}, base, hstate) : base;
  if (!saved || !saved.chain) return;

  const chain = String(saved.chain || '').toLowerCase();
  const pairId = saved.pairId ? String(saved.pairId) : '';
  const tokenAddress = saved.tokenAddress ? String(saved.tokenAddress) : '';
  const tf = saved.tf ? String(saved.tf) : '';

  // Validate chain known
  if (!CHAINS || !CHAINS[chain]) return;

  // If no identifier, nothing to restore
  if (!pairId && !tokenAddress) return;

  // Restore previously used TF if available (fallback: 15m)
  dgApplyTfUi(tf || '15m');

  // Suppress any user-visible errors/toasts during restore attempt
  __DG_SUPPRESS_TOAST = true;
  try{
    // ensure chain tab matches
    try{ setChain(chain); }catch(e){ state.chain = chain; }

    if (pairId){
      await openPool({ chain, pairId, hint:'restore' });
    } else {
      await openPool({ chain, tokenAddress, hint:'restore' });
    }

    // Restore scroll position (best effort)
    try{
      const y = (saved && saved.scrollY!=null) ? (Number(saved.scrollY)||0) : 0;
      if (y > 0){ setTimeout(() => { try{ window.scrollTo(0, y); }catch(e){} }, 80); }
    }catch(e){}

  }catch(e){
    // silent fallback (no UI error); keep last-state for next try
    try{ showTokenView(false); }catch(_){}
    try{ clearResults(); }catch(_){}
  }finally{
    __DG_SUPPRESS_TOAST = false;
  }
}

function dgRecentsToCmdItems(){
  const list = dgReadRecents().slice(0, 12);
  const out = [];
  for (const r of list){
    if (!r) continue;
    const chain = String(r.chain || '').toLowerCase();
    const pairId = r.pairId || '';
    const tokenAddress = r.tokenAddress || '';
    if (!chain || (!pairId && !tokenAddress)) continue;
    out.push({
      logoUrl: r.logoUrl || '',
      baseName: r.baseName || '—',
      baseSymbol: r.baseSymbol || '—',
      tokenAddress: tokenAddress || '',
      chainBadge: (CHAINS[chain]?.label || chain).toUpperCase(),
      dexId: r.dexId || '',
      priceUsd: (r.priceUsd!=null && isFinite(r.priceUsd)) ? r.priceUsd : null,
      change24h: (r.change24h!=null && isFinite(r.change24h)) ? r.change24h : null,
      _openPayload: {
        chain,
        pairId: pairId || null,
        tokenAddress: tokenAddress || null,
        baseSymbol: r.baseSymbol || '',
        baseName: r.baseName || '',
        quoteSymbol: r.quoteSymbol || '',
        logoUrl: r.logoUrl || '',
        priceUsd: (r.priceUsd!=null && isFinite(r.priceUsd)) ? r.priceUsd : null,
        change24h: (r.change24h!=null && isFinite(r.change24h)) ? r.change24h : null,
        hint: 'recent'
      }
    });
  }
  return out;
}
function cmdSetHeader(mode){
  cmdEnsure();
  const head = document.getElementById('cmdHead');
  const title = document.getElementById('cmdHeadTitle');
  const clearBtn = document.getElementById('cmdClearRecents');
  if (!head) return;

  if (mode === 'recents'){
    head.style.display = 'flex';
    if (title) title.textContent = 'Recent';
    if (clearBtn) clearBtn.style.display = '';
    return;
  }

  if (mode === 'defaults'){
    head.style.display = 'flex';
    if (title) title.textContent = 'Trending';
    if (clearBtn) clearBtn.style.display = 'none';
    return;
  }

  // results / anything else
  head.style.display = 'none';
  if (clearBtn) clearBtn.style.display = 'none';
}
function cmdShowRecents(){
  cmdEnsure();
  cmd.mode = 'recents';
  cmdSetHeader('recents');
  const items = dgRecentsToCmdItems();
  if (!items.length){
    cmdHide();
    return;
  }
  cmdSetItems(items);
  cmdSetHeader('recents');

/* ===== PATCH: Command Search Defaults (Trending) — keep UI fast, no extra panels ===== */
async function dgCmdLoadDefaults(opts){
  try{
    const o = opts || {};
    const force = !!o.force;

    const chain = (state && state.chain) ? String(state.chain) : 'solana';
    const cache = state.__cmdDefaults || (state.__cmdDefaults = {});
    const now = Date.now();
    const hit = cache[chain];

    if (!force && hit && Array.isArray(hit.pairs) && hit.pairs.length && (now - (hit.ts||0) < 60_000)){
      return hit.pairs;
    }

    // Separate abort from main search/candles; do not interfere with user actions.
    if (state.__cmdDefaultsAbort) state.__cmdDefaultsAbort.abort();
    state.__cmdDefaultsAbort = new AbortController();
    const signal = state.__cmdDefaultsAbort.signal;

    const chainId = CHAINS[chain].ds;

    // Pull "boosted / trending" tokens from DexScreener. Keep it tiny (<=8).
    let data = null;
    try{ data = await withBackoff(() => fetchJson(dsBoostTopUrl(), {ttl: 20_000, signal}), {tries:2, signal}); }catch(e){}
    let items = normalizeBoosts(data, chain);
    if (!items.length){
      try{
        const fb = await withBackoff(() => fetchJson(dsBoostLatestUrl(), {ttl: 20_000, signal}), {tries:2, signal});
        items = normalizeBoosts(fb, chain);
      }catch(e){}
    }
    items = (items || []).slice(0, 8);

    const queue = items.slice();
    const pairs = [];

    const worker = async ()=>{
      while (queue.length){
        const it = queue.shift();
        const token = it && it.tokenAddress ? String(it.tokenAddress) : '';
        if (!token) continue;
        try{
          const tps = await withBackoff(() => fetchJson(dsTokenPairsUrl(chainId, token), {ttl: 20_000, signal}), {tries:2, signal});
          const best = pickBestPair(Array.isArray(tps) ? tps : (tps?.pairs || []));
          const pairId = best?.pairAddress || best?.pairId || best?.pair || null;
          if (!pairId) continue;

          const pd = await withBackoff(() => fetchJson(dsPairsUrl(chainId, pairId), {ttl: 20_000, signal}), {tries:2, signal});
          const p = pd?.pairs?.[0] || null;
          if (p) pairs.push(p);
        }catch(e){
          // quiet
        }
      }
    };

    await Promise.all([worker(), worker()]);

    cache[chain] = {ts: Date.now(), pairs};
    return pairs;
  }catch(e){
    return [];
  }
}

function cmdShowDefaults(){
  cmdEnsure();
  cmd.mode = 'defaults';
  cmdSetHeader('defaults');

  const chain = (state && state.chain) ? String(state.chain) : 'solana';
  const cache = state.__cmdDefaults || {};
  const hit = cache[chain];

  // Fast path: cached
  if (hit && Array.isArray(hit.pairs) && hit.pairs.length){
    try{
      cmdSetItems(pairsToCmdItems(hit.pairs));
      cmdSetHeader('defaults');
      cmdShow();
    }catch(e){}
    return;
  }

  // Loading skeleton while we fetch
  try{ cmdSetLoading(true); }catch(e){}
  try{ cmdSetHeader('defaults'); }catch(e){}

  dgCmdLoadDefaults({force:false}).then((pairs)=>{
    try{
      if (!pairs || !pairs.length){ cmdHide(); return; }
      cmd.mode = 'defaults';
      cmdSetItems(pairsToCmdItems(pairs));
      cmdSetHeader('defaults');
      cmdShow();
    }catch(e){}
  });
}

function cmdShowEmptyList(){
  try{
    const rec = dgRecentsToCmdItems();
    if (rec && rec.length){
      cmdShowRecents();
      return;
    }
  }catch(e){}
  cmdShowDefaults();
}
/* ===== /PATCH ===== */
}

    (function(){ try{ const grid = document.querySelector('.grid'); if (grid) grid.setAttribute('data-cmd','1'); }catch(e){} })();

function cmdEnsure(){
  if (cmd._inited) return;
  cmd._inited = true;
  try{
    const grid = document.querySelector('.grid');
    if (grid) grid.setAttribute('data-cmd','1');
  }catch(e){}
  try{
    cmd.wrap = document.getElementById('cmdDropdown');
    cmd.list = document.getElementById('cmdList');
  }catch(e){}
}

function cmdShow(){
  cmdEnsure();
  if (!cmd.wrap) return;
  cmd.wrap.classList.add('show');
  cmd.open = true;
  try{ dgSheetSync(true); }catch(e){}
  try{ dgCmdOpenSync(true); }catch(e){}
}
function cmdHide(){
  cmdEnsure();
  if (!cmd.wrap) return;
  cmd.wrap.classList.remove('show');
  cmd.open = false;
  cmd.active = -1;
  cmd.loading = false;
  try{ dgSheetSync(false); }catch(e){}
  try{ dgCmdOpenSync(false); }catch(e){}
}

/* ========= STEP8: Mobile App Feel helpers (PATCH ONLY) ========= */
function dgIsMobile(){
  try{ return (window.matchMedia && window.matchMedia('(max-width: 720px)').matches) || (window.innerWidth <= 720); }catch(_){ return window.innerWidth <= 720; }
}
function dgSheetSync(isOpen){
  try{
    // No scrims/overlays; just a lightweight body flag for mobile bottom-sheet behaviors
    if (!dgIsMobile()) return;
    document.documentElement.classList.toggle('dgSheetOpen', !!isOpen);
  }catch(e){}
}
function dgMobileScrollTo(which){
  try{
    const tb = document.getElementById('tokenBlock');
    if (!tb || tb.style.display === 'none') return;
    let target = null;
    if (which === 'info'){
      target = tb.querySelector('.tokenHeader') || tb;
    } else if (which === 'chart'){
      target = tb.querySelector('.chartPanel') || document.getElementById('chart');
    } else if (which === 'trades'){
      // Prefer explicit panel label; fall back to first tableWrap within tokenBlock
      target = tb.querySelector('section[aria-label="Live trades"]') || tb.querySelector('.tableWrap') || tb;
    }
    if (target && target.scrollIntoView){
      target.scrollIntoView({behavior:'smooth', block:'start'});
    }
  }catch(e){ console.warn('[DexGuard] mobile nav scroll', e); }
}
function dgSyncMobileUI(){
  try{
    const nav = document.getElementById('mNav');
    if (!nav) return;
    const tb = document.getElementById('tokenBlock');
    const show = !!(tb && tb.style.display !== 'none' && dgIsMobile());
    nav.style.display = show ? 'flex' : 'none';
  }catch(e){}
}
function dgMobileInit(){
  if (dgMobileInit._inited) return;
  dgMobileInit._inited = true;
  try{
    const nav = document.getElementById('mNav');
    if (nav){
      const btns = nav.querySelectorAll('button[data-nav]');
      btns.forEach((b)=>{
        bindOnce(b, 'click', ()=> dgMobileScrollTo(String(b.dataset.nav||'')), {passive:true}, 'mnav:' + (b.dataset.nav||''));
      });
      // Update visibility on resize/orientation changes
      bindOnce(window, 'resize', ()=> { try{ dgSyncMobileUI(); }catch(_e){} }, {passive:true}, 'mnav:resize');
    }
    // If command sheet is open and user scrolls, keep it non-intrusive
    bindOnce(document, 'scroll', ()=>{ /* intentionally empty (no overlays) */ }, {passive:true}, 'mnav:scroll');
    dgSyncMobileUI();
  }catch(e){ console.warn('[DexGuard] mobile init', e); }
}
/* ========= /STEP8 ========= */

function cmdSetLoading(on){
  cmdEnsure();
  cmd.loading = !!on;
  if (!cmd.list) return;
  if (!on){ return; }
  cmdShow();
  cmd.list.innerHTML = '';
  for (let i=0;i<6;i++){
    const row = document.createElement('div');
    row.className = 'cmdRow skel';
    row.innerHTML = `
      <div class="cmdLogo"></div>
      <div class="cmdMain">
        <div class="bar lg"></div>
        <div style="margin-top:6px" class="bar md"></div>
      </div>
      <div class="cmdMeta">
        <div class="bar sm"></div>
      </div>
    `;
    cmd.list.appendChild(row);
  }
}


/* ===== PATCH: iOS Safari keyboard-safe viewport + cmd dropdown positioning (STEP10) ===== */
function dgUpdateVvh(){
  try{
    const vv = window.visualViewport;
    const h = vv && vv.height ? vv.height : window.innerHeight;
    document.documentElement.style.setProperty('--dgVvh', Math.round(h) + 'px');
  }catch(e){}
}

function dgCmdReposition(){
  try{
    if (!cmd || !cmd.open || !cmd.wrap) return;
    const input = document.getElementById('q');
    if (!input) return;

    dgUpdateVvh();

    const vv = window.visualViewport;
    // NOTE: Safari desktop may report visualViewport.offsetTop as scrollY; only use it on mobile (keyboard-safe).
    const rawVTop = (vv && typeof vv.offsetTop === 'number') ? vv.offsetTop : 0;
    const vTop = (typeof dgIsMobile === 'function' && dgIsMobile()) ? rawVTop : 0;
    const vH   = (vv && vv.height) ? vv.height : window.innerHeight;

    const r = input.getBoundingClientRect();
    const gap = 10;

    // Always open DOWNWARD: pin the dropdown's top to input bottom + gap.
    const top = Math.max(8, Math.round(r.bottom + gap + vTop));

    // Width matches the input on desktop; on mobile the sheet CSS takes over.
    const left = Math.max(10, Math.round(r.left));
    const width = Math.max(240, Math.round(Math.min(r.width, window.innerWidth - left - 10)));

    // Available space below input; list scrolls inside panel if short.
    const availBelow = Math.max(140, Math.round((vTop + vH) - (r.bottom + gap) - 18));
    // Panel chrome rough allowance (header/handle/footer). Keep list max in a sane range.
    const listMax = Math.max(180, Math.min(560, availBelow - 86));

    document.documentElement.style.setProperty('--dgCmdLeft', left + 'px');
    document.documentElement.style.setProperty('--dgCmdTop', top + 'px');
    document.documentElement.style.setProperty('--dgCmdWidth', width + 'px');
    document.documentElement.style.setProperty('--dgCmdListMax', listMax + 'px');

    // Fix-position dropdown under the input (desktop + mobile) via STEP10 CSS vars.
    try{
      cmd.wrap.classList.add('dgFixed');
    }catch(e){} 
  }catch(e){}
}

function dgCmdOpenSync(isOpen){
  try{
    dgUpdateVvh();
    if (!cmd || !cmd.wrap) return;
    if (!isOpen){
      cmd.wrap.classList.remove('dgFixed');
      return;
    }
    // On open: position immediately and again on next frame (Safari reflow/keyboard)
    dgCmdReposition();
    requestAnimationFrame(dgCmdReposition);
    setTimeout(dgCmdReposition, 80);
  }catch(e){}
}

// Keep vars fresh for iOS keyboard + orientation changes
try{
  dgUpdateVvh();
  window.addEventListener('resize', function(){ dgUpdateVvh(); dgCmdReposition(); }, {passive:true});
  window.addEventListener('scroll', function(){ dgCmdReposition(); }, {passive:true});
  if (window.visualViewport){
    window.visualViewport.addEventListener('resize', function(){ dgUpdateVvh(); dgCmdReposition(); }, {passive:true});
    window.visualViewport.addEventListener('scroll', function(){ dgCmdReposition(); }, {passive:true});
  }
}catch(e){}
/* ===== /PATCH ===== */

function cmdSetItems(items){
  cmdEnsure();
  try{ cmdSetHeader(cmd.mode === 'recents' ? 'recents' : (cmd.mode === 'defaults' ? 'defaults' : 'results')); }catch(e){}
  cmd.items = Array.isArray(items) ? items : [];
  if (!cmd.list) return;
  cmd.list.innerHTML = '';
  if (!cmd.items.length){
    cmdHide();
    return;
  }
  cmdShow();
  cmd.active = 0;

  const frag = document.createDocumentFragment();
  for (let i=0;i<cmd.items.length;i++){
    const it = cmd.items[i];
    const row = document.createElement('div');
    row.className = 'cmdRow';
    row.setAttribute('role','option');
    row.setAttribute('aria-selected', i===0 ? 'true' : 'false');
    row.dataset.idx = String(i);

    const logoUrl = it.logoUrl || '';
    const chg = it.change24h;
    const chgCls = (isFinite(chg) && chg !== 0) ? (chg > 0 ? 'good' : 'bad') : '';
    const chgTxt = isFinite(chg) ? ((chg>0?'+':'') + fmtNum(chg,2) + '%') : '—';
    const priceTxt = (it.priceUsd!=null && isFinite(it.priceUsd)) ? fmtUSD(it.priceUsd) : '—';
    const chainLbl = (it.chainBadge || '').toUpperCase().slice(0,8) || (CHAINS[state.chain]?.label || '—');

    row.innerHTML = `
      <div class="cmdLogo">${logoUrl ? `<img src="${escapeHtml(logoUrl)}" alt="">` : `<span class="muted mono">DG</span>`}</div>
      <div class="cmdMain">
        <div class="cmdTop">
          <div class="cmdName ellipsis">${escapeHtml(it.baseName || it.baseSymbol || '—')}</div>
          <div class="cmdSym">(${escapeHtml((it.baseSymbol||'').slice(0,16) || '—')})</div>
        </div>
        <div class="cmdSub">
          <span class="addr ellipsis">${escapeHtml(shortAddr(it.tokenAddress || ''))}</span>
          <span class="sep">•</span>
          <span class="muted ellipsis">${escapeHtml(it.dexId || '')}</span>
          <span class="sep">•</span>
          <span class="muted">24h</span> <span class="chg ${chgCls}">${chgTxt}</span>
        </div>
      </div>
      <div class="cmdMeta">
        <span class="cmdBadge">${escapeHtml(chainLbl)}</span>
        <div>
          <div class="px">${priceTxt}</div>
        </div>
      </div>
    `;

    row.addEventListener('mouseenter', ()=> cmdSetActive(i));
    row.addEventListener('mousedown', (e)=>{ e.preventDefault(); }); // keep focus
    row.addEventListener('click', ()=> cmdOpen(i));
    frag.appendChild(row);
  }
  cmd.list.appendChild(frag);
  cmdSyncActive();
}

function cmdSetActive(i){
  cmdEnsure();
  const n = cmd.items.length;
  if (!n) return;
  const idx = ((i % n) + n) % n;
  cmd.active = idx;
  cmdSyncActive(true);
}

function cmdSyncActive(scrollIntoView=false){
  if (!cmd.list) return;
  const rows = cmd.list.querySelectorAll('.cmdRow[role="option"]');
  rows.forEach((r, j)=>{
    const on = j === cmd.active;
    r.classList.toggle('active', on);
    r.setAttribute('aria-selected', on ? 'true' : 'false');
  });
  if (scrollIntoView){
    const activeRow = rows[cmd.active];
    if (activeRow && activeRow.scrollIntoView){
      try{ activeRow.scrollIntoView({block:'nearest'}); }catch(e){}
    }
  }
}

function cmdOpen(i){
  cmdEnsure();
  const it = cmd.items[i];
  if (!it) return;
  cmdHide();
  try{ openPool(it._openPayload); }catch(e){ console.warn('[DexGuard] cmd open failed', e); }
}

function pairsToCmdItems(pairs){
  const out = [];
  if (!pairs || !pairs.length) return out;

  const chainId = CHAINS[state.chain].ds;
  const filtered = pairs.filter(p => (p?.chainId || '').toLowerCase() === chainId);
  const list = filtered.length ? filtered : pairs.slice(0, 18);

  const max = Math.min(8, list.length);
  for (let i=0;i<max;i++){
    const p = list[i];
    const logo = p?.info?.imageUrl || p?.baseToken?.logoURI || p?.baseToken?.icon || '';
    const name = p?.baseToken?.name || '—';
    const sym = p?.baseToken?.symbol || '—';
    const pair = p?.pairAddress || p?.pairId || p?.pair || '';
    const token = p?.baseToken?.address || '';
    const dexId = p?.dexId || '';
    const priceUsd = toNum(p?.priceUsd);
    const chg24 = toNum(p?.priceChange?.h24);
    const chg5m = toNum(p?.priceChange?.m5);
    const chg1h = toNum(p?.priceChange?.h1);
    const chg6h = toNum(p?.priceChange?.h6);
    const liquidityUsd = toNum(p?.liquidity?.usd ?? p?.liquidityUsd);
    const volume5mUsd = toNum(p?.volume?.m5);
    const volume1hUsd = toNum(p?.volume?.h1);
    const volume6hUsd = toNum(p?.volume?.h6);
    const volume24hUsd = toNum(p?.volume?.h24 ?? p?.volume24hUsd);
    const marketCapUsd = toNum(p?.fdv ?? p?.marketCap ?? p?.marketCapUsd);
    const itemChain = (p?.chainId || '').toLowerCase();

    // If result is other chain, switch chain then open.
    const targetChain = Object.keys(CHAINS).find(k => CHAINS[k].ds === itemChain) || state.chain;

    const openPayload = {
      chain: targetChain,
      pairId: pair,
      tokenAddress: token,
      baseSymbol: sym,
      baseName: name,
      quoteSymbol: p?.quoteToken?.symbol || null,
      logoUrl: logo,
      priceUsd,
      change5m: chg5m,
      change1h: chg1h,
      change6h: chg6h,
      change24h: chg24,
      liquidityUsd,
      volume5mUsd,
      volume1hUsd,
      volume6hUsd,
      volume24hUsd,
      marketCapUsd,
      hint: 'search'
    };

    // Keep existing open behavior: remember meta, switch chain if needed, then open.
    const _openPayload = Object.assign({}, openPayload);
    const openWrapper = async () => {
      rememberMeta({
        chain: targetChain,
        pool: pair,
        token,
        baseSymbol: sym,
        baseName: name,
        quoteSymbol: p?.quoteToken?.symbol || null,
        logoUrl: logo,
        priceUsd,
        change5m: chg5m,
        change1h: chg1h,
        change6h: chg6h,
        change24h: chg24,
        liquidityUsd,
        volume5mUsd,
        volume1hUsd,
        volume6hUsd,
        volume24hUsd,
        marketCapUsd,
        dexId,
      });
      if (targetChain !== state.chain){
        setChain(targetChain, {silent:true});
      }
      openPool(_openPayload);
    };

    // openPool expects payload directly in this app; preserve by embedding in _openPayload and calling openPool.
    out.push({
      chainBadge: itemChain || CHAINS[targetChain]?.label || '',
      tokenAddress: token,
      baseSymbol: sym,
      baseName: name,
      logoUrl: logo,
      dexId: dexId,
      priceUsd: isFinite(priceUsd) ? priceUsd : null,
      change24h: isFinite(chg24) ? chg24 : null,
      _openPayload: _openPayload,
    });

    // Patch: pre-switch chain inside openPool call by wrapping openPool at call site.
    // We cannot pass a function through; instead handle chain switch here during cmdOpen via a safe override:
    out[out.length-1]._openPayload = Object.assign({}, _openPayload, { __targetChain: targetChain, __pair: pair, __token: token, __sym: sym, __name: name, __logo: logo, __dexId: dexId, __meta: {
      chain: targetChain, pool: pair, token, baseSymbol: sym, baseName: name, quoteSymbol: p?.quoteToken?.symbol || null,
      logoUrl: logo, priceUsd, change5m: chg5m, change1h: chg1h, change6h: chg6h, change24h: chg24,
      liquidityUsd, volume5mUsd, volume1hUsd, volume6hUsd, volume24hUsd, marketCapUsd, dexId
    }});
  }
  return out;
}

// Override cmdOpen to preserve chain switching + rememberMeta exactly like existing search results.
const _cmdOpenOrig = cmdOpen;
cmdOpen = function(i){
  cmdEnsure();
  const it = cmd.items[i];
  if (!it) return;
  cmdHide();
  try{
    const pay = it._openPayload || null;
    const targetChain = pay?.__targetChain || state.chain;
    if (pay?.__meta) rememberMeta(pay.__meta);
    if (targetChain !== state.chain){
      setChain(targetChain, {silent:true});
    }
    const payload = Object.assign({}, pay);
    delete payload.__targetChain; delete payload.__pair; delete payload.__token; delete payload.__sym;
    delete payload.__name; delete payload.__logo; delete payload.__dexId; delete payload.__meta;
    openPool(payload);
  }catch(e){
    console.warn('[DexGuard] cmd open failed', e);
  }
};

function cmdHandleKeys(e){
  cmdEnsure();
  const key = String(e.key || '');
  if (key === 'Escape'){
    if (cmd.open){ e.preventDefault(); cmdHide(); }
    return;
  }
  if (key === 'ArrowDown' || key === 'ArrowUp'){
    if (!cmd.open && cmd.items.length){ cmdShow(); }
    if (!cmd.items.length) return;
    e.preventDefault();
    cmdSetActive(cmd.active + (key === 'ArrowDown' ? 1 : -1));
    return;
  }
  if (key === 'Enter'){
    if (cmd.open && cmd.items.length && cmd.active >= 0){
      e.preventDefault();
      cmdOpen(cmd.active);
      return;
    }
  }
}

function cmdGlobalOutsideClose(){
  cmdEnsure();
  // close on outside click
  bindOnce(document, 'pointerdown', (e)=>{
    try{
      if (!cmd.open) return;
      const sw = document.querySelector('.searchWrap.cmdSearch');
      if (sw && sw.contains(e.target)) return;
      cmdHide();
    }catch(err){}
  }, {capture:true}, 'cmd:outside');
}

    function renderTrending(items){
      el.trending.innerHTML = '';
      if (!items || !items.length){
        el.trendingEmpty.style.display = '';
        return;
      }
      el.trendingEmpty.style.display = 'none';
      for (const it of items){
        const card = document.createElement('div');
        card.className = 'tokenCard';
        card.tabIndex = 0;

        const logoUrl = it.logoUrl || '';
        const chg = it.change24h;
        const chgChip = isFinite(chg) ? (chg>=0 ? `<span class="chip good">+${fmtNum(chg,2)}%</span>` : `<span class="chip bad">${fmtNum(chg,2)}%</span>`) : `<span class="chip">—</span>`;

        card.innerHTML = `
          <div class="tokenCardTop">
            <div class="tLogo">${logoUrl ? `<img src="${escapeHtml(logoUrl)}" alt="">` : `<span class="muted mono">DG</span>`}</div>
            <div class="tText">
              <div class="tName">${escapeHtml(it.baseName || it.baseSymbol || '—')}</div>
              <div class="tMeta">
                <span class="chip">${escapeHtml((it.baseSymbol||'').slice(0,10) || '—')}</span>
                ${chgChip}
                <span class="muted ellipsis">${escapeHtml(it.dexId || '')}</span>
              </div>
            </div>
          </div>
          <div class="metricRow">
            <div class="metric"><div class="k">Price</div><div class="v">${it.priceUsd!=null ? fmtUSD(it.priceUsd) : '—'}</div></div>
            <div class="metric"><div class="k">24h Vol</div><div class="v">${it.volume24hUsd!=null ? fmtUSD(it.volume24hUsd) : '—'}</div></div>
          </div>
        `;

        const open = () => {
          // Reset search UI immediately after selecting a token
          try{ el.q.value = ''; }catch(e){}
          try{ clearResults(); }catch(e){}
          try{ cmdHide(); }catch(e){}
          try{ el.q.blur && el.q.blur(); }catch(e){}
          rememberMeta({
            chain: state.chain,
            pool: it.pairId,
            token: it.tokenAddress,
            baseSymbol: it.baseSymbol,
            baseName: it.baseName,
            quoteSymbol: it.quoteSymbol,
            logoUrl: it.logoUrl,
            priceUsd: it.priceUsd,
            change24h: it.change24h,
            volume24hUsd: it.volume24hUsd,
            liquidityUsd: it.liquidityUsd,
            marketCapUsd: it.marketCapUsd,
            dexId: it.dexId,
          });
          openPool({
            chain: state.chain,
            pairId: it.pairId,
            tokenAddress: it.tokenAddress,
            baseSymbol: it.baseSymbol,
            baseName: it.baseName,
            logoUrl: it.logoUrl,
            priceUsd: it.priceUsd,
            change24h: it.change24h,
            volume24hUsd: it.volume24hUsd,
            liquidityUsd: it.liquidityUsd,
            marketCapUsd: it.marketCapUsd,
            hint: 'trending'
          });
        };
        card.addEventListener('click', open);
        card.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' ') { e.preventDefault(); open(); }});
        el.trending.appendChild(card);
      }
    }

    function renderResults(pairs){

      // Route results to the right UI:
      // - Normal click / typing -> render into the Search Results panel
      // - Ctrl+K / ⌘K "command" intent -> render into the command dropdown only
      const canCmd = !!(document.getElementById('cmdDropdown') && document.getElementById('cmdList'));
      const useCmd = !!(canCmd && state && state.searchUI === 'cmd');

      if (useCmd){
        try{
          cmdEnsure();
          cmd.mode = 'results';
          cmdSetHeader('results');
          cmdSetItems(pairsToCmdItems(pairs||[]));
          cmdShow();
        }catch(e){}
        // Keep legacy panel in DOM for compatibility, but do not render to it in cmd mode.
        try{ el.results.classList.remove('show'); el.results.innerHTML=''; el.resultsEmpty.style.display=''; }catch(e){}
        return;
      }else{
        // Ensure cmd dropdown is not lingering on normal searches
        try{ cmdHide(); }catch(e){}
      }

      el.results.innerHTML = '';
      el.results.classList.add('show');
      el.resultsEmpty.style.display = 'none';

      if (!pairs || !pairs.length){
        el.results.innerHTML = `<div class="empty"><div>🛡️</div><div><b>No results.</b> Try symbol, name or a contract address.</div></div>`;
        return;
      }

      const chainId = CHAINS[state.chain].ds;
      const filtered = pairs.filter(p => (p?.chainId || '').toLowerCase() === chainId);

      const list = filtered.length ? filtered : pairs.slice(0, 18);
      const max = Math.min(18, list.length);

      for (let i=0;i<max;i++){
        const p = list[i];
        const logo = p?.info?.imageUrl || p?.baseToken?.logoURI || p?.baseToken?.icon || '';
        const name = p?.baseToken?.name || '—';
        const sym = p?.baseToken?.symbol || '—';
        const pair = p?.pairAddress || p?.pairId || p?.pair || '';
        const token = p?.baseToken?.address || '';
        const dexId = p?.dexId || '';
        const priceUsd = toNum(p?.priceUsd);
        const chg24 = toNum(p?.priceChange?.h24);
        const chg5m = toNum(p?.priceChange?.m5);
        const chg1h = toNum(p?.priceChange?.h1);
        const chg6h = toNum(p?.priceChange?.h6);
        const liquidityUsd = toNum(p?.liquidity?.usd ?? p?.liquidityUsd);
        const volume24hUsd = toNum(p?.volume?.h24 ?? p?.volume24hUsd);
        const volume5mUsd = toNum(p?.volume?.m5);
        const volume1hUsd = toNum(p?.volume?.h1);
        const volume6hUsd = toNum(p?.volume?.h6);
        const marketCapUsd = toNum(p?.fdv ?? p?.marketCap ?? p?.marketCapUsd);
        const itemChain = (p?.chainId || '').toLowerCase();

        const item = document.createElement('div');
        item.className = 'resultItem';
        item.tabIndex = 0;

        item.innerHTML = `
          <div class="tLogo">${logo ? `<img src="${escapeHtml(logo)}" alt="">` : `<span class="muted mono">DG</span>`}</div>
          <div class="rMain">
            <div class="rTop">
              <div class="rName ellipsis">${escapeHtml(name)} <span class="muted">(${escapeHtml(sym)})</span></div>
              <span class="chip">${escapeHtml((itemChain||'').toUpperCase().slice(0,4) || CHAINS[state.chain].label)}</span>
            </div>
            <div class="rSub">${escapeHtml(shortAddr(token))}<span class="sep">•</span>${escapeHtml(dexId)}<span class="sep">•</span>Price ${fmtUSD(priceUsd)}<span class="sep">•</span>24h ${chg24!=null ? fmtNum(chg24,2) : '—'}%</div>
          </div>
          <div class="rActions"><button class="btn dgChartBtn" style="padding:8px 12px" aria-label="Chart">CHART</button><button class="btn dgScanBtn" style="padding:8px 12px" aria-label="Scan">SCAN</button></div>
        `;

        const open = () => {
          // Reset search UI immediately after selecting a token
          try{ el.q.value = ''; }catch(e){}
          try{ clearResults(); }catch(e){}
          try{ cmdHide(); }catch(e){}
          try{ el.q.blur && el.q.blur(); }catch(e){}
          // If result is other chain, switch chain then open.
          const targetChain = Object.keys(CHAINS).find(k => CHAINS[k].ds === itemChain) || state.chain;
          rememberMeta({
            chain: targetChain,
            pool: pair,
            token,
            baseSymbol: sym,
            baseName: name,
            quoteSymbol: p?.quoteToken?.symbol || null,
            logoUrl: logo,
            priceUsd,
            change5m: chg5m,
            change1h: chg1h,
            change6h: chg6h,
            change24h: chg24,
            liquidityUsd,
            volume5mUsd,
            volume1hUsd,
            volume6hUsd,
            volume24hUsd,
            marketCapUsd,
            dexId,
          });
          if (targetChain !== state.chain){
            setChain(targetChain, {silent:true});
          }
          openPool({
            chain: targetChain,
            pairId: pair,
            tokenAddress: token,
            baseSymbol: sym,
            baseName: name,
            quoteSymbol: p?.quoteToken?.symbol || null,
            logoUrl: logo,
            priceUsd,
            change5m: chg5m,
            change1h: chg1h,
            change6h: chg6h,
            change24h: chg24,
            liquidityUsd,
            volume5mUsd,
            volume1hUsd,
            volume6hUsd,
            volume24hUsd,
            marketCapUsd,
            hint: 'search'
          });
        };

        const chartBtn = item.querySelector('.dgChartBtn');
        const scanBtn = item.querySelector('.dgScanBtn');
        if (chartBtn){
          chartBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); open(); });
        }
        if (scanBtn){
          scanBtn.addEventListener('click', (e)=>{
            e.preventDefault(); e.stopPropagation();
            const targetChain = Object.keys(CHAINS).find(k => CHAINS[k].ds === itemChain) || state.chain;
            dgGoScan({ chain: targetChain, address: token, pool: pair });
          });
        }
        item.addEventListener('click', open);
        item.addEventListener('keydown', (e)=>{ if(e.key==='Enter'){ e.preventDefault(); open(); }});
        el.results.appendChild(item);
      }
    }

    function calcWindowStats(trades){
      const now = nowSec();
      const wins = {m5:300,h1:3600,h6:21600,h24:86400};
      const out = {
        m5:{buy:0,sell:0,total:0,buyN:0,sellN:0,txns:0,buyers:0,sellers:0,makers:0},
        h1:{buy:0,sell:0,total:0,buyN:0,sellN:0,txns:0,buyers:0,sellers:0,makers:0},
        h6:{buy:0,sell:0,total:0,buyN:0,sellN:0,txns:0,buyers:0,sellers:0,makers:0},
        h24:{buy:0,sell:0,total:0,buyN:0,sellN:0,txns:0,buyers:0,sellers:0,makers:0},
      };
      const sets = {
        m5:{buyers:new Set(), sellers:new Set(), makers:new Set()},
        h1:{buyers:new Set(), sellers:new Set(), makers:new Set()},
        h6:{buyers:new Set(), sellers:new Set(), makers:new Set()},
        h24:{buyers:new Set(), sellers:new Set(), makers:new Set()},
      };
      if (!Array.isArray(trades) || !trades.length) return out;
      for (const t of trades){
        const ts = t?.tsSec;
        if (!isFinite(ts)) continue;
        const age = now - ts;
        if (age < 0) continue;
        const usd = toNum(t?.usd);
        if (!isFinite(usd) || usd <= 0) continue;
        const isBuy = (t?.side === 'BUY');
        const w = (t?.wallet || '').toString();

        if (age <= wins.m5){
          out.m5.txns++;
          if (isBuy){ out.m5.buy += usd; out.m5.buyN++; if(w) sets.m5.buyers.add(w); }
          else { out.m5.sell += usd; out.m5.sellN++; if(w) sets.m5.sellers.add(w); }
          if(w) sets.m5.makers.add(w);
        }
        if (age <= wins.h1){
          out.h1.txns++;
          if (isBuy){ out.h1.buy += usd; out.h1.buyN++; if(w) sets.h1.buyers.add(w); }
          else { out.h1.sell += usd; out.h1.sellN++; if(w) sets.h1.sellers.add(w); }
          if(w) sets.h1.makers.add(w);
        }
        if (age <= wins.h6){
          out.h6.txns++;
          if (isBuy){ out.h6.buy += usd; out.h6.buyN++; if(w) sets.h6.buyers.add(w); }
          else { out.h6.sell += usd; out.h6.sellN++; if(w) sets.h6.sellers.add(w); }
          if(w) sets.h6.makers.add(w);
        }
        if (age <= wins.h24){
          out.h24.txns++;
          if (isBuy){ out.h24.buy += usd; out.h24.buyN++; if(w) sets.h24.buyers.add(w); }
          else { out.h24.sell += usd; out.h24.sellN++; if(w) sets.h24.sellers.add(w); }
          if(w) sets.h24.makers.add(w);
        }
      }
      out.m5.total = out.m5.buy + out.m5.sell;
      out.h1.total = out.h1.buy + out.h1.sell;
      out.h6.total = out.h6.buy + out.h6.sell;
      out.h24.total = out.h24.buy + out.h24.sell;

      out.m5.buyers = sets.m5.buyers.size; out.m5.sellers = sets.m5.sellers.size; out.m5.makers = sets.m5.makers.size;
      out.h1.buyers = sets.h1.buyers.size; out.h1.sellers = sets.h1.sellers.size; out.h1.makers = sets.h1.makers.size;
      out.h6.buyers = sets.h6.buyers.size; out.h6.sellers = sets.h6.sellers.size; out.h6.makers = sets.h6.makers.size;
      out.h24.buyers = sets.h24.buyers.size; out.h24.sellers = sets.h24.sellers.size; out.h24.makers = sets.h24.makers.size;

      return out;
    }

    function fmtDeltaSpan(v){
      if (!isFinite(v)) return '—';
      const cls = v >= 0 ? 'good' : 'bad';
      const s = (v>=0?'+':'') + fmtNum(v,2) + '%';
      return `<span class="delta ${cls}">${s}</span>`;
    }

    function fmtBuySell(bs){
      if (!bs) return '';
      const b = isFinite(bs.buy) && bs.buy > 0 ? fmtUSD(bs.buy) : '—';
      const s = isFinite(bs.sell) && bs.sell > 0 ? fmtUSD(bs.sell) : '—';
      return `B ${b} • S ${s}`;
    }

    function setChgVolUI(meta){
      if (!meta) return;

      const ui = state.statsUI || (state.statsUI = {tf:'h24'});

      const d5 = toNum(meta.change5m);
      const d1 = toNum(meta.change1h);
      const d6 = toNum(meta.change6h);
      const d24 = toNum(meta.change24h);

      const v5 = toNum(meta.volume5mUsd);
      const v1 = toNum(meta.volume1hUsd);
      const v6 = toNum(meta.volume6hUsd);
      const v24 = toNum(meta.volume24hUsd);

      const wsAll = state.winStats || null;

      const tf = ui.tf || 'h24';
      const chgMap = {m5:d5, h1:d1, h6:d6, h24:d24};
      const chgVal = chgMap[tf];
      const chgTop = fmtDeltaSpan(chgVal);

      const tabs =
        `<div class="stTabs stTabsTight">` +
          `<button type="button" class="stPill${tf==='m5'?' on':''}" data-sttf="m5">5m</button>` +
          `<button type="button" class="stPill${tf==='h1'?' on':''}" data-sttf="h1">1h</button>` +
          `<button type="button" class="stPill${tf==='h6'?' on':''}" data-sttf="h6">6h</button>` +
          `<button type="button" class="stPill${tf==='h24'?' on':''}" data-sttf="h24">24h</button>` +
        `</div>`;

      el.stChg.innerHTML = `<div class="stMain">${chgTop}</div>${tabs}`;

      const volFromMeta = (t)=>{
        if (t==='m5') return v5;
        if (t==='h1') return v1;
        if (t==='h6') return v6;
        if (t==='h24') return v24;
        return null;
      };

      const w = wsAll ? (wsAll[tf] || null) : null;
      const mt = (meta && meta._txns && meta._txns[tf]) ? meta._txns[tf] : null;

      const volMeta = volFromMeta(tf);
      const volVal = (volMeta!=null && isFinite(volMeta)) ? volMeta : (w?.total ?? null);

      const txns = (mt && isFinite(mt.txns)) ? mt.txns : w?.txns;
      const buys = (mt && isFinite(mt.buys)) ? mt.buys : w?.buyN;
      const sells = (mt && isFinite(mt.sells)) ? mt.sells : w?.sellN;
      const makers = w?.makers;
      const buyers = w?.buyers;
      const sellers = w?.sellers;

      const buyVol = w?.buy;
      const sellVol = w?.sell;

      const g = (k,v)=>`<div class="stMiniItem"><div class="stMiniK">${k}</div><div class="stMiniV">${v}</div></div>`;

      const vv = (volVal!=null && isFinite(volVal)) ? fmtUSD(volVal) : '—';
      const tv = (txns!=null && isFinite(txns)) ? fmtNum(txns,0) : '—';
      const bv = (buys!=null && isFinite(buys)) ? fmtNum(buys,0) : '—';
      const sv = (sells!=null && isFinite(sells)) ? fmtNum(sells,0) : '—';
      const mv = (makers!=null && isFinite(makers)) ? fmtNum(makers,0) : '—';
      const byv = (buyers!=null && isFinite(buyers)) ? fmtNum(buyers,0) : '—';
      const slv = (sellers!=null && isFinite(sellers)) ? fmtNum(sellers,0) : '—';
      const bvv = (buyVol!=null && isFinite(buyVol)) ? fmtUSD(buyVol) : '—';
      const svv = (sellVol!=null && isFinite(sellVol)) ? fmtUSD(sellVol) : '—';

      el.stVol.innerHTML = `<div class="stMain">${vv}</div>`;
    }


    function setTokenUI(meta){
      try{
        if (meta){
          const cachedPool = meta.pool ? state.metaByPool.get(poolKey(meta)) : null;
          const cachedToken = meta.token ? state.metaByToken.get(tokenKey(meta.chain, meta.token)) : null;
          mergeMeta(meta, cachedPool);
          mergeMeta(meta, cachedToken);
        }
      }catch(e){}

      // Rebind UI refs in case the DOM was re-created (prevents stale/null handles).
      try{
        const a = document.getElementById('tokenLogo'); if (a) el.tokenLogo = a;
        const b = document.getElementById('tokenTitle'); if (b) el.tokenTitle = b;
        const c = document.getElementById('tokenSub'); if (c) el.tokenSub = c;
        const d = document.getElementById('stPrice'); if (d) el.stPrice = d;
        const e1 = document.getElementById('stChg'); if (e1) el.stChg = e1;
        const f = document.getElementById('stVol'); if (f) el.stVol = f;
        const g = document.getElementById('stLiq'); if (g) el.stLiq = g;
        const h = document.getElementById('stMcap'); if (h) el.stMcap = h;
        const i = document.getElementById('stPool'); if (i) el.stPool = i;
        const j = document.getElementById('chartMeta'); if (j) el.chartMeta = j;
        const k = document.getElementById('lnkExplorer'); if (k) el.lnkExplorer = k;
        const l = document.getElementById('lnkPair'); if (l) el.lnkPair = l;
        const m1 = document.getElementById('lnkDex'); if (m1) el.lnkDex = m1;
        const n = document.getElementById('btnDS'); if (n) el.btnDS = n;
      }catch(e){}

      const logoUrl = meta.logoUrl || '';
      el.tokenLogo.innerHTML = logoUrl ? `<img src="${escapeHtml(logoUrl)}" alt="">` : `<span class="muted mono">DG</span>`;

      const sym = (meta.baseSymbol || meta.baseName || (meta.token ? shortAddr(meta.token) : '—'));
      const quote = (meta.quoteSymbol || '—');
      const pairText = (quote && quote !== '—') ? `${sym}/${quote}` : sym;
      el.tokenTitle.textContent = `${meta.baseName || sym}  (${pairText})`;
      {
      const __chain = CHAINS[meta.chain]?.label || meta.chain;
      const __ca = meta.token ? String(meta.token) : '—';
      const __pool = meta.pool ? String(meta.pool) : '—';
      const __caShort = (__ca !== '—') ? shortAddr(__ca) : '—';
      const __poolShort = (__pool !== '—') ? shortAddr(__pool) : '—';
      el.tokenSub.innerHTML = `${escapeHtml(__chain)} • Contract: <span class="dgCopy" data-copy="${escapeHtml(__ca)}" title="Copy contract">${escapeHtml(__caShort)}</span> • Pool: ${escapeHtml(__poolShort)}`;
    }

      el.stPrice.textContent = meta.priceUsd!=null ? fmtUSD(meta.priceUsd) : '—';
      setChgVolUI(meta);
      el.stLiq.textContent = meta.liquidityUsd!=null ? fmtUSD(meta.liquidityUsd) : '—';
      el.stMcap.textContent = meta.marketCapUsd!=null ? fmtUSD(meta.marketCapUsd) : '—';
      el.stPool.textContent = shortAddr(meta.pool);

      el.lnkExplorer.href = meta.token ? explorerLink(meta.chain, meta.token, 'token') : '#';
      el.lnkPair.href = dexLink(meta.chain, meta.pool);
      el.lnkDex.href = dexLink(meta.chain, meta.pool);
      el.btnDS.href = dexLink(meta.chain, meta.pool);
      if (el.lnkScan){
        try{
          el.lnkScan.href = dgBuildScanUrl(meta.chain, meta.token || meta.pool, meta.pool);
          el.lnkScan.onclick = (e)=>{ e.preventDefault(); dgGoScan({chain: meta.chain, address: meta.token || meta.pool, pool: meta.pool}); };
        }catch(e){}
      }
      el.chartMeta.textContent = `${sym}/${quote} • ${CHAINS[meta.chain].label} • pool ${shortAddr(meta.pool)}`;
    }

    function scrollChartIntoView(){
      const wrap = el.chartWrap;
      if (!wrap) return;
      requestAnimationFrame(() => {
        try{
          const header = document.querySelector('.header');
          const headerH = header ? Math.ceil(header.getBoundingClientRect().height) : 0;
          const rect = wrap.getBoundingClientRect();
          const viewportH = window.innerHeight || 0;
          const fullyVisible = rect.top >= headerH && rect.bottom <= viewportH;
          if (fullyVisible) return;
          const targetTop = window.scrollY + rect.top - headerH - 12;
          window.scrollTo({top: Math.max(0, targetTop), behavior:'smooth'});
        }catch(e){}
      });
    }

    function showTokenView(show){
      el.tokenEmpty.style.display = show ? 'none' : '';
      el.tokenBlock.style.display = show ? '' : 'none';
      if (show) initChart();
      try{ dgSyncMobileUI && dgSyncMobileUI(); }catch(e){}
    }

    // ========= Trending via DexScreener Boosts =========
    async function loadTrending(){
      // Trending module removed (STEP17)
      return;

      const sid = ++state.sessionId;
      if (state.abort) state.abort.abort();
      state.abort = new AbortController();
      const signal = state.abort.signal;

      setStatus('', 'Loading trending…');

      try{
        const primary = await withBackoff(() => fetchJson(dsBoostTopUrl(), {ttl: 15_000, signal}), {tries:2, signal});
        if (sid !== state.sessionId) return;
        let items = normalizeBoosts(primary, state.chain);
        if (!items.length){
          const fallback = await withBackoff(() => fetchJson(dsBoostLatestUrl(), {ttl: 15_000, signal}), {tries:2, signal});
          if (sid !== state.sessionId) return;
          items = normalizeBoosts(fallback, state.chain);
        }

        // Enrich trending with best pool + price info (limited concurrency 2, in idle)
        const enriched = await enrichTrending(items, {sid, signal});
        if (sid !== state.sessionId) return;

        renderTrending(enriched);
        setStatus('live', 'Trending live');
      }catch(e){
        if (signal.aborted) return;
        console.warn('[DexGuard] trending error', e);
        renderTrending([]);
        setStatus('warn', 'Trending unavailable');
      }
    }

    function normalizeBoosts(data, chain){
      // DexScreener token-boosts/top|latest: usually {tokens:[...]} or array. Be defensive.
      const arr = Array.isArray(data) ? data : (data?.tokens || data?.data || data?.results || []);
      const dsChain = CHAINS[chain].ds;
      const out = [];
      for (const t of arr){
        const c = (t?.chainId || t?.chain || '').toLowerCase();
        if (c !== dsChain) continue;
        out.push({
          tokenAddress: t?.tokenAddress || t?.address || t?.token || null,
          baseSymbol: t?.tokenSymbol || t?.symbol || null,
          baseName: t?.tokenName || t?.name || null,
          logoUrl: t?.icon || t?.logoURI || t?.imageUrl || t?.image || null,
          boosts: t?.totalAmount || t?.amount || t?.boosts || null,
        });
      }
      return out.slice(0, 16);
    }

    async function enrichTrending(items, {sid, signal}){
      // For each token, pick best pool via token-pairs. Concurrency limit 2.
      const chainId = CHAINS[state.chain].ds;
      const queue = items.slice();
      const out = [];
      let active = 0;

      const runOne = async () => {
        if (!queue.length) return;
        const it = queue.shift();
        active++;
        try{
          if (!it.tokenAddress){
            out.push(Object.assign({pairId:null, dexId:null, priceUsd:null, change24h:null, volume24hUsd:null, liquidityUsd:null}, it));
            return;
          }

          const pairs = await withBackoff(() => fetchJson(dsTokenPairsUrl(chainId, it.tokenAddress), {ttl: 12_000, signal}), {tries:2, signal});
          if (sid !== state.sessionId) return;

          const best = pickBestPair(Array.isArray(pairs) ? pairs : (pairs?.pairs||[]));
          const pairId = best?.pairAddress || best?.pairId || best?.pair || null;

          let metaLite = {};
          if (pairId){
            try{
              const ds = await withBackoff(() => fetchJson(dsPairsUrl(chainId, pairId), {ttl: 10_000, signal}), {tries:2, signal});
              const p = ds?.pairs?.[0] || null;
              if (p){
                metaLite = {
                  pairId,
                  dexId: p?.dexId || null,
                  priceUsd: toNum(p?.priceUsd),
                  change5m: toNum(p?.priceChange?.m5),
                  change1h: toNum(p?.priceChange?.h1),
                  change6h: toNum(p?.priceChange?.h6),
                  change24h: toNum(p?.priceChange?.h24),
                  volume5mUsd: toNum(p?.volume?.m5),
                  volume1hUsd: toNum(p?.volume?.h1),
                  volume6hUsd: toNum(p?.volume?.h6),
                  volume24hUsd: toNum(p?.volume?.h24),
                  liquidityUsd: toNum(p?.liquidity?.usd),
                  logoUrl: it.logoUrl || p?.info?.imageUrl || null,
                  baseSymbol: it.baseSymbol || p?.baseToken?.symbol || null,
                  baseName: it.baseName || p?.baseToken?.name || null,
                };
              } else {
                metaLite = {pairId};
              }
            }catch(e){
              metaLite = {pairId};
            }
          }

          out.push(Object.assign({pairId:null, dexId:null, priceUsd:null, change24h:null, volume24hUsd:null, liquidityUsd:null}, it, metaLite));
        }catch(e){
          // keep trending responsive even if enrichment fails
          out.push(Object.assign({pairId:null, dexId:null, priceUsd:null, change24h:null, volume24hUsd:null, liquidityUsd:null}, it));
        }finally{
          active--;
        }
      };

      const idle = window.requestIdleCallback || ((cb)=> setTimeout(()=>cb({timeRemaining:()=>0}), 40));
      await new Promise(resolve => idle(() => {
        (async ()=>{
          while (active < 2 && queue.length) runOne();
          while (active > 0){
            await sleep(40);
            while (active < 2 && queue.length) runOne();
          }
          resolve();
        })();
      }));

      // keep order stable-ish
      return out.slice(0, 16);
    }

    function pickBestPair(arr){
      if (!arr || !arr.length) return null;
      const scored = arr.map(p => {
        const liq = toNum(p?.liquidity?.usd ?? p?.liquidityUsd ?? p?.liquidity_in_usd ?? p?.reserve_in_usd);
        const vol = toNum(p?.volume?.h24 ?? p?.volume24hUsd ?? p?.volume_usd_24h);
        return {p, score: (liq||0)*10 + (vol||0)};
      });
      scored.sort((a,b)=> (b.score||0) - (a.score||0));
      return scored[0]?.p || arr[0];
    }

    // ========= Search =========
    let searchTimer = 0;
    async function doSearch(userTriggered=false){
      const q = (el.q.value || '').trim();
      if (!q){
        // When query is cleared, immediately reset UI (do NOT keep stale results)
        clearResults();
        try{ dgShowInstantDefaults(); }catch(e){}
        return;
      }

      const sid = ++state.sessionId;
      if (state.abort) state.abort.abort();
      state.abort = new AbortController();
      const signal = state.abort.signal;

      if (userTriggered) toast('Searching…');
      setStatus('', 'Searching…');

      try{
        const data = await withBackoff(() => fetchJson(dsSearchUrl(q), {ttl: 0, signal}), {tries:2, signal});
        if (sid !== state.sessionId) return;
        renderResults(data?.pairs || []);
        setStatus('live', 'Search ready');
      }catch(e){
        if (signal.aborted) return;
        console.warn('[DexGuard] search error', e);
        setStatus('warn', 'Search unavailable');
        if (userTriggered) toast('Search failed');
        renderResults([]);
      }
    }

    function debounceSearch(){
      clearTimeout(searchTimer);
      searchTimer = setTimeout(()=> { doSearch(false); }, 180);
    }

    // ========= Open pool / token =========
    async function openPool({
      chain,
      pairId,
      tokenAddress,
      baseSymbol,
      baseName,
      quoteSymbol,
      logoUrl,
      priceUsd,
      change24h,
      volume24hUsd,
      liquidityUsd,
      marketCapUsd,
      hint=''
    }){
      if (!pairId && tokenAddress){
        const key = tokenKey(chain, tokenAddress);
        const prev = state.metaByToken.get(key) || null;
        const seed = {
          chain,
          token: tokenAddress,
          baseSymbol: cleanText(baseSymbol) ?? cleanText(prev?.baseSymbol),
          quoteSymbol: cleanText(quoteSymbol) ?? cleanText(prev?.quoteSymbol),
          baseName: cleanText(baseName) ?? cleanText(prev?.baseName),
          logoUrl: cleanText(logoUrl) ?? cleanText(prev?.logoUrl),
          priceUsd: isFinite(priceUsd) ? priceUsd : (isFinite(prev?.priceUsd) ? prev.priceUsd : null),
          change24h: isFinite(change24h) ? change24h : (isFinite(prev?.change24h) ? prev.change24h : null),
          volume24hUsd: isFinite(volume24hUsd) ? volume24hUsd : (isFinite(prev?.volume24hUsd) ? prev.volume24hUsd : null),
          liquidityUsd: isFinite(liquidityUsd) ? liquidityUsd : (isFinite(prev?.liquidityUsd) ? prev.liquidityUsd : null),
          marketCapUsd: isFinite(marketCapUsd) ? marketCapUsd : (isFinite(prev?.marketCapUsd) ? prev.marketCapUsd : null),
        };
        state.metaByToken.set(key, Object.assign(prev || {}, seed));
        await openByToken(chain, tokenAddress);
        return;
      }
      if (!pairId){ toast('No pool found'); return; }

      const sid = ++state.sessionId;
      if (state.abort) state.abort.abort();
      state.abort = new AbortController();
      const signal = state.abort.signal;

      stopLive();
      state.lastTradeId = null;
      state.candles = [];
      state.lastCandle = null;
      state._forceFitNext = true;
      setChartLoading(false);
      el.tradesBody.innerHTML = '';
      el.tradeCount.textContent = '0';
      state.tradesMap = new Map();
      state.tradesList = [];
      state.winStats = null;

      // Default timeframe on each open: 15m (rollback from forced 5m)
      if (state.tf !== '15m'){
        state.tf = '15m';
        el.tfs.forEach(b => b.classList.toggle('active', b.dataset.tf === state.tf));
      }

      setTradesEmpty('loading');

      showTokenView(true);
      setStatus('', 'Loading token…');

      const dsChain = CHAINS[chain].ds;
      const gtNet = CHAINS[chain].gt;

      const cachedPool = state.metaByPool.get(`${chain}|${pairId}`) || null;
      const cachedToken = tokenAddress ? state.metaByToken.get(tokenKey(chain, tokenAddress)) : null;
      const cached = cachedPool || cachedToken;

      const meta = {
        chain, dsChain, gtNet,
        pool: pairId,
        token: tokenAddress || null,
        baseSymbol: cleanText(baseSymbol) ?? cleanText(cached?.baseSymbol),
        quoteSymbol: cleanText(quoteSymbol) ?? cleanText(cached?.quoteSymbol),
        baseName: cleanText(baseName) ?? cleanText(cached?.baseName),
        logoUrl: cleanText(logoUrl) ?? cleanText(cached?.logoUrl),
        dexId: null,
        priceUsd: isFinite(priceUsd) ? priceUsd : (isFinite(cached?.priceUsd) ? cached.priceUsd : null),
        change24h: isFinite(change24h) ? change24h : (isFinite(cached?.change24h) ? cached.change24h : null),
        volume24hUsd: isFinite(volume24hUsd) ? volume24hUsd : (isFinite(cached?.volume24hUsd) ? cached.volume24hUsd : null),
        liquidityUsd: isFinite(liquidityUsd) ? liquidityUsd : (isFinite(cached?.liquidityUsd) ? cached.liquidityUsd : null),
        marketCapUsd: isFinite(marketCapUsd) ? marketCapUsd : (isFinite(cached?.marketCapUsd) ? cached.marketCapUsd : null),
        gtBaseAddr: null,
        gtQuoteAddr: null,
        gtSideHint: null,
        priceQuote: null,
        quoteUsd: null,
      };

      el.btnDS.href = dexLink(chain, pairId);
      state.current = meta;
      state._pinToRight = true;

      try{
        resetChartForNewToken(meta);
        primeChart(meta);
        startLive(meta, {sid});
      }finally{
        try{ setTokenUI(meta); }catch(e){}
        try{ rememberMeta(meta); }catch(e){}
        scrollChartIntoView();
      }

      // DexScreener meta
      try{
        const ds = await withBackoff(() => fetchJson(dsPairsUrl(dsChain, pairId), {ttl: 8_000, signal}), {tries:2, signal});
        if (sid !== state.sessionId) return;
        const p = ds?.pairs?.[0] || null;
        if (p){
          meta.token = meta.token || p?.baseToken?.address || null;
          meta.baseSymbol = meta.baseSymbol ?? (p?.baseToken?.symbol || null);
          meta.baseName = meta.baseName ?? (p?.baseToken?.name || null);
          meta.quoteSymbol = meta.quoteSymbol ?? (p?.quoteToken?.symbol || null);

          // Prefer DexScreener's native (quote-token) price when available.
          // This is critical to keep the chart unit aligned with the pair (e.g. TICKER/SOL -> priceNative in SOL).
          const dsPriceNative = toNum(p?.priceNative);
          if (isFinite(dsPriceNative) && dsPriceNative > 0) meta.priceQuote = meta.priceQuote ?? dsPriceNative;

          // Stable candle side selection:
          // If user opened via a specific token contract and it matches quoteToken, use quote candles;
          // otherwise default to base candles (DexScreener pairs are base/quote).
          const baseAddr = p?.baseToken?.address || null;
          const quoteAddr = p?.quoteToken?.address || null;
          meta._baseAddr = baseAddr;
          meta._quoteAddr = quoteAddr;
          if (meta.token){
            meta.sideHint = addrEq(chain, meta.token, quoteAddr) ? 'quote' : 'base';
          } else {
            meta.sideHint = 'base';
          }
          meta.logoUrl = meta.logoUrl ?? (p?.info?.imageUrl || null);
          meta.dexId = meta.dexId ?? (p?.dexId || null);

          meta.priceUsd = toNum(p?.priceUsd);

          // If we have both USD and quote-token price, infer quote token USD (e.g. SOL/USD) for stable conversions.
          if (meta.quoteUsd == null){
            const pu = meta.priceUsd;
            const pq = meta.priceQuote;
            if (isFinite(pu) && pu > 0 && isFinite(pq) && pq > 0){
              const qUsd = pu / pq;
              if (isFinite(qUsd) && qUsd > 0) meta.quoteUsd = qUsd;
            }
          }
          meta.change5m = toNum(p?.priceChange?.m5);
          meta.change1h = toNum(p?.priceChange?.h1);
          meta.change6h = toNum(p?.priceChange?.h6);
          meta.change24h = toNum(p?.priceChange?.h24);
          meta.volume5mUsd = toNum(p?.volume?.m5);
          meta.volume1hUsd = toNum(p?.volume?.h1);
          meta.volume6hUsd = toNum(p?.volume?.h6);
          meta.volume24hUsd = toNum(p?.volume?.h24);
          meta._txns = meta._txns || {};
          const t5b = toNum(p?.txns?.m5?.buys); const t5s = toNum(p?.txns?.m5?.sells);
          const t1b = toNum(p?.txns?.h1?.buys); const t1s = toNum(p?.txns?.h1?.sells);
          const t6b = toNum(p?.txns?.h6?.buys); const t6s = toNum(p?.txns?.h6?.sells);
          const t24b = toNum(p?.txns?.h24?.buys); const t24s = toNum(p?.txns?.h24?.sells);
          meta._txns.m5 = {buys:t5b, sells:t5s, txns: (isFinite(t5b)&&isFinite(t5s)) ? (t5b+t5s) : null};
          meta._txns.h1 = {buys:t1b, sells:t1s, txns: (isFinite(t1b)&&isFinite(t1s)) ? (t1b+t1s) : null};
          meta._txns.h6 = {buys:t6b, sells:t6s, txns: (isFinite(t6b)&&isFinite(t6s)) ? (t6b+t6s) : null};
          meta._txns.h24 = {buys:t24b, sells:t24s, txns: (isFinite(t24b)&&isFinite(t24s)) ? (t24b+t24s) : null};

          meta.liquidityUsd = toNum(p?.liquidity?.usd);
          meta.marketCapUsd = toNum(p?.fdv);
          setTokenUI(meta);
          rememberMeta(meta);
        }
      }catch(e){
        if (!signal.aborted) console.warn('[DexGuard] ds meta failed', e);
      }

      // Fallback enrichment: token-pairs list often has icon/liquidity/fdv even when the pair endpoint is sparse.
      if (meta.token && (!meta.logoUrl || meta.liquidityUsd == null || meta.marketCapUsd == null)){
        try{
          const tp = await withBackoff(() => fetchJson(dsTokenPairsUrl(dsChain, meta.token), {ttl: 12_000, signal}), {tries:2, signal});
          if (sid !== state.sessionId) return;
          const arr = Array.isArray(tp) ? tp : (tp?.pairs || tp?.data || []);
          if (Array.isArray(arr) && arr.length){
            const match = arr.find(x => {
              const pid = x?.pairAddress || x?.pairId || x?.address || x?.id;
              if (pid && String(pid) === String(meta.pool)) return true;
              const url = x?.url;
              return (url && String(url).includes(String(meta.pool)));
            }) || null;

            if (match){
              meta.logoUrl = meta.logoUrl || match?.info?.imageUrl || match?.baseToken?.logoURI || match?.baseToken?.imageUrl || match?.baseToken?.icon || null;
              meta.liquidityUsd = meta.liquidityUsd ?? toNum(match?.liquidity?.usd ?? match?.liquidityUsd);
              meta.marketCapUsd = meta.marketCapUsd ?? toNum(match?.fdv ?? match?.marketCap ?? match?.marketCapUsd);
              meta.volume24hUsd = meta.volume24hUsd ?? toNum(match?.volume?.h24 ?? match?.volume24hUsd);
              meta.baseSymbol = meta.baseSymbol ?? (match?.baseToken?.symbol || null);
              meta.baseName = meta.baseName ?? (match?.baseToken?.name || null);
              meta.token = meta.token ?? (match?.baseToken?.address || null);
              meta.quoteSymbol = meta.quoteSymbol ?? (match?.quoteToken?.symbol || null);
            }
          }
        }catch(e){}
      }
      setTokenUI(meta);
      rememberMeta(meta);

      if (!state.candles.length) primeChart(meta);

      // Gecko pool enrich (optional)
      try{
        const gt = await withBackoff(() => fetchJson(gtPoolUrl(gtNet, pairId), {ttl: 8_000, signal}), {tries:2, signal});
        if (sid !== state.sessionId) return;
        const a = gt?.data?.attributes || {};
        // Capture GeckoTerminal's pool token addresses (Gecko base/quote may differ from DexScreener base/quote!)
        const gb = a?.base_token?.address || a?.base_token_address || null;
        const gq = a?.quote_token?.address || a?.quote_token_address || null;
        meta.gtBaseAddr = meta.gtBaseAddr || gb;
        meta.gtQuoteAddr = meta.gtQuoteAddr || gq;

        // Stable chart side: match the token the user opened against Gecko's base/quote.
        // This prevents the classic "SOL chart (127$)" bug when Gecko labels SOL as base.
        meta.gtSideHint = pickGtSide(meta);

        // Price hint in quote-token units (e.g. TOKEN/SOL), used for priming + fallbacks.
        // Gecko pool attributes often expose both USD and native/quote prices.
        const baseQ = toNum(a?.base_token_price_native_currency ?? a?.base_token_price_quote_token);
        const quoteQ = toNum(a?.quote_token_price_native_currency ?? a?.quote_token_price_base_token);
        if (meta.gtSideHint === 'base') meta.priceQuote = meta.priceQuote ?? baseQ;
        if (meta.gtSideHint === 'quote') meta.priceQuote = meta.priceQuote ?? quoteQ;

        meta.priceUsd = meta.priceUsd ?? toNum(a?.base_token_price_usd ?? a?.price_usd);

        if (meta.quoteUsd == null){
          const pu = meta.priceUsd;
          const pq = meta.priceQuote;
          if (isFinite(pu) && pu > 0 && isFinite(pq) && pq > 0){
            const qUsd = pu / pq;
            if (isFinite(qUsd) && qUsd > 0) meta.quoteUsd = qUsd;
          }
        }
        meta.volume24hUsd = meta.volume24hUsd ?? toNum(a?.volume_usd?.h24 ?? a?.volume_usd_24h);
        meta.liquidityUsd = meta.liquidityUsd ?? toNum(a?.reserve_in_usd ?? a?.liquidity_in_usd);
        meta.change24h = meta.change24h ?? toNum(a?.price_change_percentage?.h24 ?? a?.price_change_percentage_24h);
        meta.logoUrl = meta.logoUrl ?? (a?.base_token?.image_url || a?.base_token_image_url || a?.image_url);
        meta.baseSymbol = meta.baseSymbol ?? (a?.base_token?.symbol || a?.base_token_symbol);
        meta.baseName = meta.baseName ?? (a?.base_token?.name || a?.base_token_name);
        meta.quoteSymbol = meta.quoteSymbol ?? (a?.quote_token?.symbol || a?.quote_token_symbol);
        meta.token = meta.token ?? (a?.base_token?.address || a?.base_token_address);
        meta.marketCapUsd = meta.marketCapUsd ?? toNum(a?.market_cap_usd ?? a?.fdv_usd);
        setTokenUI(meta);
        rememberMeta(meta);
      }catch(e){
        if (!signal.aborted) console.warn('[DexGuard] gt meta failed', e);
      }

      // Birdeye enrich (Solana only; optional key)
      if (chain === 'solana' && settings.birdeyeKey && meta.token){
        try{
          const be = await withBackoff(() => fetchJson(birdeyeTokenOverviewUrl(meta.token), {
            ttl: 20_000,
            signal,
            headers: {'X-API-KEY': settings.birdeyeKey},
          }), {tries:2, signal});
          if (sid !== state.sessionId) return;
          const d = be?.data || be?.data?.data || be?.data?.items || be?.data?.token || be?.data || null;
          meta.marketCapUsd = meta.marketCapUsd ?? toNum(d?.market_cap ?? d?.marketCap ?? d?.mc ?? d?.mcap);
          meta.logoUrl = meta.logoUrl ?? (d?.logoURI || d?.logo || d?.icon);
          meta.baseName = meta.baseName ?? (d?.name);
          meta.baseSymbol = meta.baseSymbol ?? (d?.symbol);
          meta.priceUsd = meta.priceUsd ?? toNum(d?.price ?? d?.priceUsd);
          setTokenUI(meta);
          rememberMeta(meta);
        }catch(e){
          if (!signal.aborted) console.warn('[DexGuard] birdeye overview failed', e);
        }
      }

      state.current = meta;
      state._forceFitNext = true;
      setTokenUI(meta);
      try{ dgRecentsPush(meta); }catch(e){}
      try{ dgPersistLastStateFromMeta(meta); }catch(e){}
      showTokenView(true);

      await loadCandles(meta, state.tf, {sid, signal});
      if (sid !== state.sessionId) return;
      if (shouldRetryCandles(meta)){
        setTimeout(() => {
          if (sid !== state.sessionId) return;
          void refreshCandles(meta, {sid, signal, reason:'post-load retry'});
        }, 900);
      }
      setStatus('live', 'Live');
    }

    async function openByToken(chain, token){
      const sid = ++state.sessionId;
      if (state.abort) state.abort.abort();
      state.abort = new AbortController();
      const signal = state.abort.signal;

      showTokenView(true);
      setStatus('', 'Resolving token…');

      try{
        const dsChain = CHAINS[chain].ds;
        const pairs = await withBackoff(() => fetchJson(dsTokenPairsUrl(dsChain, token), {ttl: 8_000, signal}), {tries:2, signal});
        if (sid !== state.sessionId) return;
        const best = pickBestPair(Array.isArray(pairs) ? pairs : (pairs?.pairs||[]));
        const pairId = best?.pairAddress || best?.pairId || best?.pair || best?.id || null;
        if (!pairId){
          setStatus('warn', 'No pool found for token');
          toast('No pool found for this contract on this chain');
          return;
        }
        await openPool({chain, pairId, tokenAddress: token, hint:'token'});
      }catch(e){
        if (signal.aborted) return;
        console.warn('[DexGuard] openByToken failed', e);
        setStatus('warn', 'Token resolve failed');
        toast('Resolve failed');
      }
    }

    // ========= Candles =========
    const candleCache = new Map(); // key -> {t, data}
    const candleCacheKey = (meta, tf) => `${meta.chain}|${meta.pool}|${tf}`;
    const chartPriceFor = (meta) => {
      if (!meta) return null;
      const pu = meta?.priceUsd;
      if (isFinite(pu) && pu > 0) return pu;
      const last = state.lastPriceByPool.get(poolKey(meta));
      if (isFinite(last) && last > 0) return last;
      const pq = meta?.priceQuote;
      if (isFinite(pq) && pq > 0) return pq;
      return null;
    };
    const refPriceFor = chartPriceFor;
    async function waitForRefPrice(meta, timeoutMs=1400){
      const start = Date.now();
      let px = refPriceFor(meta);
      while ((!isFinite(px) || px <= 0) && (Date.now() - start) < timeoutMs){
        await sleep(120);
        px = refPriceFor(meta);
      }
      return px;
    }
    function maxCandlesForTf(tf){
      switch(tf){
        case '1m': return 8000;    // ~5.5 days (stability; avoids 1m fetch overload)
        case '5m': return 60000;   // ~208 days
        case '15m': return 30000;  // ~312 days
        case '1h': return 8000;    // ~333 days
        case '4h': return 6000;    // ~1000 days
        case '1d': return 3000;
        default: return 8000;
      }
    }

    // ===== PATCH: TF derive helpers (client-side resample for larger TFs) =====
    function tfSec(tf){
      try{ return (tfToGT(tf).sec|0) || 60; }catch(e){ return 60; }
    }
    function aggregateCandles(src, dstTf){
      const dstSec = tfSec(dstTf);
      if (!Array.isArray(src) || !src.length || !isFinite(dstSec) || dstSec <= 0) return [];
      const out = [];
      let cur = null;
      let bucket = 0;
      for (const c of src){
        if (!c || !isFinite(c.time) || !isFinite(c.open) || !isFinite(c.high) || !isFinite(c.low) || !isFinite(c.close)) continue;
        const b = Math.floor(c.time / dstSec) * dstSec;
        if (!cur || b !== bucket){
          if (cur) out.push(cur);
          bucket = b;
          cur = { time: b, open: c.open, high: c.high, low: c.low, close: c.close };
        } else {
          cur.high = Math.max(cur.high, c.high);
          cur.low = Math.min(cur.low, c.low);
          cur.close = c.close;
        }
      }
      if (cur) out.push(cur);
      return out;
    }
    async function fetchGTOhlcvPaged(meta, tf, token, {sid, signal, beforeStart}){
      const map = tfToGT(tf);
      const limit = map.timeframe === 'day' ? 260 : map.timeframe === 'hour' ? 520 : 700;
      const max = maxCandlesForTf(tf);
      let before = isFinite(beforeStart) ? beforeStart : nowSec();
      let out = [];
      let pages = 0;

      while (out.length < max && pages < 50){
        pages++;
        let data = null;
        try{
          data = await withBackoff(() => fetchJson(gtOhlcvUrl(meta.gtNet, meta.pool, tf, token, before, limit), {ttl: 8_000, signal}), {tries:2, signal});
        }catch(e){
          const msg = String(e && (e.message || e));
          if (!msg.includes('AbortError')) console.warn('[DexGuard] gt ohlcv page failed', msg);
          break;
        }
        if (sid !== state.sessionId) return null;
        const chunk = normalizeGTOhlcv(data);
        if (!chunk.length) break;
        out = out.concat(chunk);
        const oldest = chunk.reduce((min, c) => (min === null || c.time < min ? c.time : min), null);
        if (!oldest || oldest >= before) break;
        before = oldest - 1;
        if (chunk.length < limit) break;
      }
      // Convert USD candles into quote-token units (pair units) when we can infer quoteUsd.
      const qUsd = meta?.quoteUsd;
      if (isFinite(qUsd) && qUsd > 0){
        out = out.map(c => ({ time: c.time, open: c.open / qUsd, high: c.high / qUsd, low: c.low / qUsd, close: c.close / qUsd }));
      }
      return out;
    }

    async function loadCandles(meta, tf, {sid, signal}){
      // Chart is primed immediately. While switching TF, keep the previous data visible
      // and show a subtle in-chart loader to avoid the "flat line" flash.
      if (state._tfSwitching){
        setStatus('', 'Loading candles…');
        setChartLoading(true);
      } else {
        setStatus('', '');
        setChartLoading(false);
      }

      const ck = candleCacheKey(meta, tf);
      const sideKey = ck;
      const cached = candleCache.get(ck);
      const __ttl = cached?.ttl ?? 600_000;
      if (cached && (Date.now()-cached.t) < __ttl){
        state.candles = cached.data.slice();
        if (state.candles.length){
          applyCandlesToChart(state.candles);
        }
        setChartLoading(false);
        setStatus('live', 'Live (cached)');
        return;
      }

      let candles = null;
      let usedFallback = false;
      let refPrice = refPriceFor(meta);
      const needBothSides = false;
      const lockedSide = pickGtSide(meta);

      const pickWithRef = (a, b) => pickBestCandles(a, b, refPrice);

      // 0) Birdeye OHLCV (token-based, USD) — most reliable and avoids base/quote confusion
      try{
        const beCandles = await fetchBirdeyeOhlcv(meta, tf, {sid, signal});
        if (beCandles && beCandles.length) candles = beCandles;
      }catch(e){
        if (!signal.aborted) console.warn('[DexGuard] birdeye ohlcv failed', e);
      }

      // 1) GeckoTerminal OHLCV (stable side: match user's token against Gecko pool base/quote)
      try{
        const side = lockedSide || 'base';
        candles = await fetchGTOhlcvPaged(meta, tf, side, {sid, signal});
        if (candles && candles.length){
          const bad = candles.every(c => !c || !isFinite(c.close) || c.close === 0);
          if (bad) candles = null;
        }
      }catch(e){
        if (!signal.aborted) console.warn('[DexGuard] gt ohlcv failed', e);
      }
// 2) Safe fallback: generate flat candles from last known price so chart never crashes
      if (!candles || !candles.length){
        let px = null;
        try{
          px = state.lastPriceByPool.get(poolKey(meta));
        }catch(e){}
        if (!isFinite(px) || px <= 0) px = meta.priceQuote ?? refPriceFor(meta) ?? state.candles?.[state.candles.length-1]?.close ?? meta.priceUsd ?? 0;
        if (!isFinite(px) || px <= 0){
          try{ px = await waitForRefPrice(meta, 900); }catch(e){}
        }
        usedFallback = true;
        candles = generateFlatCandles((isFinite(px) && px > 0) ? px : 0.0000001, tf, 220);
      }

      // sort + dedup
      candles.sort((a,b)=> a.time - b.time);
      const dedup = [];
      let lastT = 0;
      for (const c of candles){
        if (!c || !isFinite(c.time)) continue;
        if (c.time === lastT) { dedup[dedup.length-1] = c; continue; }
        lastT = c.time;
        dedup.push(c);
      }

      state.candles = dedup;
      candleCache.set(ck, {t:Date.now(), data: dedup.slice(), ttl: (usedFallback ? 4000 : 600_000), fallback: usedFallback});

      // If we had to fall back to flat candles, retry quickly in the background.
      state._usingFallbackCandles = !!usedFallback;
      if (usedFallback){
        const __now = Date.now();
        const __prev = state._fallbackRetryAt.get(ck) || 0;
        if ((__now - __prev) > 2000){
          state._fallbackRetryAt.set(ck, __now);
          clearTimeout(state._fallbackTimer);
          state._fallbackTimer = setTimeout(() => {
            if (!state.current || state.current.pool !== meta.pool) return;
            const __sid2 = state.sessionId;
            const __signal2 = state.abort?.signal;
            if (__signal2 && __signal2.aborted) return;
            void refreshCandles(meta, {sid: __sid2, signal: __signal2, reason: 'fallback retry'});
          }, 1600);
        }
      }

      if (dedup.length){
        if (dedup.length >= 20){
          const ref = refPriceFor(meta);
          const lastC = dedup[dedup.length-1];
          const ratio = (ref && lastC && isFinite(lastC.close))
            ? Math.max(lastC.close, ref) / Math.max(1e-12, Math.min(lastC.close, ref))
            : null;

          // Even if scale looks suspicious, still render what we have, then retry quietly.
          if (ratio != null && ratio > 50 && shouldRetryCandles(meta)){
            applyCandlesToChart(dedup);
            setChartLoading(false);
            void refreshCandles(meta, {sid, signal, reason:'scale retry'});
          } else {
            applyCandlesToChart(dedup);
            setChartLoading(false);
          }
        } else {
          // Small datasets: still render (prevents "blank/flat" stuck state)
          applyCandlesToChart(dedup);
          setChartLoading(false);
        }
      } else {
        setChartLoading(false);
      }

      // Seed chart reference price from the most recent candle close (chart units = quote token for the pair).
const last = dedup && dedup.length ? dedup[dedup.length-1] : null;
if (last && isFinite(last.close)){
  state.lastPriceByPool.set(poolKey(meta), last.close);

  if (state.current && state.current.pool === meta.pool){
    if (state.current.priceQuote == null) state.current.priceQuote = last.close;
    if (state.current.priceUsd == null && isFinite(state.current.quoteUsd) && state.current.quoteUsd > 0){
      state.current.priceUsd = last.close * state.current.quoteUsd;
    }
  }

  // Only fill the USD header if we can infer it safely.
  if (el.stPrice.textContent === '—'){
    const qUsd = meta?.quoteUsd;
    if (isFinite(qUsd) && qUsd > 0) el.stPrice.textContent = fmtUSD(last.close * qUsd);
  }
}

      setStatus('live', 'Live');
    }

    async function backfillCandles(meta, {sid, signal}){
      if (!state.candles || state.candles.length < 20) return;
      if (state._backfilling) return;
      state._backfilling = true;
      try{
        const oldest = state.candles[0];
        const before = oldest?.time ? (oldest.time - 1) : null;
        if (!before) return;
        const sideKey = candleCacheKey(meta, state.tf);
        const side = state.candleSideByKey.get(sideKey) || 'base';
        const older = await fetchGTOhlcvPaged(meta, state.tf, side, {sid, signal, beforeStart: before});
        if (sid !== state.sessionId) return;
        if (!older.length) return;
        const merged = older.concat(state.candles);
        merged.sort((a,b)=> a.time - b.time);
        const dedup = [];
        let lastT = 0;
        for (const c of merged){
          if (!c || !isFinite(c.time)) continue;
          if (c.time === lastT) { dedup[dedup.length-1] = c; continue; }
          lastT = c.time;
          dedup.push(c);
        }
        state.candles = dedup;
        candleCache.set(candleCacheKey(meta, state.tf), {t:Date.now(), data: dedup.slice()});
        applyCandlesToChart(dedup);
      } finally {
        state._backfilling = false;
      }
    }

    function normalizeGTOhlcv(data){
      const list = data?.data?.attributes?.ohlcv_list || data?.data?.attributes?.ohlcv || [];
      const out = [];
      for (const row of list){
        if (!Array.isArray(row) || row.length < 5) continue;
        let t = row[0];
        // normalize timestamp: seconds preferred; handle ms or string
        t = (typeof t === 'string') ? parseFloat(t) : t;
        if (!isFinite(t)) continue;
        t = t > 1e12 ? Math.floor(t/1000) : Math.floor(t);
        const o = (typeof row[1] === 'string') ? parseFloat(row[1]) : +row[1];
        const h = (typeof row[2] === 'string') ? parseFloat(row[2]) : +row[2];
        const l = (typeof row[3] === 'string') ? parseFloat(row[3]) : +row[3];
        const c = (typeof row[4] === 'string') ? parseFloat(row[4]) : +row[4];
        if (![t,o,h,l,c].every(isFinite)) continue;
        // guard against negative/zero-only garbage
        if (o < 0 || h < 0 || l < 0 || c < 0) continue;
        out.push({time:t, open:o, high:h, low:l, close:c});
      }
      return out;
    }
    function normalizeBirdeyeOhlcv(data){
      const items = data?.data?.items || data?.data?.data?.items || data?.items || [];
      const out = [];
      for (const it of items){
        const t = Math.floor(it?.unixTime ?? it?.time ?? it?.t ?? 0);
        const o = +it?.o, h = +it?.h, l = +it?.l, c = +it?.c;
        if (![t,o,h,l,c].every(isFinite)) continue;
        out.push({time:t, open:o, high:h, low:l, close:c});
      }
      return out;
    }

    function generateFlatCandles(price, tf, count){
      const {sec} = tfToGT(tf);
      const end = Math.floor(nowSec()/sec)*sec;
      const out = [];
      for (let i=count-1;i>=0;i--){
        const t = end - i*sec;
        out.push({time:t, open:price, high:price, low:price, close:price});
      }
      return out;
    }

    function applyCandlesToChart(candles){
      // guard: chart container may be zero-sized right after view switches
      initChart();
      if (!state.series) {
        // retry once shortly
        setTimeout(() => { initChart(); if (state.series) applyCandlesToChart(candles); }, 60);
        return;
      }
      let prevTimeRange = null;
      try{
        const ts = state.chart?.timeScale?.();
        // Preserve the user's current time window when they are not pinned to the right edge.
        if (ts && !state._forceFitNext && !state._pinToRight){
          prevTimeRange = ts.getVisibleRange?.() || null;
        }
      }catch(e){}

      try{
        state.series.setData(candles || []);
        const settle = () => {
          if (!state.chart || !state.series) return;
          const w = el.chartWrap.clientWidth|0;
          const h = el.chartWrap.clientHeight|0;
          if (w < 40 || h < 160) return;

          const ts = state.chart.timeScale();
          try{
            if (state._forceFitNext){
              ts.resetTimeScale();
              ts.fitContent();
              try{ ts.scrollToRealTime(); }catch(e){}
              state._forceFitNext = false;
            } else if (state._autoFollow){
              try{ ts.scrollToRealTime(); }catch(e){}
            } else if (prevTimeRange){
              // Keep the exact same time window after setData/backfill (prepending shifts indices).
              ts.setVisibleRange(prevTimeRange);
            } else if (state._pinToRight){
              try{ ts.scrollToRealTime(); }catch(e){}
            }
          }catch(e){}
        };
        requestAnimationFrame(settle);
        setTimeout(settle, 180);

        if (candles && candles.length){
          const last = candles[candles.length-1];
          if (last && isFinite(last.close)) applySeriesPrecision(last.close);
        }
      }catch(e){
        console.warn('[DexGuard] setData failed', e);
      }
      if (candles && candles.length){
        state.lastCandle = candles[candles.length-1];
      } else {
        state.lastCandle = null;
      }
    }

    function isFlatCandles(list){
      if (!Array.isArray(list) || list.length < 12) return true;
      let min = Infinity;
      let max = -Infinity;
      for (const c of list){
        if (!c || !isFinite(c.close)) continue;
        if (c.close < min) min = c.close;
        if (c.close > max) max = c.close;
      }
      if (!isFinite(min) || !isFinite(max) || min <= 0 || max <= 0) return true;
      const ratio = max / min;
      return ratio < 1.001;
    }
    function shouldRetryCandles(meta){
      const key = poolKey(meta);
      const last = state.candleRetryAt.get(key) || 0;
      if ((Date.now() - last) < 20_000) return false;
      const refPrice = refPriceFor(meta);
      const lastCandle = state.candles?.[state.candles.length-1];
      const ratio = (refPrice && lastCandle && isFinite(lastCandle.close))
        ? Math.max(lastCandle.close, refPrice) / Math.max(1e-12, Math.min(lastCandle.close, refPrice))
        : null;
      const flat = isFlatCandles(state.candles);
      const mismatched = ratio != null && ratio > 50;
      if (!flat && !mismatched) return false;
      state.candleRetryAt.set(key, Date.now());
      return true;
    }
    async function refreshCandles(meta, {sid, signal, reason=''}){
      if (state.candleRefreshLock) return;
      state.candleRefreshLock = true;

      // If we already have a good chart on screen, never let a fallback/flat refresh overwrite it.
      const __prev = (Array.isArray(state.candles) && state.candles.length) ? state.candles.slice() : null;
      const __prevWasGood = !!(__prev && __prev.length >= 40 && !isFlatCandles(__prev) && !state._usingFallbackCandles);

      try{
        await loadCandles(meta, state.tf, {sid, signal});
        if (sid !== state.sessionId) return;

        if (__prevWasGood && state._usingFallbackCandles){
          // Restore the last known good candles for this TF.
          state.candles = __prev;
          applyCandlesToChart(__prev);
          state._usingFallbackCandles = false;
          try{
            const ck = candleCacheKey(meta, state.tf);
            candleCache.set(ck, {t: Date.now(), data: __prev.slice(), ttl: 600_000, derived: true, from:'restore'});
          }catch(e){}
        }

        if (reason) console.debug('[DexGuard] candle refresh', reason);
      } finally {
        state.candleRefreshLock = false;
      }
    }

    // ========= Live trades + candle growth =========
    function stopLive(){
      if (state.liveTimer){ clearInterval(state.liveTimer); state.liveTimer = null; }
      if (state.ageTimer){ clearInterval(state.ageTimer); state.ageTimer = null; }
      if (state._onVis){
        document.removeEventListener('visibilitychange', state._onVis);
        state._onVis = null;
      }
    }

    function startLive(meta, {sid}){
      stopLive();
      state.lastTradeId = null;

      // fresh trade cache per pool
      state.tradesMap = new Map();
      state.tradesList = [];
      state.winStats = null;

      const run = async () => {
        if (sid !== state.sessionId) return;
        if (!state.current || state.current.pool !== meta.pool) return;

        if (state._liveRunning) return;
        state._liveRunning = true;

        const hidden = document.visibilityState === 'hidden';
        const interval = hidden ? settings.pollHiddenMs : settings.pollLiveMs;

        try{
          await tickLive(meta, {sid});
          setStatus(hidden ? 'warn' : 'live', hidden ? 'Live (paused)' : 'Live');
        }catch(e){
          const msg = String(e && e.message || e);
          if (!msg.includes('AbortError')) console.warn('[DexGuard] live tick failed', e);
          setStatus(hidden ? 'warn' : 'warn', hidden ? 'Live (paused)' : 'Live (degraded)');
        }finally{
          state._liveRunning = false;
        }

        // ensure timer uses correct interval (rebuild if changed)
        if (state.liveTimer && state.liveTimer._ms !== interval){
          clearInterval(state.liveTimer);
          state.liveTimer = setInterval(run, interval);
          state.liveTimer._ms = interval;
        }
      };

      // start immediately, then poll
      run();
      const initial = (document.visibilityState === 'hidden') ? settings.pollHiddenMs : settings.pollLiveMs;
      state.liveTimer = setInterval(run, initial);
      state.liveTimer._ms = initial;

      // Visibility change: trigger an immediate tick; interval adjusts inside run
      state._onVis = () => { run(); };
      document.addEventListener('visibilitychange', state._onVis, {passive:true});

      // Keep ages ticking even between polls
      startAgeTicker();
    }

    async function tickLive(meta, {sid}){
      // Preferred: DexScreener live trades (matches what you see on DexScreener UI).
      // Fallback: GeckoTerminal trades.
      const urls = [
        dsTradesUrl(meta.dsChain, meta.pool, 200),
        gtTradesUrl(meta.gtNet, meta.pool),
      ];

      const ctrl = new AbortController();
      const signal = ctrl.signal;

      const guard = setInterval(() => {
        if (sid !== state.sessionId) ctrl.abort();
      }, 250);

      try{
        let trades = null;
        let used = '';
        for (const u of urls){
          try{
            const data = await withBackoff(() => fetchJson(u, {ttl: 0, signal}), {tries:2, signal});
            if (sid !== state.sessionId) return;

            if (u.includes('dex/trades/v1')){
              trades = normalizeDSTrades(data);
              used = 'ds';
            } else {
              trades = normalizeGTTrades(data);
              used = 'gt';
            }

            if (Array.isArray(trades) && trades.length) break;
          }catch(e){
            const msg = String(e && e.message || e);
            if (msg.includes('AbortError')) throw e;
            // try next source quietly
          }
        }

        if (sid !== state.sessionId) return;

        if (Array.isArray(trades) && trades.length){
          // Sort by timestamp desc (fallback: id). Newest always on top.
          trades = trades
            .filter(t => t && t.id)
            .sort((a,b)=> ((b.tsSec||0)-(a.tsSec||0)) || String(b.id).localeCompare(String(a.id)));

          if (!state.tradesMap) state.tradesMap = new Map();

          const newIds = new Set();
          for (const t of trades){
            if (!state.tradesMap.has(t.id)){
              state.tradesMap.set(t.id, t);
              newIds.add(t.id);
            } else {
              state.tradesMap.set(t.id, {...state.tradesMap.get(t.id), ...t});
            }
          }

          const list = Array.from(state.tradesMap.values())
            .sort((a,b)=> ((b.tsSec||0)-(a.tsSec||0)) || String(b.id).localeCompare(String(a.id)))
            .slice(0, 200);

          state.tradesList = list;
          state.winStats = calcWindowStats(list);
          if (state.current && state.current.pool === meta.pool){ try{ setChgVolUI(state.current); }catch(e){} }
          const keep = new Set(list.map(t=>t.id));
          for (const id of Array.from(state.tradesMap.keys())){
            if (!keep.has(id)) state.tradesMap.delete(id);
          }

          setTradesEmpty(list.length ? 'hide' : 'empty');
          renderTradesTable(list, meta.chain, newIds);
          el.tradeCount.textContent = String(list.length);
          state.lastTradeId = list[0]?.id || state.lastTradeId;

          // Update header price from newest trade.
          // IMPORTANT: we do NOT grow candles from trade USD here, because the chart is rendered in quote-token units
          // (currency=token) and Gecko's base/quote may differ from DexScreener.
          const top = list[0];
          if (top && isFinite(top.priceUsd) && top.priceUsd > 0){
            el.stPrice.textContent = fmtUSD(top.priceUsd);
            if (state.current && state.current.pool === meta.pool){
              // Keep our internal last-price reference in CHART units (quote-token units for the pair).
              const qUsd = meta?.quoteUsd;
              const pChart = (isFinite(qUsd) && qUsd > 0) ? (top.priceUsd / qUsd) : top.priceUsd;
              if (isFinite(pChart) && pChart > 0){
                state.lastPriceByPool.set(poolKey(meta), pChart);
                if (state.current.priceQuote == null) state.current.priceQuote = pChart;
                growLastCandle(pChart, top.tsSec);
              }
            }
          }
          if (shouldRetryCandles(meta)){
            void refreshCandles(meta, {sid, signal: state.abort?.signal, reason:'live retry'});
          }

          // reflect data source
          if (used) el.statusTxt.textContent = (document.visibilityState === 'hidden') ? 'Live (paused)' : 'Live';

          startAgeTicker();
        } else {
          if (el.tradesBody.children.length === 0) setTradesEmpty('empty');
        }
      } finally {
        clearInterval(guard);
      }
    }

    function startAgeTicker(){
      if (state.ageTimer) return;
      state.ageTimer = setInterval(updateAgeCells, 1000);
      updateAgeCells();
    }

    function updateAgeCells(){
      const rows = el.tradesBody.querySelectorAll('tr[data-ts]');
      const now = nowSec();
      for (const r of rows){
        const ts = parseInt(r.dataset.ts || '0', 10);
        const cell = r.querySelector('.ageCell');
        if (!cell) continue;
        if (!ts || !isFinite(ts)) { cell.textContent = '—'; continue; }
        const d = Math.max(0, now - ts);
        cell.textContent = d < 60 ? (d + 's') : (d < 3600 ? (Math.floor(d/60) + 'm') : (d < 172800 ? (Math.floor(d/3600) + 'h') : (Math.floor(d/86400) + 'd')));
      }
    }

    function renderTradesTable(list, chain, newIds){
      // Re-render to enforce strict ordering (newest on top). Fast enough for max 60 rows.
      const frag = document.createDocumentFragment();

      for (const t of list){
        const tr = document.createElement('tr');
      if (t.tsSec) tr.dataset.ts = String(t.tsSec);
        tr.dataset.id = t.id;
        if (t.tsSec) tr.dataset.ts = String(t.tsSec);

        if (newIds && newIds.has(t.id)) tr.classList.add('tradeNew');

        const sideCls = t.side === 'BUY' ? 'buy' : 'sell';
        tr.classList.add(t.side === 'BUY' ? 'tradeBuy' : 'tradeSell');
        const txUrl = t.tx ? explorerLink(chain, t.tx, 'tx') : '#';

        tr.innerHTML = `
          <td class="center typeCell"><span class="side ${sideCls}">${t.side}</span></td>
          <td class="right mono muted ageCell timeCell">${t.tsSec ? timeAgo(t.tsSec) : '—'}</td>
          <td class="right mono">${t.usd !== null ? fmtUsd2(t.usd) : '—'}</td>
          <td class="right mono">${t.priceUsd !== null ? fmtUSD(t.priceUsd) : '—'}</td>
          <td class="right mono">${t.amount !== null ? fmtAmt(t.amount) : '—'}</td>
          <td class="mono muted ellipsis" style="max-width:140px">${t.wallet ? escapeHtml(shortAddr(t.wallet)) : '—'}</td>
          <td class="center">${t.tx ? `<a class="linkPill" style="padding:6px 10px; display:inline-flex" href="${escapeHtml(txUrl)}" target="_blank" rel="noreferrer noopener">↗</a>` : '—'}</td>
        `;
        frag.appendChild(tr);
      }

      // Swap body content in one go (no jank)
      el.tradesBody.innerHTML = '';
      el.tradesBody.appendChild(frag);
    }

    function normalizeGTTrades(data){
      const arr = data?.data || [];
      const out = [];
      for (const row of arr){
        const a = row?.attributes || {};

        const kindRaw = (a?.kind || a?.side || a?.trade_type || a?.tradeType || '').toString().toLowerCase();
        const isBuy = kindRaw.includes('buy');

        // Amount: Gecko can expose different keys depending on chain/pool.
        const amountCandidates = [
          a?.base_token_amount, a?.baseTokenAmount,
          a?.volume_in_base_token, a?.volumeInBaseToken,
          a?.from_token_amount, a?.fromTokenAmount,
          a?.to_token_amount, a?.toTokenAmount,
          a?.token_amount, a?.tokenAmount,
          a?.amount,
        ].map(toNum).filter(v => v !== null);

        // Use the first sensible amount; if the first is tiny/zero and there is a larger alternative, prefer it.
        let amount = amountCandidates.length ? amountCandidates[0] : null;
        if (amountCandidates.length > 1){
          const best = amountCandidates.reduce((p,c)=> (p===null || (c>p && c>0)) ? c : p, amount);
          if (best !== null) amount = best;
        }

        // USD value / price
        const usd = toNum(a?.volume_in_usd ?? a?.value_in_usd ?? a?.volumeUsd ?? a?.valueUsd ?? a?.amount_usd ?? a?.usd_value ?? a?.usdValue);
        let priceUsd = toNum(a?.price_in_usd ?? a?.price_usd ?? a?.priceUsd ?? a?.execution_price_usd ?? a?.executionPriceUsd);

        if (priceUsd === null && usd !== null && amount !== null && amount > 0){
          priceUsd = usd / amount;
        }

        // Timestamp can be unix, ms, or ISO8601 string
        let ts = a?.block_timestamp ?? a?.timestamp ?? a?.time ?? a?.created_at ?? a?.createdAt ?? null;
        let tsSec = null;
        if (typeof ts === 'string'){
          const parsed = Date.parse(ts);
          if (isFinite(parsed)) tsSec = Math.floor(parsed/1000);
        } else if (isFinite(ts)){
          tsSec = ts > 1e12 ? Math.floor(ts/1000) : Math.floor(ts);
        }

        const tx = (a?.tx_hash || a?.txHash || a?.transaction_hash || a?.transactionHash || a?.hash || a?.signature || '').toString();
        const wallet = (a?.tx_from_address || a?.from_address || a?.maker || a?.maker_address || a?.trader || a?.trader_address || a?.owner || '').toString();

        const id = row?.id || tx || `${tsSec||0}_${priceUsd||0}_${usd||0}_${amount||0}_${kindRaw||''}`;

        out.push({
          id,
          side: isBuy ? 'BUY' : 'SELL',
          amount,
          priceUsd,
          usd,
          tsSec,
          wallet: wallet || null,
          tx: tx || null
        });
      }
      return out;
    }

    function normalizeDSTrades(data){
      // DexScreener trades v1 (io.dexscreener.com) usually returns an array of trade objects.
      const arr = Array.isArray(data) ? data : (data?.trades || data?.data || []);
      const out = [];
      for (const r of (arr || [])){
        if (!r) continue;
        const sideRaw = (r.type || r.side || r.kind || r.tradeType || '').toString().toLowerCase();
        const isBuy = sideRaw.includes('buy');

        const amount = toNum(r.amount ?? r.baseAmount ?? r.volume ?? r.baseVolume ?? r.tokenAmount ?? r.qty);
        const priceUsd = toNum(r.priceUsd ?? r.price_usd ?? r.price ?? r.executionPriceUsd ?? r.execution_price_usd);
        const usd = toNum(r.usd ?? r.volumeUsd ?? r.volume_usd ?? r.valueUsd ?? r.value_usd);

        // timestamp could be ms or sec
        let ts = r.timestamp ?? r.time ?? r.date ?? r.createdAt ?? r.created_at ?? null;
        let tsSec = null;
        if (typeof ts === 'string'){
          const parsed = Date.parse(ts);
          if (isFinite(parsed)) tsSec = Math.floor(parsed/1000);
        } else if (isFinite(ts)){
          tsSec = ts > 1e12 ? Math.floor(ts/1000) : Math.floor(ts);
        }

        const tx = (r.txHash || r.tx_hash || r.transactionHash || r.transaction_hash || r.hash || r.signature || '').toString();
        const wallet = (r.maker || r.owner || r.trader || r.from || r.fromAddress || r.from_address || '').toString();

        const id = (r.id || r.tradeId || r.trade_id || '') || tx || `${tsSec||0}_${priceUsd||0}_${usd||0}_${amount||0}_${sideRaw}`;

        out.push({
          id,
          side: isBuy ? 'BUY' : 'SELL',
          amount: amount !== null ? amount : null,
          priceUsd: priceUsd !== null ? priceUsd : null,
          usd: usd !== null ? usd : (priceUsd !== null && amount !== null ? priceUsd * amount : null),
          tsSec,
          wallet: wallet || null,
          tx: tx || null
        });
      }
      return out;
    }


    function addTradeRow(t, chain){
      const tr = document.createElement('tr');
      if (t.tsSec) tr.dataset.ts = String(t.tsSec);
      const sideCls = t.side === 'BUY' ? 'buy' : 'sell';
      const txUrl = t.tx ? explorerLink(chain, t.tx, 'tx') : '#';
      tr.innerHTML = `
        <td class="center"><span class="side ${sideCls}">${t.side}</span></td>
        <td class="mono">${t.amount !== null ? fmtNum(t.amount, 6) : '—'}</td>
        <td class="right mono">${t.priceUsd !== null ? fmtUSD(t.priceUsd) : '—'}</td>
        <td class="right mono">${t.usd !== null ? fmtUSD(t.usd) : '—'}</td>
        <td class="right mono muted ageCell">${t.tsSec ? timeAgo(t.tsSec) : '—'}</td>
        <td class="mono muted ellipsis" style="max-width:140px">${t.wallet ? escapeHtml(shortAddr(t.wallet)) : '—'}</td>
        <td class="center">${t.tx ? `<a class="linkPill" style="padding:6px 10px; display:inline-flex" href="${escapeHtml(txUrl)}" target="_blank" rel="noreferrer noopener">↗</a>` : '—'}</td>
      `;
      el.tradesBody.prepend(tr);
    }

    function trimTrades(maxRows){
      while (el.tradesBody.children.length > maxRows){
        el.tradesBody.removeChild(el.tradesBody.lastElementChild);
      }
    }

    function growLastCandle(price, tradeTsSec){
      if (!state.series) return;
      if (state._tfSwitching) return;
      if (isFinite(price)) applySeriesPrecision(price);
      const {sec} = tfToGT(state.tf);
      const t = isFinite(tradeTsSec) ? Math.floor(tradeTsSec) : nowSec();
      const bucket = Math.floor(t / sec) * sec;

      const last = state.lastCandle;
      if (!last){
        const c = {time: bucket, open: price, high: price, low: price, close: price};
        state.lastCandle = c;
        try{ state.series.update(c); }catch(e){}
        return;
      }

      if (bucket < last.time) return;

      if (bucket === last.time){
        const c = { time: last.time, open: last.open, high: Math.max(last.high, price), low: Math.min(last.low, price), close: price };
        state.lastCandle = c;
        try{ state.series.update(c); }catch(e){}
      } else {
        const prevClose = last.close;
        const c = { time: bucket, open: prevClose, high: Math.max(prevClose, price), low: Math.min(prevClose, price), close: price };
        state.lastCandle = c;
        try{ state.series.update(c); }catch(e){}
      }

      if (state._autoFollow){
        try{ state.chart && state.chart.timeScale && state.chart.timeScale().scrollToRealTime(); }catch(e){}
      }
    }

    // ========= Timeframe switching =========
    async function setTimeframe(tf){
      if (tf === state.tf) return;

      const prevTf = state.tf;
      const prevCandles = (Array.isArray(state.candles) && state.candles.length) ? state.candles.slice() : null;
      const prevWasFallback = !!state._usingFallbackCandles;

      state.tf = tf;
      el.tfs.forEach(b => b.classList.toggle('active', b.dataset.tf === tf));

      try{ dgPersistLastStateTf(tf); }catch(e){}
      if (!state.current){ el.chartMeta.textContent = '—'; return; }

      const sid = ++state.sessionId;
      if (state.abort) state.abort.abort();
      state.abort = new AbortController();
      const signal = state.abort.signal;

      state._autoFollow = true;
      state._pinToRight = true;

      stopLive();

      // ===== PATCH: If we already have candles and user switches to a LARGER TF,
      // derive aggregated candles instantly (no network, no jank).
      let usedDerived = false;
      try{
        const prevSec = tfSec(prevTf);
        const nextSec = tfSec(tf);
        if (prevCandles && prevCandles.length >= 30 && !prevWasFallback && isFinite(prevSec) && isFinite(nextSec) && nextSec > prevSec){
          const agg = aggregateCandles(prevCandles, tf);
          if (agg && agg.length >= 10){
            usedDerived = true;
            state._tfSwitching = false;
            state._tfSwitchSid = sid;
            state.lastCandle = null;
            state._forceFitNext = true;
            setChartLoading(false);

            state.candles = agg;
            applyCandlesToChart(agg);

            // Cache derived TF so repeated switches are instant.
            try{
              const ck = candleCacheKey(state.current, tf);
              candleCache.set(ck, {t:Date.now(), data: agg.slice(), ttl: 600_000, derived:true, srcTf: prevTf});
            }catch(e){}

            setStatus('live', 'Live (derived)');
          }
        }
      }catch(e){}

      if (usedDerived){
        startLive(state.current, {sid});
        // Optional: refresh in background (quiet) to replace with official candles if available.
        setTimeout(()=>{
          try{
            if (sid !== state.sessionId) return;
            const sig2 = state.abort?.signal;
            if (sig2 && sig2.aborted) return;
            void refreshCandles(state.current, {sid, signal: sig2, reason:'tf bg'});
          }catch(e){}
        }, 700);
        return;
      }

      // prevent "flat-line" flash while new candles fetch
      state._tfSwitching = true;
      state._tfSwitchSid = sid;
      state.lastCandle = null;
      // keep current candles on screen until new tf data is ready
      state._forceFitNext = true;
      setChartLoading(true);
      setStatus('', 'Switching timeframe…');

      await loadCandles(state.current, tf, {sid, signal});
      if (sid !== state.sessionId) return;
      // only the latest timeframe switch clears the switching flag
      if (state._tfSwitchSid === sid){
        state._tfSwitching = false;
      }
      setChartLoading(false);
      startLive(state.current, {sid});
    }

    // ========= Clear / Reset =========
    function clearAll(){
      stopLive();
      if (state.abort) state.abort.abort();
      state.abort = null;
      state.current = null;
      state.candles = [];
      state.lastCandle = null;
      state.lastTradeId = null;
      el.tradesBody.innerHTML = '';
      el.tradeCount.textContent = '0';
      el.btnDS.href = '#';
      showTokenView(false);
      setStatus('', 'Idle');
    }

    // ========= Settings Modal =========
    function openModal(){
      el.proxyUrl.value = settings.proxyUrl || '';
      el.birdeyeKey.value = settings.birdeyeKey || '';
      el.pollLive.textContent = (settings.pollLiveMs/1000).toFixed(1) + 's';
      el.pollHidden.textContent = Math.round(settings.pollHiddenMs/1000) + 's';
      el.modalBack.classList.add('show');
    }
    function closeModal(){ el.modalBack.classList.remove('show'); }
    function saveSettings(){
      settings.proxyUrl = (el.proxyUrl.value || '').trim();
      settings.birdeyeKey = (el.birdeyeKey.value || '').trim();
      try{ localStorage.setItem(LS.proxy, settings.proxyUrl); }catch(e){}
      try{ localStorage.setItem(LS.birdeye, settings.birdeyeKey); }catch(e){}
      closeModal();
      toast('Settings saved');
      loadTrending();
      if (state.current){ setTimeframe(state.tf); }
    }

    // ========= Events =========
    function setChain(chain, {silent=false}={}){
      if (chain === state.chain) return;
      state.chain = chain;
      el.tabs.forEach(t => {
        const on = t.dataset.chain === chain;
        t.classList.toggle('active', on);
        t.setAttribute('aria-selected', on ? 'true' : 'false');
      });
      clearResults();
      clearAll();
      if (!silent) loadTrending();
      else loadTrending();
      try{ dgCmdLoadDefaults({force:true}); }catch(e){}
    }

    // ========= Events binding (deduped + guarded) =========
    function bindOnce(node, evt, fn, opts, key){
      if (!node || !node.addEventListener) return;
      const store = node.__dgBound || (node.__dgBound = {});
      const k = key || (evt + ':bound');
      if (store[k]) return;
      store[k] = true;
      try{ node.addEventListener(evt, fn, opts); }
      catch(e){ console.warn('[DexGuard] bind failed:', evt, e); }
    }

    function bindUIEvents(){
      if (__DGW.__eventsBound) return;
      __DGW.__eventsBound = true;

      el.tabs.forEach(btn => bindOnce(btn, 'click', () => setChain(btn.dataset.chain), {passive:true}, 'tab:click'));
      // Search button removed (single search input)
      bindOnce(el.q, 'input', debounceSearch, null, 'q:input');

      bindOnce(el.q, 'focus', ()=>{ try{ const qv=(el.q.value||'').trim(); if(!qv) dgShowInstantDefaults(); }catch(e){} }, null, 'q:focus');
      bindOnce(el.q, 'click', ()=>{ try{ const qv=(el.q.value||'').trim(); if(!qv) dgShowInstantDefaults(); }catch(e){} }, null, 'q:click');

      bindOnce(el.q, 'keydown', (e)=>{
        try{
          if (e.key === 'Enter'){
            e.preventDefault();
            // Open first visible result (if any). Otherwise run search.
            const first = (el.results && el.results.querySelector) ? el.results.querySelector('.resultItem') : null;
            if (first && first.click){ first.click(); return; }
            doSearch(true);
            return;
          }
          if (e.key === 'Escape'){
            try{ el.q.value = ''; }catch(_){ }
            doSearch(false);
            try{ el.q.blur && el.q.blur(); }catch(_){ }
          }
        }catch(err){}
      }, null, 'q:keydown');


      // Global hotkeys (no UI buttons needed)
      bindOnce(window, 'keydown', (e)=>{
        try{
          const ae = document.activeElement;
          const tag = ae && ae.tagName ? ae.tagName.toUpperCase() : '';
          const typing = (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || (ae && ae.isContentEditable));
          // Command Search focus: Ctrl+K / ⌘K
          if ((e.ctrlKey || e.metaKey) && String(e.key).toLowerCase() === 'k'){
            e.preventDefault();
            try{ state._cmdFocusUntil = Date.now()+2000; }catch(_){ }
            if (el.q && el.q.focus){
              el.q.focus({preventScroll:true});
              try{ el.q.select && el.q.select(); }catch(_){}
            }
            return;
          }
          // Settings: Shift+S (always), button only in ?debug=1
          if (e.shiftKey && String(e.key).toLowerCase() === 's' && !typing){
            e.preventDefault();
            openModal();
          }
        }catch(err){ console.warn('[DexGuard] hotkey error', err); }
      }, null, 'global:hotkeys');


      el.tfs.forEach(b => bindOnce(b, 'click', ()=> setTimeframe(b.dataset.tf), {passive:true}, 'tf:click'));

      // Y-Scale controls (STEP12)
      if (el.yZoomIn) bindOnce(el.yZoomIn, 'click', ()=> dgYZoom(-DG_YZOOM.step), {passive:true}, 'yzoom:in');
      if (el.yZoomOut) bindOnce(el.yZoomOut, 'click', ()=> dgYZoom(+DG_YZOOM.step), {passive:true}, 'yzoom:out');

      bindOnce(el.stChg, 'click', (e)=>{
        const b = e.target && e.target.closest ? e.target.closest('button[data-sttf]') : null;
        if (!b) return;
        state.statsUI = state.statsUI || {tf:'h24'};
        state.statsUI.tf = b.dataset.sttf || 'h24';
        setChgVolUI(state.current);
      }, null, 'stChg:click');

      bindOnce(el.btnClear, 'click', ()=> { clearResults(); clearAll(); }, null, 'btnClear:click');
      bindOnce(el.btnSettings, 'click', openModal, null, 'btnSettings:click');
      bindOnce(el.btnCloseModal, 'click', closeModal, null, 'btnCloseModal:click');
      bindOnce(el.modalBack, 'click', (e)=> { if (e.target === el.modalBack) closeModal(); }, null, 'modalBack:click');
      bindOnce(el.btnSaveSettings, 'click', saveSettings, null, 'btnSaveSettings:click');

      bindOnce(el.btnClearCache, 'click', ()=>{
        cacheClear();
        candleCache.clear();
        toast('Local cache cleared');
        loadTrending();
      }, null, 'btnClearCache:click');

      bindOnce(el.btnResetPolling, 'click', ()=>{
        settings.pollLiveMs = 2500;
        settings.pollHiddenMs = 12000;
        el.pollLive.textContent = (settings.pollLiveMs/1000).toFixed(1) + 's';
        el.pollHidden.textContent = Math.round(settings.pollHiddenMs/1000) + 's';
        toast('Polling reset');
        if (state.current){
          const sid = ++state.sessionId;
          startLive(state.current, {sid});
        }
      }, null, 'btnResetPolling:click');
    }

    bindUIEvents();

    // Global suppression for benign ResizeObserver warnings
    window.addEventListener('error', (e)=>{
      const msg = String(e?.message || '');
      if (msg.includes('ResizeObserver loop limit exceeded') || msg.includes('ResizeObserver loop completed with undelivered notifications')){
        e.preventDefault?.();
        return false;
      }
    }, true);

    // ========= Boot =========
    
    // Dock the command search under the chain logos (reuses existing DOM; no duplicate IDs)
    function dgDockSearchUnderChains(){
      try{
        const dock = document.getElementById('searchDock');
        const wrap = document.querySelector('.searchWrap.cmdSearch');
        if (!dock || !wrap) return;

        if (!dock.contains(wrap)) dock.appendChild(wrap);

        // Mount results directly under the search input (single search, no dropdown, no separate panel)
        let host = document.getElementById('dgInstantResults');
        if (!host){
          host = document.createElement('div');
          host.id = 'dgInstantResults';
          host.className = 'dgInstantResults';
          dock.appendChild(host);
        }
        const res = document.getElementById('results');
        const empty = document.getElementById('resultsEmpty');
        if (empty && !host.contains(empty)) host.appendChild(empty);
        if (res && !host.contains(res)) host.appendChild(res);

        document.body.classList.add('dgSearchDocked');
      }catch(e){}
    }

function boot(){
      try{ dgMobileInit(); }catch(e){}
      setStatus('', 'Booting…');
      clearResults();
      showTokenView(false);
      dgDockSearchUnderChains();
      // Prime defaults under the search input immediately
      try{ dgShowInstantDefaults(); }catch(e){}
      // Trending removed (STEP17)
      try{ void dgRestoreLastState(); }catch(e){}
      setStatus('live', 'Ready');
    }

    /* =========================================================
       STEP6 — Live Indicator (UI forced live) — PATCH ONLY
       - Chart status UI ALWAYS shows Live + green dot
       - Runtime backoff/errors may still run internally (console only)
       ========================================================= */
    const __DG_FORCE_LIVE_UI = true;
    function dgForceLiveIndicator(){
      try{
        const s = document.getElementById('status');
        const t = document.getElementById('statusTxt');
        if(!s || !t) return;
        s.classList.remove('warn','bad');
        if(!s.classList.contains('live')) s.classList.add('live');
        if(t.textContent !== 'Live') t.textContent = 'Live';
      }catch(e){
        console.warn('[DexGuard] live-indicator patch failed', e);
      }
    }
    if(__DG_FORCE_LIVE_UI){
      dgForceLiveIndicator();
      // Keep it live even if internal logic changes it later
      setInterval(dgForceLiveIndicator, 750);
      document.addEventListener('visibilitychange', dgForceLiveIndicator, {passive:true});
      window.addEventListener('online', dgForceLiveIndicator, {passive:true});
      window.addEventListener('offline', dgForceLiveIndicator, {passive:true});
    }
    // ===== PATCH: click-to-copy contract (CA) =====
    function dgCopyText(val){
      const text = (val == null) ? '' : String(val);
      if (!text) return;
      const done = () => { try{ toast('Copied'); }catch(e){} };
      const fallback = () => {
        try{
          const ta = document.createElement('textarea');
          ta.value = text;
          ta.setAttribute('readonly','');
          ta.style.position = 'fixed';
          ta.style.top = '-9999px';
          ta.style.left = '-9999px';
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
          done();
        }catch(e){
          // silent
        }
      };
      try{
        if (navigator.clipboard && navigator.clipboard.writeText){
          navigator.clipboard.writeText(text).then(done).catch(fallback);
        } else {
          fallback();
        }
      }catch(e){ fallback(); }
    }

    if (!window.__dgCopyBound){
      window.__dgCopyBound = true;
      document.addEventListener('click', (e) => {
        const el = e.target && e.target.closest ? e.target.closest('.dgCopy') : null;
        if (!el) return;
        e.preventDefault();
        dgCopyText(el.getAttribute('data-copy') || el.textContent || '');
      }, false);
    }
    // ===== /PATCH =====

    boot();
  })();
</script>
</body>
</html>
